var main;(()=>{var __webpack_modules__={466:function(module){eval('// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){ true?module.exports=e():0})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel("FPS","#0ff","#002")),h=e(new f.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var t=e(new f.Panel("MB","#f08","#201"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=h;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+" "+e+" ("+g(c)+"-"+g(k)+")",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYWluLy4vbm9kZV9tb2R1bGVzL3N0YXRzLmpzL2J1aWxkL3N0YXRzLm1pbi5qcz8zMTkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0YXRzLmpzIC0gaHR0cDovL2dpdGh1Yi5jb20vbXJkb29iL3N0YXRzLmpzXG4oZnVuY3Rpb24oZixlKXtcIm9iamVjdFwiPT09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKTpmLlN0YXRzPWUoKX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgZj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoYSl7Yy5hcHBlbmRDaGlsZChhLmRvbSk7cmV0dXJuIGF9ZnVuY3Rpb24gdShhKXtmb3IodmFyIGQ9MDtkPGMuY2hpbGRyZW4ubGVuZ3RoO2QrKyljLmNoaWxkcmVuW2RdLnN0eWxlLmRpc3BsYXk9ZD09PWE/XCJibG9ja1wiOlwibm9uZVwiO2w9YX12YXIgbD0wLGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtjLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7Y3Vyc29yOnBvaW50ZXI7b3BhY2l0eTowLjk7ei1pbmRleDoxMDAwMFwiO2MuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpO1xudSgrK2wlYy5jaGlsZHJlbi5sZW5ndGgpfSwhMSk7dmFyIGs9KHBlcmZvcm1hbmNlfHxEYXRlKS5ub3coKSxnPWssYT0wLHI9ZShuZXcgZi5QYW5lbChcIkZQU1wiLFwiIzBmZlwiLFwiIzAwMlwiKSksaD1lKG5ldyBmLlBhbmVsKFwiTVNcIixcIiMwZjBcIixcIiMwMjBcIikpO2lmKHNlbGYucGVyZm9ybWFuY2UmJnNlbGYucGVyZm9ybWFuY2UubWVtb3J5KXZhciB0PWUobmV3IGYuUGFuZWwoXCJNQlwiLFwiI2YwOFwiLFwiIzIwMVwiKSk7dSgwKTtyZXR1cm57UkVWSVNJT046MTYsZG9tOmMsYWRkUGFuZWw6ZSxzaG93UGFuZWw6dSxiZWdpbjpmdW5jdGlvbigpe2s9KHBlcmZvcm1hbmNlfHxEYXRlKS5ub3coKX0sZW5kOmZ1bmN0aW9uKCl7YSsrO3ZhciBjPShwZXJmb3JtYW5jZXx8RGF0ZSkubm93KCk7aC51cGRhdGUoYy1rLDIwMCk7aWYoYz5nKzFFMyYmKHIudXBkYXRlKDFFMyphLyhjLWcpLDEwMCksZz1jLGE9MCx0KSl7dmFyIGQ9cGVyZm9ybWFuY2UubWVtb3J5O3QudXBkYXRlKGQudXNlZEpTSGVhcFNpemUvXG4xMDQ4NTc2LGQuanNIZWFwU2l6ZUxpbWl0LzEwNDg1NzYpfXJldHVybiBjfSx1cGRhdGU6ZnVuY3Rpb24oKXtrPXRoaXMuZW5kKCl9LGRvbUVsZW1lbnQ6YyxzZXRNb2RlOnV9fTtmLlBhbmVsPWZ1bmN0aW9uKGUsZixsKXt2YXIgYz1JbmZpbml0eSxrPTAsZz1NYXRoLnJvdW5kLGE9Zyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSkscj04MCphLGg9NDgqYSx0PTMqYSx2PTIqYSxkPTMqYSxtPTE1KmEsbj03NCphLHA9MzAqYSxxPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7cS53aWR0aD1yO3EuaGVpZ2h0PWg7cS5zdHlsZS5jc3NUZXh0PVwid2lkdGg6ODBweDtoZWlnaHQ6NDhweFwiO3ZhciBiPXEuZ2V0Q29udGV4dChcIjJkXCIpO2IuZm9udD1cImJvbGQgXCIrOSphK1wicHggSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWZcIjtiLnRleHRCYXNlbGluZT1cInRvcFwiO2IuZmlsbFN0eWxlPWw7Yi5maWxsUmVjdCgwLDAscixoKTtiLmZpbGxTdHlsZT1mO2IuZmlsbFRleHQoZSx0LHYpO1xuYi5maWxsUmVjdChkLG0sbixwKTtiLmZpbGxTdHlsZT1sO2IuZ2xvYmFsQWxwaGE9Ljk7Yi5maWxsUmVjdChkLG0sbixwKTtyZXR1cm57ZG9tOnEsdXBkYXRlOmZ1bmN0aW9uKGgsdyl7Yz1NYXRoLm1pbihjLGgpO2s9TWF0aC5tYXgoayxoKTtiLmZpbGxTdHlsZT1sO2IuZ2xvYmFsQWxwaGE9MTtiLmZpbGxSZWN0KDAsMCxyLG0pO2IuZmlsbFN0eWxlPWY7Yi5maWxsVGV4dChnKGgpK1wiIFwiK2UrXCIgKFwiK2coYykrXCItXCIrZyhrKStcIilcIix0LHYpO2IuZHJhd0ltYWdlKHEsZCthLG0sbi1hLHAsZCxtLG4tYSxwKTtiLmZpbGxSZWN0KGQrbi1hLG0sYSxwKTtiLmZpbGxTdHlsZT1sO2IuZ2xvYmFsQWxwaGE9Ljk7Yi5maWxsUmVjdChkK24tYSxtLGEsZygoMS1oL3cpKnApKX19fTtyZXR1cm4gZn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///466\n')},5:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n;// CONCATENATED MODULE: ./node_modules/ismobilejs/esm/isMobile.js\nvar appleIphone = /iPhone/i;\nvar appleIpod = /iPod/i;\nvar appleTablet = /iPad/i;\nvar appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nvar androidPhone = /\\bAndroid(?:.+)Mobile\\b/i;\nvar androidTablet = /Android/i;\nvar amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i;\nvar amazonTablet = /Silk/i;\nvar windowsPhone = /Windows Phone/i;\nvar windowsTablet = /\\bWindows(?:.+)ARM\\b/i;\nvar otherBlackBerry = /BlackBerry/i;\nvar otherBlackBerry10 = /BB10/i;\nvar otherOpera = /Opera Mini/i;\nvar otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nvar otherFirefox = /Mobile(?:.+)Firefox\\b/i;\nvar isAppleTabletOnIos13 = function (navigator) {\n    return (typeof navigator !== 'undefined' &&\n        navigator.platform === 'MacIntel' &&\n        typeof navigator.maxTouchPoints === 'number' &&\n        navigator.maxTouchPoints > 1 &&\n        typeof MSStream === 'undefined');\n};\nfunction createMatch(userAgent) {\n    return function (regex) { return regex.test(userAgent); };\n}\nfunction isMobile(param) {\n    var nav = {\n        userAgent: '',\n        platform: '',\n        maxTouchPoints: 0\n    };\n    if (!param && typeof navigator !== 'undefined') {\n        nav = {\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            maxTouchPoints: navigator.maxTouchPoints || 0\n        };\n    }\n    else if (typeof param === 'string') {\n        nav.userAgent = param;\n    }\n    else if (param && param.userAgent) {\n        nav = {\n            userAgent: param.userAgent,\n            platform: param.platform,\n            maxTouchPoints: param.maxTouchPoints || 0\n        };\n    }\n    var userAgent = nav.userAgent;\n    var tmp = userAgent.split('[FBAN');\n    if (typeof tmp[1] !== 'undefined') {\n        userAgent = tmp[0];\n    }\n    tmp = userAgent.split('Twitter');\n    if (typeof tmp[1] !== 'undefined') {\n        userAgent = tmp[0];\n    }\n    var match = createMatch(userAgent);\n    var result = {\n        apple: {\n            phone: match(appleIphone) && !match(windowsPhone),\n            ipod: match(appleIpod),\n            tablet: !match(appleIphone) &&\n                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone),\n            universal: match(appleUniversal),\n            device: (match(appleIphone) ||\n                match(appleIpod) ||\n                match(appleTablet) ||\n                match(appleUniversal) ||\n                isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone)\n        },\n        amazon: {\n            phone: match(amazonPhone),\n            tablet: !match(amazonPhone) && match(amazonTablet),\n            device: match(amazonPhone) || match(amazonTablet)\n        },\n        android: {\n            phone: (!match(windowsPhone) && match(amazonPhone)) ||\n                (!match(windowsPhone) && match(androidPhone)),\n            tablet: !match(windowsPhone) &&\n                !match(amazonPhone) &&\n                !match(androidPhone) &&\n                (match(amazonTablet) || match(androidTablet)),\n            device: (!match(windowsPhone) &&\n                (match(amazonPhone) ||\n                    match(amazonTablet) ||\n                    match(androidPhone) ||\n                    match(androidTablet))) ||\n                match(/\\bokhttp\\b/i)\n        },\n        windows: {\n            phone: match(windowsPhone),\n            tablet: match(windowsTablet),\n            device: match(windowsPhone) || match(windowsTablet)\n        },\n        other: {\n            blackberry: match(otherBlackBerry),\n            blackberry10: match(otherBlackBerry10),\n            opera: match(otherOpera),\n            firefox: match(otherFirefox),\n            chrome: match(otherChrome),\n            device: match(otherBlackBerry) ||\n                match(otherBlackBerry10) ||\n                match(otherOpera) ||\n                match(otherFirefox) ||\n                match(otherChrome)\n        },\n        any: false,\n        phone: false,\n        tablet: false\n    };\n    result.any =\n        result.apple.device ||\n            result.android.device ||\n            result.windows.device ||\n            result.other.device;\n    result.phone =\n        result.apple.phone || result.android.phone || result.windows.phone;\n    result.tablet =\n        result.apple.tablet || result.android.tablet || result.windows.tablet;\n    return result;\n}\n//# sourceMappingURL=isMobile.js.map\n;// CONCATENATED MODULE: ./node_modules/fairygui-createjs/dist/fairygui.module.js\n\n\nclass UIContainer extends createjs.Container {\n    constructor(owner) {\n        super();\n        this.UIOwner = owner;\n        this.mouseEnabled = true;\n        this.mouseChildren = true;\n    }\n    get scrollRect() {\n        return this.$scrollRect;\n    }\n    set scrollRect(rect) {\n        this.$scrollRect = rect;\n        if (rect != null) {\n            if (!this.$rectMask) {\n                this.$rectMask = new createjs.Graphics();\n                var shape = new createjs.Shape(this.$rectMask);\n                this.mask = shape;\n            }\n            this.$rectMask.clear();\n            if (rect.width > 0 && rect.height > 0) {\n                this.$rectMask.beginFill('#000');\n                this.$rectMask.drawRect(this.$scrollRect.x, this.$scrollRect.y, this.$scrollRect.width, this.$scrollRect.height);\n                this.$rectMask.endFill();\n            }\n        }\n        else\n            this.mask = null;\n    }\n}\n\nclass InteractiveEvents {\n}\nInteractiveEvents.Down = createjs.Touch.isSupported() ? 'mousedown' : 'mousedown';\nInteractiveEvents.Cancel = createjs.Touch.isSupported() ? 'mousecancel' : 'mousecancel';\nInteractiveEvents.Up = createjs.Touch.isSupported() ? 'stagemouseup' : 'stagemouseup';\nInteractiveEvents.Click = createjs.Touch.isSupported() ? 'click' : 'click';\nInteractiveEvents.UpOutside = createjs.Touch.isSupported()\n    ? 'mouseupoutside'\n    : 'mouseupoutside';\nInteractiveEvents.Move = createjs.Touch.isSupported() ? 'stagemousemove' : 'stagemousemove';\nInteractiveEvents.Over = createjs.Touch.isSupported() ? 'mouseover' : 'mouseover';\nInteractiveEvents.Out = createjs.Touch.isSupported() ? 'mouseout' : 'mouseout';\n//mouse only\nInteractiveEvents.RightDown = 'rightdown';\nInteractiveEvents.RightUp = 'rightup';\nInteractiveEvents.RightClick = 'rightclick';\nInteractiveEvents.RightUpOutside = 'rightupoutside';\nlet GearXMLNodeNameMap = {\n    gearDisplay: 0,\n    gearXY: 1,\n    gearSize: 2,\n    gearLook: 3,\n    gearColor: 4,\n    gearAni: 5,\n    gearText: 6,\n    gearIcon: 7\n};\nlet BlendModeMap = [\n    'Normal',\n    'Add',\n    'Multiply',\n    'Screen',\n    'Overlay',\n    'Darken',\n    'Lighten',\n    'ColorDodge',\n    'ColorBurn',\n    'HardLight',\n    'SoftLight',\n    'Difference',\n    'Exclusion',\n    'Hue',\n    'Saturation',\n    'Color',\n    'Luminosity',\n    'NormalNPM',\n    'AddNPM',\n    'ScreenNPM' //  SCREEN_NPM\n];\nfunction ParseOverflowType(value) {\n    switch (value) {\n        case 'visible':\n            return 0 /* Visible */;\n        case 'hidden':\n            return 1 /* Hidden */;\n        case 'scroll':\n            return 2 /* Scroll */;\n        case 'scale':\n            return 3 /* Scale */;\n        case 'scaleFree':\n            return 4 /* ScaleFree */;\n        default:\n            return 0 /* Visible */;\n    }\n}\nfunction ParseScrollType(value) {\n    switch (value) {\n        case 'horizontal':\n            return 0 /* Horizontal */;\n        case 'vertical':\n            return 1 /* Vertical */;\n        case 'both':\n            return 2 /* Both */;\n        default:\n            return 1 /* Vertical */;\n    }\n}\nfunction ParseLoaderFillType(value) {\n    switch (value) {\n        case 'none':\n            return 0 /* None */;\n        case 'scale':\n            return 1 /* Scale */;\n        case 'scaleMatchHeight':\n            return 2 /* ScaleMatchHeight */;\n        case 'scaleMatchWidth':\n            return 3 /* ScaleMatchWidth */;\n        case 'scaleFree':\n            return 4 /* ScaleFree */;\n        case 'scaleNoBorder':\n            return 5 /* ScaleNoBorder */;\n        default:\n            return 0 /* None */;\n    }\n}\nfunction ParseListLayoutType(value) {\n    switch (value) {\n        case 'column':\n            return 0 /* SingleColumn */;\n        case 'row':\n            return 1 /* SingleRow */;\n        case 'flow_hz':\n            return 2 /* FlowHorizontal */;\n        case 'flow_vt':\n            return 3 /* FlowVertical */;\n        case 'pagination':\n            return 4 /* Pagination */;\n        default:\n            return 0 /* SingleColumn */;\n    }\n}\nfunction ParseListSelectionMode(value) {\n    switch (value) {\n        case 'single':\n            return 0 /* Single */;\n        case 'multiple':\n            return 1 /* Multiple */;\n        case 'multipleSingleClick':\n            return 2 /* Multiple_SingleClick */;\n        case 'none':\n            return 3 /* None */;\n        default:\n            return 0 /* Single */;\n    }\n}\nfunction ParsePackageItemType(value) {\n    switch (value) {\n        case 'image':\n            return 0 /* Image */;\n        case 'movieclip':\n            return 2 /* MovieClip */;\n        case 'sound':\n            return 3 /* Sound */;\n        case 'component':\n            return 4 /* Component */;\n        case 'swf':\n            return 1 /* Swf */;\n        case 'font':\n            return 6 /* Font */;\n        case 'atlas':\n            return 7 /* Atlas */;\n        default:\n            return 5 /* Misc */;\n    }\n}\nfunction ParseProgressTitleType(value) {\n    switch (value) {\n        case 'percent':\n            return 0 /* Percent */;\n        case 'valueAndmax':\n            return 1 /* ValueAndMax */;\n        case 'value':\n            return 2 /* Value */;\n        case 'max':\n            return 3 /* Max */;\n        default:\n            return 0 /* Percent */;\n    }\n}\nfunction ParseScrollBarDisplayType(value) {\n    switch (value) {\n        case 'default':\n            return 0 /* Default */;\n        case 'visible':\n            return 1 /* Visible */;\n        case 'auto':\n            return 2 /* Auto */;\n        case 'hidden':\n            return 3 /* Hidden */;\n        default:\n            return 0 /* Default */;\n    }\n}\nfunction ParseFlipType(value) {\n    switch (value) {\n        case 'hz':\n            return 1 /* Horizontal */;\n        case 'vt':\n            return 2 /* Vertical */;\n        case 'both':\n            return 3 /* Both */;\n        default:\n            return 0 /* None */;\n    }\n}\nfunction ParseButtonMode(value) {\n    switch (value) {\n        case 'Common':\n            return 0 /* Common */;\n        case 'Check':\n            return 1 /* Check */;\n        case 'Radio':\n            return 2 /* Radio */;\n        default:\n            return 0 /* Common */;\n    }\n}\nfunction ParseAutoSizeType(value) {\n    switch (value) {\n        case 'none':\n            return 0 /* None */;\n        case 'both':\n            return 1 /* Both */;\n        case 'height':\n            return 2 /* Height */;\n        case 'shrink':\n            return 3 /* Shrink */;\n        default:\n            return 0 /* None */;\n    }\n}\nfunction ParseAlignType(value) {\n    switch (value) {\n        case 'left':\n            return \"left\" /* Left */;\n        case 'center':\n            return \"center\" /* Center */;\n        case 'right':\n            return \"right\" /* Right */;\n        default:\n            return \"left\" /* Left */;\n    }\n}\nfunction ParseVertAlignType(value) {\n    switch (value) {\n        case 'top':\n            return 0 /* Top */;\n        case 'middle':\n            return 1 /* Middle */;\n        case 'bottom':\n            return 2 /* Bottom */;\n        default:\n            return 0 /* Top */;\n    }\n}\nfunction ParseListChildrenRenderOrder(value) {\n    switch (value) {\n        case 'ascent':\n            return 0 /* Ascent */;\n        case 'descent':\n            return 1 /* Descent */;\n        case 'arch':\n            return 2 /* Arch */;\n        default:\n            return 0 /* Ascent */;\n    }\n}\nlet easeMap = {\n    Linear: createjs.Ease.linear,\n    'Elastic.In': createjs.Ease.elasticIn,\n    'Elastic.Out': createjs.Ease.elasticOut,\n    'Elastic.InOut': createjs.Ease.elasticInOut,\n    'Quad.In': createjs.Ease.quadIn,\n    'Quad.Out': createjs.Ease.quadOut,\n    'Quad.InOut': createjs.Ease.quadInOut,\n    'Cube.In': createjs.Ease.cubicIn,\n    'Cube.Out': createjs.Ease.cubicOut,\n    'Cube.InOut': createjs.Ease.cubicInOut,\n    'Quart.In': createjs.Ease.quartIn,\n    'Quart.Out': createjs.Ease.quartOut,\n    'Quart.InOut': createjs.Ease.quartInOut,\n    'Quint.In': createjs.Ease.quintIn,\n    'Quint.Out': createjs.Ease.quintOut,\n    'Quint.InOut': createjs.Ease.quintInOut,\n    'Sine.In': createjs.Ease.sineIn,\n    'Sine.Out': createjs.Ease.sineOut,\n    'Sine.InOut': createjs.Ease.sineInOut,\n    'Bounce.In': createjs.Ease.bounceIn,\n    'Bounce.Out': createjs.Ease.bounceOut,\n    'Bounce.InOut': createjs.Ease.bounceInOut,\n    'Circ.In': createjs.Ease.circIn,\n    'Circ.Out': createjs.Ease.circOut,\n    'Circ.InOut': createjs.Ease.circInOut,\n    'Expo.In': createjs.Ease.quartIn,\n    'Expo.Out': createjs.Ease.quartOut,\n    'Expo.InOut': createjs.Ease.quartInOut,\n    'Back.In': createjs.Ease.backIn,\n    'Back.Out': createjs.Ease.backOut,\n    'Back.InOut': createjs.Ease.backInOut\n};\nfunction ParseEaseType(name) {\n    return easeMap[name] || easeMap['Linear'];\n}\n\n/**global ui configuration */\nclass UIConfig {\n}\n/**default font name of your project. */\nUIConfig.defaultFont = \"Arial\";\n/** modal layer background configuration. */\nUIConfig.modalLayerColor = \"#333333\";\nUIConfig.modalLayerAlpha = 0.2;\nUIConfig.buttonSoundVolumeScale = 1;\n/** scrolling distance per action in pixel*/\nUIConfig.defaultScrollSpeed = 25;\n/** default scrollbar display mode. It's recommended to set ScrollBarDisplayType.Visible for Desktop environment and ScrollBarDisplayType.Auto for mobile environment.*/\nUIConfig.defaultScrollBarDisplay = 1 /* Visible */;\n/** allow user to drag the content of a container. Set to true for mobile is recommended.*/\nUIConfig.defaultScrollTouchEffect = true;\n/** enable bounce effect when the scrolling reaches to the edge of a container. Set to true for mobile is recommended.*/\nUIConfig.defaultScrollBounceEffect = true;\n/** Deceleration ratio of scrollpane when its in touch dragging.*/\nUIConfig.defaultScrollDecelerationRate = .967;\n/** maximum count of items to be displayed in the visible viewport of the GCombobox.*/\nUIConfig.defaultComboBoxVisibleItemCount = 10;\n/** the finger moving threshold in pixel to trigger the scrolling action.*/\nUIConfig.touchScrollSensitivity = 20;\n/** the finger moving threshold in pixel to trigger the dragging event.*/\nUIConfig.touchDragSensitivity = 10;\n/** auto bring the window you clicked to the topmost level of the GRoot children list.*/\nUIConfig.bringWindowToFrontOnClick = true;\n\nclass GearBase {\n    constructor(owner) {\n        this.$lockToken = 0;\n        this.$owner = owner;\n        this.$easeType = ParseEaseType('Quad.Out');\n        this.$tweenTime = 0.3;\n        this.$tweenDelay = 0;\n    }\n    get controller() {\n        return this.$controller;\n    }\n    set controller(val) {\n        if (val != this.$controller) {\n            this.$controller = val;\n            if (this.$controller)\n                this.init();\n        }\n    }\n    get tween() {\n        return this.$tween;\n    }\n    set tween(val) {\n        this.$tween = val;\n    }\n    get tweenDelay() {\n        return this.$tweenDelay;\n    }\n    set tweenDelay(val) {\n        this.$tweenDelay = val;\n    }\n    get tweenTime() {\n        return this.$tweenTime;\n    }\n    set tweenTime(value) {\n        this.$tweenTime = value;\n    }\n    get easeType() {\n        return this.$easeType;\n    }\n    set easeType(value) {\n        this.$easeType = value;\n    }\n    setup(xml) {\n        this.$controller = this.$owner.parent.getController(xml.attributes.controller);\n        if (this.$controller == null)\n            return;\n        this.init();\n        let str;\n        str = xml.attributes.tween;\n        if (str)\n            this.$tween = true;\n        str = xml.attributes.ease;\n        if (str)\n            this.$easeType = ParseEaseType(str);\n        str = xml.attributes.duration;\n        if (str)\n            this.$tweenTime = parseFloat(str);\n        str = xml.attributes.delay;\n        if (str)\n            this.$tweenDelay = parseFloat(str);\n        if (this['$vid'] != null) {\n            str = xml.attributes.pages;\n            if (str)\n                this['pages'] = str.split(',');\n        }\n        else {\n            let pages;\n            let values;\n            str = xml.attributes.pages;\n            if (str)\n                pages = str.split(',');\n            str = xml.attributes.values;\n            if (str)\n                values = str.split('|');\n            if (pages && values) {\n                values.forEach((s, i) => {\n                    this.addStatus(pages[i], s);\n                });\n            }\n            str = xml.attributes.default;\n            if (str)\n                this.addStatus(null, str);\n        }\n    }\n    updateFromRelations(dx, dy) { }\n    addStatus(pageId, value) { }\n    init() { }\n    apply() { }\n    updateState() { }\n}\nGearBase.disableAllTweenEffect = false;\n\nclass GearDisplay extends GearBase {\n    constructor(owner) {\n        super(owner);\n        this.$vid = 0;\n        this.$lockToken = 1;\n    }\n    init() {\n        this.pages = null;\n    }\n    lock() {\n        this.$vid++;\n        return this.$lockToken;\n    }\n    release(token) {\n        if (token == this.$lockToken)\n            this.$vid--;\n    }\n    get connected() {\n        return this.controller == null || this.$vid > 0;\n    }\n    apply() {\n        this.$lockToken++;\n        if (this.$lockToken <= 0)\n            this.$lockToken = 1;\n        if (this.pages == null ||\n            this.pages.length == 0 ||\n            this.pages.indexOf(this.$controller.selectedPageId) != -1)\n            this.$vid = 1;\n        else\n            this.$vid = 0;\n    }\n}\n\nclass BMGlyph {\n    constructor() {\n        this.x = 0;\n        this.y = 0;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.width = 0;\n        this.height = 0;\n        this.advance = 0;\n        this.lineHeight = 0;\n        this.channel = 0;\n    }\n}\nclass BitmapFont {\n    constructor() {\n        this.size = 0;\n        this.glyphs = {};\n    }\n}\n\nclass Frame {\n    constructor() {\n        this.addDelay = 0;\n    }\n}\n\nclass AssetLoader extends createjs.LoadQueue {\n    constructor(preferXHR, basePath, crossOrigin) {\n        super(preferXHR, basePath);\n        this.on('complete', this._onComplete, this);\n    }\n    _onComplete(event) {\n        var loader = event.target;\n        var result = loader[\"_loadedResults\"];\n        AssetLoader.addResources(result);\n    }\n    ;\n    static get resourcesPool() {\n        return AssetLoader.$resources;\n    }\n    static destroyResource(key) {\n        let res = AssetLoader.$resources[key];\n        if (res) {\n            delete AssetLoader.$resources[key];\n        }\n    }\n    static addResources(res) {\n        if (!res)\n            return;\n        for (let key in res) //override the item which has same key name\n            AssetLoader.$resources[key] = res[key];\n    }\n}\nAssetLoader.$resources = {};\n\nclass Endian {\n}\nEndian.LITTLE_ENDIAN = \"littleEndian\";\nEndian.BIG_ENDIAN = \"bigEndian\";\nclass ByteArray {\n    constructor(buffer, bufferExtSize = 0) {\n        this.bufferExtSize = 0; //Buffer expansion size\n        this.EOF_byte = -1;\n        this.EOF_code_point = -1;\n        if (bufferExtSize < 0) {\n            bufferExtSize = 0;\n        }\n        this.bufferExtSize = bufferExtSize;\n        let bytes, wpos = 0;\n        if (buffer) { //有数据，则可写字节数从字节尾开始\n            let uint8;\n            if (buffer instanceof Uint8Array) {\n                uint8 = buffer;\n                wpos = buffer.length;\n            }\n            else {\n                wpos = buffer.byteLength;\n                uint8 = new Uint8Array(buffer);\n            }\n            if (bufferExtSize == 0) {\n                bytes = new Uint8Array(wpos);\n            }\n            else {\n                let multi = (wpos / bufferExtSize | 0) + 1;\n                bytes = new Uint8Array(multi * bufferExtSize);\n            }\n            bytes.set(uint8);\n        }\n        else {\n            bytes = new Uint8Array(bufferExtSize);\n        }\n        this.write_position = wpos;\n        this._position = 0;\n        this._bytes = bytes;\n        this.data = new DataView(bytes.buffer);\n        this.endian = Endian.BIG_ENDIAN;\n    }\n    get endian() {\n        return this.$endian == 0 /* LITTLE_ENDIAN */ ? Endian.LITTLE_ENDIAN : Endian.BIG_ENDIAN;\n    }\n    set endian(value) {\n        this.$endian = value == Endian.LITTLE_ENDIAN ? 0 /* LITTLE_ENDIAN */ : 1 /* BIG_ENDIAN */;\n    }\n    get readAvailable() {\n        return this.write_position - this._position;\n    }\n    get buffer() {\n        return this.data.buffer.slice(0, this.write_position);\n    }\n    get rawBuffer() {\n        return this.data.buffer;\n    }\n    set buffer(value) {\n        let wpos = value.byteLength;\n        let uint8 = new Uint8Array(value);\n        let bufferExtSize = this.bufferExtSize;\n        let bytes;\n        if (bufferExtSize == 0) {\n            bytes = new Uint8Array(wpos);\n        }\n        else {\n            let multi = (wpos / bufferExtSize | 0) + 1;\n            bytes = new Uint8Array(multi * bufferExtSize);\n        }\n        bytes.set(uint8);\n        this.write_position = wpos;\n        this._bytes = bytes;\n        this.data = new DataView(bytes.buffer);\n    }\n    get bytes() {\n        return this._bytes;\n    }\n    get dataView() {\n        return this.data;\n    }\n    set dataView(value) {\n        this.buffer = value.buffer;\n    }\n    get bufferOffset() {\n        return this.data.byteOffset;\n    }\n    get position() {\n        return this._position;\n    }\n    set position(value) {\n        this._position = value;\n        if (value > this.write_position) {\n            this.write_position = value;\n        }\n    }\n    get length() {\n        return this.write_position;\n    }\n    set length(value) {\n        this.write_position = value;\n        if (this.data.byteLength > value) {\n            this._position = value;\n        }\n        this._validateBuffer(value);\n    }\n    _validateBuffer(value) {\n        if (this.data.byteLength < value) {\n            let be = this.bufferExtSize;\n            let tmp;\n            if (be == 0) {\n                tmp = new Uint8Array(value);\n            }\n            else {\n                let nLen = ((value / be >> 0) + 1) * be;\n                tmp = new Uint8Array(nLen);\n            }\n            tmp.set(this._bytes);\n            this._bytes = tmp;\n            this.data = new DataView(tmp.buffer);\n        }\n    }\n    get bytesAvailable() {\n        return this.data.byteLength - this._position;\n    }\n    clear() {\n        let buffer = new ArrayBuffer(this.bufferExtSize);\n        this.data = new DataView(buffer);\n        this._bytes = new Uint8Array(buffer);\n        this._position = 0;\n        this.write_position = 0;\n    }\n    readBoolean() {\n        if (this.validate(1 /* SIZE_OF_BOOLEAN */))\n            return !!this._bytes[this.position++];\n    }\n    readByte() {\n        if (this.validate(1 /* SIZE_OF_INT8 */))\n            return this.data.getInt8(this.position++);\n    }\n    readBytes(bytes, offset = 0, length = 0) {\n        if (!bytes) { //由于bytes不返回，所以new新的无意义\n            return;\n        }\n        let pos = this._position;\n        let available = this.write_position - pos;\n        if (available < 0) {\n            // egret.$error(1025);\n            return;\n        }\n        if (length == 0) {\n            length = available;\n        }\n        else if (length > available) {\n            // egret.$error(1025);\n            return;\n        }\n        const position = bytes._position;\n        bytes._position = 0;\n        bytes.validateBuffer(offset + length);\n        bytes._position = position;\n        bytes._bytes.set(this._bytes.subarray(pos, pos + length), offset);\n        this.position += length;\n    }\n    readDouble() {\n        if (this.validate(8 /* SIZE_OF_FLOAT64 */)) {\n            let value = this.data.getFloat64(this._position, this.$endian == 0 /* LITTLE_ENDIAN */);\n            this.position += 8 /* SIZE_OF_FLOAT64 */;\n            return value;\n        }\n    }\n    readFloat() {\n        if (this.validate(4 /* SIZE_OF_FLOAT32 */)) {\n            let value = this.data.getFloat32(this._position, this.$endian == 0 /* LITTLE_ENDIAN */);\n            this.position += 4 /* SIZE_OF_FLOAT32 */;\n            return value;\n        }\n    }\n    readInt() {\n        if (this.validate(4 /* SIZE_OF_INT32 */)) {\n            let value = this.data.getInt32(this._position, this.$endian == 0 /* LITTLE_ENDIAN */);\n            this.position += 4 /* SIZE_OF_INT32 */;\n            return value;\n        }\n    }\n    readShort() {\n        if (this.validate(2 /* SIZE_OF_INT16 */)) {\n            let value = this.data.getInt16(this._position, this.$endian == 0 /* LITTLE_ENDIAN */);\n            this.position += 2 /* SIZE_OF_INT16 */;\n            return value;\n        }\n    }\n    readUnsignedByte() {\n        if (this.validate(1 /* SIZE_OF_UINT8 */))\n            return this._bytes[this.position++];\n    }\n    readUnsignedInt() {\n        if (this.validate(4 /* SIZE_OF_UINT32 */)) {\n            let value = this.data.getUint32(this._position, this.$endian == 0 /* LITTLE_ENDIAN */);\n            this.position += 4 /* SIZE_OF_UINT32 */;\n            return value;\n        }\n    }\n    readUnsignedShort() {\n        if (this.validate(2 /* SIZE_OF_UINT16 */)) {\n            let value = this.data.getUint16(this._position, this.$endian == 0 /* LITTLE_ENDIAN */);\n            this.position += 2 /* SIZE_OF_UINT16 */;\n            return value;\n        }\n    }\n    readUTF() {\n        let length = this.readUnsignedShort();\n        if (length > 0) {\n            return this.readUTFBytes(length);\n        }\n        else {\n            return \"\";\n        }\n    }\n    readUTFBytes(length) {\n        if (!this.validate(length)) {\n            return;\n        }\n        let data = this.data;\n        let bytes = new Uint8Array(data.buffer, data.byteOffset + this._position, length);\n        this.position += length;\n        return this.decodeUTF8(bytes);\n    }\n    writeBoolean(value) {\n        this.validateBuffer(1 /* SIZE_OF_BOOLEAN */);\n        this._bytes[this.position++] = +value;\n    }\n    writeByte(value) {\n        this.validateBuffer(1 /* SIZE_OF_INT8 */);\n        this._bytes[this.position++] = value & 0xff;\n    }\n    writeBytes(bytes, offset = 0, length = 0) {\n        let writeLength;\n        if (offset < 0) {\n            return;\n        }\n        if (length < 0) {\n            return;\n        }\n        else if (length == 0) {\n            writeLength = bytes.length - offset;\n        }\n        else {\n            writeLength = Math.min(bytes.length - offset, length);\n        }\n        if (writeLength > 0) {\n            this.validateBuffer(writeLength);\n            this._bytes.set(bytes._bytes.subarray(offset, offset + writeLength), this._position);\n            this.position = this._position + writeLength;\n        }\n    }\n    writeDouble(value) {\n        this.validateBuffer(8 /* SIZE_OF_FLOAT64 */);\n        this.data.setFloat64(this._position, value, this.$endian == 0 /* LITTLE_ENDIAN */);\n        this.position += 8 /* SIZE_OF_FLOAT64 */;\n    }\n    writeFloat(value) {\n        this.validateBuffer(4 /* SIZE_OF_FLOAT32 */);\n        this.data.setFloat32(this._position, value, this.$endian == 0 /* LITTLE_ENDIAN */);\n        this.position += 4 /* SIZE_OF_FLOAT32 */;\n    }\n    writeInt(value) {\n        this.validateBuffer(4 /* SIZE_OF_INT32 */);\n        this.data.setInt32(this._position, value, this.$endian == 0 /* LITTLE_ENDIAN */);\n        this.position += 4 /* SIZE_OF_INT32 */;\n    }\n    writeShort(value) {\n        this.validateBuffer(2 /* SIZE_OF_INT16 */);\n        this.data.setInt16(this._position, value, this.$endian == 0 /* LITTLE_ENDIAN */);\n        this.position += 2 /* SIZE_OF_INT16 */;\n    }\n    writeUnsignedInt(value) {\n        this.validateBuffer(4 /* SIZE_OF_UINT32 */);\n        this.data.setUint32(this._position, value, this.$endian == 0 /* LITTLE_ENDIAN */);\n        this.position += 4 /* SIZE_OF_UINT32 */;\n    }\n    writeUnsignedShort(value) {\n        this.validateBuffer(2 /* SIZE_OF_UINT16 */);\n        this.data.setUint16(this._position, value, this.$endian == 0 /* LITTLE_ENDIAN */);\n        this.position += 2 /* SIZE_OF_UINT16 */;\n    }\n    writeUTF(value) {\n        let utf8bytes = this.encodeUTF8(value);\n        let length = utf8bytes.length;\n        this.validateBuffer(2 /* SIZE_OF_UINT16 */ + length);\n        this.data.setUint16(this._position, length, this.$endian == 0 /* LITTLE_ENDIAN */);\n        this.position += 2 /* SIZE_OF_UINT16 */;\n        this._writeUint8Array(utf8bytes, false);\n    }\n    writeUTFBytes(value) {\n        this._writeUint8Array(this.encodeUTF8(value));\n    }\n    toString() {\n        return \"[ByteArray] length:\" + this.length + \", bytesAvailable:\" + this.bytesAvailable;\n    }\n    _writeUint8Array(bytes, validateBuffer = true) {\n        let pos = this._position;\n        let npos = pos + bytes.length;\n        if (validateBuffer) {\n            this.validateBuffer(npos);\n        }\n        this.bytes.set(bytes, pos);\n        this.position = npos;\n    }\n    validate(len) {\n        let bl = this._bytes.length;\n        if (bl > 0 && this._position + len <= bl) {\n            return true;\n        }\n    }\n    /*  PRIVATE METHODS   */\n    validateBuffer(len) {\n        this.write_position = len > this.write_position ? len : this.write_position;\n        len += this._position;\n        this._validateBuffer(len);\n    }\n    encodeUTF8(str) {\n        let pos = 0;\n        let codePoints = this.stringToCodePoints(str);\n        let outputBytes = [];\n        while (codePoints.length > pos) {\n            let code_point = codePoints[pos++];\n            if (this.inRange(code_point, 0xD800, 0xDFFF)) {\n                this.encoderError(code_point);\n            }\n            else if (this.inRange(code_point, 0x0000, 0x007f)) {\n                outputBytes.push(code_point);\n            }\n            else {\n                let count, offset;\n                if (this.inRange(code_point, 0x0080, 0x07FF)) {\n                    count = 1;\n                    offset = 0xC0;\n                }\n                else if (this.inRange(code_point, 0x0800, 0xFFFF)) {\n                    count = 2;\n                    offset = 0xE0;\n                }\n                else if (this.inRange(code_point, 0x10000, 0x10FFFF)) {\n                    count = 3;\n                    offset = 0xF0;\n                }\n                outputBytes.push(this.div(code_point, Math.pow(64, count)) + offset);\n                while (count > 0) {\n                    let temp = this.div(code_point, Math.pow(64, count - 1));\n                    outputBytes.push(0x80 + (temp % 64));\n                    count -= 1;\n                }\n            }\n        }\n        return new Uint8Array(outputBytes);\n    }\n    decodeUTF8(data) {\n        let fatal = false;\n        let pos = 0;\n        let result = \"\";\n        let code_point;\n        let utf8_code_point = 0;\n        let utf8_bytes_needed = 0;\n        let utf8_bytes_seen = 0;\n        let utf8_lower_boundary = 0;\n        while (data.length > pos) {\n            let _byte = data[pos++];\n            if (_byte == this.EOF_byte) {\n                if (utf8_bytes_needed != 0) {\n                    code_point = this.decoderError(fatal);\n                }\n                else {\n                    code_point = this.EOF_code_point;\n                }\n            }\n            else {\n                if (utf8_bytes_needed == 0) {\n                    if (this.inRange(_byte, 0x00, 0x7F)) {\n                        code_point = _byte;\n                    }\n                    else {\n                        if (this.inRange(_byte, 0xC2, 0xDF)) {\n                            utf8_bytes_needed = 1;\n                            utf8_lower_boundary = 0x80;\n                            utf8_code_point = _byte - 0xC0;\n                        }\n                        else if (this.inRange(_byte, 0xE0, 0xEF)) {\n                            utf8_bytes_needed = 2;\n                            utf8_lower_boundary = 0x800;\n                            utf8_code_point = _byte - 0xE0;\n                        }\n                        else if (this.inRange(_byte, 0xF0, 0xF4)) {\n                            utf8_bytes_needed = 3;\n                            utf8_lower_boundary = 0x10000;\n                            utf8_code_point = _byte - 0xF0;\n                        }\n                        else {\n                            this.decoderError(fatal);\n                        }\n                        utf8_code_point = utf8_code_point * Math.pow(64, utf8_bytes_needed);\n                        code_point = null;\n                    }\n                }\n                else if (!this.inRange(_byte, 0x80, 0xBF)) {\n                    utf8_code_point = 0;\n                    utf8_bytes_needed = 0;\n                    utf8_bytes_seen = 0;\n                    utf8_lower_boundary = 0;\n                    pos--;\n                    code_point = this.decoderError(fatal, _byte);\n                }\n                else {\n                    utf8_bytes_seen += 1;\n                    utf8_code_point = utf8_code_point + (_byte - 0x80) * Math.pow(64, utf8_bytes_needed - utf8_bytes_seen);\n                    if (utf8_bytes_seen !== utf8_bytes_needed) {\n                        code_point = null;\n                    }\n                    else {\n                        let cp = utf8_code_point;\n                        let lower_boundary = utf8_lower_boundary;\n                        utf8_code_point = 0;\n                        utf8_bytes_needed = 0;\n                        utf8_bytes_seen = 0;\n                        utf8_lower_boundary = 0;\n                        if (this.inRange(cp, lower_boundary, 0x10FFFF) && !this.inRange(cp, 0xD800, 0xDFFF)) {\n                            code_point = cp;\n                        }\n                        else {\n                            code_point = this.decoderError(fatal, _byte);\n                        }\n                    }\n                }\n            }\n            //Decode string\n            if (code_point !== null && code_point !== this.EOF_code_point) {\n                if (code_point <= 0xFFFF) {\n                    if (code_point > 0)\n                        result += String.fromCharCode(code_point);\n                }\n                else {\n                    code_point -= 0x10000;\n                    result += String.fromCharCode(0xD800 + ((code_point >> 10) & 0x3ff));\n                    result += String.fromCharCode(0xDC00 + (code_point & 0x3ff));\n                }\n            }\n        }\n        return result;\n    }\n    encoderError(code_point) {\n        // egret.$error(1026, code_point);\n    }\n    decoderError(fatal, opt_code_point) {\n        return opt_code_point || 0xFFFD;\n    }\n    inRange(a, min, max) {\n        return min <= a && a <= max;\n    }\n    div(n, d) {\n        return Math.floor(n / d);\n    }\n    stringToCodePoints(string) {\n        let cps = [];\n        // Based on http://www.w3.org/TR/WebIDL/#idl-DOMString\n        let i = 0, n = string.length;\n        while (i < string.length) {\n            let c = string.charCodeAt(i);\n            if (!this.inRange(c, 0xD800, 0xDFFF)) {\n                cps.push(c);\n            }\n            else if (this.inRange(c, 0xDC00, 0xDFFF)) {\n                cps.push(0xFFFD);\n            }\n            else { // (inRange(c, 0xD800, 0xDBFF))\n                if (i == n - 1) {\n                    cps.push(0xFFFD);\n                }\n                else {\n                    let d = string.charCodeAt(i + 1);\n                    if (this.inRange(d, 0xDC00, 0xDFFF)) {\n                        let a = c & 0x3FF;\n                        let b = d & 0x3FF;\n                        i += 1;\n                        cps.push(0x10000 + (a << 10) + b);\n                    }\n                    else {\n                        cps.push(0xFFFD);\n                    }\n                }\n            }\n            i += 1;\n        }\n        return cps;\n    }\n}\n\nclass RawByte {\n    static inRange(a, min, max) {\n        return min <= a && a <= max;\n    }\n    static decodeUTF8(data) {\n        let pos = 0;\n        let result = \"\";\n        let code_point;\n        let utf8_code_point = 0;\n        let utf8_bytes_needed = 0;\n        let utf8_bytes_seen = 0;\n        let utf8_lower_boundary = 0;\n        while (data.length > pos) {\n            let _byte = data[pos++];\n            if (_byte == -1 /* EOF_byte */) {\n                if (utf8_bytes_needed != 0) {\n                    code_point = 65533 /* Fatal_code_point */;\n                }\n                else {\n                    code_point = -1 /* EOF_code_point */;\n                }\n            }\n            else {\n                if (utf8_bytes_needed == 0) {\n                    if (RawByte.inRange(_byte, 0x00, 0x7F)) {\n                        code_point = _byte;\n                    }\n                    else {\n                        if (RawByte.inRange(_byte, 0xC2, 0xDF)) {\n                            utf8_bytes_needed = 1;\n                            utf8_lower_boundary = 0x80;\n                            utf8_code_point = _byte - 0xC0;\n                        }\n                        else if (RawByte.inRange(_byte, 0xE0, 0xEF)) {\n                            utf8_bytes_needed = 2;\n                            utf8_lower_boundary = 0x800;\n                            utf8_code_point = _byte - 0xE0;\n                        }\n                        else if (RawByte.inRange(_byte, 0xF0, 0xF4)) {\n                            utf8_bytes_needed = 3;\n                            utf8_lower_boundary = 0x10000;\n                            utf8_code_point = _byte - 0xF0;\n                        }\n                        else {\n                            throw new Error(\"failed to decode the raw binary data\");\n                        }\n                        utf8_code_point = utf8_code_point * Math.pow(64, utf8_bytes_needed);\n                        code_point = null;\n                    }\n                }\n                else if (!RawByte.inRange(_byte, 0x80, 0xBF)) {\n                    utf8_code_point = 0;\n                    utf8_bytes_needed = 0;\n                    utf8_bytes_seen = 0;\n                    utf8_lower_boundary = 0;\n                    pos--;\n                    code_point = 65533 /* Fatal_code_point */;\n                }\n                else {\n                    utf8_bytes_seen += 1;\n                    utf8_code_point = utf8_code_point + (_byte - 0x80) * Math.pow(64, utf8_bytes_needed - utf8_bytes_seen);\n                    if (utf8_bytes_seen !== utf8_bytes_needed) {\n                        code_point = null;\n                    }\n                    else {\n                        let cp = utf8_code_point;\n                        let lower_boundary = utf8_lower_boundary;\n                        utf8_code_point = 0;\n                        utf8_bytes_needed = 0;\n                        utf8_bytes_seen = 0;\n                        utf8_lower_boundary = 0;\n                        if (RawByte.inRange(cp, lower_boundary, 0x10FFFF) && !this.inRange(cp, 0xD800, 0xDFFF)) {\n                            code_point = cp;\n                        }\n                        else {\n                            code_point = _byte;\n                        }\n                    }\n                }\n            }\n            //Decode string\n            if (code_point !== null && code_point !== -1 /* EOF_code_point */) {\n                if (code_point <= 0xFFFF) {\n                    if (code_point > 0)\n                        result += String.fromCharCode(code_point);\n                }\n                else {\n                    code_point -= 0x10000;\n                    result += String.fromCharCode(0xD800 + ((code_point >> 10) & 0x3ff));\n                    result += String.fromCharCode(0xDC00 + (code_point & 0x3ff));\n                }\n            }\n        }\n        return result;\n    }\n}\n\nvar BufferType;\n(function (BufferType) {\n    BufferType[BufferType[\"BLOCK\"] = 0] = \"BLOCK\";\n    BufferType[BufferType[\"ADAPTIVE\"] = 1] = \"ADAPTIVE\";\n})(BufferType || (BufferType = {}));\n/** @define {number} buffer block size. */\nconst ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]\nconst MaxBackwardLength = 32768;\nconst MaxCopyLength = 258;\nconst Order = new Uint16Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\nconst LengthCodeTable = new Uint16Array([\n    0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\n    0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\n    0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\n    0x00e3, 0x0102, 0x0102, 0x0102\n]);\nconst LengthExtraTable = new Uint8Array([\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\n    5, 5, 0, 0, 0\n]);\nconst DistCodeTable = new Uint16Array([\n    0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\n    0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\n    0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\n    0x3001, 0x4001, 0x6001\n]);\nconst DistExtraTable = new Uint8Array([\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\n    11, 12, 12, 13, 13\n]);\nconst buildHuffmanTable = (lengths) => {\n    /** @type {number} length list size. */\n    var listSize = lengths.length;\n    /** @type {number} max code length for table size. */\n    var maxCodeLength = 0;\n    /** @type {number} min code length for table size. */\n    var minCodeLength = Number.POSITIVE_INFINITY;\n    /** @type {number} table size. */\n    var size;\n    /** @type {!(Array|Uint8Array)} huffman code table. */\n    var table;\n    /** @type {number} bit length. */\n    var bitLength;\n    /** @type {number} huffman code. */\n    var code;\n    /**\n     * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.\n     * @type {number} skip length for table filling.\n     */\n    var skip;\n    /** @type {number} reversed code. */\n    var reversed;\n    /** @type {number} reverse temp. */\n    var rtemp;\n    /** @type {number} loop counter. */\n    var i;\n    /** @type {number} loop limit. */\n    var il;\n    /** @type {number} loop counter. */\n    var j;\n    /** @type {number} table value. */\n    var value;\n    // Math.max は遅いので最長の値は for-loop で取得する\n    for (i = 0, il = listSize; i < il; ++i) {\n        if (lengths[i] > maxCodeLength) {\n            maxCodeLength = lengths[i];\n        }\n        if (lengths[i] < minCodeLength) {\n            minCodeLength = lengths[i];\n        }\n    }\n    size = 1 << maxCodeLength;\n    table = new Uint32Array(size);\n    // ビット長の短い順からハフマン符号を割り当てる\n    for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {\n        for (i = 0; i < listSize; ++i) {\n            if (lengths[i] === bitLength) {\n                // ビットオーダーが逆になるためビット長分並びを反転する\n                for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {\n                    reversed = (reversed << 1) | (rtemp & 1);\n                    rtemp >>= 1;\n                }\n                // 最大ビット長をもとにテーブルを作るため、\n                // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる\n                // そのどちらでも良い場所は同じ値で埋めることで\n                // 本来のビット長以上のビット数取得しても問題が起こらないようにする\n                value = (bitLength << 16) | i;\n                for (j = reversed; j < size; j += skip) {\n                    table[j] = value;\n                }\n                ++code;\n            }\n        }\n        // 次のビット長へ\n        ++bitLength;\n        code <<= 1;\n        skip <<= 1;\n    }\n    return [table, maxCodeLength, minCodeLength];\n};\nconst FixedLiteralLengthTable = (() => {\n    let lengths = new Uint8Array(288);\n    for (let i = 0, il = lengths.length; i < il; ++i) {\n        lengths[i] =\n            (i <= 143) ? 8 :\n                (i <= 255) ? 9 :\n                    (i <= 279) ? 7 :\n                        8;\n    }\n    return buildHuffmanTable(lengths)[0];\n})();\nconst FixedDistanceTable = (() => {\n    let lengths = new Uint8Array(30);\n    for (let i = 0, il = lengths.length; i < il; ++i) {\n        lengths[i] = 5;\n    }\n    return buildHuffmanTable(lengths);\n})();\nclass RawInflate {\n    constructor(input, opt_params) {\n        this.blocks = [];\n        this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;\n        this.totalpos = 0;\n        this.ip = 0;\n        this.bitsbuf = 0;\n        this.bitsbuflen = 0;\n        this.input = new Uint8Array(input);\n        this.bfinal = false;\n        this.bufferType = BufferType.ADAPTIVE;\n        this.resize = false;\n        // option parameters\n        if (opt_params) {\n            if (opt_params['index']) {\n                this.ip = opt_params['index'];\n            }\n            if (opt_params['bufferSize']) {\n                this.bufferSize = opt_params['bufferSize'];\n            }\n            if (opt_params['bufferType']) {\n                this.bufferType = opt_params['bufferType'];\n            }\n            if (opt_params['resize']) {\n                this.resize = opt_params['resize'];\n            }\n        }\n        // initialize\n        switch (this.bufferType) {\n            case BufferType.BLOCK:\n                this.op = MaxBackwardLength;\n                this.output = new Uint8Array(MaxBackwardLength + this.bufferSize + MaxCopyLength);\n                break;\n            case BufferType.ADAPTIVE:\n                this.op = 0;\n                this.output = new Uint8Array(this.bufferSize);\n                break;\n            default:\n                throw new Error('invalid inflate mode');\n        }\n    }\n    decompress() {\n        while (!this.bfinal) {\n            this.parseBlock();\n        }\n        switch (this.bufferType) {\n            case BufferType.BLOCK:\n                return this.concatBufferBlock();\n            case BufferType.ADAPTIVE:\n                return this.concatBufferDynamic();\n            default:\n                throw new Error('invalid inflate mode');\n        }\n    }\n    parseBlock() {\n        let hdr = this.readBits(3);\n        if (hdr & 0x1) {\n            this.bfinal = true;\n        }\n        hdr >>>= 1;\n        switch (hdr) {\n            // uncompressed\n            case 0:\n                this.parseUncompressedBlock();\n                break;\n            // fixed huffman\n            case 1:\n                this.parseFixedHuffmanBlock();\n                break;\n            // dynamic huffman\n            case 2:\n                this.parseDynamicHuffmanBlock();\n                break;\n            // reserved or other\n            default:\n                throw new Error('unknown BTYPE: ' + hdr);\n        }\n    }\n    ;\n    readBits(length) {\n        let bitsbuf = this.bitsbuf;\n        let bitsbuflen = this.bitsbuflen;\n        let input = this.input;\n        let ip = this.ip;\n        let inputLength = input.length;\n        let octet;\n        if (ip + ((length - bitsbuflen + 7) >> 3) >= inputLength) {\n            throw new Error('input buffer is broken');\n        }\n        // not enough buffer\n        while (bitsbuflen < length) {\n            bitsbuf |= input[ip++] << bitsbuflen;\n            bitsbuflen += 8;\n        }\n        // output byte\n        octet = bitsbuf & /* MASK */ ((1 << length) - 1);\n        bitsbuf >>>= length;\n        bitsbuflen -= length;\n        this.bitsbuf = bitsbuf;\n        this.bitsbuflen = bitsbuflen;\n        this.ip = ip;\n        return octet;\n    }\n    ;\n    readCodeByTable(table) {\n        let bitsbuf = this.bitsbuf;\n        let bitsbuflen = this.bitsbuflen;\n        let input = this.input;\n        let ip = this.ip;\n        /** @type {number} */\n        let inputLength = input.length;\n        /** @type {!(Array.<number>|Uint8Array)} huffman code table */\n        let codeTable = table[0];\n        /** @type {number} */\n        let maxCodeLength = table[1];\n        /** @type {number} code length & code (16bit, 16bit) */\n        let codeWithLength;\n        /** @type {number} code bits length */\n        let codeLength;\n        // not enough buffer\n        while (bitsbuflen < maxCodeLength) {\n            if (ip >= inputLength) {\n                break;\n            }\n            bitsbuf |= input[ip++] << bitsbuflen;\n            bitsbuflen += 8;\n        }\n        // read max length\n        codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\n        codeLength = codeWithLength >>> 16;\n        if (codeLength > bitsbuflen) {\n            throw new Error('invalid code length: ' + codeLength);\n        }\n        this.bitsbuf = bitsbuf >> codeLength;\n        this.bitsbuflen = bitsbuflen - codeLength;\n        this.ip = ip;\n        return codeWithLength & 0xffff;\n    }\n    ;\n    parseUncompressedBlock() {\n        let input = this.input;\n        let ip = this.ip;\n        let output = this.output;\n        let op = this.op;\n        /** @type {number} */\n        let inputLength = input.length;\n        /** @type {number} block length */\n        let len;\n        /** @type {number} number for check block length */\n        let nlen;\n        /** @type {number} output buffer length */\n        let olength = output.length;\n        /** @type {number} copy counter */\n        let preCopy;\n        // skip buffered header bits\n        this.bitsbuf = 0;\n        this.bitsbuflen = 0;\n        // len\n        if (ip + 1 >= inputLength) {\n            throw new Error('invalid uncompressed block header: LEN');\n        }\n        len = input[ip++] | (input[ip++] << 8);\n        // nlen\n        if (ip + 1 >= inputLength) {\n            throw new Error('invalid uncompressed block header: NLEN');\n        }\n        nlen = input[ip++] | (input[ip++] << 8);\n        // check len & nlen\n        if (len === ~nlen) {\n            throw new Error('invalid uncompressed block header: length verify');\n        }\n        // check size\n        if (ip + len > input.length) {\n            throw new Error('input buffer is broken');\n        }\n        // expand buffer\n        switch (this.bufferType) {\n            case BufferType.BLOCK:\n                // pre copy\n                while (op + len > output.length) {\n                    preCopy = olength - op;\n                    len -= preCopy;\n                    output.set(input.subarray(ip, ip + preCopy), op);\n                    op += preCopy;\n                    ip += preCopy;\n                    this.op = op;\n                    output = this.expandBufferBlock();\n                    op = this.op;\n                }\n                break;\n            case BufferType.ADAPTIVE:\n                while (op + len > output.length) {\n                    output = this.expandBufferAdaptive({ fixRatio: 2 });\n                }\n                break;\n            default:\n                throw new Error('invalid inflate mode');\n        }\n        // copy\n        output.set(input.subarray(ip, ip + len), op);\n        op += len;\n        ip += len;\n        this.ip = ip;\n        this.op = op;\n        this.output = output;\n    }\n    ;\n    parseFixedHuffmanBlock() {\n        switch (this.bufferType) {\n            case BufferType.ADAPTIVE:\n                this.decodeHuffmanAdaptive(FixedLiteralLengthTable, FixedDistanceTable);\n                break;\n            case BufferType.BLOCK:\n                this.decodeHuffmanBlock(FixedLiteralLengthTable, FixedDistanceTable);\n                break;\n            default:\n                throw new Error('invalid inflate mode');\n        }\n    }\n    parseDynamicHuffmanBlock() {\n        /** @type {number} number of literal and length codes. */\n        let hlit = this.readBits(5) + 257;\n        /** @type {number} number of distance codes. */\n        let hdist = this.readBits(5) + 1;\n        /** @type {number} number of code lengths. */\n        let hclen = this.readBits(4) + 4;\n        /** @type {!(Uint8Array|Array.<number>)} code lengths. */\n        let codeLengths = new Uint8Array(Order.length);\n        /** @type {!Array} code lengths table. */\n        let codeLengthsTable;\n        /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */\n        let litlenTable;\n        /** @type {!(Uint8Array|Array.<number>)} distance code table. */\n        let distTable;\n        /** @type {number} */\n        let code;\n        /** @type {number} */\n        let prev;\n        /** @type {number} */\n        let repeat;\n        /** @type {number} loop counter. */\n        let i;\n        /** @type {number} loop limit. */\n        let il;\n        // decode code lengths\n        for (i = 0; i < hclen; ++i) {\n            codeLengths[Order[i]] = this.readBits(3);\n        }\n        // decode length table\n        codeLengthsTable = buildHuffmanTable(codeLengths);\n        let lengthTable = new Uint8Array(hlit + hdist);\n        for (i = 0, il = hlit + hdist; i < il;) {\n            code = this.readCodeByTable(codeLengthsTable);\n            switch (code) {\n                case 16:\n                    repeat = 3 + this.readBits(2);\n                    while (repeat--) {\n                        lengthTable[i++] = prev;\n                    }\n                    break;\n                case 17:\n                    repeat = 3 + this.readBits(3);\n                    while (repeat--) {\n                        lengthTable[i++] = 0;\n                    }\n                    prev = 0;\n                    break;\n                case 18:\n                    repeat = 11 + this.readBits(7);\n                    while (repeat--) {\n                        lengthTable[i++] = 0;\n                    }\n                    prev = 0;\n                    break;\n                default:\n                    lengthTable[i++] = code;\n                    prev = code;\n                    break;\n            }\n        }\n        litlenTable = buildHuffmanTable(lengthTable.subarray(0, hlit));\n        distTable = buildHuffmanTable(lengthTable.subarray(hlit));\n        switch (this.bufferType) {\n            case BufferType.ADAPTIVE:\n                this.decodeHuffmanAdaptive(litlenTable, distTable);\n                break;\n            case BufferType.BLOCK:\n                this.decodeHuffmanBlock(litlenTable, distTable);\n                break;\n            default:\n                throw new Error('invalid inflate mode');\n        }\n    }\n    decodeHuffmanBlock(litlen, dist) {\n        let output = this.output;\n        let op = this.op;\n        this.currentLitlenTable = litlen;\n        /** @type {number} output position limit. */\n        let olength = output.length - MaxCopyLength;\n        /** @type {number} huffman code. */\n        let code;\n        /** @type {number} table index. */\n        let ti;\n        /** @type {number} huffman code distination. */\n        let codeDist;\n        /** @type {number} huffman code length. */\n        let codeLength;\n        let lengthCodeTable = LengthCodeTable;\n        let lengthExtraTable = LengthExtraTable;\n        let distCodeTable = DistCodeTable;\n        let distExtraTable = DistExtraTable;\n        while ((code = this.readCodeByTable(litlen)) !== 256) {\n            // literal\n            if (code < 256) {\n                if (op >= olength) {\n                    this.op = op;\n                    output = this.expandBufferBlock();\n                    op = this.op;\n                }\n                output[op++] = code;\n                continue;\n            }\n            // length code\n            ti = code - 257;\n            codeLength = lengthCodeTable[ti];\n            if (lengthExtraTable[ti] > 0) {\n                codeLength += this.readBits(lengthExtraTable[ti]);\n            }\n            // dist code\n            code = this.readCodeByTable(dist);\n            codeDist = distCodeTable[code];\n            if (distExtraTable[code] > 0) {\n                codeDist += this.readBits(distExtraTable[code]);\n            }\n            // lz77 decode\n            if (op >= olength) {\n                this.op = op;\n                output = this.expandBufferBlock();\n                op = this.op;\n            }\n            while (codeLength--) {\n                output[op] = output[(op++) - codeDist];\n            }\n        }\n        while (this.bitsbuflen >= 8) {\n            this.bitsbuflen -= 8;\n            this.ip--;\n        }\n        this.op = op;\n    }\n    ;\n    decodeHuffmanAdaptive(litlen, dist) {\n        let output = this.output;\n        let op = this.op;\n        this.currentLitlenTable = litlen;\n        /** @type {number} output position limit. */\n        let olength = output.length;\n        /** @type {number} huffman code. */\n        let code;\n        /** @type {number} table index. */\n        let ti;\n        /** @type {number} huffman code distination. */\n        let codeDist;\n        /** @type {number} huffman code length. */\n        let codeLength;\n        let lengthCodeTable = LengthCodeTable;\n        let lengthExtraTable = LengthExtraTable;\n        let distCodeTable = DistCodeTable;\n        let distExtraTable = DistExtraTable;\n        while ((code = this.readCodeByTable(litlen)) !== 256) {\n            // literal\n            if (code < 256) {\n                if (op >= olength) {\n                    output = this.expandBufferAdaptive();\n                    olength = output.length;\n                }\n                output[op++] = code;\n                continue;\n            }\n            // length code\n            ti = code - 257;\n            codeLength = lengthCodeTable[ti];\n            if (lengthExtraTable[ti] > 0) {\n                codeLength += this.readBits(lengthExtraTable[ti]);\n            }\n            // dist code\n            code = this.readCodeByTable(dist);\n            codeDist = distCodeTable[code];\n            if (distExtraTable[code] > 0) {\n                codeDist += this.readBits(distExtraTable[code]);\n            }\n            // lz77 decode\n            if (op + codeLength > olength) {\n                output = this.expandBufferAdaptive();\n                olength = output.length;\n            }\n            while (codeLength--) {\n                output[op] = output[(op++) - codeDist];\n            }\n        }\n        while (this.bitsbuflen >= 8) {\n            this.bitsbuflen -= 8;\n            this.ip--;\n        }\n        this.op = op;\n    }\n    expandBufferBlock() {\n        let buffer = new Uint8Array(this.op - MaxBackwardLength);\n        let backward = this.op - MaxBackwardLength;\n        let output = this.output;\n        // copy to output buffer\n        buffer.set(output.subarray(MaxBackwardLength, buffer.length));\n        this.blocks.push(buffer);\n        this.totalpos += buffer.length;\n        // copy to backward buffer\n        output.set(output.subarray(backward, backward + MaxBackwardLength));\n        this.op = MaxBackwardLength;\n        return output;\n    }\n    expandBufferAdaptive(opt_param) {\n        /** @type {!(Array.<number>|Uint8Array)} store buffer. */\n        let buffer;\n        /** @type {number} expantion ratio. */\n        let ratio = (this.input.length / this.ip + 1) | 0;\n        /** @type {number} maximum number of huffman code. */\n        let maxHuffCode;\n        /** @type {number} new output buffer size. */\n        let newSize;\n        /** @type {number} max inflate size. */\n        let maxInflateSize;\n        let input = this.input;\n        let output = this.output;\n        if (opt_param) {\n            if (typeof opt_param.fixRatio === 'number') {\n                ratio = opt_param.fixRatio;\n            }\n            if (typeof opt_param.addRatio === 'number') {\n                ratio += opt_param.addRatio;\n            }\n        }\n        // calculate new buffer size\n        if (ratio < 2) {\n            maxHuffCode =\n                (input.length - this.ip) / this.currentLitlenTable[2];\n            maxInflateSize = (maxHuffCode / 2 * 258) | 0;\n            newSize = maxInflateSize < output.length ?\n                output.length + maxInflateSize :\n                output.length << 1;\n        }\n        else {\n            newSize = output.length * ratio;\n        }\n        buffer = new Uint8Array(newSize);\n        buffer.set(output);\n        this.output = buffer;\n        return this.output;\n    }\n    ;\n    concatBufferBlock() {\n        /** @type {number} buffer pointer. */\n        let pos = 0;\n        /** @type {number} buffer pointer. */\n        let limit = this.totalpos + (this.op - MaxBackwardLength);\n        /** @type {!(Array.<number>|Uint8Array)} output block array. */\n        let output = this.output;\n        /** @type {!Array} blocks array. */\n        let blocks = this.blocks;\n        /** @type {!(Array.<number>|Uint8Array)} output block array. */\n        let block;\n        /** @type {!(Array.<number>|Uint8Array)} output buffer. */\n        let buffer = new Uint8Array(limit);\n        /** @type {number} loop counter. */\n        let i;\n        /** @type {number} loop limiter. */\n        let il;\n        /** @type {number} loop counter. */\n        let j;\n        /** @type {number} loop limiter. */\n        let jl;\n        // single buffer\n        if (blocks.length === 0) {\n            return this.output.subarray(MaxBackwardLength, this.op);\n        }\n        // copy to buffer\n        for (i = 0, il = blocks.length; i < il; ++i) {\n            block = blocks[i];\n            for (j = 0, jl = block.length; j < jl; ++j) {\n                buffer[pos++] = block[j];\n            }\n        }\n        // current buffer\n        for (i = MaxBackwardLength, il = this.op; i < il; ++i) {\n            buffer[pos++] = output[i];\n        }\n        this.blocks = [];\n        this.buffer = buffer;\n        return this.buffer;\n    }\n    ;\n    concatBufferDynamic() {\n        let buffer;\n        let op = this.op;\n        if (this.resize) {\n            buffer = new Uint8Array(op);\n            buffer.set(this.output.subarray(0, op));\n        }\n        else {\n            buffer = this.output.subarray(0, op);\n        }\n        this.buffer = buffer;\n        return this.buffer;\n    }\n}\n\nclass StringUtil {\n    static encodeHTML(str) {\n        if (!str)\n            return \"\";\n        else\n            return str.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\").replace(\"'\", \"&apos;\");\n    }\n    static getFileName(source) {\n        let i = source.lastIndexOf(\"/\");\n        if (i != -1)\n            source = source.substr(i + 1);\n        i = source.lastIndexOf(\"\\\\\");\n        if (i != -1)\n            source = source.substr(i + 1);\n        i = source.lastIndexOf(\".\");\n        if (i != -1)\n            return source.substring(0, i);\n        else\n            return source;\n    }\n    static startsWith(source, str, ignoreCase = false) {\n        if (!source)\n            return false;\n        else if (source.length < str.length)\n            return false;\n        else {\n            source = source.substring(0, str.length);\n            if (!ignoreCase)\n                return source == str;\n            else\n                return source.toLowerCase() == str.toLowerCase();\n        }\n    }\n    static endsWith(source, str, ignoreCase = false) {\n        if (!source)\n            return false;\n        else if (source.length < str.length)\n            return false;\n        else {\n            source = source.substring(source.length - str.length);\n            if (!ignoreCase)\n                return source == str;\n            else\n                return source.toLowerCase() == str.toLowerCase();\n        }\n    }\n    static trim(targetString) {\n        return StringUtil.trimLeft(StringUtil.trimRight(targetString));\n    }\n    static trimLeft(targetString) {\n        let tempChar = \"\";\n        let i;\n        for (i = 0; i < targetString.length; i++) {\n            tempChar = targetString.charAt(i);\n            if (tempChar != \" \" && tempChar != \"\\n\" && tempChar != \"\\r\")\n                break;\n        }\n        return targetString.substr(i);\n    }\n    static trimRight(targetString) {\n        let tempChar = \"\";\n        let i;\n        for (i = targetString.length - 1; i >= 0; i--) {\n            tempChar = targetString.charAt(i);\n            if (tempChar != \" \" && tempChar != \"\\n\" && tempChar != \"\\r\")\n                break;\n        }\n        return targetString.substring(0, i + 1);\n    }\n    static convertToHtmlColor(argb, hasAlpha = false) {\n        let alpha;\n        if (hasAlpha)\n            alpha = (argb >> 24 & 0xFF).toString(16);\n        else\n            alpha = \"\";\n        let red = (argb >> 16 & 0xFF).toString(16);\n        let green = (argb >> 8 & 0xFF).toString(16);\n        let blue = (argb & 0xFF).toString(16);\n        if (alpha.length == 1)\n            alpha = `0${alpha}`;\n        if (red.length == 1)\n            red = `0${red}`;\n        if (green.length == 1)\n            green = `0${green}`;\n        if (blue.length == 1)\n            blue = `0${blue}`;\n        return `#${alpha}${red}${green}${blue}`;\n    }\n    static convertFromHtmlColor(str, hasAlpha = false) {\n        if (str.length < 1)\n            return 0;\n        if (str.charAt(0) == \"#\")\n            str = str.substr(1);\n        if (str.length == 8)\n            return (parseInt(str.substr(0, 2), 16) << 24) + parseInt(str.substr(2), 16);\n        else if (hasAlpha)\n            return 0xFF000000 + parseInt(str, 16);\n        else\n            return parseInt(str, 16);\n    }\n    static convertToRGBA(str) {\n        if (str.charAt(0) == \"#\")\n            str = str.substr(1);\n        let alpha = +(parseInt('0x' + str.slice(0, 2)) / 255).toFixed(2);\n        str = str.substr(2);\n        let r = parseInt(str.substring(0, 2), 16);\n        let g = parseInt(str.substring(2, 4), 16);\n        let b = parseInt(str.substring(4), 16);\n        return createjs.Graphics.getRGB(r, g, b, alpha);\n    }\n    static HEX2RGB(hex) {\n        if (hex.charAt(0) == \"#\")\n            hex = hex.substr(1);\n        if (hex.length === 3) {\n            hex += hex;\n        }\n        return `${this.HEX2DEC(hex.substring(0, 2))},${this.HEX2DEC(hex.substring(2, 4))},${this.HEX2DEC(hex.substring(4))}`;\n    }\n    static HEX2DEC(hex) {\n        return parseInt(hex, 16).toString();\n    }\n}\n\nclass Utils {\n    static deepCopyProperties(target, source, propertyObj) {\n        for (var prop in propertyObj) {\n            if (Array.isArray(source[prop])) {\n                target[prop] = source[prop].slice();\n            }\n            else {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    static fillPath(ctx, points, px, py) {\n        var cnt = points.length;\n        ctx.moveTo(points[0] + px, points[1] + py);\n        for (var i = 2; i < cnt; i += 2) {\n            ctx.lineTo(points[i] + px, points[i + 1] + py);\n        }\n        ctx.lineTo(points[0] + px, points[1] + py);\n    }\n}\nUtils.TextureCache = {};\n\nclass XmlNode {\n    constructor(ele) {\n        this.nodeName = ele.nodeName;\n        this.context = ele;\n        this.type = ele.nodeType;\n        this.text = (this.type == Node.COMMENT_NODE || this.type == Node.TEXT_NODE) ? this.context.textContent : null;\n    }\n    get children() {\n        if (!this.$children)\n            this.$children = XmlParser.getChildNodes(this);\n        return this.$children;\n    }\n    get attributes() {\n        if (!this.$attributes)\n            this.$attributes = XmlParser.getNodeAttributes(this);\n        return this.$attributes;\n    }\n}\nclass XmlParser {\n    static tryParse(xmlstring, mimeType = \"application/xml\") {\n        let doc = XmlParser.$parser.parseFromString(xmlstring, mimeType);\n        if (doc && doc.childNodes && doc.childNodes.length >= 1)\n            return new XmlNode(doc.firstChild);\n        return null;\n    }\n    static getXmlRoot(xml) {\n        if (!xml || !xml.context)\n            throw new Error(\"Invalid xml node\");\n        let p = xml.context;\n        while (p.parentNode != null)\n            p = p.parentNode;\n        return p == xml.context ? xml : new XmlNode(p);\n    }\n    static getChildNodes(xml, matchName = null) {\n        let nodes = xml.context.childNodes;\n        let ret = [];\n        if (!nodes || nodes.length <= 0)\n            return ret;\n        let len = nodes.length;\n        for (let i = 0; i < len; i++) {\n            let n = nodes.item(i);\n            if (n.nodeType == Node.TEXT_NODE)\n                continue;\n            if (!matchName || (matchName && matchName.length > 0 && n.nodeName.toLowerCase() == matchName.toLowerCase()))\n                ret.push(new XmlNode(n));\n        }\n        return ret;\n    }\n    static getNodeAttributes(xml) {\n        let context = xml.context;\n        let asList = context.attributes;\n        let ret = {};\n        if (!asList || asList.length <= 0)\n            return ret;\n        let len = asList.length;\n        for (let i = 0; i < len; i++) {\n            let a = asList.item(i);\n            ret[a.nodeName] = a.nodeValue;\n        }\n        return ret;\n    }\n}\nXmlParser.$parser = new DOMParser();\n\nclass DisplayListItem {\n    constructor(packageItem, type) {\n        this.packageItem = packageItem;\n        this.type = type;\n    }\n}\n\nclass PackageItem {\n    constructor() {\n        this.width = 0;\n        this.height = 0;\n        this.tiledSlices = 0;\n        //movieclip\n        this.interval = 0;\n        this.repeatDelay = 0;\n    }\n    load() {\n        return this.owner.getItemAsset(this);\n    }\n    toString() {\n        return this.name;\n    }\n}\n\nclass AtlasConfig {\n    constructor(atlasName, frame, orig, trim, rotate) {\n        this.atlasName = atlasName;\n        this.frame = frame;\n        this.orig = orig;\n        this.trim = trim;\n        this.rotate = rotate;\n    }\n}\nclass UIPackage {\n    constructor() {\n        this.$items = [];\n        this.$atlasConfigs = {};\n    }\n    static getById(id) {\n        return UIPackage.$packageInstById[id];\n    }\n    static getByName(name) {\n        return UIPackage.$packageInstByName[name];\n    }\n    static addPackage(resKey) {\n        let pkg = new UIPackage();\n        pkg.$resKey = resKey;\n        pkg.create(resKey);\n        UIPackage.$packageInstById[pkg.id] = pkg;\n        UIPackage.$packageInstByName[pkg.name] = pkg;\n        pkg.customId = resKey;\n        return pkg;\n    }\n    static removePackage(packageId) {\n        let pkg = UIPackage.$packageInstById[packageId];\n        pkg.dispose();\n        delete UIPackage.$packageInstById[pkg.id];\n        if (pkg.$customId != null)\n            delete UIPackage.$packageInstById[pkg.$customId];\n        delete UIPackage.$packageInstByName[pkg.name];\n    }\n    static createObject(pkgName, resName, userClass) {\n        let pkg = UIPackage.getByName(pkgName);\n        if (pkg)\n            return pkg.createObject(resName, userClass);\n        else\n            return null;\n    }\n    static createObjectFromURL(url, userClass) {\n        let pi = UIPackage.getItemByURL(url);\n        if (pi)\n            return pi.owner.internalCreateObject(pi, userClass);\n        else\n            return null;\n    }\n    static getItemURL(pkgName, resName) {\n        let pkg = UIPackage.getByName(pkgName);\n        if (!pkg)\n            return null;\n        let pi = pkg.$itemsByName[resName];\n        if (!pi)\n            return null;\n        return `ui://${pkg.id}${pi.id}`;\n    }\n    static getItemByURL(url) {\n        let pos1 = url.indexOf('//');\n        if (pos1 == -1)\n            return null;\n        let pos2 = url.indexOf('/', pos1 + 2);\n        let pkg;\n        if (pos2 == -1) {\n            if (url.length > 13) {\n                let pkgId = url.substr(5, 8);\n                pkg = UIPackage.getById(pkgId);\n                if (pkg != null) {\n                    let srcId = url.substr(13);\n                    return pkg.getItemById(srcId);\n                }\n            }\n        }\n        else {\n            let pkgName = url.substr(pos1 + 2, pos2 - pos1 - 2);\n            pkg = UIPackage.getByName(pkgName);\n            if (pkg != null) {\n                let srcName = url.substr(pos2 + 1);\n                return pkg.getItemByName(srcName);\n            }\n        }\n        return null;\n    }\n    static getBitmapFontByURL(url) {\n        return UIPackage.$bitmapFonts[url];\n    }\n    static setStringsSource(source) {\n        UIPackage.$stringsSource = {};\n        let xmlroot = XmlParser.tryParse(source);\n        xmlroot.children.forEach(cxml => {\n            if (cxml.nodeName == 'string') {\n                let key = cxml.attributes.name;\n                let i = key.indexOf('-');\n                if (i == -1)\n                    return;\n                let text = cxml.children.length > 0 ? cxml.children[0].text : '';\n                let key2 = key.substr(0, i);\n                let key3 = key.substr(i + 1);\n                let col = UIPackage.$stringsSource[key2];\n                if (!col) {\n                    col = {};\n                    UIPackage.$stringsSource[key2] = col;\n                }\n                col[key3] = text;\n            }\n        });\n    }\n    /**\n     * format the URL from old version to new version\n     * @param url url with old version format\n     */\n    static normalizeURL(url) {\n        if (url == null)\n            return null;\n        let pos1 = url.indexOf('//');\n        if (pos1 == -1)\n            return null;\n        let pos2 = url.indexOf('/', pos1 + 2);\n        if (pos2 == -1)\n            return url;\n        let pkgName = url.substr(pos1 + 2, pos2 - pos1 - 2);\n        let srcName = url.substr(pos2 + 1);\n        return UIPackage.getItemURL(pkgName, srcName);\n    }\n    create(resKey) {\n        this.$resKey = resKey;\n        let buf = AssetLoader.resourcesPool[this.$resKey];\n        if (!buf) {\n            buf = AssetLoader.resourcesPool[`${this.$resKey}_fui`];\n        }\n        if (!buf) {\n            throw new Error(`Resource '${this.$resKey}' not found, please make sure that you use \"new fgui.utils.AssetLoader\" to load resources\".`);\n        }\n        if (!buf || !(buf instanceof ArrayBuffer)) {\n            throw new Error(`Resource '${this.$resKey}' is not a proper binary resource, please load it as binary format in manifest file add[{ id, src, type: \"binary\" }]`);\n        }\n        this.loadPackage(buf);\n    }\n    loadPackage(descData) {\n        this.decompressPackage(descData);\n        let str = this.getResDescriptor('sprites.bytes');\n        str &&\n            str.split(UIPackage.sep1).forEach((str, index) => {\n                if (index >= 1 && str && str.length) {\n                    let arr = str.split(UIPackage.sep2);\n                    let texID;\n                    let itemId = arr[0];\n                    let binIndex = parseInt(arr[1]);\n                    if (binIndex >= 0)\n                        texID = `atlas${binIndex}`;\n                    else {\n                        let pos = itemId.indexOf('_');\n                        if (pos == -1)\n                            texID = `atlas_${itemId}`;\n                        else\n                            texID = `atlas_${itemId.substr(0, pos)}`;\n                    }\n                    let cfg = new AtlasConfig(texID);\n                    cfg.frame = new createjs.Rectangle(parseInt(arr[2]), parseInt(arr[3]), parseInt(arr[4]), parseInt(arr[5]));\n                    cfg.rotate = arr[6] == '1' ? 6 : 0;\n                    cfg.orig =\n                        cfg.rotate != 0 ? new createjs.Rectangle(0, 0, cfg.frame.height, cfg.frame.width) : null;\n                    /*\n                          cfg.trim = trimed;  //ignored for now - editor not support\n                          */\n                    this.$atlasConfigs[itemId] = cfg;\n                }\n            });\n        str = this.getResDescriptor('package.xml');\n        let xml = XmlParser.tryParse(str);\n        this.$id = xml.attributes.id;\n        this.$name = xml.attributes.name;\n        let resources = xml.children[0].children;\n        this.$itemsById = {};\n        this.$itemsByName = {};\n        resources.forEach(cxml => {\n            let pi = new PackageItem();\n            pi.type = ParsePackageItemType(cxml.nodeName);\n            pi.id = cxml.attributes.id;\n            pi.name = cxml.attributes.name;\n            pi.file = cxml.attributes.file;\n            str = cxml.attributes.size;\n            if (str) {\n                let arr = str.split(UIPackage.sep0);\n                pi.width = parseInt(arr[0]);\n                pi.height = parseInt(arr[1]);\n            }\n            switch (pi.type) {\n                case 0 /* Image */: {\n                    str = cxml.attributes.scale;\n                    if (str == '9grid') {\n                        str = cxml.attributes.scale9grid;\n                        if (str) {\n                            let arr = str.split(UIPackage.sep0);\n                            let rect = new createjs.Rectangle(parseInt(arr[0]), parseInt(arr[1]), parseInt(arr[2]), parseInt(arr[3]));\n                            pi.scale9Grid = rect;\n                            str = cxml.attributes.gridTile;\n                            if (str)\n                                pi.tiledSlices = parseInt(str);\n                        }\n                    }\n                    else if (str == 'tile')\n                        pi.scaleByTile = true;\n                    break;\n                }\n            }\n            pi.owner = this;\n            this.$items.push(pi);\n            this.$itemsById[pi.id] = pi;\n            if (pi.name != null)\n                this.$itemsByName[pi.name] = pi;\n        }, this);\n        this.$items.forEach(pi => {\n            if (pi.type == 6 /* Font */) {\n                this.loadFont(pi);\n                UIPackage.$bitmapFonts[pi.bitmapFont.id] = pi.bitmapFont;\n            }\n        }, this);\n    }\n    decompressPackage(buf) {\n        this.$resData = {};\n        var mark = new Uint8Array(buf.slice(0, 2));\n        if (mark[0] == 0x50 && mark[1] == 0x4b) {\n            this.decodeUncompressed(buf);\n            return;\n        }\n        let inflater = new RawInflate(buf);\n        let data = inflater.decompress();\n        let source = RawByte.decodeUTF8(data);\n        let curr = 0;\n        let fn;\n        let size;\n        while (true) {\n            let pos = source.indexOf('|', curr);\n            if (pos == -1)\n                break;\n            fn = source.substring(curr, pos);\n            curr = pos + 1;\n            pos = source.indexOf('|', curr);\n            size = parseInt(source.substring(curr, pos));\n            curr = pos + 1;\n            this.$resData[fn] = source.substr(curr, size);\n            curr += size;\n        }\n    }\n    /**\n     * @param buf\n     */\n    decodeUncompressed(buf) {\n        var ba = new ByteArray(buf);\n        ba.endian = Endian.LITTLE_ENDIAN;\n        var pos = ba.length - 22;\n        ba.position = pos + 10;\n        var entryCount = ba.readUnsignedShort();\n        ba.position = pos + 16;\n        pos = ba.readInt();\n        for (var i = 0; i < entryCount; i++) {\n            ba.position = pos + 28;\n            var len = ba.readUnsignedShort();\n            var len2 = ba.readUnsignedShort() + ba.readUnsignedShort();\n            ba.position = pos + 46;\n            var entryName = ba.readUTFBytes(len);\n            if (entryName[entryName.length - 1] != '/' && entryName[entryName.length - 1] != '\\\\') {\n                //not directory\n                ba.position = pos + 20;\n                var size = ba.readInt();\n                ba.position = pos + 42;\n                var offset = ba.readInt() + 30 + len;\n                if (size > 0) {\n                    ba.position = offset;\n                    this.$resData[entryName] = ba.readUTFBytes(size);\n                }\n            }\n            pos += 46 + len + len2;\n        }\n    }\n    dispose() {\n        this.$items.forEach(pi => {\n            let cfg = this.$atlasConfigs[pi.id];\n            if (cfg)\n                AssetLoader.destroyResource(`${this.$resKey}@${cfg.atlasName}`);\n        }, this);\n    }\n    get id() {\n        return this.$id;\n    }\n    get name() {\n        return this.$name;\n    }\n    get customId() {\n        return this.$customId;\n    }\n    set customId(value) {\n        if (this.$customId != null)\n            delete UIPackage.$packageInstById[this.$customId];\n        this.$customId = value;\n        if (this.$customId != null)\n            UIPackage.$packageInstById[this.$customId] = this;\n    }\n    createObject(resName, userClass) {\n        let pi = this.$itemsByName[resName];\n        if (pi)\n            return this.internalCreateObject(pi, userClass);\n        else\n            return null;\n    }\n    internalCreateObject(item, userClass = null) {\n        let g = item.type == 4 /* Component */ && userClass != null\n            ? new userClass()\n            : Decls.UIObjectFactory.newObject(item);\n        if (g == null)\n            return null;\n        UIPackage.$constructingObjects++;\n        g.packageItem = item;\n        g.constructFromResource();\n        UIPackage.$constructingObjects--;\n        return g;\n    }\n    getItemById(itemId) {\n        return this.$itemsById[itemId];\n    }\n    getItemByName(resName) {\n        return this.$itemsByName[resName];\n    }\n    getItemAssetByName(resName) {\n        let pi = this.$itemsByName[resName];\n        if (pi == null)\n            throw new Error(`Resource '${resName}' not found`);\n        return this.getItemAsset(pi);\n    }\n    /**\n     * todo\n     */\n    createSpriteTexture(cfgName, cfg) {\n        let atlasItem = this.$itemsById[cfg.atlasName];\n        if (atlasItem != null) {\n            let atlasTexture = this.getItemAsset(atlasItem);\n            if (!atlasTexture)\n                return null;\n            if (!cfg.texCacheID) {\n                cfg.texCacheID = `${this.$resKey}@${cfg.atlasName}`;\n            }\n            let tex = Utils.TextureCache[cfg.texCacheID];\n            //todo add to cache\n            if (!tex) {\n                tex = {\n                    image: atlasTexture,\n                    rect: cfg.frame\n                };\n            }\n            return tex;\n        }\n        else\n            return null;\n    }\n    getItemAsset(item) {\n        switch (item.type) {\n            case 0 /* Image */:\n                if (!item.decoded) {\n                    item.decoded = true;\n                    let cfg = this.$atlasConfigs[item.id];\n                    if (cfg != null)\n                        item.texture = this.createSpriteTexture(item.id, cfg);\n                }\n                return item.texture;\n            case 7 /* Atlas */:\n                if (!item.decoded) {\n                    item.decoded = true;\n                    let fileName = item.file != null && item.file.length > 0 ? item.file : `${item.id}.png`;\n                    let resName = `${this.$resKey}@${StringUtil.getFileName(fileName)}`;\n                    let texture = AssetLoader.resourcesPool[resName];\n                    if (!texture) {\n                        throw new Error(`${resName} not found in fgui.AssetLoader.resourcesPool, please load assets first!`);\n                    }\n                    item.texture = texture;\n                    if (!item.texture) {\n                        texture = AssetLoader.resourcesPool[`${this.$resKey}@${fileName.replace('.', '_')}`];\n                        item.texture = texture;\n                    }\n                }\n                return item.texture;\n            case 3 /* Sound */:\n                if (!item.decoded) {\n                    item.decoded = true;\n                    this.loadAudio(item);\n                }\n                return item.sound;\n            case 6 /* Font */:\n                if (!item.decoded) {\n                    item.decoded = true;\n                    this.loadFont(item);\n                }\n                return item.bitmapFont;\n            case 2 /* MovieClip */:\n                if (!item.decoded) {\n                    item.decoded = true;\n                    this.loadMovieClip(item);\n                }\n                return item.frames;\n            case 4 /* Component */:\n                if (!item.decoded) {\n                    item.decoded = true;\n                    let str = this.getResDescriptor(`${item.id}.xml`);\n                    let xml = XmlParser.tryParse(str);\n                    item.componentData = xml;\n                    this.loadComponentChildren(item);\n                    this.loadComponentTranslation(item);\n                }\n                return item.componentData;\n            default:\n                return AssetLoader.resourcesPool[`${this.$resKey}@${item.id}`];\n        }\n    }\n    loadComponentChildren(item) {\n        let listNode = XmlParser.getChildNodes(item.componentData, 'displayList');\n        if (listNode != null && listNode.length > 0) {\n            item.displayList = [];\n            listNode[0].children.forEach(cxml => {\n                let tagName = cxml.nodeName;\n                let di;\n                let src = cxml.attributes.src;\n                if (src) {\n                    let pkgId = cxml.attributes.pkg;\n                    let pkg;\n                    if (pkgId && pkgId != item.owner.id)\n                        pkg = UIPackage.getById(pkgId);\n                    else\n                        pkg = item.owner;\n                    let pi = pkg != null ? pkg.getItemById(src) : null;\n                    if (pi != null)\n                        di = new DisplayListItem(pi, null);\n                    else\n                        di = new DisplayListItem(null, tagName);\n                }\n                else {\n                    if (tagName == 'text' && cxml.attributes.input == 'true')\n                        di = new DisplayListItem(null, 'inputtext');\n                    else\n                        di = new DisplayListItem(null, tagName);\n                }\n                di.desc = cxml;\n                item.displayList.push(di);\n            });\n        }\n        else\n            item.displayList = [];\n    }\n    getResDescriptor(fn) {\n        return this.$resData[fn];\n    }\n    loadComponentTranslation(item) {\n        if (UIPackage.$stringsSource == null)\n            return;\n        let strings = UIPackage.$stringsSource[this.id + item.id];\n        if (strings == null)\n            return;\n        let value;\n        let cxml, dxml;\n        let ename;\n        let elementId;\n        let str;\n        item.displayList.forEach(item => {\n            cxml = item.desc;\n            ename = cxml.nodeName;\n            elementId = cxml.attributes.id;\n            str = cxml.attributes.tooltips;\n            if (str) {\n                value = strings[`${elementId}-tips`];\n                if (value != undefined)\n                    cxml.attributes.tooltips = value;\n            }\n            let cs = XmlParser.getChildNodes(cxml, 'gearText');\n            dxml = cs && cs[0];\n            if (dxml) {\n                value = strings[`${elementId}-texts`];\n                if (value != undefined)\n                    dxml.attributes.values = value;\n                value = strings[`${elementId}-texts_def`];\n                if (value != undefined)\n                    dxml.attributes.default = value;\n            }\n            if (ename == 'text' || ename == 'richtext') {\n                value = strings[elementId];\n                if (value != undefined)\n                    cxml.attributes.text = value;\n                value = strings[`${elementId}-prompt`];\n                if (value != undefined)\n                    cxml.attributes.prompt = value;\n            }\n            else if (ename == 'list') {\n                cxml.children.forEach((exml, index) => {\n                    if (exml.nodeName != 'item')\n                        return;\n                    value = strings[`${elementId}-${index}`];\n                    if (value != undefined)\n                        exml.attributes.title = value;\n                });\n            }\n            else if (ename == 'component') {\n                cs = XmlParser.getChildNodes(cxml, 'Button');\n                dxml = cs && cs[0];\n                if (dxml) {\n                    value = strings[elementId];\n                    if (value != undefined)\n                        dxml.attributes.title = value;\n                    value = strings[`${elementId}-0`];\n                    if (value != undefined)\n                        dxml.attributes.selectedTitle = value;\n                    return;\n                }\n                cs = XmlParser.getChildNodes(cxml, 'Label');\n                dxml = cs && cs[0];\n                if (dxml) {\n                    value = strings[elementId];\n                    if (value != undefined)\n                        dxml.attributes.title = value;\n                    return;\n                }\n                cs = XmlParser.getChildNodes(cxml, 'ComboBox');\n                dxml = cs && cs[0];\n                if (dxml) {\n                    value = strings[elementId];\n                    if (value != undefined)\n                        dxml.attributes.title = value;\n                    dxml.children.forEach((exml, index) => {\n                        if (exml.nodeName != 'item')\n                            return;\n                        value = strings[`${elementId}-${index}`];\n                        if (value != undefined)\n                            exml.attributes.title = value;\n                    });\n                    return;\n                }\n            }\n        });\n    }\n    loadMovieClip(item) {\n        let xml = XmlParser.tryParse(this.getResDescriptor(`${item.id}.xml`));\n        let str;\n        str = xml.attributes.interval;\n        if (str != null)\n            item.interval = parseInt(str);\n        str = xml.attributes.swing;\n        if (str != null)\n            item.swing = str == 'true';\n        str = xml.attributes.repeatDelay;\n        if (str != null)\n            item.repeatDelay = parseInt(str);\n        item.frames = [];\n        let frameNodes = xml.children[0].children;\n        frameNodes.forEach((node, index) => {\n            let frame = new Frame();\n            str = node.attributes.rect;\n            let arr = str.split(UIPackage.sep0);\n            let trimRect = new createjs.Rectangle(parseInt(arr[0]), parseInt(arr[1]), parseInt(arr[2]), parseInt(arr[3]));\n            str = node.attributes.addDelay;\n            if (str)\n                frame.addDelay = parseInt(str);\n            item.frames.push(frame);\n            if (trimRect.width <= 0)\n                return;\n            str = node.attributes.sprite;\n            if (str)\n                str = `${item.id}_${str}`;\n            else\n                str = `${item.id}_${index}`;\n            let cfg = this.$atlasConfigs[str];\n            if (cfg != null) {\n                frame.texture = this.createSpriteTexture(str, cfg);\n                frame.texture.trim = trimRect;\n            }\n        });\n    }\n    loadFont(item) {\n        let font = new BitmapFont();\n        font.id = `ui://${this.id}${item.id}`;\n        let str = this.getResDescriptor(`${item.id}.fnt`);\n        let lines = str.split(UIPackage.sep1);\n        let kv = {};\n        let ttf = false;\n        let size = 0;\n        let xadvance = 0;\n        let resizable = false;\n        let colorable = false;\n        let atlasOffsetX = 0, atlasOffsetY = 0;\n        let charImg;\n        let mainTexture;\n        let lineHeight = 0;\n        let maxCharHeight = 0;\n        lines.forEach(line => {\n            if (line && line.length) {\n                str = StringUtil.trim(line);\n                let arr = str.split(UIPackage.sep2);\n                arr.forEach(v => {\n                    let at = v.split(UIPackage.sep3);\n                    kv[at[0]] = at[1];\n                });\n                str = arr[0];\n                if (str == 'char') {\n                    let bg = new BMGlyph();\n                    bg.x = parseInt(kv.x) || 0;\n                    bg.y = parseInt(kv.y) || 0;\n                    bg.offsetX = parseInt(kv.xoffset) || 0;\n                    bg.offsetY = parseInt(kv.yoffset) || 0;\n                    bg.width = parseInt(kv.width) || 0;\n                    bg.height = parseInt(kv.height) || 0;\n                    maxCharHeight = Math.max(bg.height, maxCharHeight);\n                    bg.advance = parseInt(kv.xadvance) || 0;\n                    if (kv.chnl != undefined) {\n                        bg.channel = parseInt(kv.chnl);\n                        if (bg.channel == 15)\n                            bg.channel = 4;\n                        else if (bg.channel == 1)\n                            bg.channel = 3;\n                        else if (bg.channel == 2)\n                            bg.channel = 2;\n                        else\n                            bg.channel = 1;\n                    }\n                    if (!ttf) {\n                        if (kv.img) {\n                            charImg = this.$itemsById[kv.img];\n                            if (charImg != null) {\n                                charImg.load();\n                                bg.width = charImg.width;\n                                bg.height = charImg.height;\n                                bg.texture = charImg.texture;\n                            }\n                        }\n                    }\n                    else if (mainTexture != null) {\n                        if (!bg.texture) {\n                            bg.texture = { image: mainTexture, rect: {} };\n                        }\n                        bg.texture.rect = new createjs.Rectangle(bg.x + atlasOffsetX, bg.y + atlasOffsetY, bg.width, bg.height);\n                    }\n                    if (ttf)\n                        bg.lineHeight = lineHeight;\n                    else {\n                        if (bg.advance == 0) {\n                            if (xadvance == 0)\n                                bg.advance = bg.offsetX + bg.width;\n                            else\n                                bg.advance = xadvance;\n                        }\n                        bg.lineHeight = bg.offsetY < 0 ? bg.height : bg.offsetY + bg.height;\n                        if (size > 0 && bg.lineHeight < size)\n                            bg.lineHeight = size;\n                    }\n                    font.glyphs[String.fromCharCode(+kv.id | 0)] = bg;\n                }\n                else if (str == 'info') {\n                    ttf = kv.face != null;\n                    if (kv.size)\n                        size = parseInt(kv.size);\n                    resizable = kv.resizable == 'true';\n                    colorable = kv.colored == 'true';\n                    if (ttf) {\n                        let cfg = this.$atlasConfigs[item.id];\n                        if (cfg != null) {\n                            atlasOffsetX = cfg.frame.x;\n                            atlasOffsetY = cfg.frame.y;\n                            let atlasItem = this.$itemsById[cfg.atlasName];\n                            if (atlasItem != null)\n                                mainTexture = this.getItemAsset(atlasItem);\n                        }\n                    }\n                }\n                else if (str == 'common') {\n                    if (kv.lineHeight)\n                        lineHeight = parseInt(kv.lineHeight);\n                    if (size == 0)\n                        size = lineHeight;\n                    else if (lineHeight == 0)\n                        lineHeight = size;\n                    if (kv.xadvance)\n                        xadvance = parseInt(kv.xadvance);\n                }\n            }\n        });\n        if (size == 0 && maxCharHeight > 0)\n            size = maxCharHeight;\n        font.ttf = ttf;\n        font.size = size;\n        font.resizable = resizable;\n        font.colorable = colorable;\n        item.bitmapFont = font;\n    }\n    loadAudio(item) {\n        let fileName = item.file != null && item.file.length > 0 ? item.file : `${item.id}.mp3`;\n        let resName = `${this.$resKey}@${StringUtil.getFileName(fileName)}`;\n        let sound = AssetLoader.resourcesPool[resName];\n        if (sound) {\n            item.sound = createjs.Sound.play(resName);\n        }\n        else {\n            console.log(\"Resource '\" + item.file + \"' not found, please loadManifest first!\");\n        }\n    }\n}\n/**@internal */\nUIPackage.$constructingObjects = 0;\nUIPackage.$packageInstById = {};\nUIPackage.$packageInstByName = {};\nUIPackage.$bitmapFonts = {};\nUIPackage.$stringsSource = null;\nUIPackage.sep0 = ',';\nUIPackage.sep1 = '\\n';\nUIPackage.sep2 = ' ';\nUIPackage.sep3 = '=';\nlet Decls = {};\n\nclass GearLook extends GearBase {\n    constructor(owner) {\n        super(owner);\n    }\n    init() {\n        this.$default = new GearLookValue(this.$owner.alpha, this.$owner.rotation, this.$owner.grayed);\n        this.$storage = {};\n    }\n    addStatus(pageId, value) {\n        if (value == '-')\n            return;\n        let arr = value.split(',');\n        let gv;\n        if (pageId == null)\n            gv = this.$default;\n        else {\n            gv = new GearLookValue();\n            this.$storage[pageId] = gv;\n        }\n        gv.alpha = parseFloat(arr[0]);\n        gv.rotation = parseInt(arr[1]);\n        gv.grayed = arr[2] == '1' ? true : false;\n    }\n    apply() {\n        let gv = this.$storage[this.$controller.selectedPageId];\n        if (!gv)\n            gv = this.$default;\n        if (this.$tween && !UIPackage.$constructingObjects && !GearBase.disableAllTweenEffect) {\n            this.$owner.$gearLocked = true;\n            this.$owner.grayed = gv.grayed;\n            this.$owner.$gearLocked = false;\n            if (this.$tweener) {\n                if (this.$tweenTarget.alpha === gv.alpha && this.$tweenTarget.rotation === gv.rotation)\n                    return;\n                this.$tweener.gotoAndStop(this.$tweener.duration); //set to end\n                this.$tweener = null;\n            }\n            let a = gv.alpha != this.$owner.alpha;\n            let b = gv.rotation != this.$owner.rotation;\n            if (a || b) {\n                if (this.$owner.hasGearController(0, this.$controller))\n                    this.$lockToken = this.$owner.lockGearDisplay();\n                this.$tweenTarget = gv;\n                let vars = {\n                    onChange: () => {\n                        this.$owner.$gearLocked = true;\n                        if (a)\n                            this.$owner.alpha = this.$tweenValue.x;\n                        if (b)\n                            this.$owner.rotation = this.$tweenValue.y;\n                        this.$owner.$gearLocked = false;\n                    }\n                };\n                if (this.$tweenValue == null)\n                    this.$tweenValue = new createjs.Point();\n                this.$tweenValue.x = this.$owner.alpha;\n                this.$tweenValue.y = this.$owner.rotation;\n                this.$tweener = createjs.Tween.get(this.$tweenValue, vars)\n                    .wait(this.$tweenDelay * 1000)\n                    .to({ x: gv.alpha, y: gv.rotation }, this.$tweenTime * 1000, this.$easeType)\n                    .call(this.tweenComplete, null, this);\n            }\n        }\n        else {\n            this.$owner.$gearLocked = true;\n            this.$owner.grayed = gv.grayed;\n            this.$owner.alpha = gv.alpha;\n            this.$owner.rotation = gv.rotation;\n            this.$owner.$gearLocked = false;\n        }\n    }\n    tweenComplete() {\n        if (this.$lockToken != 0) {\n            this.$owner.releaseGearDisplay(this.$lockToken);\n            this.$lockToken = 0;\n        }\n        this.$tweener = null;\n        let evt = new createjs.Event(\"__gearStop\" /* GEAR_STOP */, true, false);\n        this.$owner.dispatchEvent(evt, this);\n    }\n    updateState() {\n        if (this.$controller == null || this.$owner.$gearLocked || this.$owner.$inProgressBuilding)\n            return;\n        let gv = this.$storage[this.$controller.selectedPageId];\n        if (!gv) {\n            gv = new GearLookValue();\n            this.$storage[this.$controller.selectedPageId] = gv;\n        }\n        gv.alpha = this.$owner.alpha;\n        gv.rotation = this.$owner.rotation;\n        gv.grayed = this.$owner.grayed;\n    }\n}\nclass GearLookValue {\n    constructor(alpha = 0, rotation = 0, grayed = false) {\n        this.alpha = alpha;\n        this.rotation = rotation;\n        this.grayed = grayed;\n    }\n}\n\nclass GearSize extends GearBase {\n    constructor(owner) {\n        super(owner);\n    }\n    init() {\n        this.$default = new GearSizeValue(this.$owner.width, this.$owner.height, this.$owner.scaleX, this.$owner.scaleY);\n        this.$storage = {};\n    }\n    addStatus(pageId, value) {\n        if (value == '-')\n            return;\n        let arr = value.split(',');\n        let gv;\n        if (pageId == null)\n            gv = this.$default;\n        else {\n            gv = new GearSizeValue();\n            this.$storage[pageId] = gv;\n        }\n        gv.width = parseInt(arr[0]);\n        gv.height = parseInt(arr[1]);\n        if (arr.length > 2) {\n            gv.scaleX = parseFloat(arr[2]);\n            gv.scaleY = parseFloat(arr[3]);\n        }\n    }\n    apply() {\n        let gv = this.$storage[this.$controller.selectedPageId];\n        if (!gv)\n            gv = this.$default;\n        if (this.$tween && !UIPackage.$constructingObjects && !GearBase.disableAllTweenEffect) {\n            if (this.$tweener) {\n                if (this.$tweenTarget.width != gv.width ||\n                    this.$tweenTarget.height != gv.height ||\n                    this.$tweenTarget.scaleX != gv.scaleX ||\n                    this.$tweenTarget.scaleY != gv.scaleY) {\n                    this.$tweener.gotoAndStop(this.$tweener.duration); //set to end\n                    this.$tweener = null;\n                }\n                else\n                    return;\n            }\n            let a = gv.width != this.$owner.width || gv.height != this.$owner.height;\n            let b = gv.scaleX != this.$owner.scaleX || gv.scaleY != this.$owner.scaleY;\n            if (a || b) {\n                if (this.$owner.hasGearController(0, this.$controller))\n                    this.$lockToken = this.$owner.lockGearDisplay();\n                this.$tweenTarget = gv;\n                let vars = {\n                    onChange: () => {\n                        this.$owner.$gearLocked = true;\n                        if (a)\n                            this.$owner.setSize(this.$tweenValue.width, this.$tweenValue.height, this.$owner.gearXY.controller == this.$controller);\n                        if (b)\n                            this.$owner.setScale(this.$tweenValue.scaleX, this.$tweenValue.scaleY);\n                        this.$owner.$gearLocked = false;\n                    }\n                };\n                if (this.$tweenValue == null)\n                    this.$tweenValue = new GearSizeValue();\n                this.$tweenValue.width = this.$owner.width;\n                this.$tweenValue.height = this.$owner.height;\n                this.$tweenValue.scaleX = this.$owner.scaleX;\n                this.$tweenValue.scaleY = this.$owner.scaleY;\n                this.$tweener = createjs.Tween.get(this.$tweenValue, vars)\n                    .wait(this.$tweenDelay * 1000)\n                    .to({ width: gv.width, height: gv.height, scaleX: gv.scaleX, scaleY: gv.scaleY }, this.$tweenTime * 1000, this.$easeType)\n                    .call(this.tweenComplete, null, this);\n            }\n        }\n        else {\n            this.$owner.$gearLocked = true;\n            this.$owner.setSize(gv.width, gv.height, this.$owner.gearXY.controller == this.$controller);\n            this.$owner.setScale(gv.scaleX, gv.scaleY);\n            this.$owner.$gearLocked = false;\n        }\n    }\n    tweenComplete() {\n        if (this.$lockToken != 0) {\n            this.$owner.releaseGearDisplay(this.$lockToken);\n            this.$lockToken = 0;\n        }\n        this.$tweener = null;\n        let evt = new createjs.Event(\"__gearStop\" /* GEAR_STOP */, true, false);\n        this.$owner.dispatchEvent(evt, this);\n    }\n    updateState() {\n        if (this.$controller == null || this.$owner.$gearLocked || this.$owner.$inProgressBuilding)\n            return;\n        let gv = this.$storage[this.$controller.selectedPageId];\n        if (!gv) {\n            gv = new GearSizeValue();\n            this.$storage[this.$controller.selectedPageId] = gv;\n        }\n        gv.width = this.$owner.width;\n        gv.height = this.$owner.height;\n        gv.scaleX = this.$owner.scaleX;\n        gv.scaleY = this.$owner.scaleY;\n    }\n    updateFromRelations(dx, dy) {\n        if (this.$controller == null || this.$storage == null)\n            return;\n        for (let key in this.$storage) {\n            let gv = this.$storage[key];\n            gv.width += dx;\n            gv.height += dy;\n        }\n        this.$default.width += dx;\n        this.$default.height += dy;\n        this.updateState();\n    }\n}\nclass GearSizeValue {\n    constructor(width = 0, height = 0, scaleX = 0, scaleY = 0) {\n        this.width = width;\n        this.height = height;\n        this.scaleX = scaleX;\n        this.scaleY = scaleY;\n    }\n}\n\nclass GearXY extends GearBase {\n    constructor(owner) {\n        super(owner);\n    }\n    init() {\n        this.$default = new createjs.Point(this.$owner.x, this.$owner.y);\n        this.$storage = {};\n    }\n    addStatus(pageId, value) {\n        if (value == '-')\n            return;\n        let arr = value.split(',');\n        let pt;\n        if (pageId == null)\n            pt = this.$default;\n        else {\n            pt = new createjs.Point();\n            this.$storage[pageId] = pt;\n        }\n        pt.x = parseInt(arr[0]);\n        pt.y = parseInt(arr[1]);\n    }\n    apply() {\n        let pt = this.$storage[this.$controller.selectedPageId];\n        if (!pt)\n            pt = this.$default;\n        if (this.$tween && !UIPackage.$constructingObjects && !GearBase.disableAllTweenEffect) {\n            if (this.$tweener) {\n                if (this.$tweenTarget.x === pt.x && this.$tweenTarget.y === pt.y)\n                    return;\n                this.$tweener.gotoAndStop(this.$tweener.duration); //set to end\n                this.$tweener = null;\n            }\n            if (this.$owner.x != pt.x || this.$owner.y != pt.y) {\n                this.$owner.hasGearController(0, this.$controller);\n                this.$lockToken = this.$owner.lockGearDisplay();\n                this.$tweenTarget = pt;\n                let vars = {\n                    onChange: () => {\n                        this.$owner.$gearLocked = true;\n                        this.$owner.setXY(this.$tweenValue.x, this.$tweenValue.y);\n                        this.$owner.$gearLocked = false;\n                    }\n                };\n                if (this.$tweenValue == null)\n                    this.$tweenValue = new createjs.Point();\n                this.$tweenValue.x = this.$owner.x;\n                this.$tweenValue.y = this.$owner.y;\n                this.$tweener = createjs.Tween.get(this.$tweenValue, vars)\n                    .wait(this.$tweenDelay * 1000)\n                    .to({ x: pt.x, y: pt.y }, this.$tweenTime * 1000, this.$easeType)\n                    .call(this.tweenComplete, null, this);\n            }\n        }\n        else {\n            this.$owner.$gearLocked = true;\n            this.$owner.setXY(pt.x, pt.y);\n            this.$owner.$gearLocked = false;\n        }\n    }\n    tweenComplete() {\n        if (this.$lockToken != 0) {\n            this.$owner.releaseGearDisplay(this.$lockToken);\n            this.$lockToken = 0;\n        }\n        this.$tweener = null;\n        let evt = new createjs.Event(\"__gearStop\" /* GEAR_STOP */, true, false);\n        this.$owner.dispatchEvent(evt, this);\n    }\n    updateState() {\n        if (this.$controller == null || this.$owner.$gearLocked || this.$owner.$inProgressBuilding)\n            return;\n        let pt = this.$storage[this.$controller.selectedPageId];\n        if (!pt) {\n            pt = new createjs.Point();\n            this.$storage[this.$controller.selectedPageId] = pt;\n        }\n        pt.x = this.$owner.x;\n        pt.y = this.$owner.y;\n    }\n    updateFromRelations(dx, dy) {\n        if (this.$controller == null || this.$storage == null)\n            return;\n        for (let key in this.$storage) {\n            let pt = this.$storage[key];\n            pt.x += dx;\n            pt.y += dy;\n        }\n        this.$default.x += dx;\n        this.$default.y += dy;\n        this.updateState();\n    }\n}\n\nlet isUIObject = function (obj) {\n    return obj && 'UIOwner' in obj && obj.UIOwner != null;\n};\n\nclass RelationDef {\n    copyFrom(source) {\n        this.percent = source.percent;\n        this.type = source.type;\n    }\n}\nclass RelationItem {\n    constructor(owner) {\n        this.$owner = owner;\n        this.$defs = [];\n    }\n    get owner() {\n        return this.$owner;\n    }\n    set target(value) {\n        if (this.$target != value) {\n            if (this.$target)\n                this.releaseRefTarget(this.$target);\n            this.$target = value;\n            if (this.$target)\n                this.addRefTarget(this.$target);\n        }\n    }\n    get target() {\n        return this.$target;\n    }\n    add(relationType, usePercent) {\n        if (relationType == 24 /* Size */) {\n            this.add(14 /* Width */, usePercent);\n            this.add(15 /* Height */, usePercent);\n            return;\n        }\n        let length = this.$defs.length;\n        for (let i = 0; i < length; i++) {\n            let def = this.$defs[i];\n            if (def.type == relationType)\n                return;\n        }\n        this.internalAdd(relationType, usePercent);\n    }\n    internalAdd(relationType, usePercent) {\n        if (relationType == 24 /* Size */) {\n            this.internalAdd(14 /* Width */, usePercent);\n            this.internalAdd(15 /* Height */, usePercent);\n            return;\n        }\n        let info = new RelationDef();\n        info.percent = usePercent;\n        info.type = relationType;\n        this.$defs.push(info);\n        //CENTER relation will cause float pixel, so enable the auto-pixel-snapping here\n        if (usePercent ||\n            relationType == 1 /* Left_Center */ ||\n            relationType == 3 /* Center_Center */ ||\n            relationType == 5 /* Right_Center */ ||\n            relationType == 8 /* Top_Middle */ ||\n            relationType == 10 /* Middle_Middle */ ||\n            relationType == 12 /* Bottom_Middle */) {\n            this.$owner.pixelSnapping = true;\n        }\n    }\n    remove(relationType = 0) {\n        if (relationType == 24 /* Size */) {\n            this.remove(14 /* Width */);\n            this.remove(15 /* Height */);\n            return;\n        }\n        let dc = this.$defs.length;\n        for (let k = dc - 1; k >= 0; k--) {\n            if (this.$defs[k].type == relationType) {\n                this.$defs.splice(k, 1);\n                break;\n            }\n        }\n    }\n    copyFrom(source) {\n        this.target = source.target;\n        this.$defs.length = 0;\n        source.$defs.forEach(info => {\n            let info2 = new RelationDef();\n            info2.copyFrom(info);\n            this.$defs.push(info2);\n        }, this);\n    }\n    dispose() {\n        if (this.$target != null) {\n            this.releaseRefTarget(this.$target);\n            this.$target = null;\n        }\n    }\n    get isEmpty() {\n        return this.$defs.length == 0;\n    }\n    applyOnSelfResized(dWidth, dHeight) {\n        let ox = this.$owner.x;\n        let oy = this.$owner.y;\n        this.$defs.forEach(info => {\n            switch (info.type) {\n                case 3 /* Center_Center */:\n                case 5 /* Right_Center */:\n                    this.$owner.x -= dWidth / 2;\n                    break;\n                case 4 /* Right_Left */:\n                case 6 /* Right_Right */:\n                    this.$owner.x -= dWidth;\n                    break;\n                case 10 /* Middle_Middle */:\n                case 12 /* Bottom_Middle */:\n                    this.$owner.y -= dHeight / 2;\n                    break;\n                case 11 /* Bottom_Top */:\n                case 13 /* Bottom_Bottom */:\n                    this.$owner.y -= dHeight;\n                    break;\n            }\n        }, this);\n        if (ox != this.$owner.x || oy != this.$owner.y) {\n            ox = this.$owner.x - ox;\n            oy = this.$owner.y - oy;\n            this.$owner.updateGearFromRelations(1 /* XY */, ox, oy);\n            if (this.$owner.parent != null && this.$owner.parent.$transitions.length > 0) {\n                this.$owner.parent.$transitions.forEach(t => {\n                    t.updateFromRelations(this.$owner.id, ox, oy);\n                }, this);\n            }\n        }\n    }\n    applyOnXYChanged(info, dx, dy) {\n        let tmp;\n        switch (info.type) {\n            case 0 /* Left_Left */:\n            case 1 /* Left_Center */:\n            case 2 /* Left_Right */:\n            case 3 /* Center_Center */:\n            case 4 /* Right_Left */:\n            case 5 /* Right_Center */:\n            case 6 /* Right_Right */:\n                this.$owner.x += dx;\n                break;\n            case 7 /* Top_Top */:\n            case 8 /* Top_Middle */:\n            case 9 /* Top_Bottom */:\n            case 10 /* Middle_Middle */:\n            case 11 /* Bottom_Top */:\n            case 12 /* Bottom_Middle */:\n            case 13 /* Bottom_Bottom */:\n                this.$owner.y += dy;\n                break;\n            case 14 /* Width */:\n            case 15 /* Height */:\n                break;\n            case 16 /* LeftExt_Left */:\n            case 17 /* LeftExt_Right */:\n                tmp = this.$owner.x;\n                this.$owner.x += dx;\n                this.$owner.width = this.$owner.$rawWidth - (this.$owner.x - tmp);\n                break;\n            case 18 /* RightExt_Left */:\n            case 19 /* RightExt_Right */:\n                this.$owner.width = this.$owner.$rawWidth + dx;\n                break;\n            case 20 /* TopExt_Top */:\n            case 21 /* TopExt_Bottom */:\n                tmp = this.$owner.y;\n                this.$owner.y += dy;\n                this.$owner.height = this.$owner.$rawHeight - (this.$owner.y - tmp);\n                break;\n            case 22 /* BottomExt_Top */:\n            case 23 /* BottomExt_Bottom */:\n                this.$owner.height = this.$owner.$rawHeight + dy;\n                break;\n        }\n    }\n    applyOnSizeChanged(info) {\n        let targetX, targetY;\n        if (this.$target != this.$owner.parent) {\n            targetX = this.$target.x;\n            targetY = this.$target.y;\n        }\n        else {\n            targetX = 0;\n            targetY = 0;\n        }\n        let v, tmp;\n        switch (info.type) {\n            case 0 /* Left_Left */:\n                break;\n            case 1 /* Left_Center */:\n                v = this.$owner.x - (targetX + this.$targetWidth / 2);\n                if (info.percent)\n                    v = (v / this.$targetWidth) * this.$target.$rawWidth;\n                this.$owner.x = targetX + this.$target.$rawWidth / 2 + v;\n                break;\n            case 2 /* Left_Right */:\n                v = this.$owner.x - (targetX + this.$targetWidth);\n                if (info.percent)\n                    v = (v / this.$targetWidth) * this.$target.$rawWidth;\n                this.$owner.x = targetX + this.$target.$rawWidth + v;\n                break;\n            case 3 /* Center_Center */:\n                v = this.$owner.x + this.$owner.$rawWidth / 2 - (targetX + this.$targetWidth / 2);\n                if (info.percent)\n                    v = (v / this.$targetWidth) * this.$target.$rawWidth;\n                this.$owner.x = targetX + this.$target.$rawWidth / 2 + v - this.$owner.$rawWidth / 2;\n                break;\n            case 4 /* Right_Left */:\n                v = this.$owner.x + this.$owner.$rawWidth - targetX;\n                if (info.percent)\n                    v = (v / this.$targetWidth) * this.$target.$rawWidth;\n                this.$owner.x = targetX + v - this.$owner.$rawWidth;\n                break;\n            case 5 /* Right_Center */:\n                v = this.$owner.x + this.$owner.$rawWidth - (targetX + this.$targetWidth / 2);\n                if (info.percent)\n                    v = (v / this.$targetWidth) * this.$target.$rawWidth;\n                this.$owner.x = targetX + this.$target.$rawWidth / 2 + v - this.$owner.$rawWidth;\n                break;\n            case 6 /* Right_Right */:\n                v = this.$owner.x + this.$owner.$rawWidth - (targetX + this.$targetWidth);\n                if (info.percent)\n                    v = (v / this.$targetWidth) * this.$target.$rawWidth;\n                this.$owner.x = targetX + this.$target.$rawWidth + v - this.$owner.$rawWidth;\n                break;\n            case 7 /* Top_Top */:\n                break;\n            case 8 /* Top_Middle */:\n                v = this.$owner.y - (targetY + this.$targetHeight / 2);\n                if (info.percent)\n                    v = (v / this.$targetHeight) * this.$target.$rawHeight;\n                this.$owner.y = targetY + this.$target.$rawHeight / 2 + v;\n                break;\n            case 9 /* Top_Bottom */:\n                v = this.$owner.y - (targetY + this.$targetHeight);\n                if (info.percent)\n                    v = (v / this.$targetHeight) * this.$target.$rawHeight;\n                this.$owner.y = targetY + this.$target.$rawHeight + v;\n                break;\n            case 10 /* Middle_Middle */:\n                v = this.$owner.y + this.$owner.$rawHeight / 2 - (targetY + this.$targetHeight / 2);\n                if (info.percent)\n                    v = (v / this.$targetHeight) * this.$target.$rawHeight;\n                this.$owner.y = targetY + this.$target.$rawHeight / 2 + v - this.$owner.$rawHeight / 2;\n                break;\n            case 11 /* Bottom_Top */:\n                v = this.$owner.y + this.$owner.$rawHeight - targetY;\n                if (info.percent)\n                    v = (v / this.$targetHeight) * this.$target.$rawHeight;\n                this.$owner.y = targetY + v - this.$owner.$rawHeight;\n                break;\n            case 12 /* Bottom_Middle */:\n                v = this.$owner.y + this.$owner.$rawHeight - (targetY + this.$targetHeight / 2);\n                if (info.percent)\n                    v = (v / this.$targetHeight) * this.$target.$rawHeight;\n                this.$owner.y = targetY + this.$target.$rawHeight / 2 + v - this.$owner.$rawHeight;\n                break;\n            case 13 /* Bottom_Bottom */:\n                v = this.$owner.y + this.$owner.$rawHeight - (targetY + this.$targetHeight);\n                if (info.percent)\n                    v = (v / this.$targetHeight) * this.$target.$rawHeight;\n                this.$owner.y = targetY + this.$target.$rawHeight + v - this.$owner.$rawHeight;\n                break;\n            case 14 /* Width */:\n                if (this.$owner.$inProgressBuilding && this.$owner == this.$target.parent)\n                    v = this.$owner.sourceWidth - this.$target.$initWidth;\n                else\n                    v = this.$owner.$rawWidth - this.$targetWidth;\n                if (info.percent)\n                    v = (v / this.$targetWidth) * this.$target.$rawWidth;\n                if (this.$target == this.$owner.parent)\n                    this.$owner.setSize(this.$target.$rawWidth + v, this.$owner.$rawHeight, true);\n                else\n                    this.$owner.width = this.$target.$rawWidth + v;\n                break;\n            case 15 /* Height */:\n                if (this.$owner.$inProgressBuilding && this.$owner == this.$target.parent)\n                    v = this.$owner.sourceHeight - this.$target.$initHeight;\n                else\n                    v = this.$owner.$rawHeight - this.$targetHeight;\n                if (info.percent)\n                    v = (v / this.$targetHeight) * this.$target.$rawHeight;\n                if (this.$target == this.$owner.parent)\n                    this.$owner.setSize(this.$owner.$rawWidth, this.$target.$rawHeight + v, true);\n                else\n                    this.$owner.height = this.$target.$rawHeight + v;\n                break;\n            case 16 /* LeftExt_Left */:\n                break;\n            case 17 /* LeftExt_Right */:\n                v = this.$owner.x - (targetX + this.$targetWidth);\n                if (info.percent)\n                    v = (v / this.$targetWidth) * this.$target.$rawWidth;\n                tmp = this.$owner.x;\n                this.$owner.x = targetX + this.$target.$rawWidth + v;\n                this.$owner.width = this.$owner.$rawWidth - (this.$owner.x - tmp);\n                break;\n            case 18 /* RightExt_Left */:\n                break;\n            case 19 /* RightExt_Right */:\n                if (this.$owner.$inProgressBuilding && this.$owner == this.$target.parent)\n                    v = this.$owner.sourceWidth - (targetX + this.$target.$initWidth);\n                else\n                    v = this.$owner.width - (targetX + this.$targetWidth);\n                if (this.$owner != this.$target.parent)\n                    v += this.$owner.x;\n                if (info.percent)\n                    v = (v / this.$targetWidth) * this.$target.$rawWidth;\n                if (this.$owner != this.$target.parent)\n                    this.$owner.width = targetX + this.$target.$rawWidth + v - this.$owner.x;\n                else\n                    this.$owner.width = targetX + this.$target.$rawWidth + v;\n                break;\n            case 20 /* TopExt_Top */:\n                break;\n            case 21 /* TopExt_Bottom */:\n                v = this.$owner.y - (targetY + this.$targetHeight);\n                if (info.percent)\n                    v = (v / this.$targetHeight) * this.$target.$rawHeight;\n                tmp = this.$owner.y;\n                this.$owner.y = targetY + this.$target.$rawHeight + v;\n                this.$owner.height = this.$owner.$rawHeight - (this.$owner.y - tmp);\n                break;\n            case 22 /* BottomExt_Top */:\n                break;\n            case 23 /* BottomExt_Bottom */:\n                if (this.$owner.$inProgressBuilding && this.$owner == this.$target.parent)\n                    v = this.$owner.sourceHeight - (targetY + this.$target.$initHeight);\n                else\n                    v = this.$owner.$rawHeight - (targetY + this.$targetHeight);\n                if (this.$owner != this.$target.parent)\n                    v += this.$owner.y;\n                if (info.percent)\n                    v = (v / this.$targetHeight) * this.$target.$rawHeight;\n                if (this.$owner != this.$target.parent)\n                    this.$owner.height = targetY + this.$target.$rawHeight + v - this.$owner.y;\n                else\n                    this.$owner.height = targetY + this.$target.$rawHeight + v;\n                break;\n        }\n    }\n    addRefTarget(target) {\n        if (target != this.$owner.parent)\n            target.on(\"__xyChanged\" /* XY_CHANGED */, this.$targetXYChanged, this);\n        target.on(\"__sizeChanged\" /* SIZE_CHANGED */, this.$targetSizeChanged, this);\n        target.on(\"__sizeDelayChange\" /* SIZE_DELAY_CHANGE */, this.$targetSizeWillChange, this);\n        this.$targetX = this.$target.x;\n        this.$targetY = this.$target.y;\n        this.$targetWidth = this.$target.$rawWidth;\n        this.$targetHeight = this.$target.$rawHeight;\n    }\n    releaseRefTarget(target) {\n        target.off(\"__xyChanged\" /* XY_CHANGED */, this.$targetXYChanged);\n        target.off(\"__sizeChanged\" /* SIZE_CHANGED */, this.$targetSizeChanged);\n        target.off(\"__sizeDelayChange\" /* SIZE_DELAY_CHANGE */, this.$targetSizeWillChange);\n    }\n    $targetXYChanged(evt) {\n        if (this.$owner.relations.$dealing != null ||\n            (this.$owner.group != null && this.$owner.group.$updating)) {\n            this.$targetX = this.$target.x;\n            this.$targetY = this.$target.y;\n            return;\n        }\n        this.$owner.relations.$dealing = this.$target;\n        let ox = this.$owner.x;\n        let oy = this.$owner.y;\n        let dx = this.$target.x - this.$targetX;\n        let dy = this.$target.y - this.$targetY;\n        this.$defs.forEach(info => {\n            this.applyOnXYChanged(info, dx, dy);\n        }, this);\n        this.$targetX = this.$target.x;\n        this.$targetY = this.$target.y;\n        if (ox != this.$owner.x || oy != this.$owner.y) {\n            ox = this.$owner.x - ox;\n            oy = this.$owner.y - oy;\n            this.$owner.updateGearFromRelations(1 /* XY */, ox, oy);\n            if (this.$owner.parent != null && this.$owner.parent.$transitions.length > 0) {\n                this.$owner.parent.$transitions.forEach(t => {\n                    t.updateFromRelations(this.$owner.id, ox, oy);\n                }, this);\n            }\n        }\n        this.$owner.relations.$dealing = null;\n    }\n    $targetSizeChanged(evt) {\n        if (this.$owner.relations.$dealing != null)\n            return;\n        this.$owner.relations.$dealing = this.$target;\n        let ox = this.$owner.x;\n        let oy = this.$owner.y;\n        let ow = this.$owner.$rawWidth;\n        let oh = this.$owner.$rawHeight;\n        this.$defs.forEach(info => {\n            this.applyOnSizeChanged(info);\n        }, this);\n        this.$targetWidth = this.$target.$rawWidth;\n        this.$targetHeight = this.$target.$rawHeight;\n        if (ox != this.$owner.x || oy != this.$owner.y) {\n            ox = this.$owner.x - ox;\n            oy = this.$owner.y - oy;\n            this.$owner.updateGearFromRelations(1 /* XY */, ox, oy);\n            if (this.$owner.parent != null && this.$owner.parent.$transitions.length > 0) {\n                this.$owner.parent.$transitions.forEach(t => {\n                    t.updateFromRelations(this.$owner.id, ox, oy);\n                }, this);\n            }\n        }\n        if (ow != this.$owner.$rawWidth || oh != this.$owner.$rawHeight) {\n            ow = this.$owner.$rawWidth - ow;\n            oh = this.$owner.$rawHeight - oh;\n            this.$owner.updateGearFromRelations(2 /* Size */, ow, oh);\n        }\n        this.$owner.relations.$dealing = null;\n    }\n    $targetSizeWillChange(evt) {\n        this.$owner.relations.sizeDirty = true;\n    }\n}\n\nclass Relations {\n    constructor(owner) {\n        this.sizeDirty = false;\n        this.$owner = owner;\n        this.$items = [];\n    }\n    add(target, relationType, usePercent = false) {\n        let length = this.$items.length;\n        for (let i = 0; i < length; i++) {\n            let item = this.$items[i];\n            if (item.target == target) {\n                item.add(relationType, usePercent);\n                return;\n            }\n        }\n        let newItem = new RelationItem(this.$owner);\n        newItem.target = target;\n        newItem.add(relationType, usePercent);\n        this.$items.push(newItem);\n    }\n    addItems(target, sidePairs) {\n        let arr = sidePairs.split(',');\n        let s;\n        let usePercent;\n        for (let i = 0; i < 2; i++) {\n            s = arr[i];\n            if (!s)\n                continue;\n            if (s.charAt(s.length - 1) == '%') {\n                s = s.substr(0, s.length - 1);\n                usePercent = true;\n            }\n            else\n                usePercent = false;\n            if (s.indexOf('-') == -1)\n                s = `${s}-${s}`;\n            let t = Relations.RELATION_NAMES.indexOf(s);\n            if (t == -1)\n                throw new Error('Invalid relation type');\n            this.add(target, t, usePercent);\n        }\n    }\n    remove(target, relationType = 0) {\n        let cnt = this.$items.length;\n        let i = 0;\n        while (i < cnt) {\n            let item = this.$items[i];\n            if (item.target == target) {\n                item.remove(relationType);\n                if (item.isEmpty) {\n                    item.dispose();\n                    this.$items.splice(i, 1);\n                    cnt--;\n                }\n                else\n                    i++;\n            }\n            else\n                i++;\n        }\n    }\n    contains(target) {\n        let length = this.$items.length;\n        for (let i = 0; i < length; i++) {\n            if (this.$items[i].target == target)\n                return true;\n        }\n        return false;\n    }\n    clearFor(target) {\n        let cnt = this.$items.length;\n        let i = 0;\n        while (i < cnt) {\n            let item = this.$items[i];\n            if (item.target == target) {\n                item.dispose();\n                this.$items.splice(i, 1);\n                cnt--;\n            }\n            else\n                i++;\n        }\n    }\n    clearAll() {\n        this.$items.forEach(item => {\n            item.dispose();\n        }, this);\n        this.$items.length = 0;\n    }\n    copyFrom(source) {\n        this.clearAll();\n        source.$items.forEach(ri => {\n            let item = new RelationItem(this.$owner);\n            item.copyFrom(ri);\n            this.$items.push(item);\n        }, this);\n    }\n    dispose() {\n        this.clearAll();\n    }\n    onOwnerSizeChanged(dWidth, dHeight) {\n        if (this.$items.length <= 0)\n            return;\n        this.$items.forEach(item => {\n            item.applyOnSelfResized(dWidth, dHeight);\n        }, this);\n    }\n    ensureRelationsSizeCorrect() {\n        if (this.$items.length == 0)\n            return;\n        this.sizeDirty = false;\n        this.$items.forEach(item => {\n            item.target.ensureSizeCorrect();\n        }, this);\n    }\n    get empty() {\n        return this.$items.length == 0;\n    }\n    setup(xml) {\n        xml.children.forEach(cxml => {\n            if (cxml.nodeName != 'relation')\n                return;\n            let targetId;\n            let target;\n            targetId = cxml.attributes.target;\n            if (this.$owner.parent) {\n                if (targetId)\n                    target = this.$owner.parent.getChildById(targetId);\n                else\n                    target = this.$owner.parent;\n            }\n            else {\n                //call from the component's constructor\n                target = this.$owner.getChildById(targetId);\n            }\n            if (target)\n                this.addItems(target, cxml.attributes.sidePair);\n        }, this);\n    }\n}\nRelations.RELATION_NAMES = [\n    'left-left',\n    'left-center',\n    'left-right',\n    'center-center',\n    'right-left',\n    'right-center',\n    'right-right',\n    'top-top',\n    'top-middle',\n    'top-bottom',\n    'middle-middle',\n    'bottom-top',\n    'bottom-middle',\n    'bottom-bottom',\n    'width-width',\n    'height-height',\n    'leftext-left',\n    'leftext-right',\n    'rightext-left',\n    'rightext-right',\n    'topext-top',\n    'topext-bottom',\n    'bottomext-top',\n    'bottomext-bottom' //23\n];\n\nlet isColorGear = function (obj) {\n    return obj && \"color\" in obj;\n};\n\nclass GearColor extends GearBase {\n    constructor(owner) {\n        super(owner);\n        this.$default = '#ffffff';\n    }\n    init() {\n        this.$default = this.$owner['color'];\n        this.$storage = {};\n    }\n    addStatus(pageId, value) {\n        if (value == '-')\n            return;\n        let col = value;\n        if (pageId == null)\n            this.$default = col;\n        else\n            this.$storage[pageId] = col;\n    }\n    apply() {\n        this.$owner.$gearLocked = true;\n        let data = this.$storage[this.$controller.selectedPageId];\n        if (data != undefined)\n            this.$owner['color'] = StringUtil.HEX2RGB(data);\n        else\n            this.$owner['color'] = StringUtil.HEX2RGB(this.$default);\n        this.$owner.$gearLocked = false;\n    }\n    updateState() {\n        if (this.$controller == null || this.$owner.$gearLocked || this.$owner.$inProgressBuilding)\n            return;\n        this.$storage[this.$controller.selectedPageId] = this.$owner['color'];\n    }\n}\n\nlet isAnimationGear = function (obj) {\n    return obj && \"playing\" in obj && \"frame\" in obj;\n};\n\nclass GearAnimation extends GearBase {\n    constructor(owner) {\n        super(owner);\n    }\n    init() {\n        this.$default = new GearAnimationValue(this.$owner['playing'], this.$owner['frame']);\n        this.$storage = {};\n    }\n    addStatus(pageId, value) {\n        if (value == '-')\n            return;\n        let gv;\n        if (pageId == null)\n            gv = this.$default;\n        else {\n            gv = new GearAnimationValue();\n            this.$storage[pageId] = gv;\n        }\n        let arr = value.split(',');\n        gv.frame = parseInt(arr[0]);\n        gv.playing = arr[1] == 'p';\n    }\n    apply() {\n        this.$owner.$gearLocked = true;\n        let gv = this.$storage[this.$controller.selectedPageId];\n        if (!gv)\n            gv = this.$default;\n        this.$owner['frame'] = gv.frame;\n        this.$owner['playing'] = gv.playing;\n        this.$owner.$gearLocked = false;\n    }\n    updateState() {\n        if (this.$controller == null || this.$owner.$gearLocked || this.$owner.$inProgressBuilding)\n            return;\n        let gv = this.$storage[this.$controller.selectedPageId];\n        if (!gv) {\n            gv = new GearAnimationValue();\n            this.$storage[this.$controller.selectedPageId] = gv;\n        }\n        gv.frame = this.$owner['frame'];\n        gv.playing = this.$owner['playing'];\n    }\n}\nclass GearAnimationValue {\n    constructor(playing = true, frame = 0) {\n        this.playing = playing;\n        this.frame = frame;\n    }\n}\n\nclass Sprite extends createjs.DisplayObject {\n    constructor() {\n        super();\n        this.$tint = '#fff';\n        this.$isTrim = false;\n    }\n    get tint() {\n        return this.$tint;\n    }\n    set tint(v) {\n        this.$tint = v;\n        let rgb = v.split(',');\n        this.filters = [\n            new createjs.ColorFilter(+rgb[0] / 255, +rgb[1] / 255, +rgb[2] / 255, 1, 0, 0, 0, 1)\n        ];\n    }\n    set sourceRect(rect) {\n        this.$sourceRect = rect;\n    }\n    get sourceRect() {\n        return this.$sourceRect;\n    }\n    set textureRect(rect) {\n        this.$textureRect = rect;\n    }\n    get textureRect() {\n        return this.$textureRect;\n    }\n    isVisible() {\n        var hasContent = this.cacheCanvas ||\n            (this.texture &&\n                (this.texture['naturalWidth'] ||\n                    this.texture['getContext'] ||\n                    this.texture['readyState'] >= 2));\n        return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n    }\n    getBounds() {\n        var rect = super.getBounds();\n        if (rect) {\n            return rect;\n        }\n        var texture = this.texture, o = this.sourceRect || texture;\n        var hasContent = texture && (texture['naturalWidth'] || texture['getContext'] || texture['readyState'] >= 2);\n        return hasContent ? this.sourceRect.setValues(0, 0, o.width, o.height) : null;\n    }\n    destroy() {\n        //todo\n    }\n}\nSprite.$cachedTexturePool = {};\n\nclass GearIcon extends GearBase {\n    constructor(owner) {\n        super(owner);\n    }\n    init() {\n        this.$default = this.$owner.icon;\n        this.$storage = {};\n    }\n    addStatus(pageId, value) {\n        if (pageId == null)\n            this.$default = value;\n        else\n            this.$storage[pageId] = value;\n    }\n    apply() {\n        this.$owner.$gearLocked = true;\n        let data = this.$storage[this.$controller.selectedPageId];\n        if (data != undefined)\n            this.$owner.icon = data;\n        else\n            this.$owner.icon = this.$default;\n        this.$owner.$gearLocked = false;\n    }\n    updateState() {\n        if (this.$controller == null || this.$owner.$gearLocked || this.$owner.$inProgressBuilding)\n            return;\n        this.$storage[this.$controller.selectedPageId] = this.$owner.icon;\n    }\n}\n\nclass GearText extends GearBase {\n    constructor(owner) {\n        super(owner);\n    }\n    init() {\n        this.$default = this.$owner.text;\n        this.$storage = {};\n    }\n    addStatus(pageId, value) {\n        if (pageId == null)\n            this.$default = value;\n        else\n            this.$storage[pageId] = value;\n    }\n    apply() {\n        this.$owner.$gearLocked = true;\n        let data = this.$storage[this.$controller.selectedPageId];\n        if (data != undefined)\n            this.$owner.text = data;\n        else\n            this.$owner.text = this.$default;\n        this.$owner.$gearLocked = false;\n    }\n    updateState() {\n        if (this.$controller == null || this.$owner.$gearLocked || this.$owner.$inProgressBuilding)\n            return;\n        this.$storage[this.$controller.selectedPageId] = this.$owner.text;\n    }\n}\n\nclass GObject extends createjs.EventDispatcher {\n    constructor() {\n        super();\n        this.$x = 0;\n        this.$y = 0;\n        this.$width = 0;\n        this.$height = 0;\n        this.$alpha = 1;\n        this.$rotation = 0;\n        this.$visible = true;\n        this.$touchable = true;\n        this.$grayed = false;\n        this.$draggable = false;\n        this.$scaleX = 1;\n        this.$scaleY = 1;\n        this.$skewX = 0;\n        this.$skewY = 0;\n        this.$pivot = new createjs.Point();\n        this.$pivotAsAnchor = false;\n        this.$pivotOffset = new createjs.Point();\n        this.$sortingOrder = 0;\n        this.$internalVisible = true;\n        this.$focusable = false;\n        this.$pixelSnapping = false;\n        this.$handlingController = false;\n        this.$lastColorComponents = null;\n        this.$displayEventMap = {};\n        /**@internal */\n        this.$rawWidth = 0;\n        /**@internal */\n        this.$rawHeight = 0;\n        /**@internal */\n        this.$initWidth = 0;\n        /**@internal */\n        this.$initHeight = 0;\n        this.$sourceWidth = 0;\n        this.$sourceHeight = 0;\n        this.$id = `${GObject.gInstanceCounter++}`;\n        this.$name = '';\n        this.createDisplayObject();\n        this.$relations = new Relations(this);\n        this.$gears = [];\n        this.$touchable = true;\n    }\n    get id() {\n        return this.$id;\n    }\n    get name() {\n        return this.$name;\n    }\n    set name(value) {\n        this.$name = value;\n    }\n    get x() {\n        return this.$x;\n    }\n    set x(value) {\n        this.setXY(value, this.$y);\n    }\n    get y() {\n        return this.$y;\n    }\n    set y(value) {\n        this.setXY(this.$x, value);\n    }\n    setXY(xv, yv) {\n        if (this.$x != xv || this.$y != yv) {\n            this.$x = xv;\n            this.$y = yv;\n            this.handleXYChanged();\n            this.updateGear(1 /* XY */);\n            if (this.$parent) {\n                this.$parent.setBoundsChangedFlag();\n                let evt = new createjs.Event(\"__xyChanged\" /* XY_CHANGED */, true, false);\n                this.$displayObject.dispatchEvent(evt, this);\n            }\n            if (GObject.draggingObject == this && !GObject.sUpdatingWhileDragging)\n                this.localToGlobalRect(0, 0, this.width, this.height, GObject.sGlobalRect);\n        }\n    }\n    get pixelSnapping() {\n        return this.$pixelSnapping;\n    }\n    set pixelSnapping(value) {\n        if (this.$pixelSnapping != value) {\n            this.$pixelSnapping = value;\n            this.handleXYChanged();\n        }\n    }\n    center(restraint = false) {\n        let r;\n        if (this.$parent != null)\n            r = this.parent;\n        else\n            r = Decls$1.GRoot.inst;\n        this.setXY((r.width - this.width) / 2, (r.height - this.height) / 2);\n        if (restraint) {\n            this.addRelation(r, 3 /* Center_Center */);\n            this.addRelation(r, 10 /* Middle_Middle */);\n        }\n    }\n    get width() {\n        this.ensureSizeCorrect();\n        if (this.$relations.sizeDirty)\n            this.$relations.ensureRelationsSizeCorrect();\n        return this.$width;\n    }\n    set width(value) {\n        this.setSize(value, this.$rawHeight);\n    }\n    get height() {\n        this.ensureSizeCorrect();\n        if (this.$relations.sizeDirty)\n            this.$relations.ensureRelationsSizeCorrect();\n        return this.$height;\n    }\n    set height(value) {\n        this.setSize(this.$rawWidth, value);\n    }\n    setSize(wv, hv, ignorePivot = false) {\n        if (this.$rawWidth != wv || this.$rawHeight != hv) {\n            this.$rawWidth = wv;\n            this.$rawHeight = hv;\n            wv = Math.max(0, wv);\n            hv = Math.max(0, hv);\n            let diffw = wv - this.mapPivotWidth(1);\n            let diffh = hv - this.mapPivotHeight(1);\n            this.$width = wv;\n            this.$height = hv;\n            this.handleSizeChanged();\n            if (this.$pivot.x != 0 || this.$pivot.y != 0) {\n                if (!this.$pivotAsAnchor) {\n                    if (!ignorePivot)\n                        this.setXY(this.x - this.$pivot.x * diffw, this.y - this.$pivot.y * diffh);\n                    this.updatePivotOffset();\n                }\n                else {\n                    this.applyPivot();\n                }\n            }\n            this.updateGear(2 /* Size */);\n            if (this.$parent) {\n                this.$relations.onOwnerSizeChanged(diffw, diffh);\n                this.$parent.setBoundsChangedFlag();\n            }\n            let evt = new createjs.Event(\"__sizeChanged\" /* SIZE_CHANGED */, true, false);\n            this.$displayObject.dispatchEvent(evt, this);\n        }\n    }\n    ensureSizeCorrect() { }\n    get sourceHeight() {\n        return this.$sourceHeight;\n    }\n    get sourceWidth() {\n        return this.$sourceWidth;\n    }\n    get initHeight() {\n        return this.$initHeight;\n    }\n    get initWidth() {\n        return this.$initWidth;\n    }\n    get actualWidth() {\n        return this.width * Math.abs(this.$scaleX);\n    }\n    get actualHeight() {\n        return this.height * Math.abs(this.$scaleY);\n    }\n    get scaleX() {\n        return this.$scaleX;\n    }\n    set scaleX(value) {\n        this.setScale(value, this.$scaleY);\n    }\n    get scaleY() {\n        return this.$scaleY;\n    }\n    set scaleY(value) {\n        this.setScale(this.$scaleX, value);\n    }\n    setScale(sx, sy) {\n        if (this.$scaleX != sx || this.$scaleY != sy) {\n            this.$scaleX = sx;\n            this.$scaleY = sy;\n            this.handleScaleChanged();\n            this.applyPivot();\n            this.updateGear(2 /* Size */);\n        }\n    }\n    get skewX() {\n        return this.$skewX;\n    }\n    set skewX(value) {\n        this.setSkew(value, this.$skewY);\n    }\n    get skewY() {\n        return this.$skewY;\n    }\n    set skewY(value) {\n        this.setSkew(this.$skewX, value);\n    }\n    setSkew(xv, yv) {\n        if (this.$skewX != xv || this.$skewY != yv) {\n            this.$skewX = xv;\n            this.$skewY = yv;\n            this.$displayObject.skewX = xv;\n            this.$displayObject.skewY = yv;\n            this.applyPivot();\n        }\n    }\n    mapPivotWidth(scale) {\n        return scale * this.$width;\n    }\n    mapPivotHeight(scale) {\n        return scale * this.$height;\n    }\n    get pivotX() {\n        return this.$pivot.x;\n    }\n    get pivotY() {\n        return this.$pivot.y;\n    }\n    set pivotX(value) {\n        this.setPivot(value, this.pivotY);\n    }\n    set pivotY(value) {\n        this.setPivot(this.pivotX, value);\n    }\n    setPivot(xv, yv, asAnchor = false) {\n        if (this.$pivot.x != xv || this.$pivot.y != yv || this.$pivotAsAnchor != asAnchor) {\n            this.$pivot.setValues(xv, yv);\n            this.$pivotAsAnchor = asAnchor;\n            this.updatePivotOffset();\n            this.handleXYChanged();\n        }\n    }\n    internalSetPivot(xv, yv, asAnchor) {\n        this.$pivot.setValues(xv, yv);\n        this.$pivotAsAnchor = asAnchor;\n        if (asAnchor)\n            this.handleXYChanged();\n    }\n    updatePivotOffset() {\n        let transform = this.$displayObject.getMatrix();\n        if (this.$pivot.x != 0 || (this.$pivot.y != 0 && transform)) {\n            let vx = this.mapPivotWidth(this.$pivot.x), vy = this.mapPivotHeight(this.$pivot.y);\n            GObject.sHelperPoint.setValues(vx, vy);\n            let p = transform.transformPoint(GObject.sHelperPoint.x, GObject.sHelperPoint.y);\n            (p.x -= transform.tx), (p.y -= transform.ty);\n            let offsetX = this.$pivot.x * this.$width - p.x;\n            let offsetY = this.$pivot.y * this.$height - p.y;\n            this.$pivotOffset.setValues(offsetX, offsetY);\n        }\n        else\n            this.$pivotOffset.setValues(0, 0);\n    }\n    applyPivot() {\n        if (this.$pivot.x != 0 || this.$pivot.y != 0) {\n            this.updatePivotOffset();\n            this.handleXYChanged();\n        }\n    }\n    get touchable() {\n        return this.$touchable;\n    }\n    set touchable(value) {\n        this.$touchable = value;\n        if (this.$touchable) {\n            this.$displayObject.mouseEnabled = true;\n        }\n        else {\n            this.$displayObject.mouseEnabled = false;\n        }\n    }\n    get grayed() {\n        return this.$grayed;\n    }\n    set grayed(value) {\n        if (this.$grayed != value) {\n            this.$grayed = value;\n            this.handleGrayedChanged();\n            this.updateGear(3 /* Look */);\n        }\n    }\n    get enabled() {\n        return !this.$grayed && this.$touchable;\n    }\n    set enabled(value) {\n        this.grayed = !value;\n        this.touchable = value;\n    }\n    get rotation() {\n        return this.$rotation;\n    }\n    set rotation(value) {\n        if (this.$rotation != value) {\n            this.$rotation = value;\n            if (this.$displayObject)\n                this.$displayObject.rotation = value;\n            this.applyPivot();\n            this.updateGear(3 /* Look */);\n        }\n    }\n    get normalizeRotation() {\n        let rot = this.$rotation % 360;\n        if (rot > 180)\n            rot -= 360;\n        else if (rot < -180)\n            rot += 360;\n        return rot;\n    }\n    get alpha() {\n        return this.$alpha;\n    }\n    set alpha(value) {\n        if (this.$alpha != value) {\n            this.$alpha = value;\n            this.updateAlpha();\n        }\n    }\n    updateAlpha() {\n        if (this.$displayObject)\n            this.$displayObject.alpha = this.$alpha;\n        this.updateGear(3 /* Look */);\n    }\n    get visible() {\n        return this.$visible;\n    }\n    set visible(value) {\n        if (this.$visible != value) {\n            this.$visible = value;\n            if (this.$displayObject)\n                this.$displayObject.visible = this.$visible;\n            if (this.$parent) {\n                this.$parent.childStateChanged(this);\n                this.$parent.setBoundsChangedFlag();\n            }\n            let event = new createjs.Event(\"__visibleChanged\" /* VISIBLE_CHANGED */, true, false);\n            event.data = { visible: this.$visible };\n            this.dispatchEvent(event, this);\n        }\n    }\n    /**@internal */\n    set internalVisible(value) {\n        if (value != this.$internalVisible) {\n            this.$internalVisible = value;\n            if (this.$parent)\n                this.$parent.childStateChanged(this);\n        }\n    }\n    /**@internal */\n    get internalVisible() {\n        return this.$internalVisible;\n    }\n    get finalVisible() {\n        return this.$visible && this.$internalVisible && (!this.$group || this.$group.finalVisible);\n    }\n    get sortingOrder() {\n        return this.$sortingOrder;\n    }\n    set sortingOrder(value) {\n        if (value < 0)\n            value = 0;\n        if (this.$sortingOrder != value) {\n            let old = this.$sortingOrder;\n            this.$sortingOrder = value;\n            if (this.$parent != null)\n                this.$parent.childSortingOrderChanged(this, old, this.$sortingOrder);\n        }\n    }\n    get focusable() {\n        return this.$focusable;\n    }\n    set focusable(value) {\n        this.$focusable = value;\n    }\n    get focused() {\n        return Decls$1.GRoot.inst.focus == this;\n    }\n    requestFocus() {\n        let p = this;\n        while (p && !p.$focusable)\n            p = p.parent;\n        if (p != null)\n            Decls$1.GRoot.inst.focus = p;\n    }\n    get tooltips() {\n        return this.$tooltips;\n    }\n    set tooltips(value) {\n        this.$tooltips = value;\n    }\n    get blendMode() {\n        if (this.$displayObject && this.$displayObject instanceof Sprite)\n            return BlendModeMap[this.$displayObject.compositeOperation] || 'None';\n        return BlendModeMap[0]; //Normal\n    }\n    set blendMode(value) {\n        if (!value || !value.length || !this.$displayObject || !(this.$displayObject instanceof Sprite))\n            return;\n        for (let i = 0; i < BlendModeMap.length; i++) {\n            if (BlendModeMap[i].toLowerCase() === value.toLowerCase()) {\n                this.$displayObject.compositeOperation = BlendModeMap[i];\n                return;\n            }\n        }\n    }\n    get filters() {\n        return this.$displayObject.filters;\n    }\n    set filters(value) {\n        this.$displayObject.filters = value;\n    }\n    get inContainer() {\n        return this.$displayObject.parent != null;\n    }\n    static isDisplayObjectOnStage(display) {\n        if (!display || !display.parent)\n            return false;\n        let p = display;\n        while (p != null) {\n            if (p == Decls$1.GRoot.inst.nativeStage)\n                return true;\n            p = p.parent;\n        }\n        return false;\n    }\n    get onStage() {\n        return GObject.isDisplayObjectOnStage(this.$displayObject);\n    }\n    get resourceURL() {\n        if (this.packageItem != null)\n            return `ui://${this.packageItem.owner.id}${this.packageItem.id}`;\n        else\n            return null;\n    }\n    set group(value) {\n        this.$group = value;\n    }\n    get group() {\n        return this.$group;\n    }\n    getGear(index) {\n        let gear = this.$gears[index];\n        if (gear == null) {\n            switch (index) {\n                case 0 /* Display */:\n                    gear = new GearDisplay(this);\n                    break;\n                case 1 /* XY */:\n                    gear = new GearXY(this);\n                    break;\n                case 2 /* Size */:\n                    gear = new GearSize(this);\n                    break;\n                case 3 /* Look */:\n                    gear = new GearLook(this);\n                    break;\n                case 4 /* Color */:\n                    if (isColorGear(this))\n                        gear = new GearColor(this);\n                    else\n                        throw new Error(`Invalid component type to add GearColor feature, please check the component named ${this.$name} in the Editor.`);\n                    break;\n                case 5 /* Animation */:\n                    if (isAnimationGear(this))\n                        gear = new GearAnimation(this);\n                    else\n                        throw new Error(`Invalid component type to add GearAnimation feature, please check the component named ${this.$name} in the Editor.`);\n                    break;\n                case 6 /* Text */:\n                    gear = new GearText(this);\n                    break;\n                case 7 /* Icon */:\n                    gear = new GearIcon(this);\n                    break;\n                default:\n                    throw new Error('FGUI: invalid gear type');\n            }\n            this.$gears[index] = gear;\n        }\n        return gear;\n    }\n    updateGear(index) {\n        if (this.$gears[index] != null)\n            this.$gears[index].updateState();\n    }\n    updateGearFromRelations(index, dx, dy) {\n        if (this.$gears[index] != null)\n            this.$gears[index].updateFromRelations(dx, dy);\n    }\n    hasGearController(index, c) {\n        return this.$gears[index] && this.$gears[index].controller == c;\n    }\n    /**@internal */\n    lockGearDisplay() {\n        let g = this.$gears[0];\n        if (g && g.controller) {\n            let ret = g.lock();\n            this.checkGearVisible();\n            return ret;\n        }\n        else\n            return 0;\n    }\n    /**@internal */\n    releaseGearDisplay(token) {\n        let g = this.$gears[0];\n        if (g && g.controller) {\n            g.release(token);\n            this.checkGearVisible();\n        }\n    }\n    checkGearVisible() {\n        if (this.$handlingController)\n            return;\n        let g = this.$gears[0];\n        let v = !g || g.connected;\n        if (v != this.$internalVisible) {\n            this.$internalVisible = v;\n            if (this.$parent)\n                this.$parent.childStateChanged(this);\n        }\n    }\n    get gearXY() {\n        return this.getGear(1 /* XY */);\n    }\n    get gearSize() {\n        return this.getGear(2 /* Size */);\n    }\n    get gearLook() {\n        return this.getGear(3 /* Look */);\n    }\n    get relations() {\n        return this.$relations;\n    }\n    addRelation(target, relationType, usePercent = false) {\n        this.$relations.add(target, relationType, usePercent);\n    }\n    removeRelation(target, relationType = 0) {\n        this.$relations.remove(target, relationType);\n    }\n    get displayObject() {\n        return this.$displayObject;\n    }\n    createDisplayObject() { }\n    setDisplayObject(value) {\n        this.$displayObject = value;\n    }\n    get parent() {\n        return this.$parent;\n    }\n    set parent(val) {\n        this.$parent = val;\n    }\n    removeFromParent() {\n        if (this.$parent)\n            this.$parent.removeChild(this);\n    }\n    /** @virtual */\n    get text() {\n        return null;\n    }\n    /** @virtual */\n    set text(value) { }\n    /** @virtual */\n    get icon() {\n        return null;\n    }\n    /** @virtual */\n    set icon(value) { }\n    dispose() {\n        this.removeFromParent();\n        this.$relations.dispose();\n        this.removeAllListeners();\n        this.$mouseMoveEvent = Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Move, this.$moving);\n        this.$mouseUpEvent = Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$end);\n        this.$mouseMove2Event = Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Move, this.$moving2);\n        this.$mouseUp2Event = Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$end2);\n        // this.$displayObject.destroy();  //cjs not the destroy API\n    }\n    click(listener, thisObj) {\n        this.on(InteractiveEvents.Click, listener, thisObj);\n    }\n    removeClick(listener) {\n        this.off(InteractiveEvents.Click, listener);\n    }\n    hasClick(fn) {\n        return this.hasListener(InteractiveEvents.Click);\n    }\n    on(type, listener, thisObject, once = false) {\n        if (type == null)\n            return this;\n        let fn = this.$displayObject.on(type, listener, thisObject, once);\n        this.$displayEventMap[type] = fn;\n        return this;\n    }\n    off(type, listener) {\n        if (this.$displayObject.hasEventListener(type)) {\n            this.$displayObject.off(type, this.$displayEventMap[type]);\n        }\n    }\n    once(type, listener, thisObject) {\n        if (type == null)\n            return this;\n        this.on(type, listener, thisObject, true);\n    }\n    hasListener(event) {\n        //do we need to also check the context?\n        // super.hasEventListener(event)\n        return this.$displayObject.hasEventListener(event);\n    }\n    dispatchEvent(event, ...args) {\n        // super.dispatchEvent(event, args)\n        if (!args || args.length <= 0)\n            args = [event];\n        else\n            args.unshift(event);\n        return this.$displayObject.dispatchEvent(event, this.$displayObject);\n    }\n    removeAllListeners(type) {\n        this.removeAllEventListeners(type);\n    }\n    get draggable() {\n        return this.$draggable;\n    }\n    set draggable(value) {\n        if (this.$draggable != value) {\n            this.$draggable = value;\n            this.initDrag();\n        }\n    }\n    get dragBounds() {\n        return this.$dragBounds;\n    }\n    set dragBounds(value) {\n        this.$dragBounds = value;\n    }\n    startDrag(touchPointID = -1) {\n        if (!this.onStage)\n            return;\n        this.dragBegin();\n    }\n    stopDrag() {\n        this.dragEnd();\n    }\n    get dragging() {\n        return GObject.draggingObject == this;\n    }\n    localToGlobal(ax = 0, ay = 0, resultPoint) {\n        if (this.$pivotAsAnchor) {\n            ax += this.$pivot.x * this.$width;\n            ay += this.$pivot.y * this.$height;\n        }\n        if (!resultPoint)\n            resultPoint = GObject.sHelperPoint;\n        resultPoint.x = ax;\n        resultPoint.y = ay;\n        return this.$displayObject.localToGlobal(resultPoint.x, resultPoint.y);\n    }\n    globalToLocal(ax = 0, ay = 0, resultPoint) {\n        if (!resultPoint)\n            resultPoint = GObject.sHelperPoint;\n        resultPoint.setValues(ax, ay);\n        resultPoint = this.$displayObject.globalToLocal(resultPoint.x, resultPoint.y);\n        if (this.$pivotAsAnchor) {\n            resultPoint.x -= this.$pivot.x * this.$width;\n            resultPoint.y -= this.$pivot.y * this.$height;\n        }\n        return resultPoint;\n    }\n    localToRoot(ax = 0, ay = 0, resultPoint) {\n        let pt = this.localToGlobal(ax, ay, resultPoint);\n        pt.x /= Decls$1.GRoot.inst.contentScaleFactor;\n        pt.y /= Decls$1.GRoot.inst.contentScaleFactor;\n        return pt;\n    }\n    rootToLocal(ax = 0, ay = 0, resultPoint) {\n        ax *= Decls$1.GRoot.inst.contentScaleFactor;\n        ay *= Decls$1.GRoot.inst.contentScaleFactor;\n        return this.globalToLocal(ax, ay, resultPoint);\n    }\n    localToGlobalRect(ax = 0, ay = 0, aWidth = 0, aHeight = 0, resultRect) {\n        if (resultRect == null)\n            resultRect = GObject.sDragHelperRect;\n        let pt = this.localToGlobal(ax, ay);\n        resultRect.x = pt.x;\n        resultRect.y = pt.y;\n        resultRect.width = aWidth;\n        resultRect.height = aHeight;\n        return resultRect;\n    }\n    globalToLocalRect(ax = 0, ay = 0, aWidth = 0, aHeight = 0, resultRect) {\n        if (resultRect == null)\n            resultRect = GObject.sDragHelperRect;\n        let pt = this.globalToLocal(ax, ay);\n        resultRect.x = pt.x;\n        resultRect.y = pt.y;\n        resultRect.width = aWidth;\n        resultRect.height = aHeight;\n        return resultRect;\n    }\n    handleControllerChanged(c) {\n        this.$handlingController = true;\n        for (let i = 0; i < 8 /* Count */; i++) {\n            let gear = this.$gears[i];\n            if (gear != null && gear.controller == c)\n                gear.apply();\n        }\n        this.$handlingController = false;\n        this.checkGearVisible();\n    }\n    switchDisplayObject(newObj) {\n        if (newObj == this.$displayObject)\n            return;\n        let old = this.$displayObject;\n        if (this.inContainer) {\n            let i = this.$displayObject.parent.getChildIndex(this.$displayObject);\n            this.$displayObject.parent.addChildAt(newObj, i);\n            this.$displayObject.parent.removeChild(this.$displayObject);\n        }\n        this.$displayObject = newObj;\n        this.$displayObject.x = old.x;\n        this.$displayObject.y = old.y;\n        this.$displayObject.rotation = old.rotation;\n        this.$displayObject.alpha = old.alpha;\n        this.$displayObject.visible = old.visible;\n        this.$displayObject.scaleX = old.scaleX;\n        this.$displayObject.scaleY = old.scaleY;\n        this.$displayObject.mouseEnabled = old.mouseEnabled;\n    }\n    handleXYChanged() {\n        if (this.$displayObject) {\n            let xv = this.$x;\n            let yv = this.$y;\n            if (this.$pivotAsAnchor) {\n                xv -= this.$pivot.x * this.$width;\n                yv -= this.$pivot.y * this.$height;\n            }\n            if (this.$pixelSnapping) {\n                xv = Math.round(xv);\n                yv = Math.round(yv);\n            }\n            this.$displayObject.x = xv + this.$pivotOffset.x;\n            this.$displayObject.y = yv + this.$pivotOffset.y;\n        }\n    }\n    handleSizeChanged() { }\n    handleScaleChanged() {\n        if (this.$displayObject)\n            this.$displayObject.scaleX = this.$scaleX;\n        this.$displayObject.scaleY = this.$scaleY;\n    }\n    get colorFilter() {\n        if (this.$colorFilter)\n            return this.$colorFilter;\n        /**\n         * todo\n         */\n        var matrix = new createjs.ColorMatrix();\n        this.$colorFilter = new createjs.ColorMatrixFilter(matrix);\n        if (this.$displayObject) {\n            let a = this.$displayObject.filters || [];\n            a.push(this.$colorFilter);\n            this.$displayObject.filters = a;\n        }\n        return this.$colorFilter;\n    }\n    /**\n     * update color appearance\n     * @param brightness value of the brigthness (-1 - 1, where -1 is black)\n     * @param contrast value of the contrast (-1 - 1)\n     * @param saturate The saturation amount (-1 - 1)\n     * @param hue The hue property of the color in degress (-1 - 1, where 1 is 360deg)\n     */\n    updateColorComponents(brightness, contrast, saturate, hue) {\n        var matrix = new createjs.ColorMatrix()\n            .adjustBrightness(brightness)\n            .adjustContrast(contrast * 100)\n            .adjustHue(hue * 180)\n            .adjustSaturation(saturate * 100);\n        this.$displayObject.filters = [new createjs.ColorMatrixFilter(matrix)];\n        this.$displayObject.cache(0, 0, this.$width, this.$height);\n        if (!this.$lastColorComponents)\n            this.$lastColorComponents = [];\n        this.$lastColorComponents.length = 0;\n        this.$lastColorComponents.push(brightness, contrast, saturate, hue);\n    }\n    handleGrayedChanged() {\n        if (this.$displayObject) {\n            if (this.$grayed) {\n                var Grayscale = new createjs.ColorMatrixFilter([\n                    0.3, 0.3, 0.3, 0, 0,\n                    0.3, 0.3, 0.3, 0, 0,\n                    0.3, 0.3, 0.3, 0, 0,\n                    0, 0, 0, 1, 0 // alpha\n                ]);\n                this.$displayObject.filters = [Grayscale];\n                this.$displayObject.cache(0, 0, this.$width, this.$height);\n            }\n            else {\n                if (this.$lastColorComponents && this.$lastColorComponents.length >= 4)\n                    this.updateColorComponents(this.$lastColorComponents[0], this.$lastColorComponents[1], this.$lastColorComponents[2], this.$lastColorComponents[3]);\n                else\n                    this.$displayObject.filters = [];\n            }\n        }\n    }\n    /**@internal */\n    constructFromResource() {\n    }\n    setupBeforeAdd(xml) {\n        let str;\n        let arr;\n        this.$id = xml.attributes.id;\n        this.$name = xml.attributes.name;\n        str = xml.attributes.xy;\n        arr = str.split(',');\n        this.setXY(parseInt(arr[0]), parseInt(arr[1]));\n        str = xml.attributes.size;\n        if (str) {\n            arr = str.split(',');\n            this.$initWidth = parseInt(arr[0]);\n            this.$initHeight = parseInt(arr[1]);\n            this.setSize(this.$initWidth, this.$initHeight, true);\n        }\n        str = xml.attributes.scale;\n        if (str) {\n            arr = str.split(',');\n            this.setScale(parseFloat(arr[0]), parseFloat(arr[1]));\n        }\n        str = xml.attributes.rotation;\n        if (str)\n            this.rotation = parseInt(str);\n        str = xml.attributes.skew;\n        if (str) {\n            arr = str.split(',');\n            this.setSkew(parseFloat(arr[0]), parseFloat(arr[1]));\n        }\n        str = xml.attributes.pivot;\n        if (str) {\n            arr = str.split(',');\n            let n1 = parseFloat(arr[0]), n2 = parseFloat(arr[1]);\n            str = xml.attributes.anchor;\n            this.setPivot(n1, n2, str == 'true');\n        }\n        str = xml.attributes.alpha;\n        if (str)\n            this.alpha = parseFloat(str);\n        if (xml.attributes.touchable == 'false')\n            this.touchable = false;\n        if (xml.attributes.visible == 'false')\n            this.visible = false;\n        if (xml.attributes.grayed == 'true')\n            this.grayed = true;\n        this.tooltips = xml.attributes.tooltips;\n        str = xml.attributes.blend;\n        if (str)\n            this.blendMode = str;\n        str = xml.attributes.filter;\n        if (str) {\n            switch (str) {\n                case 'color':\n                    str = xml.attributes.filterData;\n                    arr = str.split(',');\n                    this.updateColorComponents(parseFloat(arr[0]), parseFloat(arr[1]), parseFloat(arr[2]), parseFloat(arr[3]));\n                    break;\n            }\n        }\n    }\n    setupAfterAdd(xml) {\n        let str = xml.attributes.group;\n        if (str)\n            this.$group = this.$parent.getChildById(str);\n        let col = xml.children;\n        col.forEach(cxml => {\n            let index = GearXMLNodeNameMap[cxml.nodeName];\n            if (index != void 0)\n                this.getGear(index).setup(cxml);\n        }, this);\n    }\n    static castFromNativeObject(disp) {\n        if (isUIObject(disp))\n            return disp.UIOwner;\n        return null;\n    }\n    initDrag() {\n        if (this.$draggable)\n            this.on(InteractiveEvents.Down, this.$touchBegin, this);\n        else\n            this.off(InteractiveEvents.Down, this.$touchBegin);\n    }\n    dragBegin() {\n        if (GObject.draggingObject != null)\n            GObject.draggingObject.stopDrag();\n        GObject.sGlobalDragStart.x = Decls$1.GRoot.globalMouseStatus.mouseX;\n        GObject.sGlobalDragStart.y = Decls$1.GRoot.globalMouseStatus.mouseY;\n        this.localToGlobalRect(0, 0, this.width, this.height, GObject.sGlobalRect);\n        GObject.draggingObject = this;\n        this.$mouseMove2Event = Decls$1.GRoot.inst.nativeStage.on(InteractiveEvents.Move, this.$moving2, this);\n        this.$mouseUp2Event = Decls$1.GRoot.inst.nativeStage.on(InteractiveEvents.Up, this.$end2, this);\n    }\n    dragEnd() {\n        if (GObject.draggingObject == this) {\n            Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Move, this.$mouseMove2Event);\n            Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$mouseUp2Event);\n            GObject.draggingObject = null;\n        }\n        GObject.$dragBeginCancelled = true;\n    }\n    reset() {\n        Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Move, this.$mouseMoveEvent);\n        Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$mouseUpEvent);\n    }\n    $touchBegin(evt) {\n        if (this.$touchDownPoint == null)\n            this.$touchDownPoint = new createjs.Point();\n        this.$touchDownPoint.x = evt.stageX;\n        this.$touchDownPoint.y = evt.stageY;\n        this.$mouseMoveEvent = Decls$1.GRoot.inst.nativeStage.on(InteractiveEvents.Move, this.$moving, this);\n        this.$mouseUpEvent = Decls$1.GRoot.inst.nativeStage.on(InteractiveEvents.Up, this.$end, this);\n    }\n    $end(evt) {\n        this.reset();\n    }\n    $moving(evt) {\n        // console.log(\"moving\");\n        let sensitivity = UIConfig.touchDragSensitivity;\n        if (this.$touchDownPoint != null &&\n            Math.abs(this.$touchDownPoint.x - evt.stageX) < sensitivity &&\n            Math.abs(this.$touchDownPoint.y - evt.stageY) < sensitivity)\n            return;\n        this.reset();\n        GObject.$dragBeginCancelled = false;\n        let event = new createjs.Event(\"__dragStart\" /* START */, true, false);\n        event.data = { currentTarget: this.$displayObject };\n        this.$displayObject.dispatchEvent(event, this);\n        if (!GObject.$dragBeginCancelled)\n            //user may call obj.stopDrag in the DragStart event handler\n            this.dragBegin();\n    }\n    $moving2(evt) {\n        let xx = evt.stageX - GObject.sGlobalDragStart.x + GObject.sGlobalRect.x;\n        let yy = evt.stageY - GObject.sGlobalDragStart.y + GObject.sGlobalRect.y;\n        if (this.$dragBounds != null) {\n            let rect = Decls$1.GRoot.inst.localToGlobalRect(this.$dragBounds.x, this.$dragBounds.y, this.$dragBounds.width, this.$dragBounds.height, GObject.sDragHelperRect);\n            if (xx < rect.x)\n                xx = rect.x;\n            else if (xx + GObject.sGlobalRect.width > rect.x + rect.width) {\n                xx = rect.x + rect.width - GObject.sGlobalRect.width;\n                if (xx < rect.x)\n                    xx = rect.x;\n            }\n            if (yy < rect.y)\n                yy = rect.y;\n            else if (yy + GObject.sGlobalRect.height > rect.y + rect.height) {\n                yy = rect.y + rect.height - GObject.sGlobalRect.height;\n                if (yy < rect.y)\n                    yy = rect.y;\n            }\n        }\n        GObject.sUpdatingWhileDragging = true;\n        GObject.sHelperPoint.x = xx;\n        GObject.sHelperPoint.y = yy;\n        let pt = this.parent.globalToLocal(xx, yy, GObject.sHelperPoint);\n        this.setXY(Math.round(pt.x), Math.round(pt.y));\n        GObject.sUpdatingWhileDragging = false;\n        let currentTarget = this.$displayObject;\n        let event = new createjs.Event(\"__dragMoving\" /* MOVING */, true, false);\n        event.data = { currentTarget };\n        this.$displayObject.dispatchEvent(event, this);\n    }\n    $end2(evt) {\n        if (GObject.draggingObject == this) {\n            this.stopDrag();\n            let currentTarget = this.$displayObject;\n            let event = new createjs.Event(\"__dragEnd\" /* END */, true, false);\n            event.data = { currentTarget };\n            this.$displayObject.dispatchEvent(event, this);\n        }\n    }\n}\nGObject.gInstanceCounter = 0;\n//dragging\n//-------------------------------------------------------------------\nGObject.sGlobalDragStart = new createjs.Point();\nGObject.sGlobalRect = new createjs.Rectangle();\nGObject.sHelperPoint = new createjs.Point();\nGObject.sDragHelperRect = new createjs.Rectangle();\nlet Decls$1 = {};\n\nclass GGroup extends GObject {\n    createDisplayObject() {\n        let c = new UIContainer(this);\n        /**\n         * todo\n         */\n        // c.interactive = false;\n        c.mouseEnabled = false;\n        this.setDisplayObject(c);\n    }\n    updateBounds() {\n        if (this.$updating || !this.parent)\n            return;\n        let cnt = this.$parent.numChildren;\n        let i = 0;\n        let ax = Number.POSITIVE_INFINITY, ay = Number.POSITIVE_INFINITY;\n        let ar = Number.NEGATIVE_INFINITY, ab = Number.NEGATIVE_INFINITY;\n        this.$empty = true;\n        let child;\n        let tmp = 0;\n        for (i = 0; i < cnt; i++) {\n            child = this.$parent.getChildAt(i);\n            if (child.group == this) {\n                tmp = child.x;\n                if (tmp < ax)\n                    ax = tmp;\n                tmp = child.y;\n                if (tmp < ay)\n                    ay = tmp;\n                tmp = child.x + child.width;\n                if (tmp > ar)\n                    ar = tmp;\n                tmp = child.y + child.height;\n                if (tmp > ab)\n                    ab = tmp;\n                this.$empty = false;\n            }\n        }\n        this.$updating = true;\n        if (!this.$empty) {\n            this.setXY(ax, ay);\n            this.setSize(ar - ax, ab - ay);\n        }\n        else\n            this.setSize(0, 0);\n        this.$updating = false;\n    }\n    setXY(xv, yv) {\n        if (this.$x != xv || this.$y != yv) {\n            let dx = xv - this.$x;\n            let dy = yv - this.$y;\n            super.setXY(xv, yv);\n            this.moveChildren(dx, dy);\n        }\n    }\n    moveChildren(dx, dy) {\n        if (this.$updating || !this.$parent)\n            return;\n        this.$updating = true;\n        let cnt = this.$parent.numChildren;\n        let i = 0;\n        let child;\n        for (i = 0; i < cnt; i++) {\n            child = this.$parent.getChildAt(i);\n            if (child.group == this) {\n                child.setXY(child.x + dx, child.y + dy);\n            }\n        }\n        this.$updating = false;\n    }\n    updateAlpha() {\n        super.updateAlpha();\n        if (this.$inProgressBuilding)\n            return;\n        let cnt = this.$parent.numChildren;\n        let i;\n        let child;\n        for (i = 0; i < cnt; i++) {\n            child = this.$parent.getChildAt(i);\n            if (child.group == this)\n                child.alpha = this.alpha;\n        }\n    }\n}\n\nclass UISprite extends createjs.Shape {\n    constructor(owner) {\n        super();\n        this.UIOwner = owner;\n        this.mouseEnabled = false;\n        // this.interactive = false;\n        // this.interactiveChildren = false;\n    }\n}\n\nclass GGraph extends GObject {\n    constructor() {\n        super();\n        this.$type = 0;\n        this.$lineSize = 1;\n        this.$sides = 0;\n        this.$startAngle = 0;\n        this.$points = [];\n        this.$lineSize = 1;\n        this.$lineColor = '#000000';\n        this.$fillColor = '#FFFFFF';\n    }\n    drawRect(lineSize, lineColor, fillColor) {\n        this.$type = 1;\n        this.$lineSize = lineSize;\n        this.$lineColor = lineColor;\n        this.$fillColor = fillColor;\n        this.drawGraph();\n    }\n    drawEllipse(lineSize, lineColor, fillColor) {\n        this.$type = 2;\n        this.$lineSize = lineSize;\n        this.$lineColor = lineColor;\n        this.$fillColor = fillColor;\n        this.drawGraph();\n    }\n    get color() {\n        return this.$fillColor;\n    }\n    set color(value) {\n        this.$fillColor = value;\n        if (this.$type != 0)\n            this.drawGraph();\n    }\n    drawGraph() {\n        let shape = this.$displayObject;\n        let g = shape.graphics;\n        g.clear();\n        let w = this.width;\n        let h = this.height;\n        if (w == 0 || h == 0)\n            return;\n        g.beginStroke(this.$lineColor);\n        if (this.$lineSize == 0) {\n            g.setStrokeStyle(0.1); // see https://github.com/CreateJS/EaselJS/issues/734\n        }\n        else {\n            g.setStrokeStyle(this.$lineSize);\n            w -= this.$lineSize;\n            h -= this.$lineSize;\n        }\n        g.beginFill(this.$fillColor);\n        if (this.$type == 1) {\n            if (this.$corner && this.$corner.length >= 1) {\n                if (this.$corner.length == 1) {\n                    g.drawRoundRect(this.$lineSize / 2, this.$lineSize / 2, w, h, this.$corner[0]);\n                }\n                else {\n                    g.drawRoundRectComplex(this.$lineSize / 2, this.$lineSize / 2, w, h, this.$corner[0], this.$corner[1], this.$corner[3], this.$corner[2]);\n                }\n            }\n            else {\n                g.drawRect(this.$lineSize / 2, this.$lineSize / 2, w, h);\n            }\n        }\n        else if (this.$type == 2) {\n            let halfW = w * 0.5;\n            if (w == h)\n                g.drawCircle(halfW + this.$lineSize / 2, halfW + this.$lineSize / 2, halfW);\n            else {\n                w = w - this.$lineSize;\n                h = h - this.$lineSize;\n                g.drawEllipse(this.$lineSize / 2, this.$lineSize / 2, w, h);\n            }\n        }\n        else if (this.$type == 3) {\n            let radius = w > h ? w / 2 : h / 2;\n            g.drawPolyStar(0 + radius, 0 + radius, radius, this.$sides, 0, this.$startAngle);\n        }\n        else if (this.$type == 4) {\n            Utils.fillPath(g, this.$points, 0, 0);\n        }\n        g.endFill();\n        shape.cache(0, 0, this.$width, this.$height);\n    }\n    replaceMe(target) {\n        if (!this.$parent)\n            throw new Error('parent not set');\n        target.name = this.name;\n        target.alpha = this.alpha;\n        target.rotation = this.rotation;\n        target.visible = this.visible;\n        target.touchable = this.touchable;\n        target.grayed = this.grayed;\n        target.setXY(this.x, this.y);\n        target.setSize(this.width, this.height);\n        let index = this.$parent.getChildIndex(this);\n        this.$parent.addChildAt(target, index);\n        target.relations.copyFrom(this.relations);\n        this.$parent.removeChild(this, true);\n    }\n    addBeforeMe(target) {\n        if (this.$parent == null)\n            throw new Error('parent not set');\n        let index = this.$parent.getChildIndex(this);\n        this.$parent.addChildAt(target, index);\n    }\n    addAfterMe(target) {\n        if (this.$parent == null)\n            throw new Error('parent not set');\n        let index = this.$parent.getChildIndex(this);\n        index++;\n        this.$parent.addChildAt(target, index);\n    }\n    createDisplayObject() {\n        this.$displayObject = new UISprite(this);\n        this.$displayObject.mouseEnabled = true;\n    }\n    handleSizeChanged() {\n        if (this.$type != 0)\n            this.drawGraph();\n    }\n    setupBeforeAdd(xml) {\n        super.setupBeforeAdd(xml);\n        let type = xml.attributes.type;\n        if (type && type != 'empty') {\n            let str;\n            str = xml.attributes.lineSize;\n            if (str)\n                this.$lineSize = parseInt(str);\n            let c;\n            str = xml.attributes.lineColor;\n            if (str) {\n                c = StringUtil.convertToRGBA(str);\n                this.$lineColor = c;\n            }\n            str = xml.attributes.fillColor;\n            if (str) {\n                c = StringUtil.convertToRGBA(str);\n                this.$fillColor = c;\n            }\n            let arr;\n            str = xml.attributes.corner;\n            if (str) {\n                arr = str.split(',');\n                if (arr.length > 1)\n                    this.$corner = [parseInt(arr[0]), parseInt(arr[1]), parseInt(arr[2]), parseInt(arr[3])];\n                else\n                    this.$corner = [parseInt(arr[0])];\n            }\n            if (type == 'rect') {\n                this.$type = 1;\n            }\n            else if (type == 'eclipse') {\n                this.$type = 2;\n            }\n            else if (type == 'regular_polygon') {\n                this.$type = 3;\n                str = xml.attributes.sides;\n                if (str) {\n                    this.$sides = parseInt(str);\n                }\n                str = xml.attributes.startAngle;\n                if (str) {\n                    this.$startAngle = parseInt(str);\n                }\n            }\n            else if (type == 'polygon') {\n                this.$type = 4;\n                str = xml.attributes.points;\n                if (str) {\n                    arr = str.split(',');\n                    this.$points = arr.map(point => {\n                        return parseInt(point);\n                    });\n                }\n            }\n            this.drawGraph();\n        }\n    }\n}\n\nclass Bitmap extends Sprite {\n    constructor(item) {\n        super();\n        if (item) {\n            let { width, height, texture, id } = item;\n            this.$frameId = id;\n            if (typeof texture == 'string') {\n                this.texture = document.createElement('img');\n                this.texture.src = texture;\n            }\n            else {\n                this.texture = texture.image;\n            }\n            this.sourceRect = new createjs.Rectangle(0, 0, width, height);\n            this.textureRect = texture.rect;\n        }\n    }\n    draw(ctx, ignoreCache) {\n        let flag = super.draw(ctx, ignoreCache);\n        if (flag) {\n            return flag;\n        }\n        if (this.sourceRect && this.textureRect) {\n            let { x, y, width, height } = this.sourceRect;\n            x = this.$isTrim ? x : 0;\n            y = this.$isTrim ? y : 0;\n            ctx.drawImage(this.texture, this.textureRect.x, this.textureRect.y, this.textureRect.width, this.textureRect.height, x, y, width, height); //GObject来控制位置坐标\n        }\n        else {\n            ctx.drawImage(this.texture, 0, 0);\n        }\n        return true;\n    }\n    getBounds() {\n        var rect = super.getBounds();\n        if (rect) {\n            return rect;\n        }\n        var texture = this.texture, o = this.sourceRect || texture;\n        var hasContent = texture && (texture['naturalWidth'] || texture['getContext'] || texture['readyState'] >= 2);\n        return hasContent ? this.sourceRect.setValues(0, 0, o.width, o.height) : null;\n    }\n}\n\nclass ScaleBitmap extends Sprite {\n    constructor(item, scale9Grid) {\n        super();\n        if (item) {\n            let { width, height, texture, id } = item;\n            this.$frameId = id;\n            if (typeof texture == 'string') {\n                this.texture = document.createElement('img');\n                this.texture.src = texture;\n            }\n            else {\n                this.texture = texture.image;\n            }\n            this.sourceRect = new createjs.Rectangle(0, 0, width, height);\n            this.textureRect = texture.rect;\n        }\n        this.scale9Grid = scale9Grid;\n        this.snapToPixel = true;\n    }\n    draw(ctx, ignoreCache) {\n        let flag = super.draw(ctx, ignoreCache);\n        if (flag) {\n            return true;\n        }\n        var centerX = this.scale9Grid.width;\n        var centerY = this.scale9Grid.height;\n        var scaledCenterX;\n        var scaledCenterY;\n        var imageHeight = this.sourceRect.height;\n        var imageWidth = this.sourceRect.width;\n        if (centerX == 0) {\n            //vertical\n            if (centerY == 0) {\n                throw 'One of scale9Grid width or height must be greater than zero.';\n            }\n            var scale3Region2 = this.textureRect.y + this.scale9Grid.y;\n            var scale3Region3 = this.textureRect.y + this.scale9Grid.y + this.scale9Grid.height;\n            var scaledFirstRegion = this.scale9Grid.y;\n            var scaledSecondRegion = this.scale9Grid.height;\n            var scaledThirdRegion = this.textureRect.height - scaledFirstRegion - scaledSecondRegion;\n            scaledCenterY = imageHeight - scaledFirstRegion - scaledThirdRegion;\n            ctx.drawImage(this.texture, this.textureRect.x, this.textureRect.y, this.textureRect.width, scaledFirstRegion, 0, 0, imageWidth, scaledFirstRegion);\n            ctx.drawImage(this.texture, this.textureRect.x, scale3Region2, this.textureRect.width, scaledSecondRegion, 0, scaledFirstRegion, imageWidth, scaledCenterY);\n            ctx.drawImage(this.texture, this.textureRect.x, scale3Region3, this.textureRect.width, scaledThirdRegion, 0, scaledCenterY + scaledFirstRegion, imageWidth, scaledThirdRegion);\n        }\n        else if (centerY == 0) {\n            //horizontal\n            var scale3Region2 = this.textureRect.x + this.scale9Grid.x;\n            var scale3Region3 = this.textureRect.x + this.scale9Grid.x + this.scale9Grid.width;\n            var scaledFirstRegion = this.scale9Grid.x;\n            var scaledSecondRegion = this.scale9Grid.width;\n            var scaledThirdRegion = this.textureRect.width - scaledFirstRegion - scaledSecondRegion;\n            scaledCenterX = imageWidth - scaledFirstRegion - scaledThirdRegion;\n            ctx.drawImage(this.texture, this.textureRect.x, this.textureRect.y, scaledFirstRegion, this.textureRect.height, 0, 0, scaledFirstRegion, imageHeight);\n            ctx.drawImage(this.texture, scale3Region2, this.textureRect.y, scaledSecondRegion, this.textureRect.height, scaledFirstRegion, 0, scaledCenterX, imageHeight);\n            ctx.drawImage(this.texture, scale3Region3, this.textureRect.y, scaledThirdRegion, this.textureRect.height, scaledFirstRegion + scaledCenterX, 0, scaledThirdRegion, imageHeight);\n        }\n        else {\n            var left = this.scale9Grid.x;\n            var top = this.scale9Grid.y;\n            var right = this.textureRect.width - centerX - left;\n            var bottom = this.textureRect.height - centerY - top;\n            scaledCenterX = imageWidth - left - right;\n            scaledCenterY = imageHeight - top - bottom;\n            ctx.drawImage(this.texture, this.textureRect.x, this.textureRect.y, left, top, 0, 0, left, top);\n            ctx.drawImage(this.texture, this.textureRect.x + left, this.textureRect.y, centerX, top, left, 0, scaledCenterX, top);\n            ctx.drawImage(this.texture, this.textureRect.x + left + centerX, this.textureRect.y, right, top, left + scaledCenterX, 0, right, top);\n            ctx.drawImage(this.texture, this.textureRect.x, this.textureRect.y + top, left, centerY, 0, top, left, scaledCenterY);\n            ctx.drawImage(this.texture, this.textureRect.x + left, this.textureRect.y + top, centerX, centerY, left, top, scaledCenterX, scaledCenterY);\n            ctx.drawImage(this.texture, this.textureRect.x + left + centerX, this.textureRect.y + top, right, centerY, left + scaledCenterX, top, right, scaledCenterY);\n            ctx.drawImage(this.texture, this.textureRect.x, this.textureRect.y + top + centerY, left, bottom, 0, top + scaledCenterY, left, bottom);\n            ctx.drawImage(this.texture, this.textureRect.x + left, this.textureRect.y + top + centerY, centerX, bottom, left, top + scaledCenterY, scaledCenterX, bottom);\n            ctx.drawImage(this.texture, this.textureRect.x + left + centerX, this.textureRect.y + top + centerY, right, bottom, left + scaledCenterX, top + scaledCenterY, right, bottom);\n        }\n        return true;\n    }\n}\n\nclass TilingBitmap extends Sprite {\n    constructor(item) {\n        super();\n        if (item) {\n            let { width, height, texture, id } = item;\n            this.$frameId = id;\n            if (typeof texture == 'string') {\n                this.texture = document.createElement('img');\n                this.texture.src = texture;\n            }\n            else {\n                this.texture = texture.image;\n            }\n            this.sourceRect = new createjs.Rectangle(0, 0, width, height);\n            this.textureRect = texture.rect;\n            let offsetCanvas = document.createElement('canvas');\n            let offsetCanvasContext = offsetCanvas.getContext('2d');\n            offsetCanvas.width = this.textureRect.width;\n            offsetCanvas.height = this.textureRect.height;\n            offsetCanvasContext.drawImage(this.texture, this.textureRect.x, this.textureRect.y, this.textureRect.width, this.textureRect.height, 0, 0, this.textureRect.width, this.textureRect.height);\n            this._pattern = offsetCanvasContext.createPattern(offsetCanvas, 'repeat');\n        }\n    }\n    draw(ctx, ignoreCache) {\n        let flag = super.draw(ctx, ignoreCache);\n        if (flag) {\n            return flag;\n        }\n        // ctx.save();\n        let { width, height } = this.sourceRect;\n        ctx.fillStyle = this._pattern;\n        ctx.fillRect(0, 0, width, height);\n        // ctx.restore();\n        return true;\n    }\n}\n\nclass UIImage extends createjs.Container {\n    constructor(owner) {\n        super();\n        this.UIOwner = owner;\n        // this.mouseEnabled = this.mouseChildren = false;\n    }\n    set sourceRect(rect) {\n        this.$disp.sourceRect = rect;\n    }\n    setCache(x, y, width, height) {\n        this.$disp.cache(x, y, width, height);\n    }\n    /**@internal */\n    $initDisp(item) {\n        if (this.$disp)\n            return;\n        if (item) {\n            item.load();\n            if (item.scaleByTile) {\n                this.$disp = new TilingBitmap(item);\n            }\n            else if (item.scale9Grid) {\n                let rect = new createjs.Rectangle(item.scale9Grid.x, item.scale9Grid.y, Math.max(0, item.scale9Grid.width), Math.max(0, item.scale9Grid.height));\n                this.$disp = new ScaleBitmap(item, rect);\n            }\n            else {\n                this.$disp = new Bitmap(item);\n            }\n        }\n        else {\n            this.$disp = new Bitmap();\n        }\n        this.addChild(this.$disp);\n    }\n    get tint() {\n        return this.$disp.tint;\n    }\n    set tint(value) {\n        this.$disp.tint = value;\n    }\n    get height() {\n        return this.$disp.sourceRect.height;\n    }\n    set height(v) {\n        this.$disp.sourceRect.height = v;\n    }\n    get width() {\n        return this.$disp.sourceRect.width;\n    }\n    set width(v) {\n        this.$disp.sourceRect.width = v;\n    }\n    get texture() {\n        return this.$disp.texture;\n    }\n    set texture(v) {\n        this.$disp.texture = v;\n    }\n    /**\n     * rect = x,y,w,h = l,t,r,b\n     */\n    get scale9Grid() {\n        if (this.$disp instanceof ScaleBitmap) {\n            return this.$disp.scale9Grid;\n        }\n        return null;\n    }\n    /**\n     * rect = x,y,w,h = l,t,r,b\n     */\n    set scale9Grid(rect) {\n        if (this.$disp instanceof ScaleBitmap) {\n            this.$disp.scale9Grid = rect;\n        }\n    }\n    /**\n     * todo\n     */\n    destroy() {\n        //     if(this.$disp) {\n        //         this.$disp.destroy(options);\n        //         this.$disp = null;\n        //     }\n        //     super.destroy(options);\n    }\n}\n\nclass GImage extends GObject {\n    constructor() {\n        super();\n    }\n    get touchable() {\n        return false;\n    }\n    set touchable(value) {\n        this.$touchable = false; //GImage has no interaction\n    }\n    get color() {\n        return this.$content.tint;\n    }\n    set color(value) {\n        if (this.color != value) {\n            this.updateGear(4 /* Color */);\n            this.$content.tint = value;\n            this.$content.setCache(0, 0, this.$width, this.$height);\n        }\n    }\n    get flip() {\n        return this.$flip;\n    }\n    set flip(value) {\n        if (this.$flip != value) {\n            this.$flip = value;\n            this.$content.scaleX = this.$content.scaleY = 1;\n            if (this.$flip == 1 /* Horizontal */ || this.$flip == 3 /* Both */) {\n                this.$content.scaleX = -1;\n            }\n            if (this.$flip == 2 /* Vertical */ || this.$flip == 3 /* Both */) {\n                this.$content.scaleY = -1;\n            }\n            this.handleXYChanged();\n        }\n    }\n    get texture() {\n        return this.$content.texture;\n    }\n    set texture(value) {\n        if (value != null) {\n            this.$sourceWidth = value.width;\n            this.$sourceHeight = value.height;\n        }\n        else\n            this.$sourceWidth = this.$sourceHeight = 0;\n        this.$initWidth = this.$sourceWidth;\n        this.$initHeight = this.$sourceHeight;\n        this.$content.texture = value;\n    }\n    createDisplayObject() {\n        this.$content = new UIImage(this);\n        this.setDisplayObject(this.$content);\n    }\n    dispose() {\n        this.$content.destroy();\n        super.dispose();\n    }\n    constructFromResource() {\n        this.$sourceWidth = this.packageItem.width;\n        this.$sourceHeight = this.packageItem.height;\n        this.$initWidth = this.$sourceWidth;\n        this.$initHeight = this.$sourceHeight;\n        this.$content.$initDisp(this.packageItem);\n        this.setSize(this.$sourceWidth, this.$sourceHeight);\n    }\n    handleXYChanged() {\n        super.handleXYChanged();\n        if (this.$flip != 0 /* None */) {\n            if (this.$content.scaleX == -1)\n                this.$content.x += this.width;\n            if (this.$content.scaleY == -1)\n                this.$content.y += this.height;\n        }\n    }\n    handleSizeChanged() {\n        this.$content.width = this.width;\n        this.$content.height = this.height;\n        let rect = new createjs.Rectangle(this.x, this.y, this.width, this.height);\n        this.$content.sourceRect = rect;\n    }\n    setupBeforeAdd(xml) {\n        super.setupBeforeAdd(xml);\n        let str;\n        str = xml.attributes.color;\n        if (str) {\n            this.color = StringUtil.HEX2RGB(str);\n        }\n        str = xml.attributes.flip;\n        if (str)\n            this.flip = ParseFlipType(str);\n    }\n}\n\nclass GTimer {\n    constructor() {\n        this.$enumIdx = 0;\n        this.$enumCount = 0;\n        this.$curTime = Date.now();\n        this.$items = [];\n        this.$itemPool = [];\n        // this.$lastTime = createjs.Ticker.getTime();\n        // GTimer.time = this.$lastTime;\n        createjs.Ticker.on('tick', this.advance, this);\n    }\n    getItem() {\n        if (this.$itemPool.length)\n            return this.$itemPool.pop();\n        else\n            return new TimerItem();\n    }\n    findItem(callback, thisObj) {\n        let len = this.$items.length;\n        for (let i = 0; i < len; i++) {\n            let item = this.$items[i];\n            if (item.callback == callback && item.thisObj == thisObj)\n                return item;\n        }\n        return null;\n    }\n    //repeat <= 0 means loop\n    add(delayInMs, repeat, callback, thisObj, callbackParam) {\n        let item = this.findItem(callback, thisObj);\n        if (!item) {\n            item = this.getItem();\n            item.callback = callback;\n            item.thisObj = thisObj;\n            this.$items.push(item);\n        }\n        item.delay = delayInMs;\n        item.counter = 0;\n        item.repeat = repeat;\n        item.param = callbackParam;\n        item.end = false;\n    }\n    addLoop(delayInMs, callback, thisObj, callbackParam) {\n        this.add(delayInMs, 0, callback, thisObj, callbackParam);\n    }\n    callLater(callback, thisObj, callbackParam) {\n        this.add(1, 1, callback, thisObj, callbackParam);\n    }\n    callDelay(delayInMs, callback, thisObj, callbackParam) {\n        this.add(delayInMs, 1, callback, thisObj, callbackParam);\n    }\n    exists(callback, thisObj) {\n        let item = this.findItem(callback, thisObj);\n        return item != null;\n    }\n    remove(callback, thisObj) {\n        let item = this.findItem(callback, thisObj);\n        if (item) {\n            let i = this.$items.indexOf(item);\n            this.$items.splice(i, 1);\n            if (i < this.$enumIdx)\n                this.$enumIdx--;\n            this.$enumCount--;\n            item.callback = null;\n            item.param = null;\n            this.$itemPool.push(item);\n        }\n    }\n    get ticker() {\n        return this.$ticker;\n    }\n    get curTime() {\n        return this.$curTime;\n    }\n    advance() {\n        this.$enumIdx = 0;\n        this.$enumCount = this.$items.length;\n        while (this.$enumIdx < this.$enumCount) {\n            let item = this.$items[this.$enumIdx];\n            this.$enumIdx++;\n            let ms = createjs.Ticker.interval;\n            this.$curTime += ms;\n            if (item.advance(ms)) {\n                if (item.end) {\n                    this.$enumIdx--;\n                    this.$enumCount--;\n                    this.$items.splice(this.$enumIdx, 1);\n                    this.$itemPool.push(item);\n                }\n                if (item.callback) {\n                    let args = [ms];\n                    if (item.param && item.param instanceof Array)\n                        args = item.param.concat(args);\n                    else if (item.param !== void 0)\n                        args.unshift(item.param);\n                    item.callback.apply(item.thisObj, args);\n                }\n                if (item.end)\n                    item.callback = item.thisObj = item.param = null;\n            }\n        }\n    }\n}\nGTimer.inst = new GTimer();\nclass TimerItem {\n    constructor() {\n        this.delay = 0;\n        this.counter = 0;\n        this.repeat = 0;\n    }\n    advance(delta = 0) {\n        this.counter += delta;\n        if (this.counter >= this.delay) {\n            this.counter -= this.delay;\n            if (this.counter > this.delay)\n                this.counter = this.delay;\n            if (this.repeat > 0) {\n                this.repeat--;\n                if (this.repeat == 0)\n                    this.end = true;\n            }\n            return true;\n        }\n        else\n            return false;\n    }\n}\n\nclass MathUtil {\n    static clamp(value, min, max) {\n        if (value < min)\n            value = min;\n        else if (value > max)\n            value = max;\n        return value;\n    }\n    static clamp01(value) {\n        if (value > 1)\n            value = 1;\n        else if (value < 0)\n            value = 0;\n        return value;\n    }\n    static isNumber(n) {\n        if (typeof (n) != \"number\")\n            return false;\n        if (isNaN(n))\n            return false;\n        return true;\n    }\n    static sign(x) {\n        x = Number(x);\n        if (x === 0 || isNaN(x))\n            return x;\n        return x > 0 ? 1 : -1;\n    }\n    static angleToRadian(n) {\n        return n * MathUtil.RADIAN;\n    }\n    static lerp(s, e, p) {\n        return s + p * (e - s);\n    }\n}\nMathUtil.RADIAN = Math.PI / 180;\n\nclass MovieClipData {\n    constructor() {\n        this.repeatedCount = 0;\n        this.$curFrame = 0;\n        this.$lastTime = 0;\n        this.$curFrameDelay = 0;\n        this.$lastTime = Date.now();\n    }\n    update(mc) {\n        let t = Date.now();\n        let elapsed = t - this.$lastTime;\n        this.$lastTime = t;\n        let cur = this.$curFrame;\n        if (cur >= mc.frameCount)\n            cur = mc.frameCount - 1;\n        this.reachesEnd = false;\n        this.$curFrameDelay += elapsed;\n        let interval = mc.interval + mc.frames[cur].addDelay\n            + ((cur == 0 && this.repeatedCount > 0) ? mc.repeatDelay : 0);\n        if (this.$curFrameDelay < interval)\n            return;\n        this.$curFrameDelay -= interval;\n        if (this.$curFrameDelay > mc.interval)\n            this.$curFrameDelay = mc.interval;\n        if (mc.swing) {\n            if (this.reversed) {\n                this.$curFrame--;\n                if (this.$curFrame < 0) {\n                    this.$curFrame = Math.min(1, mc.frameCount - 1);\n                    this.repeatedCount++;\n                    this.reversed = !this.reversed;\n                }\n            }\n            else {\n                this.$curFrame++;\n                if (this.$curFrame > mc.frameCount - 1) {\n                    this.$curFrame = Math.max(0, mc.frameCount - 2);\n                    this.repeatedCount++;\n                    this.reachesEnd = true;\n                    this.reversed = !this.reversed;\n                }\n            }\n        }\n        else {\n            this.$curFrame++;\n            if (this.$curFrame > mc.frameCount - 1) {\n                this.$curFrame = 0;\n                this.repeatedCount++;\n                this.reachesEnd = true;\n            }\n        }\n    }\n    get currentFrame() {\n        return this.$curFrame;\n    }\n    set currentFrame(value) {\n        this.$curFrame = value;\n        this.$curFrameDelay = 0;\n    }\n    rewind() {\n        this.$curFrame = 0;\n        this.$curFrameDelay = 0;\n        this.reversed = false;\n        this.reachesEnd = false;\n    }\n    reset() {\n        this.$curFrame = 0;\n        this.$curFrameDelay = 0;\n        this.repeatedCount = 0;\n        this.reachesEnd = false;\n        this.reversed = false;\n    }\n    copy(src) {\n        this.$curFrame = src.$curFrame;\n        this.$curFrameDelay = src.$curFrameDelay;\n        this.repeatedCount = src.repeatedCount;\n        this.reachesEnd = src.reachesEnd;\n        this.reversed = src.reversed;\n    }\n}\n\nclass DefaultMovieClipSettings {\n    constructor() {\n        /**the first frame number to start to play */\n        this.startFrame = 0;\n        /**the end frame the playing will end at, -1 means to the tail */\n        this.endFrame = -1;\n        /**play count, 0 means endeless */\n        this.repeatCount = 0;\n        /**once the repeated playing completes, the playing will end at, -1 means to the tail */\n        this.loopEndAt = -1;\n        /**complete callback handler */\n        this.endCallback = null;\n        /**context object for the callback function */\n        this.endCallbackContext = null;\n    }\n    /**modify the current settings without whole parameters provided */\n    mix(other) {\n        let ret = this;\n        for (let key in other) {\n            if (key == \"mix\")\n                continue;\n            ret[key] = other[key];\n        }\n        return this;\n    }\n}\n\nclass MovieClip extends Bitmap {\n    constructor(owner) {\n        super();\n        this.interval = 0;\n        this.repeatDelay = 0;\n        this.$frameCount = 0;\n        this.$currentFrame = 0;\n        this.$status = 0 /* NORMAL */;\n        this.UIOwner = owner;\n        this.data = new MovieClipData();\n        this.$playing = true;\n        this.mouseEnabled = false;\n        this.$settings = new DefaultMovieClipSettings();\n        this.$isTrim = true;\n        this.on('added', this.added, this);\n        this.on('removed', this.removed, this);\n    }\n    // draw(ctx: CanvasRenderingContext2D, ignoreCache: boolean): boolean {\n    //     // let flag = super.draw(ctx, ignoreCache);\n    //     // if (flag) {\n    //     //     return flag;\n    //     // }\n    //     if (this.sourceRect && this.textureRect) {\n    //         let { x, y, width, height } = this.textureRect;\n    //         ctx.drawImage(this.texture, x, y, width, height, this.sourceRect.x, this.sourceRect.y, this.sourceRect.width, this.sourceRect.height);//GObject来控制位置坐标\n    //     } else {\n    //         ctx.drawImage(this.texture, 0, 0);\n    //     }\n    //     return true;\n    // }\n    get frames() {\n        return this.$frames;\n    }\n    set frames(value) {\n        this.$frames = value;\n        if (this.$frames != null)\n            this.$frameCount = this.$frames.length;\n        else\n            this.$frameCount = 0;\n        if (this.$settings.endFrame == -1 || this.$settings.endFrame > this.$frameCount - 1)\n            this.$settings.endFrame = this.$frameCount - 1;\n        if (this.$settings.loopEndAt == -1 || this.$settings.loopEndAt > this.$frameCount - 1)\n            this.$settings.loopEndAt = this.$frameCount - 1;\n        if (this.$currentFrame < 0 || this.$currentFrame > this.$frameCount - 1)\n            this.$currentFrame = this.$frameCount - 1;\n        if (this.$frameCount > 0) {\n            this.setFrame(this.$frames[this.$currentFrame]);\n        }\n        else {\n            this.setFrame(null);\n        }\n        this.data.rewind();\n    }\n    get frameCount() {\n        return this.$frameCount;\n    }\n    // public get boundsRect(): createjs.Rectangle {\n    //     return this.getBounds();\n    //     // return this._boundsRect;\n    // }\n    set boundsRect(value) {\n        // this._boundsRect = value;\n        // this.sourceRect = value;\n    }\n    get currentFrame() {\n        return this.$currentFrame;\n    }\n    set currentFrame(value) {\n        if (this.$currentFrame != value) {\n            this.$currentFrame = value;\n            this.data.currentFrame = value;\n            this.setFrame(this.$currentFrame < this.$frameCount ? this.$frames[this.$currentFrame] : null);\n        }\n    }\n    get playing() {\n        return this.$playing;\n    }\n    set playing(value) {\n        this.$playing = value;\n        if (value && GObject.isDisplayObjectOnStage(this))\n            GTimer.inst.add(0, 0, this.update, this);\n        else\n            GTimer.inst.remove(this.update, this);\n    }\n    /**\n       * Modify the playing settings for the current MovieClip object, there are two ways to call this method:\n       * 1) pass whole parameters:\n              startFrame: number;\n              endFrame: number;\n              repeatCount: number;\n              loopEndAt: number;\n              endCallback: (target?: MovieClip) => void;\n              endCallbackContext: any;\n       * 2) just pass 1 object which implements MovieClipSettings (recommended)\n       */\n    setPlaySettings(...args) {\n        if (args.length == 1 && typeof args[0] == 'object')\n            this.$settings.mix(args[0]);\n        else {\n            let s = args[0], e = args[1], r = args[2], l = args[3], ec = args[4], ecc = args[5];\n            let o = {};\n            if (MathUtil.isNumber(s))\n                o.startFrame = s;\n            if (MathUtil.isNumber(e))\n                o.endFrame = e;\n            if (MathUtil.isNumber(r))\n                o.repeatCount = r;\n            if (MathUtil.isNumber(l))\n                o.loopEndAt = l;\n            if (ec && typeof ec == 'function')\n                o.endCallback = ec;\n            if (ecc)\n                o.endCallbackContext = ecc;\n            this.$settings.mix(o);\n        }\n        if (this.$settings.endFrame == -1 || this.$settings.endFrame > this.$frameCount - 1)\n            this.$settings.endFrame = this.$frameCount - 1;\n        if (this.$settings.loopEndAt == -1)\n            this.$settings.loopEndAt = this.$settings.endFrame;\n        this.$status = 0 /* NORMAL */;\n        this.currentFrame = this.$settings.startFrame;\n    }\n    update() {\n        if (this.UIOwner.$inProgressBuilding)\n            return;\n        if (this.$playing && this.$frameCount != 0 && this.$status != 3 /* ENDED */) {\n            this.data.update(this);\n            if (this.$currentFrame != this.data.currentFrame) {\n                if (this.$status == 1 /* LOOPING */) {\n                    this.$currentFrame = this.$settings.startFrame;\n                    this.data.currentFrame = this.$currentFrame;\n                    this.$status = 0 /* NORMAL */;\n                }\n                else if (this.$status == 2 /* STOPPING */) {\n                    this.$currentFrame = this.$settings.loopEndAt;\n                    this.data.currentFrame = this.$currentFrame;\n                    this.$status = 3 /* ENDED */;\n                    //play end\n                    if (this.$settings.endCallback != null)\n                        GTimer.inst.callLater(this.$playEnd, this);\n                }\n                else {\n                    this.$currentFrame = this.data.currentFrame;\n                    if (this.$currentFrame == this.$settings.endFrame) {\n                        if (this.$settings.repeatCount > 0) {\n                            this.$settings.repeatCount--;\n                            if (this.$settings.repeatCount == 0)\n                                this.$status = 2 /* STOPPING */;\n                            else\n                                this.$status = 1 /* LOOPING */;\n                        }\n                    }\n                }\n                this.setFrame(this.$frames[this.$currentFrame]);\n            }\n        }\n    }\n    $playEnd() {\n        if (this.$settings.endCallback != null) {\n            let f = this.$settings.endCallback;\n            let fObj = this.$settings.endCallbackContext;\n            this.$settings.endCallback = this.$settings.endCallbackContext = null;\n            this.$settings.endCallbackContext = null;\n            if (f)\n                f.call(fObj, this);\n        }\n    }\n    setFrame(frame) {\n        this.texture = frame == null ? null : frame.texture.image;\n        this.textureRect = frame.texture.rect;\n        this.sourceRect = frame.texture.trim;\n        let { x, y, width, height } = this.sourceRect;\n        this.cache(x, y, width, height);\n        // this._textureID = -1;\n    }\n    added(disp) {\n        if (this.$playing)\n            GTimer.inst.add(0, 0, this.update, this);\n    }\n    removed(disp) {\n        if (this.$playing)\n            GTimer.inst.remove(this.update, this);\n    }\n    destroy() {\n        GTimer.inst.remove(this.update, this);\n        this.off('added', this.added);\n        this.off('removed', this.removed);\n        super.destroy();\n    }\n}\n\nclass GMovieClip extends GObject {\n    constructor() {\n        super();\n    }\n    mapPivotWidth(scale) {\n        return scale * this.$sourceWidth;\n    }\n    mapPivotHeight(scale) {\n        return scale * this.$sourceHeight;\n    }\n    handleSizeChanged() {\n        if (this.$displayObject != null && this.$sourceWidth != 0 && this.$sourceHeight != 0)\n            this.$displayObject.set({\n                scaleX: (this.$width / this.$sourceWidth) * this.$scaleX,\n                scaleY: (this.$height / this.$sourceHeight) * this.$scaleY\n            });\n    }\n    handleScaleChanged() {\n        if (this.$displayObject != null) {\n            this.$displayObject.set({\n                scaleX: (this.$width / this.$sourceWidth) * this.$scaleX,\n                scaleY: (this.$height / this.$sourceHeight) * this.$scaleY\n            });\n        }\n    }\n    get touchable() {\n        return false;\n    }\n    set touchable(value) {\n        this.$touchable = false; //GMovieClip has no interaction\n    }\n    get color() {\n        return this.$movieClip.tint;\n    }\n    set color(value) {\n        this.$movieClip.tint = value;\n    }\n    createDisplayObject() {\n        this.$movieClip = new MovieClip(this);\n        this.setDisplayObject(this.$movieClip);\n    }\n    get playing() {\n        return this.$movieClip.playing;\n    }\n    set playing(value) {\n        if (this.$movieClip.playing != value) {\n            this.$movieClip.playing = value;\n            this.updateGear(5 /* Animation */);\n        }\n    }\n    get frame() {\n        return this.$movieClip.currentFrame;\n    }\n    set frame(value) {\n        if (this.$movieClip.currentFrame != value) {\n            this.$movieClip.currentFrame = value;\n            this.updateGear(5 /* Animation */);\n        }\n    }\n    /**\n       * Modify the playing settings for the current MovieClip object, there are two ways to call this method:\n       * 1) pass whole parameters:\n              startFrame: number;\n              endFrame: number;\n              repeatCount: number;\n              loopEndAt: number;\n              endCallback: (target?: MovieClip) => void;\n              endCallbackContext: any;\n       * 2) just pass 1 object which implements MovieClipSettings (recommended)\n       */\n    setPlaySettings(...args) {\n        this.$movieClip.setPlaySettings.apply(this.$movieClip, args);\n    }\n    constructFromResource() {\n        this.$sourceWidth = this.packageItem.width;\n        this.$sourceHeight = this.packageItem.height;\n        this.$initWidth = this.$sourceWidth;\n        this.$initHeight = this.$sourceHeight;\n        this.setSize(this.$sourceWidth, this.$sourceHeight);\n        this.packageItem.load();\n        this.$movieClip.interval = this.packageItem.interval;\n        this.$movieClip.swing = this.packageItem.swing;\n        this.$movieClip.repeatDelay = this.packageItem.repeatDelay;\n        this.$movieClip.frames = this.packageItem.frames;\n        this.$movieClip.boundsRect = new createjs.Rectangle(0, 0, this.$sourceWidth, this.$sourceHeight);\n    }\n    setupBeforeAdd(xml) {\n        super.setupBeforeAdd(xml);\n        let str;\n        str = xml.attributes.frame;\n        if (str)\n            this.$movieClip.currentFrame = parseInt(str);\n        str = xml.attributes.playing;\n        this.$movieClip.playing = str != 'false';\n        str = xml.attributes.color;\n        if (str) {\n            this.color = StringUtil.HEX2RGB(str);\n        }\n    }\n}\n\nclass DOMEventManager extends createjs.EventDispatcher {\n    constructor() {\n        super();\n        this.retEvent = {};\n        this.nullLowestDeltaTimeout = NaN;\n        /*******************keys*******************/\n        this.$pressedKeys = {};\n        this.$releasedKeys = {};\n        this.$downKeys = [];\n        //resize\n        window.addEventListener('resize', e => this.notifyResizeEvents(e), false);\n        //modifer keys\n        window.addEventListener('keydown', e => this.onWindowKeyDown(e), false);\n        window.addEventListener('keyup', e => this.onWindowKeyUp(e), false);\n        //mouse wheel\n        const toBind = 'onwheel' in document || document['documentMode'] >= 9\n            ? ['wheel']\n            : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'];\n        for (let i = toBind.length; i;) {\n            window.addEventListener(toBind[--i], e => this.onMouseWheel(e), false);\n        }\n    }\n    //resize\n    notifyResizeEvents(e) {\n        this.dispatchEvent('resize');\n    }\n    onMouseWheel(event) {\n        let orgEvent = event || window.event, delta = 0, deltaX = 0, deltaY = 0, absDelta = 0;\n        if ('detail' in orgEvent) {\n            deltaY = orgEvent.detail * -1;\n        }\n        if ('wheelDelta' in orgEvent) {\n            deltaY = orgEvent.wheelDelta;\n        }\n        if ('wheelDeltaY' in orgEvent) {\n            deltaY = orgEvent.wheelDeltaY;\n        }\n        if ('wheelDeltaX' in orgEvent) {\n            deltaX = orgEvent.wheelDeltaX * -1;\n        }\n        //FF DOMMouseScroll\n        if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {\n            deltaX = deltaY * -1;\n            deltaY = 0;\n        }\n        delta = deltaY === 0 ? deltaX : deltaY;\n        if ('deltaY' in orgEvent) {\n            deltaY = orgEvent.deltaY * -1;\n            delta = deltaY;\n        }\n        if ('deltaX' in orgEvent) {\n            deltaX = orgEvent.deltaX;\n            if (deltaY === 0) {\n                delta = deltaX * -1;\n            }\n        }\n        if (deltaY === 0 && deltaX === 0) {\n            return;\n        }\n        // Delta modes:\n        //   * deltaMode 0 is by pixels, nothing to do\n        //   * deltaMode 1 is by lines\n        //   * deltaMode 2 is by pages\n        if (orgEvent.deltaMode === 1) {\n            const lineHeight = 16; //fontSize - line-height;\n            delta *= lineHeight;\n            deltaY *= lineHeight;\n            deltaX *= lineHeight;\n        }\n        else if (orgEvent.deltaMode === 2) {\n            const pageHeight = 16; //dom.clientHeight = page-height\n            delta *= pageHeight;\n            deltaY *= pageHeight;\n            deltaX *= pageHeight;\n        }\n        absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));\n        if (!this.lowestDelta || absDelta < this.lowestDelta) {\n            this.lowestDelta = absDelta;\n            if (orgEvent.type === 'mousewheel' && absDelta % 120 === 0)\n                this.lowestDelta /= 40;\n        }\n        if (orgEvent.type === 'mousewheel' && absDelta % 120 === 0) {\n            delta /= 40;\n            deltaX /= 40;\n            deltaY /= 40;\n        }\n        delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / this.lowestDelta);\n        deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / this.lowestDelta);\n        deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / this.lowestDelta);\n        this.retEvent.delta = delta;\n        this.retEvent.deltaX = deltaX;\n        this.retEvent.deltaY = deltaY;\n        this.retEvent.deltaFactor = this.lowestDelta;\n        this.retEvent.deltaMode = 0;\n        if (this.nullLowestDeltaTimeout) {\n            clearTimeout(this.nullLowestDeltaTimeout);\n        }\n        this.nullLowestDeltaTimeout = window.setTimeout(() => this.nullLowestDelta(), 200);\n        let evt = new createjs.Event(\"__mouseWheel\" /* MOUSE_WHEEL */, true, false);\n        evt.data = { event: this.retEvent };\n        this.dispatchEvent(evt, this);\n    }\n    nullLowestDelta() {\n        this.lowestDelta = null;\n    }\n    isKeyDown(key) {\n        return this.$downKeys.indexOf(key) >= 0;\n    }\n    isKeyPressed(key) {\n        return !!this.$pressedKeys[key];\n    }\n    isKeyReleased(key) {\n        return !!this.$releasedKeys[key];\n    }\n    onWindowKeyDown(evt) {\n        let key = evt.which || evt.keyCode;\n        if (!this.isKeyDown(key)) {\n            this.$downKeys.push(key);\n            this.$pressedKeys[key] = true;\n            this.dispatchEvent('keyPressed', key);\n        }\n    }\n    onWindowKeyUp(evt) {\n        let key = evt.which || evt.keyCode;\n        if (this.isKeyDown(key)) {\n            this.$pressedKeys[key] = false;\n            this.$releasedKeys[key] = true;\n            let index = this.$downKeys.indexOf(key);\n            if (index >= 0)\n                this.$downKeys.splice(index, 1);\n            this.dispatchEvent('keyReleased', key);\n        }\n    }\n}\nDOMEventManager.inst = new DOMEventManager();\n\nclass HTMLInput {\n    constructor() {\n        /**@internal */\n        this.$requestToShow = false;\n        /**@internal */\n        this.$scaleX = 1;\n        /**@internal */\n        this.$scaleY = 1;\n    }\n    static get inst() {\n        if (!HTMLInput.$instance)\n            HTMLInput.$instance = new HTMLInput();\n        return HTMLInput.$instance;\n    }\n    initialize(container, view) {\n        this.$canvas = view;\n        let div;\n        if (!this.$delegateDiv) {\n            div = document.createElement('div');\n            this.$delegateDiv = div;\n            div.id = '__delegateDiv';\n            container.appendChild(div);\n            this.initDomPos(div);\n            this.$wrapper = document.createElement('div');\n            this.initDomPos(this.$wrapper);\n            this.$wrapper.style.width = '0px';\n            this.$wrapper.style.height = '0px';\n            this.$wrapper.style.left = '0px';\n            this.$wrapper.style.top = '-100px';\n            this.setTransform(this.$wrapper, '0% 0% 0px');\n            div.appendChild(this.$wrapper);\n            Decls$1.GRoot.inst.on(InteractiveEvents.Click, this.canvasClickHandler, this);\n            this.initInputElement(true); //input\n            this.initInputElement(false); //textarea\n        }\n    }\n    isInputOn() {\n        return this.$input != null;\n    }\n    canvasClickHandler(e) {\n        if (this.$requestToShow) {\n            this.$requestToShow = false;\n            this.$input.onClickHandler(e);\n            this.show();\n        }\n        else {\n            if (this.$curEle) {\n                this.clearInputElement();\n                this.$curEle.blur();\n                this.$curEle = null;\n            }\n        }\n    }\n    isInputShown() {\n        return this.$input != null;\n    }\n    isCurrentInput(input) {\n        return this.$input == input;\n    }\n    initDomPos(dom) {\n        dom.style.position = 'absolute';\n        dom.style.left = '0px';\n        dom.style.top = '0px';\n        dom.style.border = 'none';\n        dom.style.padding = '0';\n    }\n    setTransform(el, origin, transform) {\n        let style = el.style;\n        style.transformOrigin = style.webkitTransformOrigin = style.msTransformOrigin = style.mozTransformOrigin = style.oTransformOrigin = origin;\n        if (transform && transform.length > 0)\n            style.transform = style.webkitTransform = style.msTransform = style.mozTransform = style.oTransform = transform;\n    }\n    /**@internal */\n    updateSize(sx, sy) {\n        if (!this.$canvas)\n            return;\n        this.$scaleX = sx;\n        this.$scaleY = sy;\n        this.$delegateDiv.style.left = this.$canvas.style.left;\n        this.$delegateDiv.style.top = this.$canvas.style.top;\n        let cvsStyle = this.$canvas.style;\n        this.setTransform(this.$delegateDiv, '0% 0% 0px', cvsStyle.transform ||\n            cvsStyle.webkitTransform ||\n            cvsStyle.msTransform ||\n            cvsStyle.mozTransform ||\n            cvsStyle.oTransform);\n    }\n    initInputElement(multiline) {\n        let inputElement;\n        if (multiline) {\n            inputElement = document.createElement('textarea');\n            inputElement.style.resize = 'none';\n            this.$multiLine = inputElement;\n            inputElement.id = 'stageTextAreaEle';\n        }\n        else {\n            inputElement = document.createElement('input');\n            this.$singleLine = inputElement;\n            inputElement.type = 'text';\n            inputElement.id = 'stageInputEle';\n        }\n        this.$wrapper.appendChild(inputElement);\n        inputElement.setAttribute('tabindex', '-1');\n        inputElement.style.width = '1px';\n        inputElement.style.height = '12px';\n        this.initDomPos(inputElement);\n        let style = inputElement.style;\n        style.outline = 'thin';\n        style.background = 'none';\n        style.overflow = 'hidden';\n        style.wordBreak = 'break-all';\n        style.opacity = 0;\n        inputElement.oninput = e => {\n            if (this.$input)\n                this.$input.onInputHandler();\n        };\n    }\n    show() {\n        GTimer.inst.callLater(() => {\n            this.$curEle.style.opacity = '1';\n        }, this);\n    }\n    disconnect(ele) {\n        if (this.$input == null || this.$input == ele) {\n            this.clearInputElement();\n            if (this.$curEle)\n                this.$curEle.blur();\n        }\n    }\n    clearAttributes(obj) {\n        if (this.$curEle) {\n            for (let key in obj) {\n                this.$curEle.removeAttribute(key);\n            }\n        }\n    }\n    clearInputElement() {\n        if (this.$curEle) {\n            this.$curEle.value = '';\n            this.$curEle.onblur = null;\n            let style = this.$curEle.style;\n            style.width = '1px';\n            style.height = '12px';\n            style.left = '0px';\n            style.top = '0px';\n            style.opacity = '0';\n            let el2;\n            if (this.$singleLine == this.$curEle)\n                el2 = this.$multiLine;\n            else\n                el2 = this.$singleLine;\n            el2.style.display = 'block';\n            this.$wrapper.style.left = '0px';\n            this.$wrapper.style.top = '-100px';\n            this.$wrapper.style.height = '0px';\n            this.$wrapper.style.width = '0px';\n        }\n        if (this.$input) {\n            this.$input.onDisconnect();\n            this.$input = null;\n            HTMLInput.isTyping = false;\n        }\n    }\n    requestInput(ele) {\n        this.clearInputElement();\n        this.$input = ele;\n        HTMLInput.isTyping = true;\n        let el2;\n        if (this.$input.textField.multipleLine) {\n            this.$curEle = this.$multiLine;\n            el2 = this.$singleLine;\n        }\n        else {\n            this.$curEle = this.$singleLine;\n            el2 = this.$multiLine;\n        }\n        el2.style.display = 'none';\n        return this.$curEle;\n    }\n}\nHTMLInput.isTyping = false;\n\nclass DefaultUIStageOptions {\n    constructor() {\n        this.scaleMode = \"showAll\" /* SHOW_ALL */;\n        this.orientation = \"auto\" /* AUTO */;\n        this.resolution = 1;\n        this.designWidth = 800;\n        this.designHeight = 600;\n        this.alignV = 4 /* MIDDLE */;\n        this.alignH = 1 /* CENTER */;\n        this.fallbackWidth = 0;\n        this.fallbackHeight = 0;\n    }\n}\nclass DefaultBoudingRectCalculator {\n    getRect(view, fallbackWidth, fallbackHeight) {\n        let p = view.parentElement;\n        if (!p)\n            //this should be impossible situation unless the user forget to append the view into the DOM.\n            throw new Error(\"Your view of PIXI are still in memory but not appended to DOM yet? it's necessary that there is a parent element to wrap your view up.\");\n        let rect = p.getBoundingClientRect();\n        let ret = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n        if (!rect || rect.width <= 0 || rect.height <= 0) {\n            console.warn('It seems that you did not set a explicit size for the parent element of your view, now fall back to window size instead.');\n            ret.width = window.innerWidth;\n            ret.height = window.innerHeight;\n            ret.x = 0;\n            ret.y = 0;\n        }\n        else {\n            ret.x = rect.left;\n            ret.y = rect.top;\n            ret.width = rect.width;\n            ret.height = rect.height;\n        }\n        //consider the worst situation: window does not have size!!\n        if (ret.width <= 0 || ret.height <= 0) {\n            console.warn('fetch container size to initialize PIXI in all ways have failed, now use default size (fallbackWidth / fallbackHeight) specified in the options instead.');\n            ret.width = fallbackWidth;\n            ret.height = fallbackHeight;\n        }\n        return ret;\n    }\n}\nclass UIStage extends createjs.EventDispatcher {\n    constructor(app, stageOptions) {\n        super();\n        this.$width = 0;\n        this.$height = 0;\n        this.$scaleX = 1;\n        this.$scaleY = 1;\n        this.$canvasMatrix = new createjs.Matrix2D();\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.$sizeCalcer = new DefaultBoudingRectCalculator();\n        UIStageInst.push(this);\n        this.$appContext = app;\n        let opt;\n        if (stageOptions instanceof DefaultUIStageOptions)\n            opt = stageOptions;\n        else {\n            opt = new DefaultUIStageOptions();\n            if (stageOptions != null) {\n                for (let i in stageOptions) {\n                    opt[i] = stageOptions[i];\n                }\n            }\n        }\n        if (!opt.designWidth || !opt.designHeight)\n            throw new Error(\"Invalid designWidth / designHeight in the parameter 'stageOptions'.\");\n        this.$options = opt;\n        this.$appContext.canvas.style.position = 'absolute';\n        let container = this.$appContext.canvas.parentElement;\n        let style = container.style;\n        //if parent is not a DIV box, make one\n        if (container.tagName != 'DIV') {\n            container = document.createElement('DIV');\n            style.position = 'relative';\n            style.left = style.top = '0px';\n            style.width = style.height = '100%'; //and set default full-screen\n            style.overflow = 'hidden';\n            // this.$appContext.view.parentElement.appendChild(container); //todo\n            // container.appendChild(this.$appContext.view); //todo\n        }\n        let containerPosition;\n        if (document.defaultView && document.defaultView.getComputedStyle)\n            containerPosition = document.defaultView.getComputedStyle(container).position;\n        else\n            containerPosition = style.position;\n        if (containerPosition == '' || containerPosition == 'static') {\n            containerPosition = 'relative';\n            container.style.position = containerPosition;\n        }\n        HTMLInput.inst.initialize(container, this.$appContext.canvas);\n        this.updateScreenSize();\n    }\n    get orientation() {\n        return this.$options.orientation;\n    }\n    get stageWidth() {\n        return this.$width;\n    }\n    get stageHeight() {\n        return this.$height;\n    }\n    get applicationContext() {\n        return this.$appContext;\n    }\n    get nativeStage() {\n        return this.$appContext;\n    }\n    get resolution() {\n        return this.$options.resolution;\n    }\n    set resolution(v) {\n        this.$options.resolution = v;\n        this.updateScreenSize();\n    }\n    get scaleX() {\n        return this.$scaleX;\n    }\n    get scaleY() {\n        return this.$scaleY;\n    }\n    get designWidth() {\n        return this.$options.designWidth;\n    }\n    get designHeight() {\n        return this.$options.designHeight;\n    }\n    setDesignSize(width, height) {\n        let option = this.$options;\n        option.designWidth = width;\n        option.designHeight = height;\n        this.updateScreenSize();\n    }\n    calculateStageSize(scaleMode, screenWidth, screenHeight, contentWidth, contentHeight) {\n        let displayWidth = screenWidth;\n        let displayHeight = screenHeight;\n        let stageWidth = contentWidth;\n        let stageHeight = contentHeight;\n        let scaleX = screenWidth / stageWidth || 0;\n        let scaleY = screenHeight / stageHeight || 0;\n        switch (scaleMode) {\n            case \"exactFit\" /* EXACT_FIT */:\n                break;\n            case \"fixedHeight\" /* FIXED_HEIGHT */:\n                stageWidth = Math.round(screenWidth / scaleY);\n                break;\n            case \"fixedWidth\" /* FIXED_WIDTH */:\n                stageHeight = Math.round(screenHeight / scaleX);\n                break;\n            case \"noBorder\" /* NO_BORDER */:\n                if (scaleX > scaleY)\n                    displayHeight = Math.round(stageHeight * scaleX);\n                else\n                    displayWidth = Math.round(stageWidth * scaleY);\n                break;\n            case \"showAll\" /* SHOW_ALL */:\n                if (scaleX > scaleY)\n                    displayWidth = Math.round(stageWidth * scaleY);\n                else\n                    displayHeight = Math.round(stageHeight * scaleX);\n                break;\n            case \"fixedAuto\" /* FIXED_AUTO */:\n                if (displayWidth / displayHeight < stageWidth / stageHeight) {\n                    scaleY = scaleX;\n                    stageHeight = Math.round(screenHeight / scaleX);\n                }\n                else {\n                    scaleX = scaleY;\n                    stageWidth = Math.round(screenWidth / scaleY);\n                }\n                break;\n            default:\n                stageWidth = screenWidth;\n                stageHeight = screenHeight;\n                break;\n        }\n        return {\n            stageWidth: stageWidth,\n            stageHeight: stageHeight,\n            displayWidth: displayWidth,\n            displayHeight: displayHeight\n        };\n    }\n    /**@internal */\n    updateScreenSize() {\n        if (HTMLInput.isTyping)\n            return; //todo\n        let canvas = this.$appContext.canvas;\n        let canvasStyle = canvas.style;\n        // todo\n        let rect = this.$sizeCalcer.getRect(canvas, this.$options.fallbackWidth, this.$options.fallbackHeight);\n        let shouldRotate = false;\n        let orientation = this.$options.orientation;\n        if (orientation != \"auto\" /* AUTO */) {\n            shouldRotate =\n                (orientation != \"portrait\" /* PORTRAIT */ && rect.height > rect.width) ||\n                    (orientation == \"portrait\" /* PORTRAIT */ && rect.width > rect.height);\n        }\n        let screenWidth = shouldRotate ? rect.height : rect.width;\n        let screenHeight = shouldRotate ? rect.width : rect.height;\n        let stageSize = this.calculateStageSize(this.$options.scaleMode, screenWidth, screenHeight, this.$options.designWidth, this.$options.designHeight);\n        let stageWidth = stageSize.stageWidth;\n        let stageHeight = stageSize.stageHeight;\n        let displayWidth = stageSize.displayWidth;\n        let displayHeight = stageSize.displayHeight;\n        if (canvas.width !== stageWidth)\n            canvas.width = stageWidth;\n        if (canvas.height !== stageHeight)\n            canvas.height = stageHeight;\n        canvasStyle.transformOrigin = canvasStyle.webkitTransformOrigin = canvasStyle.msTransformOrigin = canvasStyle.mozTransformOrigin = canvasStyle.oTransformOrigin =\n            '0px 0px 0px';\n        canvasStyle.width = displayWidth + 'px';\n        canvasStyle.height = displayHeight + 'px';\n        let mat = this.$canvasMatrix.identity();\n        let dispWidth = shouldRotate ? displayHeight : displayWidth;\n        let dispHeight = shouldRotate ? displayWidth : displayHeight;\n        let offx, offy;\n        if (this.$options.alignH == 0 /* LEFT */)\n            offx = 0;\n        else if (this.$options.alignH == 2 /* RIGHT */)\n            offx = rect.width - dispWidth;\n        else\n            offx = (rect.width - dispWidth) * 0.5;\n        if (this.$options.alignV == 3 /* TOP */)\n            offy = 0;\n        else if (this.$options.alignV == 5 /* BOTTOM */)\n            offy = rect.height - dispHeight;\n        else\n            offy = (rect.height - dispHeight) * 0.5;\n        if (shouldRotate) {\n            if (this.$options.orientation == \"landscape\" /* LANDSCAPE */) {\n                mat.rotate(Math.PI / 2);\n                mat.translate(screenHeight - offx, offy);\n            }\n            else {\n                mat.rotate(-Math.PI / 2);\n                mat.translate(offx, screenWidth - offy);\n            }\n        }\n        else\n            mat.translate(offx, offy);\n        if (shouldRotate) {\n            mat.tx += this.offsetY;\n            mat.ty += this.offsetX;\n        }\n        else {\n            mat.tx += this.offsetX;\n            mat.ty += this.offsetY;\n        }\n        (mat.a = this.formatData(mat.a)),\n            (mat.d = this.formatData(mat.d)),\n            (mat.tx = this.formatData(mat.tx)),\n            (mat.ty = this.formatData(mat.ty));\n        canvasStyle.transformOrigin = canvasStyle.webkitTransformOrigin = canvasStyle.msTransformOrigin = canvasStyle.mozTransformOrigin = canvasStyle.oTransformOrigin =\n            '0px 0px 0px';\n        canvasStyle.transform = canvasStyle.webkitTransform = canvasStyle.msTransform = canvasStyle.mozTransform = canvasStyle.oTransform = `matrix(${mat.a},${mat.b},${mat.c},${mat.d},${mat.tx},${mat.ty})`;\n        this.$width = stageWidth;\n        this.$height = stageHeight;\n        this.$scaleX = stageWidth / displayWidth;\n        this.$scaleY = stageHeight / displayHeight;\n        this.$appContext.set({ width: stageWidth, height: stageHeight });\n        HTMLInput.inst.updateSize(displayWidth / stageWidth, displayHeight / stageHeight);\n        let evt = new createjs.Event(\"__sizeChanged\" /* SIZE_CHANGED */, true, false);\n        this.dispatchEvent(evt, this);\n    }\n    formatData(value) {\n        if (Math.abs(value) < 0.000001)\n            return 0;\n        if (Math.abs(1 - value) < 0.001)\n            return value > 0 ? 1 : -1;\n        return value;\n    }\n    dispose() {\n        let i = UIStageInst.length;\n        while (i-- >= 0) {\n            if (UIStageInst[i] === this)\n                UIStageInst.splice(i, 1);\n        }\n    }\n}\nlet UIStageInst = [];\nlet resizeCheckTimer = NaN;\nfunction resizeHandler() {\n    UIStageInst.forEach(stage => {\n        stage.updateScreenSize();\n    });\n}\nDOMEventManager.inst.on('resize', function () {\n    clearTimeout(resizeCheckTimer);\n    resizeCheckTimer = window.setTimeout(resizeHandler, 300);\n});\n\nclass Action {\n    execute(controller, prevPage, curPage) {\n        if ((!this.fromPage || this.fromPage.length == 0 || this.fromPage.indexOf(prevPage) != -1)\n            && (!this.toPage || this.toPage.length == 0 || this.toPage.indexOf(curPage) != -1))\n            this.enter(controller);\n        else\n            this.leave(controller);\n    }\n    enter(controller) {\n    }\n    leave(controller) {\n    }\n    setup(xml) {\n        let str;\n        str = xml.attributes.fromPage;\n        if (str)\n            this.fromPage = str.split(\",\");\n        str = xml.attributes.toPage;\n        if (str)\n            this.toPage = str.split(\",\");\n    }\n}\n\nclass ChangePageAction extends Action {\n    enter(controller) {\n        if (!this.controllerName)\n            return;\n        let gcom;\n        if (this.objectId)\n            gcom = controller.parent.getChildById(this.objectId);\n        else\n            gcom = controller.parent;\n        if (gcom) {\n            let cc = gcom.getController(this.controllerName);\n            if (cc && cc != controller && !cc.$updating)\n                cc.selectedPageId = this.targetPage;\n        }\n    }\n    setup(xml) {\n        super.setup(xml);\n        this.objectId = xml.attributes.objectId;\n        this.controllerName = xml.attributes.controller;\n        this.targetPage = xml.attributes.targetPage;\n    }\n}\n\nclass PlayTransitionAction extends Action {\n    constructor() {\n        super(...arguments);\n        this.repeat = 1;\n        this.delay = 0;\n        this.stopOnExit = false;\n    }\n    enter(controller) {\n        let trans = controller.parent.getTransition(this.transitionName);\n        if (trans) {\n            if (this.$currentTransition && this.$currentTransition.playing)\n                trans.changeRepeat(this.repeat);\n            else\n                trans.play({\n                    times: this.repeat,\n                    delay: this.delay\n                });\n            this.$currentTransition = trans;\n        }\n    }\n    leave() {\n        if (this.stopOnExit && this.$currentTransition) {\n            this.$currentTransition.stop();\n            this.$currentTransition = null;\n        }\n    }\n    /**@internal */\n    setup(xml) {\n        super.setup(xml);\n        this.transitionName = xml.attributes.transition;\n        let str;\n        str = xml.attributes.repeat;\n        if (str)\n            this.repeat = parseInt(str);\n        str = xml.attributes.delay;\n        if (str)\n            this.delay = parseFloat(str);\n        this.stopOnExit = xml.attributes.stopOnExit == \"true\";\n    }\n}\n\nclass Controller extends createjs.EventDispatcher {\n    constructor() {\n        super();\n        this.$selectedIndex = 0;\n        this.$previousIndex = 0;\n        this.$pageIds = [];\n        this.$pageNames = [];\n        this.$selectedIndex = -1;\n        this.$previousIndex = -1;\n    }\n    get name() {\n        return this.$name;\n    }\n    set name(value) {\n        this.$name = value;\n    }\n    get parent() {\n        return this.$parent;\n    }\n    get selectedIndex() {\n        return this.$selectedIndex;\n    }\n    set selectedIndex(value) {\n        if (this.$selectedIndex != value) {\n            if (value > this.$pageIds.length - 1)\n                throw new Error(`index out of range: ${value}`);\n            this.$updating = true;\n            this.$previousIndex = this.$selectedIndex;\n            this.$selectedIndex = value;\n            this.$parent.applyController(this);\n            let event = new createjs.Event(\"__stateChanged\" /* CHANGED */, true, false);\n            this.dispatchEvent(event, this);\n            this.$updating = false;\n        }\n    }\n    //same effect as selectedIndex but without event emitted\n    setSelectedIndex(value = 0) {\n        if (this.$selectedIndex != value) {\n            if (value > this.$pageIds.length - 1)\n                throw new Error(`index out of range: ${value}`);\n            this.$updating = true;\n            this.$previousIndex = this.$selectedIndex;\n            this.$selectedIndex = value;\n            this.$parent.applyController(this);\n            this.$updating = false;\n        }\n    }\n    get previsousIndex() {\n        return this.$previousIndex;\n    }\n    get selectedPage() {\n        if (this.$selectedIndex == -1)\n            return null;\n        else\n            return this.$pageNames[this.$selectedIndex];\n    }\n    set selectedPage(val) {\n        this.selectedIndex = Math.max(0, this.$pageNames.indexOf(val));\n    }\n    setSelectedPage(value) {\n        this.setSelectedIndex(Math.max(0, this.$pageNames.indexOf(value)));\n    }\n    get previousPage() {\n        if (this.$previousIndex == -1)\n            return null;\n        else\n            return this.$pageNames[this.$previousIndex];\n    }\n    get pageCount() {\n        return this.$pageIds.length;\n    }\n    getPageName(index = 0) {\n        return this.$pageNames[index];\n    }\n    addPage(name = '') {\n        this.addPageAt(name, this.$pageIds.length);\n    }\n    addPageAt(name, index = 0) {\n        let nid = `${Controller.$nextPageId++}`;\n        if (index == this.$pageIds.length) {\n            this.$pageIds.push(nid);\n            this.$pageNames.push(name);\n        }\n        else {\n            this.$pageIds.splice(index, 0, nid);\n            this.$pageNames.splice(index, 0, name);\n        }\n    }\n    removePage(name) {\n        let i = this.$pageNames.indexOf(name);\n        if (i != -1) {\n            this.$pageIds.splice(i, 1);\n            this.$pageNames.splice(i, 1);\n            if (this.$selectedIndex >= this.$pageIds.length)\n                this.selectedIndex = this.$selectedIndex - 1;\n            else\n                this.$parent.applyController(this);\n        }\n    }\n    removePageAt(index = 0) {\n        this.$pageIds.splice(index, 1);\n        this.$pageNames.splice(index, 1);\n        if (this.$selectedIndex >= this.$pageIds.length)\n            this.selectedIndex = this.$selectedIndex - 1;\n        else\n            this.$parent.applyController(this);\n    }\n    clearPages() {\n        this.$pageIds.length = 0;\n        this.$pageNames.length = 0;\n        if (this.$selectedIndex != -1)\n            this.selectedIndex = -1;\n        else\n            this.$parent.applyController(this);\n    }\n    hasPage(aName) {\n        return this.$pageNames.indexOf(aName) >= 0;\n    }\n    getPageIndexById(aId) {\n        return this.$pageIds.indexOf(aId);\n    }\n    getPageIdByName(aName) {\n        let i = this.$pageNames.indexOf(aName);\n        if (i != -1)\n            return this.$pageIds[i];\n        else\n            return null;\n    }\n    getPageNameById(aId) {\n        let i = this.$pageIds.indexOf(aId);\n        if (i != -1)\n            return this.$pageNames[i];\n        else\n            return null;\n    }\n    getPageId(index = 0) {\n        return this.$pageIds[index];\n    }\n    get selectedPageId() {\n        if (this.$selectedIndex == -1)\n            return null;\n        else\n            return this.$pageIds[this.$selectedIndex];\n    }\n    set selectedPageId(val) {\n        this.selectedIndex = this.$pageIds.indexOf(val);\n    }\n    set oppositePageId(val) {\n        let i = this.$pageIds.indexOf(val);\n        if (i > 0)\n            this.selectedIndex = 0;\n        else if (this.$pageIds.length > 1)\n            this.selectedIndex = 1;\n    }\n    get previousPageId() {\n        if (this.$previousIndex == -1)\n            return null;\n        else\n            return this.$pageIds[this.$previousIndex];\n    }\n    executeActions() {\n        if (this.$actions && this.$actions.length > 0) {\n            this.$actions.forEach(a => {\n                a.execute(this, this.previousPageId, this.selectedPageId);\n            });\n        }\n    }\n    createAction(type) {\n        switch (type) {\n            case 'play_transition':\n                return new PlayTransitionAction();\n            case 'change_page':\n                return new ChangePageAction();\n        }\n        return null;\n    }\n    setup(xml) {\n        this.$name = xml.attributes.name;\n        this.$autoRadioGroupDepth = xml.attributes.autoRadioGroupDepth == 'true';\n        let str = xml.attributes.pages;\n        if (str) {\n            let arr = str.split(',');\n            let cnt = arr.length;\n            for (let i = 0; i < cnt; i += 2) {\n                this.$pageIds.push(arr[i]);\n                this.$pageNames.push(arr[i + 1]);\n            }\n        }\n        let col = xml.children;\n        if (col.length > 0) {\n            this.$actions = this.$actions || [];\n            col.forEach(cxml => {\n                let action = this.createAction(cxml.attributes.type);\n                action.setup(cxml);\n                this.$actions.push(action);\n            });\n        }\n        str = xml.attributes.transitions;\n        if (str) {\n            this.$actions = this.$actions || [];\n            let k, e;\n            str.split(',').forEach(str => {\n                if (str && str.length) {\n                    let pt = new PlayTransitionAction();\n                    k = str.indexOf('=');\n                    pt.transitionName = str.substr(k + 1);\n                    str = str.substring(0, k);\n                    k = str.indexOf('-');\n                    e = parseInt(str.substring(k + 1));\n                    if (e < this.$pageIds.length)\n                        pt.toPage = [this.$pageIds[e]];\n                    str = str.substring(0, k);\n                    if (str != '*') {\n                        e = parseInt(str);\n                        if (e < this.$pageIds.length)\n                            pt.fromPage = [this.$pageIds[e]];\n                    }\n                    pt.stopOnExit = true;\n                    this.$actions.push(pt);\n                }\n            });\n        }\n        if (this.$parent && this.$pageIds.length > 0)\n            this.$selectedIndex = 0;\n        else\n            this.$selectedIndex = -1;\n    }\n}\nController.$nextPageId = 0;\n\nclass NumberUtil {\n    static clamp(value, min, max) {\n        if (value < min)\n            value = min;\n        else if (value > max)\n            value = max;\n        return value;\n    }\n    static clamp01(value) {\n        if (value > 1)\n            value = 1;\n        else if (value < 0)\n            value = 0;\n        return value;\n    }\n    static isNumber(n) {\n        if (typeof n != 'number')\n            return false;\n        if (isNaN(n))\n            return false;\n        return true;\n    }\n    static sign(x) {\n        x = Number(x);\n        if (x === 0 || isNaN(x))\n            return x;\n        return x > 0 ? 1 : -1;\n    }\n    static angleToRadian(n) {\n        return n * NumberUtil.RADIAN;\n    }\n    static lerp(s, e, p) {\n        return s + p * (e - s);\n    }\n}\nNumberUtil.RADIAN = Math.PI / 180;\n\nconst fairygui_module_isMobile = isMobile(window.navigator);\n\nclass ScrollPane extends createjs.EventDispatcher {\n    constructor(owner, scrollType, scrollBarMargin, scrollBarDisplay, flags, vtScrollBarRes, hzScrollBarRes, headerRes, footerRes) {\n        super();\n        this.$isDragging = false;\n        this.$owner = owner;\n        this.$maskContainer = new UIContainer(null);\n        this.$owner.$rootContainer.addChild(this.$maskContainer);\n        this.$container = this.$owner.$container;\n        this.$container.x = 0;\n        this.$container.y = 0;\n        this.$maskContainer.addChild(this.$container);\n        this.$scrollBarMargin = scrollBarMargin;\n        this.$scrollType = scrollType;\n        this.$scrollSpeed = UIConfig.defaultScrollSpeed;\n        this.$mouseWheelSpeed = this.$scrollSpeed * 2;\n        this.$decelerationRate = UIConfig.defaultScrollDecelerationRate;\n        this.$displayOnLeft = (flags & 1 /* DisplayOnLeft */) != 0;\n        this.$snapToItem = (flags & 2 /* SnapToItem */) != 0;\n        this.$displayOnDemand = (flags & 4 /* DisplayOnDemand */) != 0;\n        this.$pageMode = (flags & 8 /* PageMode */) != 0;\n        if (flags & 16 /* TouchEffect */)\n            this.$touchEffect = true;\n        else if (flags & 32 /* DisableTouchEffect */)\n            this.$touchEffect = false;\n        else\n            this.$touchEffect = UIConfig.defaultScrollTouchEffect;\n        if (flags & 64 /* BounceEffect */)\n            this.$bouncebackEffect = true;\n        else if (flags & 128 /* DisableBounceEffect */)\n            this.$bouncebackEffect = false;\n        else\n            this.$bouncebackEffect = UIConfig.defaultScrollBounceEffect;\n        this.$inertiaDisabled = (flags & 256 /* DisableInertia */) != 0;\n        if ((flags & 512 /* DisableScissorRect */) == 0)\n            this.$maskContainer.scrollRect = new createjs.Rectangle();\n        this.$scrollBarVisible = true;\n        this.$mouseWheelEnabled = true;\n        this.$xPos = 0;\n        this.$yPos = 0;\n        this.$aniFlag = 0;\n        this.$footerLockedSize = 0;\n        this.$headerLockedSize = 0;\n        if (scrollBarDisplay == 0 /* Default */)\n            scrollBarDisplay = UIConfig.defaultScrollBarDisplay;\n        this.$viewSize = new createjs.Point();\n        this.$contentSize = new createjs.Point();\n        this.$pageSize = new createjs.Point(1, 1);\n        this.$overlapSize = new createjs.Point();\n        this.$tweening = 0;\n        this.$tweenTime = new createjs.Point();\n        this.$tweenStart = new createjs.Point();\n        this.$tweenDuration = new createjs.Point();\n        this.$tweenChange = new createjs.Point();\n        this.$velocity = new createjs.Point();\n        this.$containerPos = new createjs.Point();\n        this.$beginTouchPos = new createjs.Point();\n        this.$lastTouchPos = new createjs.Point();\n        this.$lastTouchGlobalPos = new createjs.Point();\n        let res;\n        if (scrollBarDisplay != 3 /* Hidden */) {\n            if (this.$scrollType == 2 /* Both */ || this.$scrollType == 1 /* Vertical */) {\n                const res = vtScrollBarRes ? vtScrollBarRes : UIConfig.verticalScrollBar;\n                if (res) {\n                    this.$vtScrollBar = UIPackage.createObjectFromURL(res);\n                    if (!this.$vtScrollBar)\n                        throw new Error(`Cannot create scrollbar from ${res}`);\n                    this.$vtScrollBar.setScrollPane(this, true);\n                    this.$owner.$rootContainer.addChild(this.$vtScrollBar.displayObject);\n                }\n            }\n            if (this.$scrollType == 2 /* Both */ || this.$scrollType == 0 /* Horizontal */) {\n                res = hzScrollBarRes ? hzScrollBarRes : UIConfig.horizontalScrollBar;\n                if (res) {\n                    this.$hzScrollBar = UIPackage.createObjectFromURL(res);\n                    if (!this.$hzScrollBar)\n                        throw new Error(`Cannot create scrollbar from ${res}`);\n                    this.$hzScrollBar.setScrollPane(this, false);\n                    this.$owner.$rootContainer.addChild(this.$hzScrollBar.displayObject);\n                }\n            }\n            this.$scrollBarDisplayAuto = scrollBarDisplay == 2 /* Auto */;\n            if (this.$scrollBarDisplayAuto) {\n                this.$scrollBarVisible = false;\n                if (this.$vtScrollBar)\n                    this.$vtScrollBar.displayObject.visible = false;\n                if (this.$hzScrollBar)\n                    this.$hzScrollBar.displayObject.visible = false;\n            }\n        }\n        else\n            this.$mouseWheelEnabled = false;\n        if (headerRes) {\n            this.$header = UIPackage.createObjectFromURL(headerRes);\n            if (this.$header == null)\n                throw new Error(`Cannot create scrollPane.header from ${res}`);\n        }\n        if (footerRes) {\n            this.$footer = UIPackage.createObjectFromURL(footerRes);\n            if (this.$footer == null)\n                throw new Error(`Cannot create scrollPane.footer from ${res}`);\n        }\n        if (this.$header != null || this.$footer != null)\n            this.$refreshBarAxis =\n                this.$scrollType == 2 /* Both */ || this.$scrollType == 1 /* Vertical */ ? 'y' : 'x';\n        this.setSize(owner.width, owner.height);\n        this.$owner.on(InteractiveEvents.Over, this.$rollOver, this);\n        this.$owner.on(InteractiveEvents.Out, this.$rollOut, this);\n        this.$owner.on(InteractiveEvents.Down, this.$mouseDown, this);\n        this.$owner.on(\"__mouseWheel\" /* MOUSE_WHEEL */, this.$mouseWheel, this);\n    }\n    get owner() {\n        return this.$owner;\n    }\n    dispose() {\n        if (this.$tweening != 0)\n            GTimer.inst.remove(this.tweenUpdate, this);\n        this.$pageController = null;\n        if (this.$hzScrollBar != null)\n            this.$hzScrollBar.dispose();\n        if (this.$vtScrollBar != null)\n            this.$vtScrollBar.dispose();\n        if (this.$header != null)\n            this.$header.dispose();\n        if (this.$footer != null)\n            this.$footer.dispose();\n        Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Move, this.$mouseMoveEvent);\n        Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$mouseUpEvent);\n        Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Click, this.$clickEvent);\n        this.$owner.off(InteractiveEvents.Over, this.$rollOver);\n        this.$owner.off(InteractiveEvents.Out, this.$rollOut);\n        this.$owner.off(InteractiveEvents.Down, this.$mouseDown);\n        this.$owner.off(\"__mouseWheel\" /* MOUSE_WHEEL */, this.$mouseWheel);\n    }\n    get horzScrollBar() {\n        return this.$hzScrollBar;\n    }\n    get vertScrollBar() {\n        return this.$vtScrollBar;\n    }\n    get header() {\n        return this.$header;\n    }\n    get footer() {\n        return this.$footer;\n    }\n    get bouncebackEffect() {\n        return this.$bouncebackEffect;\n    }\n    set bouncebackEffect(sc) {\n        this.$bouncebackEffect = sc;\n    }\n    get touchEffect() {\n        return this.$touchEffect;\n    }\n    set touchEffect(sc) {\n        this.$touchEffect = sc;\n    }\n    set scrollSpeed(val) {\n        this.$scrollSpeed = val;\n        if (this.$scrollSpeed == 0)\n            this.$scrollSpeed = UIConfig.defaultScrollSpeed;\n        this.$mouseWheelSpeed = this.$scrollSpeed * 2;\n    }\n    get scrollSpeed() {\n        return this.$scrollSpeed;\n    }\n    get snapToItem() {\n        return this.$snapToItem;\n    }\n    set snapToItem(value) {\n        this.$snapToItem = value;\n    }\n    get mouseWheelEnabled() {\n        return this.$mouseWheelEnabled;\n    }\n    set mouseWheelEnabled(value) {\n        this.$mouseWheelEnabled = value;\n    }\n    get decelerationRate() {\n        return this.$decelerationRate;\n    }\n    set decelerationRate(value) {\n        this.$decelerationRate = value;\n    }\n    get percX() {\n        return this.$overlapSize.x == 0 ? 0 : this.$xPos / this.$overlapSize.x;\n    }\n    set percX(value) {\n        this.setPercX(value, false);\n    }\n    setPercX(value, ani = false) {\n        this.$owner.ensureBoundsCorrect();\n        this.setPosX(this.$overlapSize.x * NumberUtil.clamp01(value), ani);\n    }\n    get percY() {\n        return this.$overlapSize.y == 0 ? 0 : this.$yPos / this.$overlapSize.y;\n    }\n    set percY(value) {\n        this.setPercY(value, false);\n    }\n    setPercY(value, ani = false) {\n        this.$owner.ensureBoundsCorrect();\n        this.setPosY(this.$overlapSize.y * NumberUtil.clamp01(value), ani);\n    }\n    get posX() {\n        return this.$xPos;\n    }\n    set posX(value) {\n        this.setPosX(value, false);\n    }\n    setPosX(value, ani = false) {\n        this.$owner.ensureBoundsCorrect();\n        if (this.$loop == 1)\n            value = this.loopCheckingNewPos(value, 'x');\n        value = NumberUtil.clamp(value, 0, this.$overlapSize.x);\n        if (value != this.$xPos) {\n            this.$xPos = value;\n            this.posChanged(ani);\n        }\n    }\n    get posY() {\n        return this.$yPos;\n    }\n    set posY(value) {\n        this.setPosY(value, false);\n    }\n    setPosY(value, ani = false) {\n        this.$owner.ensureBoundsCorrect();\n        if (this.$loop == 1)\n            value = this.loopCheckingNewPos(value, 'y');\n        value = NumberUtil.clamp(value, 0, this.$overlapSize.y);\n        if (value != this.$yPos) {\n            this.$yPos = value;\n            this.posChanged(ani);\n        }\n    }\n    get contentWidth() {\n        return this.$contentSize.x;\n    }\n    get contentHeight() {\n        return this.$contentSize.y;\n    }\n    get viewWidth() {\n        return this.$viewSize.x;\n    }\n    set viewWidth(value) {\n        value = value + this.$owner.margin.left + this.$owner.margin.right;\n        if (this.$vtScrollBar != null)\n            value += this.$vtScrollBar.width;\n        this.$owner.width = value;\n    }\n    get viewHeight() {\n        return this.$viewSize.y;\n    }\n    set viewHeight(value) {\n        value = value + this.$owner.margin.top + this.$owner.margin.bottom;\n        if (this.$hzScrollBar != null)\n            value += this.$hzScrollBar.height;\n        this.$owner.height = value;\n    }\n    get currentPageX() {\n        if (!this.$pageMode)\n            return 0;\n        var page = Math.floor(this.$xPos / this.$pageSize.x);\n        if (this.$xPos - page * this.$pageSize.x > this.$pageSize.x * 0.5)\n            page++;\n        return page;\n    }\n    set currentPageX(value) {\n        if (this.$pageMode && this.$overlapSize.x > 0)\n            this.setPosX(value * this.$pageSize.x, false);\n    }\n    get currentPageY() {\n        if (!this.$pageMode)\n            return 0;\n        let page = Math.floor(this.$yPos / this.$pageSize.y);\n        if (this.$yPos - page * this.$pageSize.y > this.$pageSize.y * 0.5)\n            page++;\n        return page;\n    }\n    set currentPageY(value) {\n        if (this.$pageMode && this.$overlapSize.y > 0)\n            this.setPosY(value * this.$pageSize.y, false);\n    }\n    get isBottomMost() {\n        return this.$yPos == this.$overlapSize.y || this.$overlapSize.y == 0;\n    }\n    get isRightMost() {\n        return this.$xPos == this.$overlapSize.x || this.$overlapSize.x == 0;\n    }\n    get pageController() {\n        return this.$pageController;\n    }\n    set pageController(value) {\n        this.$pageController = value;\n    }\n    get scrollingPosX() {\n        return NumberUtil.clamp(-this.$container.x, 0, this.$overlapSize.x);\n    }\n    get scrollingPosY() {\n        return NumberUtil.clamp(-this.$container.y, 0, this.$overlapSize.y);\n    }\n    scrollTop(ani = false) {\n        this.setPercY(0, ani);\n    }\n    scrollBottom(ani = false) {\n        this.setPercY(1, ani);\n    }\n    scrollUp(ratio = 1, ani = false) {\n        if (this.$pageMode)\n            this.setPosY(this.$yPos - this.$pageSize.y * ratio, ani);\n        else\n            this.setPosY(this.$yPos - this.$scrollSpeed * ratio, ani);\n    }\n    scrollDown(ratio = 1, ani = false) {\n        if (this.$pageMode)\n            this.setPosY(this.$yPos + this.$pageSize.y * ratio, ani);\n        else\n            this.setPosY(this.$yPos + this.$scrollSpeed * ratio, ani);\n    }\n    scrollLeft(ratio = 1, ani = false) {\n        if (this.$pageMode)\n            this.setPosX(this.$xPos - this.$pageSize.x * ratio, ani);\n        else\n            this.setPosX(this.$xPos - this.$scrollSpeed * ratio, ani);\n    }\n    scrollRight(ratio = 1, ani = false) {\n        if (this.$pageMode)\n            this.setPosX(this.$xPos + this.$pageSize.x * ratio, ani);\n        else\n            this.setPosX(this.$xPos + this.$scrollSpeed * ratio, ani);\n    }\n    scrollToView(target, ani = false, snapToFirst = false) {\n        this.$owner.ensureBoundsCorrect();\n        if (this.$needRefresh)\n            this.refresh();\n        let rect;\n        if (target instanceof GObject) {\n            if (target.parent != this.$owner) {\n                target.parent.localToGlobalRect(target.x, target.y, target.width, target.height, ScrollPane.sHelperRect);\n                rect = this.$owner.globalToLocalRect(ScrollPane.sHelperRect.x, ScrollPane.sHelperRect.y, ScrollPane.sHelperRect.width, ScrollPane.sHelperRect.height, ScrollPane.sHelperRect);\n            }\n            else {\n                rect = ScrollPane.sHelperRect;\n                rect.x = target.x;\n                rect.y = target.y;\n                rect.width = target.width;\n                rect.height = target.height;\n            }\n        }\n        else\n            rect = target;\n        if (this.$overlapSize.y > 0) {\n            const bottom = this.$yPos + this.$viewSize.y;\n            if (snapToFirst || rect.y <= this.$yPos || rect.height >= this.$viewSize.y) {\n                if (this.$pageMode)\n                    this.setPosY(Math.floor(rect.y / this.$pageSize.y) * this.$pageSize.y, ani);\n                else\n                    this.setPosY(rect.y, ani);\n            }\n            else if (rect.y + rect.height > bottom) {\n                if (this.$pageMode)\n                    this.setPosY(Math.floor(rect.y / this.$pageSize.y) * this.$pageSize.y, ani);\n                else if (rect.height <= this.$viewSize.y / 2)\n                    this.setPosY(rect.y + rect.height * 2 - this.$viewSize.y, ani);\n                else\n                    this.setPosY(rect.y + rect.height - this.$viewSize.y, ani);\n            }\n        }\n        if (this.$overlapSize.x > 0) {\n            let right = this.$xPos + this.$viewSize.x;\n            if (snapToFirst || rect.x <= this.$xPos || rect.width >= this.$viewSize.x) {\n                if (this.$pageMode)\n                    this.setPosX(Math.floor(rect.x / this.$pageSize.x) * this.$pageSize.x, ani);\n                else\n                    this.setPosX(rect.x, ani);\n            }\n            else if (rect.x + rect.width > right) {\n                if (this.$pageMode)\n                    this.setPosX(Math.floor(rect.x / this.$pageSize.x) * this.$pageSize.x, ani);\n                else if (rect.width <= this.$viewSize.x / 2)\n                    this.setPosX(rect.x + rect.width * 2 - this.$viewSize.x, ani);\n                else\n                    this.setPosX(rect.x + rect.width - this.$viewSize.x, ani);\n            }\n        }\n        if (!ani && this.$needRefresh)\n            this.refresh();\n    }\n    isChildInView(obj) {\n        if (this.$overlapSize.y > 0) {\n            var dist = obj.y + this.$container.y;\n            if (dist < -obj.height || dist > this.$viewSize.y)\n                return false;\n        }\n        if (this.$overlapSize.x > 0) {\n            dist = obj.x + this.$container.x;\n            if (dist < -obj.width || dist > this.$viewSize.x)\n                return false;\n        }\n        return true;\n    }\n    cancelDragging() {\n        Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Move, this.$mouseMoveEvent);\n        Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$mouseUpEvent);\n        Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Click, this.$clickEvent);\n        if (ScrollPane.draggingPane == this)\n            ScrollPane.draggingPane = null;\n        ScrollPane.$gestureFlag = 0;\n        this.$isDragging = false;\n        this.$maskContainer.mouseEnabled = true;\n    }\n    get isDragging() {\n        return this.$isDragging;\n    }\n    lockHeader(size) {\n        if (this.$headerLockedSize == size)\n            return;\n        this.$headerLockedSize = size;\n        if (!this.$refreshEventDispatching &&\n            this.$container[this.$refreshBarAxis] >= 0) {\n            this.$tweenStart.setValues(this.$container.x, this.$container.y);\n            this.$tweenChange.setValues(0, 0);\n            this.$tweenChange[this.$refreshBarAxis] =\n                this.$headerLockedSize - this.$tweenStart[this.$refreshBarAxis];\n            this.$tweenDuration.setValues(ScrollPane.TWEEN_DEFAULT_DURATION, ScrollPane.TWEEN_DEFAULT_DURATION);\n            this.$tweenTime.setValues(0, 0);\n            this.$tweening = 2;\n            GTimer.inst.addLoop(1, this.tweenUpdate, this);\n        }\n    }\n    lockFooter(size) {\n        if (this.$footerLockedSize == size)\n            return;\n        this.$footerLockedSize = size;\n        if (!this.$refreshEventDispatching &&\n            this.$container[this.$refreshBarAxis] <=\n                -this.$overlapSize[this.$refreshBarAxis]) {\n            this.$tweenStart.setValues(this.$container.x, this.$container.y);\n            this.$tweenChange.setValues(0, 0);\n            let max = this.$overlapSize[this.$refreshBarAxis];\n            if (max == 0)\n                max = Math.max(this.$contentSize[this.$refreshBarAxis] +\n                    this.$footerLockedSize -\n                    this.$viewSize[this.$refreshBarAxis], 0);\n            else\n                max += this.$footerLockedSize;\n            this.$tweenChange[this.$refreshBarAxis] =\n                -max - this.$tweenStart[this.$refreshBarAxis];\n            this.$tweenDuration.setValues(ScrollPane.TWEEN_DEFAULT_DURATION, ScrollPane.TWEEN_DEFAULT_DURATION);\n            this.$tweenTime.setValues(0, 0);\n            this.$tweening = 2;\n            GTimer.inst.addLoop(1, this.tweenUpdate, this);\n        }\n    }\n    /**\n     * @internal\n     */\n    onOwnerSizeChanged() {\n        this.setSize(this.$owner.width, this.$owner.height);\n        this.posChanged(false);\n    }\n    /**\n     * @internal\n     */\n    handleControllerChanged(c) {\n        if (this.$pageController == c) {\n            if (this.$scrollType == 0 /* Horizontal */)\n                this.currentPageX = c.selectedIndex;\n            else\n                this.currentPageY = c.selectedIndex;\n        }\n    }\n    updatePageController() {\n        if (this.$pageController != null && !this.$pageController.$updating) {\n            let index;\n            if (this.$scrollType == 0 /* Horizontal */)\n                index = this.currentPageX;\n            else\n                index = this.currentPageY;\n            if (index < this.$pageController.pageCount) {\n                const c = this.$pageController;\n                this.$pageController = null; //prevent from handleControllerChanged calling\n                c.selectedIndex = index;\n                this.$pageController = c;\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    adjustMaskContainer() {\n        let x, y;\n        if (this.$displayOnLeft && this.$vtScrollBar != null)\n            x = Math.floor(this.$owner.margin.left + this.$vtScrollBar.width);\n        else\n            x = Math.floor(this.$owner.margin.left);\n        y = Math.floor(this.$owner.margin.top);\n        this.$maskContainer.set({ x, y });\n        if (this.$owner.$alignOffset.x != 0 || this.$owner.$alignOffset.y != 0) {\n            if (this.$alignContainer == null) {\n                this.$alignContainer = new createjs.Container();\n                this.$maskContainer.addChild(this.$alignContainer);\n                this.$alignContainer.addChild(this.$container);\n            }\n            this.$alignContainer.set({ x: this.$owner.$alignOffset.x, y: this.$owner.$alignOffset.y });\n        }\n        else if (this.$alignContainer)\n            this.$alignContainer.set({ x: 0, y: 0 });\n    }\n    setSize(width, height) {\n        this.adjustMaskContainer();\n        if (this.$hzScrollBar) {\n            this.$hzScrollBar.y = height - this.$hzScrollBar.height;\n            if (this.$vtScrollBar && !this.$vScrollNone) {\n                this.$hzScrollBar.width =\n                    width - this.$vtScrollBar.width - this.$scrollBarMargin.left - this.$scrollBarMargin.right;\n                if (this.$displayOnLeft)\n                    this.$hzScrollBar.x = this.$scrollBarMargin.left + this.$vtScrollBar.width;\n                else\n                    this.$hzScrollBar.x = this.$scrollBarMargin.left;\n            }\n            else {\n                this.$hzScrollBar.width = width - this.$scrollBarMargin.left - this.$scrollBarMargin.right;\n                this.$hzScrollBar.x = this.$scrollBarMargin.left;\n            }\n        }\n        if (this.$vtScrollBar) {\n            if (!this.$displayOnLeft)\n                this.$vtScrollBar.x = width - this.$vtScrollBar.width;\n            if (this.$hzScrollBar)\n                this.$vtScrollBar.height =\n                    height -\n                        this.$hzScrollBar.height -\n                        this.$scrollBarMargin.top -\n                        this.$scrollBarMargin.bottom;\n            else\n                this.$vtScrollBar.height = height - this.$scrollBarMargin.top - this.$scrollBarMargin.bottom;\n            this.$vtScrollBar.y = this.$scrollBarMargin.top;\n        }\n        this.$viewSize.x = width;\n        this.$viewSize.y = height;\n        if (this.$hzScrollBar && !this.$hScrollNone)\n            this.$viewSize.y -= this.$hzScrollBar.height;\n        if (this.$vtScrollBar && !this.$vScrollNone)\n            this.$viewSize.x -= this.$vtScrollBar.width;\n        this.$viewSize.x -= this.$owner.margin.left + this.$owner.margin.right;\n        this.$viewSize.y -= this.$owner.margin.top + this.$owner.margin.bottom;\n        this.$viewSize.x = Math.max(1, this.$viewSize.x);\n        this.$viewSize.y = Math.max(1, this.$viewSize.y);\n        this.$pageSize.x = this.$viewSize.x;\n        this.$pageSize.y = this.$viewSize.y;\n        this.handleSizeChanged();\n    }\n    setContentSize(w, h) {\n        if (this.$contentSize.x == w && this.$contentSize.y == h)\n            return;\n        this.$contentSize.x = w;\n        this.$contentSize.y = h;\n        this.handleSizeChanged();\n    }\n    /**\n     * @internal\n     */\n    changeContentSizeOnScrolling(deltaWidth, deltaHeight, deltaPosX, deltaPosY) {\n        const isRightmost = this.$xPos == this.$overlapSize.x;\n        const isBottom = this.$yPos == this.$overlapSize.y;\n        this.$contentSize.x += deltaWidth;\n        this.$contentSize.y += deltaHeight;\n        this.handleSizeChanged();\n        if (this.$tweening == 1) {\n            //if the last scroll is CLINGING-SIDE, then just continue to cling\n            if (deltaWidth != 0 && isRightmost && this.$tweenChange.x < 0) {\n                this.$xPos = this.$overlapSize.x;\n                this.$tweenChange.x = -this.$xPos - this.$tweenStart.x;\n            }\n            if (deltaHeight != 0 && isBottom && this.$tweenChange.y < 0) {\n                this.$yPos = this.$overlapSize.y;\n                this.$tweenChange.y = -this.$yPos - this.$tweenStart.y;\n            }\n        }\n        else if (this.$tweening == 2) {\n            //re-pos to ensure the scrolling will go on smooth\n            if (deltaPosX != 0) {\n                this.$container.x -= deltaPosX;\n                this.$tweenStart.x -= deltaPosX;\n                this.$xPos = -this.$container.x;\n            }\n            if (deltaPosY != 0) {\n                this.$container.y -= deltaPosY;\n                this.$tweenStart.y -= deltaPosY;\n                this.$yPos = -this.$container.y;\n            }\n        }\n        else if (this.$isDragging) {\n            if (deltaPosX != 0) {\n                this.$container.x -= deltaPosX;\n                this.$containerPos.x -= deltaPosX;\n                this.$xPos = -this.$container.x;\n            }\n            if (deltaPosY != 0) {\n                this.$container.y -= deltaPosY;\n                this.$containerPos.y -= deltaPosY;\n                this.$yPos = -this.$container.y;\n            }\n        }\n        else {\n            //if the last scroll is CLINGING-SIDE, then just continue to cling\n            if (deltaWidth != 0 && isRightmost) {\n                this.$xPos = this.$overlapSize.x;\n                this.$container.x = -this.$xPos;\n            }\n            if (deltaHeight != 0 && isBottom) {\n                this.$yPos = this.$overlapSize.y;\n                this.$container.y = -this.$yPos;\n            }\n        }\n        if (this.$pageMode)\n            this.updatePageController();\n    }\n    handleSizeChanged(onScrolling = false) {\n        if (this.$displayOnDemand) {\n            if (this.$vtScrollBar) {\n                if (this.$contentSize.y <= this.$viewSize.y) {\n                    if (!this.$vScrollNone) {\n                        this.$vScrollNone = true;\n                        this.$viewSize.x += this.$vtScrollBar.width;\n                    }\n                }\n                else {\n                    if (this.$vScrollNone) {\n                        this.$vScrollNone = false;\n                        this.$viewSize.x -= this.$vtScrollBar.width;\n                    }\n                }\n            }\n            if (this.$hzScrollBar) {\n                if (this.$contentSize.x <= this.$viewSize.x) {\n                    if (!this.$hScrollNone) {\n                        this.$hScrollNone = true;\n                        this.$viewSize.y += this.$hzScrollBar.height;\n                    }\n                }\n                else {\n                    if (this.$hScrollNone) {\n                        this.$hScrollNone = false;\n                        this.$viewSize.y -= this.$hzScrollBar.height;\n                    }\n                }\n            }\n        }\n        if (this.$vtScrollBar) {\n            if (this.$viewSize.y < this.$vtScrollBar.minSize)\n                //use this.$vtScrollBar.displayObject.visible instead of this.$vtScrollBar.visible... ScrollBar actually is not in its owner's display tree, so vtScrollBar.visible will not work\n                this.$vtScrollBar.displayObject.visible = false;\n            else {\n                this.$vtScrollBar.displayObject.visible = this.$scrollBarVisible && !this.$vScrollNone;\n                if (this.$contentSize.y == 0)\n                    this.$vtScrollBar.displayPerc = 0;\n                else\n                    this.$vtScrollBar.displayPerc = Math.min(1, this.$viewSize.y / this.$contentSize.y);\n            }\n        }\n        if (this.$hzScrollBar) {\n            if (this.$viewSize.x < this.$hzScrollBar.minSize)\n                this.$hzScrollBar.displayObject.visible = false;\n            else {\n                this.$hzScrollBar.displayObject.visible = this.$scrollBarVisible && !this.$hScrollNone;\n                if (this.$contentSize.x == 0)\n                    this.$hzScrollBar.displayPerc = 0;\n                else\n                    this.$hzScrollBar.displayPerc = Math.min(1, this.$viewSize.x / this.$contentSize.x);\n            }\n        }\n        const rect = this.$maskContainer.scrollRect;\n        if (rect) {\n            rect.width = this.$viewSize.x;\n            rect.height = this.$viewSize.y;\n            this.$maskContainer.scrollRect = rect;\n        }\n        if (this.$scrollType == 0 /* Horizontal */ || this.$scrollType == 2 /* Both */)\n            this.$overlapSize.x = Math.ceil(Math.max(0, this.$contentSize.x - this.$viewSize.x));\n        else\n            this.$overlapSize.x = 0;\n        if (this.$scrollType == 1 /* Vertical */ || this.$scrollType == 2 /* Both */)\n            this.$overlapSize.y = Math.ceil(Math.max(0, this.$contentSize.y - this.$viewSize.y));\n        else\n            this.$overlapSize.y = 0;\n        //bounds checking\n        this.$xPos = NumberUtil.clamp(this.$xPos, 0, this.$overlapSize.x);\n        this.$yPos = NumberUtil.clamp(this.$yPos, 0, this.$overlapSize.y);\n        if (this.$refreshBarAxis != null) {\n            var max = this.$overlapSize[this.$refreshBarAxis];\n            if (max == 0)\n                max = Math.max(this.$contentSize[this.$refreshBarAxis] +\n                    this.$footerLockedSize -\n                    this.$viewSize[this.$refreshBarAxis], 0);\n            else\n                max += this.$footerLockedSize;\n            if (this.$refreshBarAxis == 'x') {\n                this.$container.set({\n                    x: NumberUtil.clamp(this.$container.x, -max, this.$headerLockedSize),\n                    y: NumberUtil.clamp(this.$container.y, -this.$overlapSize.y, 0)\n                });\n            }\n            else {\n                this.$container.set({\n                    x: NumberUtil.clamp(this.$container.x, -this.$overlapSize.x, 0),\n                    y: NumberUtil.clamp(this.$container.y, -max, this.$headerLockedSize)\n                });\n            }\n            if (this.$header != null) {\n                if (this.$refreshBarAxis == 'x')\n                    this.$header.height = this.$viewSize.y;\n                else\n                    this.$header.width = this.$viewSize.x;\n            }\n            if (this.$footer != null) {\n                if (this.$refreshBarAxis == 'y')\n                    this.$footer.height = this.$viewSize.y;\n                else\n                    this.$footer.width = this.$viewSize.x;\n            }\n        }\n        else {\n            this.$container.set({\n                x: NumberUtil.clamp(this.$container.x, -this.$overlapSize.x, 0),\n                y: NumberUtil.clamp(this.$container.y, -this.$overlapSize.y, 0)\n            });\n        }\n        this.syncScrollBar();\n        this.checkRefreshBar();\n        if (this.$pageMode)\n            this.updatePageController();\n    }\n    posChanged(ani) {\n        if (this.$aniFlag == 0)\n            this.$aniFlag = ani ? 1 : -1;\n        else if (this.$aniFlag == 1 && !ani)\n            this.$aniFlag = -1;\n        this.$needRefresh = true;\n        GTimer.inst.callLater(this.refresh, this);\n    }\n    refresh() {\n        this.$needRefresh = false;\n        GTimer.inst.remove(this.refresh, this);\n        if (this.$pageMode || this.$snapToItem) {\n            ScrollPane.sEndPos.setValues(-this.$xPos, -this.$yPos);\n            this.alignPosition(ScrollPane.sEndPos, false);\n            this.$xPos = -ScrollPane.sEndPos.x;\n            this.$yPos = -ScrollPane.sEndPos.y;\n        }\n        this.refresh2();\n        let evt = new createjs.Event(\"__scroll\" /* SCROLL */, true, false);\n        this.dispatchEvent(evt, this);\n        if (this.$needRefresh) {\n            //developer might modify position in the callback, so here refresh again to avoid flickering\n            this.$needRefresh = false;\n            GTimer.inst.remove(this.refresh, this);\n            this.refresh2();\n        }\n        this.syncScrollBar();\n        this.$aniFlag = 0;\n    }\n    refresh2() {\n        if (this.$aniFlag == 1 && !this.$isDragging) {\n            let posX;\n            let posY;\n            if (this.$overlapSize.x > 0)\n                posX = -Math.floor(this.$xPos);\n            else {\n                if (this.$container.x != 0)\n                    this.$container.x = 0;\n                posX = 0;\n            }\n            if (this.$overlapSize.y > 0)\n                posY = -Math.floor(this.$yPos);\n            else {\n                if (this.$container.y != 0)\n                    this.$container.y = 0;\n                posY = 0;\n            }\n            if (posX != this.$container.x || posY != this.$container.y) {\n                this.$tweening = 1;\n                this.$tweenTime.setValues(0, 0);\n                this.$tweenDuration.setValues(ScrollPane.TWEEN_MANUALLY_SET_DURATION, ScrollPane.TWEEN_MANUALLY_SET_DURATION);\n                this.$tweenStart.setValues(this.$container.x, this.$container.y);\n                this.$tweenChange.setValues(posX - this.$tweenStart.x, posY - this.$tweenStart.y);\n                GTimer.inst.addLoop(1, this.tweenUpdate, this);\n            }\n            else if (this.$tweening != 0)\n                this.killTween();\n        }\n        else {\n            if (this.$tweening != 0)\n                this.killTween();\n            this.$container.set({ x: Math.floor(-this.$xPos), y: Math.floor(-this.$yPos) });\n            this.loopCheckingCurrent();\n        }\n        if (this.$pageMode)\n            this.updatePageController();\n    }\n    syncScrollBar(end = false) {\n        if (this.$vtScrollBar != null) {\n            this.$vtScrollBar.scrollPerc =\n                this.$overlapSize.y == 0\n                    ? 0\n                    : NumberUtil.clamp(-this.$container.y, 0, this.$overlapSize.y) / this.$overlapSize.y;\n            if (this.$scrollBarDisplayAuto)\n                this.showScrollBar(!end);\n        }\n        if (this.$hzScrollBar != null) {\n            this.$hzScrollBar.scrollPerc =\n                this.$overlapSize.x == 0\n                    ? 0\n                    : NumberUtil.clamp(-this.$container.x, 0, this.$overlapSize.x) / this.$overlapSize.x;\n            if (this.$scrollBarDisplayAuto)\n                this.showScrollBar(!end);\n        }\n        if (end)\n            this.$maskContainer.mouseEnabled = true;\n    }\n    $mouseDown(e) {\n        if (!this.$touchEffect)\n            return;\n        if (this.$tweening != 0) {\n            this.killTween();\n            this.$isDragging = true;\n        }\n        else\n            this.$isDragging = false;\n        const globalMouse = fairygui_module_isMobile.any\n            ? this.$owner.globalToLocal(e.localX, e.localY)\n            : this.$owner.globalToLocal(Decls$1.GRoot.globalMouseStatus.mouseX, Decls$1.GRoot.globalMouseStatus.mouseY, ScrollPane.sHelperPoint);\n        this.$containerPos.setValues(this.$container.x, this.$container.y);\n        this.$beginTouchPos.copy(globalMouse);\n        this.$lastTouchPos.copy(globalMouse);\n        this.$lastTouchGlobalPos.copy(globalMouse);\n        this.$isHoldAreaDone = false;\n        this.$velocity.setValues(0, 0);\n        this.$velocityScale = 1;\n        this.$lastMoveTime = GTimer.inst.curTime / 1000;\n        this.$mouseMoveEvent = Decls$1.GRoot.inst.nativeStage.on(InteractiveEvents.Move, this.$mouseMove, this);\n        this.$mouseUpEvent = Decls$1.GRoot.inst.nativeStage.on(InteractiveEvents.Up, this.$mouseUp, this);\n        this.$clickEvent = Decls$1.GRoot.inst.nativeStage.on(InteractiveEvents.Click, this.$click, this);\n    }\n    $mouseMove() {\n        if (!this.$touchEffect)\n            return;\n        if ((ScrollPane.draggingPane != null && ScrollPane.draggingPane != this) ||\n            GObject.draggingObject != null)\n            return;\n        let sensitivity = UIConfig.touchScrollSensitivity;\n        const globalMouse = this.$owner.globalToLocal(Decls$1.GRoot.globalMouseStatus.mouseX, Decls$1.GRoot.globalMouseStatus.mouseY, ScrollPane.sHelperPoint);\n        let diff, diff2;\n        let sv, sh;\n        if (this.$scrollType == 1 /* Vertical */) {\n            if (!this.$isHoldAreaDone) {\n                //gesture on vertical dir is being observed\n                ScrollPane.$gestureFlag |= 1;\n                diff = Math.abs(this.$beginTouchPos.y - globalMouse.y);\n                if (diff < sensitivity)\n                    return;\n                if ((ScrollPane.$gestureFlag & 2) != 0) {\n                    diff2 = Math.abs(this.$beginTouchPos.x - globalMouse.x);\n                    if (diff < diff2)\n                        return;\n                }\n            }\n            sv = true;\n        }\n        else if (this.$scrollType == 0 /* Horizontal */) {\n            if (!this.$isHoldAreaDone) {\n                ScrollPane.$gestureFlag |= 2; //gesture on horz dir is being observed\n                diff = Math.abs(this.$beginTouchPos.x - globalMouse.x);\n                if (diff < sensitivity)\n                    return;\n                if ((ScrollPane.$gestureFlag & 1) != 0) {\n                    diff2 = Math.abs(this.$beginTouchPos.y - globalMouse.y);\n                    if (diff < diff2)\n                        return;\n                }\n            }\n            sh = true;\n        }\n        else {\n            ScrollPane.$gestureFlag = 3; //both\n            if (!this.$isHoldAreaDone) {\n                diff = Math.abs(this.$beginTouchPos.y - globalMouse.y);\n                if (diff < sensitivity) {\n                    diff = Math.abs(this.$beginTouchPos.x - globalMouse.x);\n                    if (diff < sensitivity)\n                        return;\n                }\n            }\n            sv = sh = true;\n        }\n        let newPosX = Math.floor(this.$containerPos.x + globalMouse.x - this.$beginTouchPos.x);\n        let newPosY = Math.floor(this.$containerPos.y + globalMouse.y - this.$beginTouchPos.y);\n        if (sv) {\n            if (newPosY > 0) {\n                if (!this.$bouncebackEffect)\n                    this.$container.y = 0;\n                else if (this.$header != null && this.$header.height != 0)\n                    //TODO: height -> maxHeight\n                    this.$container.y = Math.floor(Math.min(newPosY * 0.5, this.$header.height));\n                else\n                    this.$container.y = Math.floor(Math.min(newPosY * 0.5, this.$viewSize.y * ScrollPane.PULL_DIST_RATIO));\n            }\n            else if (newPosY < -this.$overlapSize.y) {\n                if (!this.$bouncebackEffect)\n                    this.$container.y = -this.$overlapSize.y;\n                else if (this.$footer != null && this.$footer.height > 0)\n                    //TODO: height -> maxHeight\n                    this.$container.y = Math.floor(Math.max((newPosY + this.$overlapSize.y) * 0.5, -this.$footer.height) -\n                        this.$overlapSize.y);\n                else\n                    this.$container.y = Math.floor(Math.max((newPosY + this.$overlapSize.y) * 0.5, -this.$viewSize.y * ScrollPane.PULL_DIST_RATIO) - this.$overlapSize.y);\n            }\n            else\n                this.$container.y = newPosY;\n        }\n        if (sh) {\n            if (newPosX > 0) {\n                if (!this.$bouncebackEffect)\n                    this.$container.x = 0;\n                else if (this.$header != null && this.$header.width != 0)\n                    //TODO: width -> maxWidth\n                    this.$container.x = Math.floor(Math.min(newPosX * 0.5, this.$header.width));\n                else\n                    this.$container.x = Math.floor(Math.min(newPosX * 0.5, this.$viewSize.x * ScrollPane.PULL_DIST_RATIO));\n            }\n            else if (newPosX < 0 - this.$overlapSize.x) {\n                if (!this.$bouncebackEffect)\n                    this.$container.x = -this.$overlapSize.x;\n                else if (this.$footer != null && this.$footer.width > 0)\n                    //TODO: width -> maxWidth\n                    this.$container.x = Math.floor(Math.max((newPosX + this.$overlapSize.x) * 0.5, -this.$footer.width) -\n                        this.$overlapSize.x);\n                else\n                    this.$container.x = Math.floor(Math.max((newPosX + this.$overlapSize.x) * 0.5, -this.$viewSize.x * ScrollPane.PULL_DIST_RATIO) - this.$overlapSize.x);\n            }\n            else\n                this.$container.x = newPosX;\n        }\n        //update acceleration\n        const frameRate = createjs.Ticker.framerate;\n        const now = GTimer.inst.curTime / 1000;\n        const deltaTime = Math.max(now - this.$lastMoveTime, 1 / frameRate);\n        let deltaPositionX = globalMouse.x - this.$lastTouchPos.x;\n        let deltaPositionY = globalMouse.y - this.$lastTouchPos.y;\n        if (!sh)\n            deltaPositionX = 0;\n        if (!sv)\n            deltaPositionY = 0;\n        if (deltaTime != 0) {\n            const elapsed = deltaTime * frameRate - 1;\n            if (elapsed > 1) {\n                const factor = Math.pow(0.833, elapsed);\n                this.$velocity.x = this.$velocity.x * factor;\n                this.$velocity.y = this.$velocity.y * factor;\n            }\n            this.$velocity.x = NumberUtil.lerp(this.$velocity.x, (deltaPositionX * 60) / frameRate / deltaTime, deltaTime * 10);\n            this.$velocity.y = NumberUtil.lerp(this.$velocity.y, (deltaPositionY * 60) / frameRate / deltaTime, deltaTime * 10);\n        }\n        //in the inertia scrolling we need the offset value to screen space, so here we need to reocrd the offset ratio\n        const deltaGlobalPositionX = this.$lastTouchGlobalPos.x - globalMouse.x;\n        const deltaGlobalPositionY = this.$lastTouchGlobalPos.y - globalMouse.y;\n        if (deltaPositionX != 0)\n            this.$velocityScale = Math.abs(deltaGlobalPositionX / deltaPositionX);\n        else if (deltaPositionY != 0)\n            this.$velocityScale = Math.abs(deltaGlobalPositionY / deltaPositionY);\n        this.$lastTouchPos.copy(globalMouse);\n        this.$lastTouchGlobalPos.copy(globalMouse);\n        this.$lastMoveTime = now;\n        //update position\n        if (this.$overlapSize.x > 0)\n            this.$xPos = NumberUtil.clamp(-this.$container.x, 0, this.$overlapSize.x);\n        if (this.$overlapSize.y > 0)\n            this.$yPos = NumberUtil.clamp(-this.$container.y, 0, this.$overlapSize.y);\n        if (this.$loop != 0) {\n            newPosX = this.$container.x;\n            newPosY = this.$container.y;\n            if (this.loopCheckingCurrent()) {\n                this.$containerPos.x += this.$container.x - newPosX;\n                this.$containerPos.y += this.$container.y - newPosY;\n            }\n        }\n        ScrollPane.draggingPane = this;\n        this.$isHoldAreaDone = true;\n        this.$isDragging = true;\n        // this.$maskContainer.interactive = false;\n        this.syncScrollBar();\n        this.checkRefreshBar();\n        if (this.$pageMode)\n            this.updatePageController();\n        let evt = new createjs.Event(\"__scroll\" /* SCROLL */, true, false);\n        this.dispatchEvent(evt, this);\n    }\n    $mouseUp() {\n        Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Move, this.$mouseMoveEvent);\n        Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$mouseMoveEvent);\n        Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Click, this.$clickEvent);\n        if (ScrollPane.draggingPane == this)\n            ScrollPane.draggingPane = null;\n        ScrollPane.$gestureFlag = 0;\n        if (!this.$isDragging || !this.$touchEffect) {\n            this.$isDragging = false;\n            this.$maskContainer.mouseEnabled = true;\n            return;\n        }\n        this.$isDragging = false;\n        this.$maskContainer.mouseEnabled = true;\n        this.$tweenStart.setValues(this.$container.x, this.$container.y);\n        ScrollPane.sEndPos.setValues(this.$tweenStart.x, this.$tweenStart.y);\n        let flag = false;\n        if (this.$container.x > 0) {\n            ScrollPane.sEndPos.x = 0;\n            flag = true;\n        }\n        else if (this.$container.x < -this.$overlapSize.x) {\n            ScrollPane.sEndPos.x = -this.$overlapSize.x;\n            flag = true;\n        }\n        if (this.$container.y > 0) {\n            ScrollPane.sEndPos.y = 0;\n            flag = true;\n        }\n        else if (this.$container.y < -this.$overlapSize.y) {\n            ScrollPane.sEndPos.y = -this.$overlapSize.y;\n            flag = true;\n        }\n        if (flag) {\n            this.$tweenChange.setValues(ScrollPane.sEndPos.x - this.$tweenStart.x, ScrollPane.sEndPos.y - this.$tweenStart.y);\n            if (this.$tweenChange.x < -UIConfig.touchDragSensitivity ||\n                this.$tweenChange.y < -UIConfig.touchDragSensitivity) {\n                this.$refreshEventDispatching = true;\n                let evt = new createjs.Event(\"__pullDownRelease\" /* PULL_DOWN_RELEASE */, true, false);\n                this.dispatchEvent(evt, this);\n                this.$refreshEventDispatching = false;\n            }\n            else if (this.$tweenChange.x > UIConfig.touchDragSensitivity ||\n                this.$tweenChange.y > UIConfig.touchDragSensitivity) {\n                this.$refreshEventDispatching = true;\n                let evt = new createjs.Event(\"__pullUpRelease\" /* PULL_UP_RELEASE */, true, false);\n                this.dispatchEvent(evt, this);\n                this.$refreshEventDispatching = false;\n            }\n            if (this.$headerLockedSize > 0 &&\n                ScrollPane.sEndPos[this.$refreshBarAxis] == 0) {\n                ScrollPane.sEndPos[this.$refreshBarAxis] = this.$headerLockedSize;\n                this.$tweenChange.x = ScrollPane.sEndPos.x - this.$tweenStart.x;\n                this.$tweenChange.y = ScrollPane.sEndPos.y - this.$tweenStart.y;\n            }\n            else if (this.$footerLockedSize > 0 &&\n                ScrollPane.sEndPos[this.$refreshBarAxis] ==\n                    -this.$overlapSize[this.$refreshBarAxis]) {\n                var max = this.$overlapSize[this.$refreshBarAxis];\n                if (max == 0)\n                    max = Math.max(this.$contentSize[this.$refreshBarAxis] +\n                        this.$footerLockedSize -\n                        this.$viewSize[this.$refreshBarAxis], 0);\n                else\n                    max += this.$footerLockedSize;\n                ScrollPane.sEndPos[this.$refreshBarAxis] = -max;\n                this.$tweenChange.x = ScrollPane.sEndPos.x - this.$tweenStart.x;\n                this.$tweenChange.y = ScrollPane.sEndPos.y - this.$tweenStart.y;\n            }\n            this.$tweenDuration.setValues(ScrollPane.TWEEN_DEFAULT_DURATION, ScrollPane.TWEEN_DEFAULT_DURATION);\n        }\n        else {\n            if (!this.$inertiaDisabled) {\n                const frameRate = createjs.Ticker.framerate;\n                const elapsed = (GTimer.inst.curTime / 1000 - this.$lastMoveTime) * frameRate - 1;\n                if (elapsed > 1) {\n                    const factor = Math.pow(0.833, elapsed);\n                    this.$velocity.x = this.$velocity.x * factor;\n                    this.$velocity.y = this.$velocity.y * factor;\n                }\n                //calc dist & duration by speed\n                this.updateTargetAndDuration(this.$tweenStart, ScrollPane.sEndPos);\n            }\n            else\n                this.$tweenDuration.setValues(ScrollPane.TWEEN_DEFAULT_DURATION, ScrollPane.TWEEN_DEFAULT_DURATION);\n            ScrollPane.sOldChange.setValues(ScrollPane.sEndPos.x - this.$tweenStart.x, ScrollPane.sEndPos.y - this.$tweenStart.y);\n            //adjust\n            this.loopCheckingTarget(ScrollPane.sEndPos);\n            if (this.$pageMode || this.$snapToItem)\n                this.alignPosition(ScrollPane.sEndPos, true);\n            this.$tweenChange.x = ScrollPane.sEndPos.x - this.$tweenStart.x;\n            this.$tweenChange.y = ScrollPane.sEndPos.y - this.$tweenStart.y;\n            if (this.$tweenChange.x == 0 && this.$tweenChange.y == 0) {\n                if (this.$scrollBarDisplayAuto)\n                    this.showScrollBar(false);\n                return;\n            }\n            if (this.$pageMode || this.$snapToItem) {\n                this.fixDuration('x', ScrollPane.sOldChange.x);\n                this.fixDuration('y', ScrollPane.sOldChange.y);\n            }\n        }\n        this.$tweening = 2;\n        this.$tweenTime.setValues(0, 0);\n        GTimer.inst.addLoop(1, this.tweenUpdate, this);\n    }\n    $click() {\n        this.$isDragging = false;\n    }\n    $mouseWheel(evt) {\n        let event = evt.data.event;\n        if (!this.$mouseWheelEnabled)\n            return;\n        const delta = event.delta > 0 ? -1 : event.delta < 0 ? 1 : 0;\n        if (this.$overlapSize.x > 0 && this.$overlapSize.y == 0) {\n            if (this.$pageMode)\n                this.setPosX(this.$xPos + this.$pageSize.x * delta, false);\n            else\n                this.setPosX(this.$xPos + this.$mouseWheelSpeed * delta, false);\n        }\n        else {\n            if (this.$pageMode)\n                this.setPosY(this.$yPos + this.$pageSize.y * delta, false);\n            else\n                this.setPosY(this.$yPos + this.$mouseWheelSpeed * delta, false);\n        }\n    }\n    $rollOver() {\n        this.showScrollBar(true);\n    }\n    $rollOut() {\n        this.showScrollBar(false);\n    }\n    showScrollBar(visible) {\n        if (visible) {\n            GTimer.inst.remove(this.setScrollBarVisible, this);\n            this.setScrollBarVisible(true);\n        }\n        else\n            GTimer.inst.add(500, 1, this.setScrollBarVisible, this, visible);\n    }\n    setScrollBarVisible(visible) {\n        this.$scrollBarVisible = visible && this.$viewSize.x > 0 && this.$viewSize.y > 0;\n        if (this.$vtScrollBar)\n            this.$vtScrollBar.displayObject.visible = this.$scrollBarVisible && !this.$vScrollNone;\n        if (this.$hzScrollBar)\n            this.$hzScrollBar.displayObject.visible = this.$scrollBarVisible && !this.$hScrollNone;\n    }\n    getLoopPartSize(division, axis) {\n        let pad = 0;\n        // if (this.$owner instanceof GList)\n        //     pad = axis == \"x\" ? this.$owner.columnGap : this.$owner.lineGap;\n        return (this.$contentSize[axis] + pad) / division;\n    }\n    loopCheckingCurrent() {\n        let changed = false;\n        if (this.$loop == 1 && this.$overlapSize.x > 0) {\n            if (this.$xPos < 0.001) {\n                this.$xPos += this.getLoopPartSize(2, 'x');\n                changed = true;\n            }\n            else if (this.$xPos >= this.$overlapSize.x) {\n                this.$xPos -= this.getLoopPartSize(2, 'x');\n                changed = true;\n            }\n        }\n        else if (this.$loop == 2 && this.$overlapSize.y > 0) {\n            if (this.$yPos < 0.001) {\n                this.$yPos += this.getLoopPartSize(2, 'y');\n                changed = true;\n            }\n            else if (this.$yPos >= this.$overlapSize.y) {\n                this.$yPos -= this.getLoopPartSize(2, 'y');\n                changed = true;\n            }\n        }\n        if (changed)\n            this.$container.set({ x: Math.floor(-this.$xPos), y: Math.floor(-this.$yPos) });\n        return changed;\n    }\n    loopCheckingTarget(endPos) {\n        if (this.$loop == 1)\n            this.loopCheckingTarget2(endPos, 'x');\n        if (this.$loop == 2)\n            this.loopCheckingTarget2(endPos, 'y');\n    }\n    loopCheckingTarget2(endPos, axis) {\n        let halfSize;\n        let tmp;\n        if (endPos[axis] > 0) {\n            halfSize = this.getLoopPartSize(2, axis);\n            tmp = this.$tweenStart[axis] - halfSize;\n            if (tmp <= 0 && tmp >= -this.$overlapSize[axis]) {\n                endPos[axis] -= halfSize;\n                this.$tweenStart[axis] = tmp;\n            }\n        }\n        else if (endPos[axis] < -this.$overlapSize[axis]) {\n            halfSize = this.getLoopPartSize(2, axis);\n            tmp = this.$tweenStart[axis] + halfSize;\n            if (tmp <= 0 && tmp >= -this.$overlapSize[axis]) {\n                endPos[axis] += halfSize;\n                this.$tweenStart[axis] = tmp;\n            }\n        }\n    }\n    loopCheckingNewPos(value, axis) {\n        if (this.$overlapSize[axis] == 0)\n            return value;\n        let pos = axis == 'x' ? this.$xPos : this.$yPos;\n        let changed = false;\n        let v;\n        if (value < 0.001) {\n            value += this.getLoopPartSize(2, axis);\n            if (value > pos) {\n                v = this.getLoopPartSize(6, axis);\n                v = Math.ceil((value - pos) / v) * v;\n                pos = NumberUtil.clamp(pos + v, 0, this.$overlapSize[axis]);\n                changed = true;\n            }\n        }\n        else if (value >= this.$overlapSize[axis]) {\n            value -= this.getLoopPartSize(2, axis);\n            if (value < pos) {\n                v = this.getLoopPartSize(6, axis);\n                v = Math.ceil((pos - value) / v) * v;\n                pos = NumberUtil.clamp(pos - v, 0, this.$overlapSize[axis]);\n                changed = true;\n            }\n        }\n        if (changed) {\n            if (axis == 'x')\n                this.$container.x = -Math.floor(pos);\n            else\n                this.$container.y = -Math.floor(pos);\n        }\n        return value;\n    }\n    alignPosition(pos, inertialScrolling) {\n        if (this.$pageMode) {\n            pos.x = this.alignByPage(pos.x, 'x', inertialScrolling);\n            pos.y = this.alignByPage(pos.y, 'y', inertialScrolling);\n        }\n        else if (this.$snapToItem) {\n            var pt = this.$owner.getSnappingPosition(-pos.x, -pos.y, ScrollPane.sHelperPoint);\n            if (pos.x < 0 && pos.x > -this.$overlapSize.x)\n                pos.x = -pt.x;\n            if (pos.y < 0 && pos.y > -this.$overlapSize.y)\n                pos.y = -pt.y;\n        }\n    }\n    alignByPage(pos, axis, inertialScrolling) {\n        let page;\n        if (pos > 0)\n            page = 0;\n        else if (pos < -this.$overlapSize[axis])\n            page =\n                Math.ceil(this.$contentSize[axis] / this.$pageSize[axis]) - 1;\n        else {\n            page = Math.floor(-pos / this.$pageSize[axis]);\n            var change = inertialScrolling\n                ? pos - this.$containerPos[axis]\n                : pos - this.$container[axis];\n            var testPageSize = Math.min(this.$pageSize[axis], this.$contentSize[axis] -\n                (page + 1) * this.$pageSize[axis]);\n            var delta = -pos - page * this.$pageSize[axis];\n            //page mode magnetic\n            if (Math.abs(change) > this.$pageSize[axis]) {\n                if (delta > testPageSize * 0.5)\n                    page++;\n            }\n            else {\n                if (delta > testPageSize * (change < 0 ? 0.3 : 0.7))\n                    page++;\n            }\n            //re-calc dist\n            const dst = this.$pageSize[axis];\n            pos = -page * dst;\n            if (pos < -dst)\n                pos = -dst;\n        }\n        if (inertialScrolling) {\n            var oldPos = this.$tweenStart[axis];\n            var oldPage;\n            if (oldPos > 0)\n                oldPage = 0;\n            else if (oldPos < -this.$overlapSize[axis])\n                oldPage =\n                    Math.ceil(this.$contentSize[axis] / this.$pageSize[axis]) - 1;\n            else\n                oldPage = Math.floor(-oldPos / this.$pageSize[axis]);\n            var startPage = Math.floor(-this.$containerPos[axis] / this.$pageSize[axis]);\n            if (Math.abs(page - startPage) > 1 && Math.abs(oldPage - startPage) <= 1) {\n                if (page > startPage)\n                    page = startPage + 1;\n                else\n                    page = startPage - 1;\n                pos = -page * this.$pageSize[axis];\n            }\n        }\n        return pos;\n    }\n    updateTargetAndDuration(orignPos, resultPos) {\n        resultPos.x = this.updateTargetAndDuration2(orignPos.x, 'x');\n        resultPos.y = this.updateTargetAndDuration2(orignPos.y, 'y');\n    }\n    updateTargetAndDuration2(pos, axis) {\n        let v = this.$velocity[axis];\n        var duration = 0;\n        if (pos > 0)\n            pos = 0;\n        else if (pos < -this.$overlapSize[axis])\n            pos = -this.$overlapSize[axis];\n        else {\n            let v2 = Math.abs(v) * this.$velocityScale;\n            if (fairygui_module_isMobile.any)\n                v2 *=\n                    Math.max(Decls$1.GRoot.inst.stageWrapper.designWidth, Decls$1.GRoot.inst.stageWrapper.designHeight) / Math.max(Decls$1.GRoot.inst.stageWidth, Decls$1.GRoot.inst.stageHeight);\n            //threshold, if too slow, stop it\n            let ratio = 0;\n            if (this.$pageMode || !fairygui_module_isMobile.any) {\n                if (v2 > 500)\n                    ratio = Math.pow((v2 - 500) / 500, 2);\n            }\n            else {\n                if (v2 > 1000)\n                    ratio = Math.pow((v2 - 1000) / 1000, 2);\n            }\n            if (ratio != 0) {\n                if (ratio > 1)\n                    ratio = 1;\n                v2 *= ratio;\n                v *= ratio;\n                this.$velocity[axis] = v;\n                duration = Math.log(60 / v2) / Math.log(this.$decelerationRate) / 60;\n                const change = (v / 60 - 1) / (1 - this.$decelerationRate);\n                //const change: number = Math.floor(v * duration * 0.4);\n                pos += change;\n            }\n        }\n        if (duration < ScrollPane.TWEEN_DEFAULT_DURATION)\n            duration = ScrollPane.TWEEN_DEFAULT_DURATION;\n        this.$tweenDuration[axis] = duration;\n        return pos;\n    }\n    fixDuration(axis, oldChange) {\n        if (this.$tweenChange[axis] == 0 ||\n            Math.abs(this.$tweenChange[axis]) >= Math.abs(oldChange))\n            return;\n        let newDuration = Math.abs(this.$tweenChange[axis] / oldChange) *\n            this.$tweenDuration[axis];\n        if (newDuration < ScrollPane.TWEEN_DEFAULT_DURATION)\n            newDuration = ScrollPane.TWEEN_DEFAULT_DURATION;\n        this.$tweenDuration[axis] = newDuration;\n    }\n    killTween() {\n        //tweening == 1: set to end immediately\n        if (this.$tweening == 1) {\n            this.$container.set({\n                x: this.$tweenStart.x + this.$tweenChange.x,\n                y: this.$tweenStart.y + this.$tweenChange.y\n            });\n            let evt = new createjs.Event(\"__scroll\" /* SCROLL */, true, false);\n            this.dispatchEvent(evt, this);\n        }\n        this.$tweening = 0;\n        GTimer.inst.remove(this.tweenUpdate, this);\n        let evt = new createjs.Event(\"__scrollEnd\" /* SCROLL_END */, true, false);\n        this.dispatchEvent(evt, this);\n    }\n    checkRefreshBar() {\n        if (this.$header == null && this.$footer == null)\n            return;\n        const pos = this.$container[this.$refreshBarAxis];\n        if (this.$header != null) {\n            if (pos > 0) {\n                if (this.$header.displayObject.parent == null)\n                    this.$maskContainer.addChildAt(this.$header.displayObject, 0);\n                const pt = ScrollPane.sHelperPoint;\n                pt.setValues(this.$header.width, this.$header.height);\n                pt[this.$refreshBarAxis] = pos;\n                this.$header.setSize(pt.x, pt.y);\n            }\n            else {\n                if (this.$header.displayObject.parent != null)\n                    this.$maskContainer.removeChild(this.$header.displayObject);\n            }\n        }\n        if (this.$footer != null) {\n            var max = this.$overlapSize[this.$refreshBarAxis];\n            if (pos < -max || (max == 0 && this.$footerLockedSize > 0)) {\n                if (this.$footer.displayObject.parent == null)\n                    this.$maskContainer.addChildAt(this.$footer.displayObject, 0);\n                const pt = ScrollPane.sHelperPoint;\n                pt.setValues(this.$footer.x, this.$footer.y);\n                if (max > 0)\n                    pt[this.$refreshBarAxis] =\n                        pos + this.$contentSize[this.$refreshBarAxis];\n                else\n                    pt[this.$refreshBarAxis] = Math.max(Math.min(pos + this.$viewSize[this.$refreshBarAxis], this.$viewSize[this.$refreshBarAxis] - this.$footerLockedSize), this.$viewSize[this.$refreshBarAxis] -\n                        this.$contentSize[this.$refreshBarAxis]);\n                this.$footer.setXY(pt.x, pt.y);\n                pt.setValues(this.$footer.width, this.$footer.height);\n                if (max > 0)\n                    pt[this.$refreshBarAxis] = -max - pos;\n                else\n                    pt[this.$refreshBarAxis] =\n                        this.$viewSize[this.$refreshBarAxis] -\n                            this.$footer[this.$refreshBarAxis];\n                this.$footer.setSize(pt.x, pt.y);\n            }\n            else {\n                if (this.$footer.displayObject.parent != null)\n                    this.$maskContainer.removeChild(this.$footer.displayObject);\n            }\n        }\n    }\n    tweenUpdate() {\n        var nx = this.runTween('x');\n        var ny = this.runTween('y');\n        this.$container.set({ x: nx, y: ny });\n        if (this.$tweening == 2) {\n            if (this.$overlapSize.x > 0)\n                this.$xPos = NumberUtil.clamp(-nx, 0, this.$overlapSize.x);\n            if (this.$overlapSize.y > 0)\n                this.$yPos = NumberUtil.clamp(-ny, 0, this.$overlapSize.y);\n            if (this.$pageMode)\n                this.updatePageController();\n        }\n        if (this.$tweenChange.x == 0 && this.$tweenChange.y == 0) {\n            this.$tweening = 0;\n            GTimer.inst.remove(this.tweenUpdate, this);\n            this.loopCheckingCurrent();\n            this.syncScrollBar(true);\n            this.checkRefreshBar();\n            let scrollEvent = new createjs.Event(\"__scroll\" /* SCROLL */, true, false);\n            this.dispatchEvent(scrollEvent, this);\n            let scrollEndEvent = new createjs.Event(\"__scrollEnd\" /* SCROLL_END */, true, false);\n            this.dispatchEvent(scrollEndEvent, this);\n        }\n        else {\n            this.syncScrollBar(false);\n            this.checkRefreshBar();\n            let scrollEvent = new createjs.Event(\"__scroll\" /* SCROLL */, true, false);\n            this.dispatchEvent(scrollEvent, this);\n        }\n    }\n    runTween(axis) {\n        const delta = createjs.Ticker.interval;\n        let newValue;\n        if (this.$tweenChange[axis] != 0) {\n            this.$tweenTime[axis] += delta * createjs.Ticker.framerate;\n            if (this.$tweenTime[axis] >= this.$tweenDuration[axis]) {\n                newValue =\n                    this.$tweenStart[axis] + this.$tweenChange[axis];\n                this.$tweenChange[axis] = 0;\n            }\n            else {\n                const ratio = ScrollPane.$easeTypeFunc(this.$tweenTime[axis], this.$tweenDuration[axis]);\n                newValue =\n                    this.$tweenStart[axis] +\n                        Math.floor(this.$tweenChange[axis] * ratio);\n            }\n            var threshold1 = 0;\n            var threshold2 = -this.$overlapSize[axis];\n            if (this.$headerLockedSize > 0 && this.$refreshBarAxis == axis)\n                threshold1 = this.$headerLockedSize;\n            if (this.$footerLockedSize > 0 && this.$refreshBarAxis == axis) {\n                var max = this.$overlapSize[this.$refreshBarAxis];\n                if (max == 0)\n                    max = Math.max(this.$contentSize[this.$refreshBarAxis] +\n                        this.$footerLockedSize -\n                        this.$viewSize[this.$refreshBarAxis], 0);\n                else\n                    max += this.$footerLockedSize;\n                threshold2 = -max;\n            }\n            if (this.$tweening == 2 && this.$bouncebackEffect) {\n                if ((newValue > 20 + threshold1 && this.$tweenChange[axis] > 0) ||\n                    (newValue > threshold1 && this.$tweenChange[axis] == 0)) {\n                    this.$tweenTime[axis] = 0;\n                    this.$tweenDuration[axis] = ScrollPane.TWEEN_DEFAULT_DURATION;\n                    this.$tweenChange[axis] = -newValue + threshold1;\n                    this.$tweenStart[axis] = newValue;\n                }\n                else if ((newValue < threshold2 - 20 && this.$tweenChange[axis] < 0) ||\n                    (newValue < threshold2 && this.$tweenChange[axis] == 0)) {\n                    this.$tweenTime[axis] = 0;\n                    this.$tweenDuration[axis] = ScrollPane.TWEEN_DEFAULT_DURATION;\n                    this.$tweenChange[axis] = threshold2 - newValue;\n                    this.$tweenStart[axis] = newValue;\n                }\n            }\n            else {\n                if (newValue > threshold1) {\n                    newValue = threshold1;\n                    this.$tweenChange[axis] = 0;\n                }\n                else if (newValue < threshold2) {\n                    newValue = threshold2;\n                    this.$tweenChange[axis] = 0;\n                }\n            }\n        }\n        else\n            newValue = this.$container[axis];\n        return newValue;\n    }\n}\nScrollPane.$easeTypeFunc = (t, d) => {\n    return (t = t / d - 1) * t * t + 1;\n}; //cubic out\nScrollPane.$gestureFlag = 0;\nScrollPane.sHelperPoint = new createjs.Point();\nScrollPane.sHelperRect = new createjs.Rectangle();\nScrollPane.sEndPos = new createjs.Point();\nScrollPane.sOldChange = new createjs.Point();\nScrollPane.TWEEN_DEFAULT_DURATION = 0.4;\nScrollPane.TWEEN_MANUALLY_SET_DURATION = 0.5; //tween duration used when call setPos(useAni=true)\nScrollPane.PULL_DIST_RATIO = 0.5; //pulldown / pullup distance ratio of the whole viewport\n\nclass Binder {\n    static create(func, context, ...args) {\n        if (!context)\n            return func;\n        return (function () {\n            let fullargs = arguments.length > 0 ? [].concat(Array.prototype.slice.call(arguments)).concat(args) : [].concat(args);\n            func.apply(context, fullargs);\n        });\n    }\n}\n\nclass Transition {\n    constructor(owner) {\n        this.autoPlayRepeat = 1;\n        this.autoPlayDelay = 0;\n        this.$ownerBaseX = 0;\n        this.$ownerBaseY = 0;\n        this.$totalTimes = 0;\n        this.$startTime = 0;\n        this.$totalTasks = 0;\n        this.$playing = false;\n        this.$options = 0;\n        this.$maxTime = 0;\n        this.$owner = owner;\n        this.$items = [];\n        this.$owner.on(\"__visibleChanged\" /* VISIBLE_CHANGED */, this.$ownerVisibleChanged, this);\n    }\n    // private $ownerVisibleChanged(vis: boolean, owner: GComponent): void {\n    $ownerVisibleChanged(event) {\n        let vis = event.data;\n        if ((this.$options & Transition.OPTION_AUTO_STOP_DISABLED) == 0 && vis === false)\n            this.stop((this.$options & Transition.OPTION_AUTO_STOP_AT_END) != 0 ? true : false, false);\n    }\n    get autoPlay() {\n        return this.$autoPlay;\n    }\n    set autoPlay(value) {\n        if (this.$autoPlay != value) {\n            this.$autoPlay = value;\n            if (this.$autoPlay) {\n                if (this.$owner.onStage)\n                    this.play({\n                        times: this.autoPlayRepeat,\n                        delay: this.autoPlayDelay\n                    });\n            }\n            else {\n                if (!this.$owner.onStage)\n                    this.stop(false, true);\n            }\n        }\n    }\n    changeRepeat(value) {\n        this.$totalTimes = value | 0;\n    }\n    /**\n       * Play transition by specified settings:\n       * 1) pass whole parameters:\n              onComplete?: (...args:any[]) => void,\n              onCompleteObj?: any,\n              onCompleteParam?: any,\n              times: number,\n              delay: number\n       * 2) just pass 1 object which implements TransitionPlaySetting (recommended)\n       */\n    play(...args) {\n        if (args.length && typeof args[0] == 'object') {\n            let obj = args[0];\n            this.$play(obj.onComplete, obj.onCompleteObj, obj.onCompleteParam, obj.times || 1, obj.delay || 0, false);\n        }\n        else\n            this.$play(args[0], args[1], args[2], args[3] || 1, args[4] || 0, false);\n    }\n    /**\n       * Play transition by specified settings:\n       * 1) pass whole parameters:\n              onComplete?: (...args:any[]) => void,\n              onCompleteObj?: any,\n              onCompleteParam?: any,\n              times: number,\n              delay: number\n       * 2) just pass 1 object which implements TransitionPlaySetting (recommended)\n       */\n    playReverse(...args) {\n        if (args.length && typeof args[0] == 'object') {\n            let obj = args[0];\n            this.$play(obj.onComplete, obj.onCompleteObj, obj.onCompleteParam, obj.times || 1, obj.delay || 0, true);\n        }\n        else\n            this.$play(args[0], args[1], args[2], args[3] || 1, args[4] || 0, true);\n    }\n    $play(onComplete, onCompleteObj, onCompleteParam, times, delay, reversed = false) {\n        this.stop();\n        if (times == 0)\n            times = 1;\n        else if (times == -1)\n            times = Number.MAX_VALUE;\n        this.$totalTimes = times;\n        this.$startTime = 0;\n        this.$reversed = reversed;\n        this.internalPlay(delay);\n        this.$playing = this.$totalTasks > 0;\n        if (this.$playing) {\n            this.$onComplete = onComplete;\n            this.$onCompleteParam = onCompleteParam;\n            this.$onCompleteObj = onCompleteObj;\n            if ((this.$options & Transition.OPTION_IGNORE_DISPLAY_CONTROLLER) != 0) {\n                this.$items.forEach(item => {\n                    if (item.target != null && item.target != this.$owner)\n                        item.lockToken = item.target.lockGearDisplay();\n                }, this);\n            }\n        }\n        else if (onComplete != null) {\n            onCompleteParam && onCompleteParam.length\n                ? onComplete.apply(onCompleteObj, onCompleteParam)\n                : onComplete.call(onCompleteObj, onCompleteParam);\n        }\n    }\n    stop(setToComplete = true, processCallback = false) {\n        if (this.$playing) {\n            this.$playing = false;\n            this.$totalTasks = 0;\n            this.$totalTimes = 0;\n            let func = this.$onComplete;\n            let param = this.$onCompleteParam;\n            let thisObj = this.$onCompleteObj;\n            this.$onComplete = null;\n            this.$onCompleteParam = null;\n            this.$onCompleteObj = null;\n            let cnt = this.$items.length;\n            let item;\n            if (this.$reversed) {\n                for (let i = cnt - 1; i >= 0; i--) {\n                    item = this.$items[i];\n                    if (item.target == null)\n                        continue;\n                    this.stopItem(item, setToComplete);\n                }\n            }\n            else {\n                for (let i = 0; i < cnt; i++) {\n                    item = this.$items[i];\n                    if (item.target == null)\n                        continue;\n                    this.stopItem(item, setToComplete);\n                }\n            }\n            if (processCallback && func != null)\n                param && param.length > 0 ? func.apply(thisObj, param) : func.call(thisObj, param);\n        }\n    }\n    stopItem(item, setToComplete) {\n        if (item.lockToken != 0) {\n            item.target.releaseGearDisplay(item.lockToken);\n            item.lockToken = 0;\n        }\n        if (item.type == 12 /* ColorFilter */ && item.filterCreated)\n            item.target.filters = null;\n        if (item.completed)\n            return;\n        this.disposeTween(item);\n        if (item.type == 10 /* Transition */) {\n            let trans = item.target.getTransition(item.value.s);\n            if (trans != null)\n                trans.stop(setToComplete, false);\n        }\n        else if (item.type == 11 /* Shake */) {\n            GTimer.inst.remove(item.$shake, item);\n            item.target.$gearLocked = true;\n            item.target.setXY(item.target.x - item.startValue.f1, item.target.y - item.startValue.f2);\n            item.target.$gearLocked = false;\n        }\n        else {\n            if (setToComplete) {\n                if (item.tween) {\n                    if (!item.yoyo || item.repeat % 2 == 0)\n                        this.applyValue(item, this.$reversed ? item.startValue : item.endValue);\n                    else\n                        this.applyValue(item, this.$reversed ? item.endValue : item.startValue);\n                }\n                else if (item.type != 9 /* Sound */)\n                    this.applyValue(item, item.value);\n            }\n        }\n    }\n    dispose() {\n        GTimer.inst.remove(this.internalPlay, this);\n        this.$owner.off(\"__visibleChanged\" /* VISIBLE_CHANGED */, this.$ownerVisibleChanged);\n        this.$playing = false;\n        this.$items.forEach(item => {\n            if (item.target == null || item.completed)\n                return;\n            this.disposeTween(item);\n            if (item.type == 10 /* Transition */) {\n                let trans = item.target.getTransition(item.value.s);\n                if (trans != null)\n                    trans.dispose();\n            }\n            else if (item.type == 11 /* Shake */)\n                GTimer.inst.remove(item.$shake, item);\n        }, this);\n    }\n    get playing() {\n        return this.$playing;\n    }\n    setValue(label, ...args) {\n        this.$items.forEach(item => {\n            if (item.label == null && item.label2 == null)\n                return;\n            let value;\n            if (item.label == label) {\n                if (item.tween)\n                    value = item.startValue;\n                else\n                    value = item.value;\n            }\n            else if (item.label2 == label)\n                value = item.endValue;\n            else\n                return;\n            switch (item.type) {\n                case 0 /* XY */:\n                case 1 /* Size */:\n                case 3 /* Pivot */:\n                case 2 /* Scale */:\n                case 13 /* Skew */:\n                    value.b1 = true;\n                    value.b2 = true;\n                    value.f1 = parseFloat(args[0]);\n                    value.f2 = parseFloat(args[1]);\n                    break;\n                case 4 /* Alpha */:\n                    value.f1 = parseFloat(args[0]);\n                    break;\n                case 5 /* Rotation */:\n                    value.i = parseInt(args[0]);\n                    break;\n                case 6 /* Color */:\n                    value.c = args[0];\n                    break;\n                case 7 /* Animation */:\n                    value.i = parseInt(args[0]);\n                    if (args.length > 1)\n                        value.b = args[1];\n                    break;\n                case 8 /* Visible */:\n                    value.b = args[0];\n                    break;\n                case 9 /* Sound */:\n                    value.s = args[0];\n                    if (args.length > 1)\n                        value.f1 = parseFloat(args[1]);\n                    break;\n                case 10 /* Transition */:\n                    value.s = args[0];\n                    if (args.length > 1)\n                        value.i = parseInt(args[1]);\n                    break;\n                case 11 /* Shake */:\n                    value.f1 = parseFloat(args[0]);\n                    if (args.length > 1)\n                        value.f2 = parseFloat(args[1]);\n                    break;\n                case 12 /* ColorFilter */:\n                    value.f1 = parseFloat(args[0]);\n                    value.f2 = parseFloat(args[1]);\n                    value.f3 = parseFloat(args[2]);\n                    value.f4 = parseFloat(args[3]);\n                    break;\n            }\n        }, this);\n    }\n    setHook(label, callback, thisObj) {\n        let cnt = this.$items.length;\n        for (let i = 0; i < cnt; i++) {\n            let item = this.$items[i];\n            if (item.label == label) {\n                item.hook = callback;\n                item.hookObj = thisObj;\n                break;\n            }\n            else if (item.label2 == label) {\n                item.hook2 = callback;\n                item.hook2Obj = thisObj;\n                break;\n            }\n        }\n    }\n    clearHooks() {\n        this.$items.forEach(item => {\n            item.hook = null;\n            item.hookObj = null;\n            item.hook2 = null;\n            item.hook2Obj = null;\n        }, this);\n    }\n    setTarget(label, newTarget) {\n        this.$items.forEach(item => {\n            if (item.label == label)\n                item.targetId = newTarget.id;\n        }, this);\n    }\n    setDuration(label, value) {\n        this.$items.forEach(item => {\n            if (item.tween && item.label == label)\n                item.duration = value;\n        }, this);\n    }\n    updateFromRelations(targetId, dx, dy) {\n        this.$items.forEach(item => {\n            if (item.type == 0 /* XY */ && item.targetId == targetId) {\n                if (item.tween) {\n                    item.startValue.f1 += dx;\n                    item.startValue.f2 += dy;\n                    item.endValue.f1 += dx;\n                    item.endValue.f2 += dy;\n                }\n                else {\n                    item.value.f1 += dx;\n                    item.value.f2 += dy;\n                }\n            }\n        }, this);\n    }\n    internalPlay(delay = 0) {\n        this.$ownerBaseX = this.$owner.x;\n        this.$ownerBaseY = this.$owner.y;\n        this.$totalTasks = 0;\n        this.$items.forEach(item => {\n            if (item.targetId)\n                item.target = this.$owner.getChildById(item.targetId);\n            else\n                item.target = this.$owner;\n            if (item.target == null)\n                return;\n            let startTime;\n            this.disposeTween(item);\n            if (item.tween) {\n                if (this.$reversed)\n                    startTime = delay + this.$maxTime - item.time - item.duration;\n                else\n                    startTime = delay + item.time;\n                if (startTime > 0) {\n                    this.$totalTasks++;\n                    item.completed = false;\n                    item.tweener = createjs.Tween.get(item.value)\n                        .wait(startTime * 1000)\n                        .call(this.$delayCall, [item], this);\n                }\n                else\n                    this.startTween(item);\n            }\n            else {\n                if (this.$reversed)\n                    startTime = delay + this.$maxTime - item.time;\n                else\n                    startTime = delay + item.time;\n                if (startTime <= 0)\n                    this.applyValue(item, item.value);\n                else {\n                    this.$totalTasks++;\n                    item.completed = false;\n                    item.tweener = createjs.Tween.get(item.value)\n                        .wait(startTime * 1000)\n                        .call(this.$delayCall2, [item], this);\n                }\n            }\n        }, this);\n    }\n    prepareValue(item, toProps, reversed = false) {\n        let startValue;\n        let endValue;\n        if (reversed) {\n            startValue = item.endValue;\n            endValue = item.startValue;\n        }\n        else {\n            startValue = item.startValue;\n            endValue = item.endValue;\n        }\n        switch (item.type) {\n            case 0 /* XY */:\n            case 1 /* Size */:\n                if (item.type == 0 /* XY */) {\n                    if (item.target == this.$owner) {\n                        if (!startValue.b1)\n                            startValue.f1 = 0;\n                        if (!startValue.b2)\n                            startValue.f2 = 0;\n                    }\n                    else {\n                        if (!startValue.b1)\n                            startValue.f1 = item.target.x;\n                        if (!startValue.b2)\n                            startValue.f2 = item.target.y;\n                    }\n                }\n                else {\n                    if (!startValue.b1)\n                        startValue.f1 = item.target.width;\n                    if (!startValue.b2)\n                        startValue.f2 = item.target.height;\n                }\n                item.value.f1 = startValue.f1;\n                item.value.f2 = startValue.f2;\n                if (!endValue.b1)\n                    endValue.f1 = item.value.f1;\n                if (!endValue.b2)\n                    endValue.f2 = item.value.f2;\n                item.value.b1 = startValue.b1 || endValue.b1;\n                item.value.b2 = startValue.b2 || endValue.b2;\n                toProps.f1 = endValue.f1;\n                toProps.f2 = endValue.f2;\n                break;\n            case 2 /* Scale */:\n            case 13 /* Skew */:\n                item.value.f1 = startValue.f1;\n                item.value.f2 = startValue.f2;\n                toProps.f1 = endValue.f1;\n                toProps.f2 = endValue.f2;\n                break;\n            case 4 /* Alpha */:\n                item.value.f1 = startValue.f1;\n                toProps.f1 = endValue.f1;\n                break;\n            case 5 /* Rotation */:\n                item.value.i = startValue.i;\n                toProps.i = endValue.i;\n                break;\n            case 12 /* ColorFilter */:\n                item.value.f1 = startValue.f1;\n                item.value.f2 = startValue.f2;\n                item.value.f3 = startValue.f3;\n                item.value.f4 = startValue.f4;\n                toProps.f1 = endValue.f1;\n                toProps.f2 = endValue.f2;\n                toProps.f3 = endValue.f3;\n                toProps.f4 = endValue.f4;\n                break;\n        }\n    }\n    startTween(item) {\n        let toProps = new TransitionValue();\n        this.prepareValue(item, toProps, this.$reversed);\n        this.applyValue(item, item.value);\n        let completeHandler;\n        if (item.repeat != 0) {\n            item.tweenTimes = 0;\n            completeHandler = Binder.create(this.$tweenRepeatComplete, this, item);\n        }\n        else\n            completeHandler = Binder.create(this.$tweenComplete, this, item);\n        this.$totalTasks++;\n        item.completed = false;\n        this.prepareValue(item, toProps, this.$reversed);\n        item.tweener = createjs.Tween.get(item.value, {\n            onChange: Binder.create(this.$tweenUpdate, this, item)\n        })\n            .to(toProps, item.duration * 1000, item.easeType)\n            .call(completeHandler);\n        if (item.hook != null)\n            item.hook.call(item.hookObj);\n    }\n    $delayCall(item) {\n        this.disposeTween(item);\n        this.$totalTasks--;\n        this.startTween(item);\n    }\n    $delayCall2(item) {\n        this.disposeTween(item);\n        this.$totalTasks--;\n        item.completed = true;\n        this.applyValue(item, item.value);\n        if (item.hook != null)\n            item.hook.call(item.hookObj);\n        this.checkAllComplete();\n    }\n    $tweenUpdate(event, item) {\n        this.applyValue(item, item.value);\n    }\n    $tweenComplete(event, item) {\n        this.disposeTween(item);\n        this.$totalTasks--;\n        item.completed = true;\n        if (item.hook2 != null)\n            item.hook2.call(item.hook2Obj);\n        this.checkAllComplete();\n    }\n    $tweenRepeatComplete(event, item) {\n        item.tweenTimes++;\n        if (item.repeat == -1 || item.tweenTimes < item.repeat + 1) {\n            let toProps = new TransitionValue();\n            let reversed;\n            if (item.yoyo) {\n                if (this.$reversed)\n                    reversed = item.tweenTimes % 2 == 0;\n                else\n                    reversed = item.tweenTimes % 2 == 1;\n            }\n            else\n                reversed = this.$reversed;\n            this.prepareValue(item, toProps, reversed);\n            this.disposeTween(item);\n            item.tweener = createjs.Tween.get(item.value, {\n                onChange: Binder.create(this.$tweenUpdate, this, item)\n            })\n                .to(toProps, item.duration * 1000, item.easeType)\n                .call(this.$tweenRepeatComplete, [null, item], this);\n        }\n        else\n            this.$tweenComplete(null, item);\n    }\n    disposeTween(item) {\n        if (!item)\n            return;\n        if (item.tweener) {\n            item.tweener.paused = true;\n            item.tweener.removeAllEventListeners();\n            createjs.Tween.removeTweens(item.value);\n            item.tweener = null;\n        }\n    }\n    $playTransComplete(item) {\n        this.disposeTween(item);\n        this.$totalTasks--;\n        item.completed = true;\n        this.checkAllComplete();\n    }\n    checkAllComplete() {\n        if (this.$playing && this.$totalTasks == 0) {\n            if (this.$totalTimes < 0) {\n                //the reason we don't call 'internalPlay' immediately here is because of the onChange handler issue, the handler's been calling all the time even the tween is in waiting/complete status.\n                GTimer.inst.callLater(this.internalPlay, this, 0);\n            }\n            else {\n                this.$totalTimes--;\n                if (this.$totalTimes > 0)\n                    GTimer.inst.callLater(this.internalPlay, this, 0);\n                else {\n                    this.$playing = false;\n                    this.$items.forEach(item => {\n                        if (item.target != null) {\n                            if (item.lockToken != 0) {\n                                item.target.releaseGearDisplay(item.lockToken);\n                                item.lockToken = 0;\n                            }\n                            if (item.filterCreated) {\n                                item.filterCreated = false;\n                                item.target.filters = null;\n                            }\n                            this.disposeTween(item);\n                        }\n                    });\n                    if (this.$onComplete != null) {\n                        let func = this.$onComplete;\n                        let param = this.$onCompleteParam;\n                        let thisObj = this.$onCompleteObj;\n                        this.$onComplete = null;\n                        this.$onCompleteParam = null;\n                        this.$onCompleteObj = null;\n                        param && param.length ? func.apply(thisObj, param) : func.call(thisObj, param);\n                    }\n                }\n            }\n        }\n    }\n    applyValue(item, value) {\n        item.target.$gearLocked = true;\n        switch (item.type) {\n            case 0 /* XY */:\n                if (item.target == this.$owner) {\n                    let f1 = 0, f2 = 0;\n                    if (!value.b1)\n                        f1 = item.target.x;\n                    else\n                        f1 = value.f1 + this.$ownerBaseX;\n                    if (!value.b2)\n                        f2 = item.target.y;\n                    else\n                        f2 = value.f2 + this.$ownerBaseY;\n                    item.target.setXY(f1, f2);\n                }\n                else {\n                    if (!value.b1)\n                        value.f1 = item.target.x;\n                    if (!value.b2)\n                        value.f2 = item.target.y;\n                    item.target.setXY(value.f1, value.f2);\n                }\n                break;\n            case 1 /* Size */:\n                if (!value.b1)\n                    value.f1 = item.target.width;\n                if (!value.b2)\n                    value.f2 = item.target.height;\n                item.target.setSize(value.f1, value.f2);\n                break;\n            case 3 /* Pivot */:\n                item.target.setPivot(value.f1, value.f2);\n                break;\n            case 4 /* Alpha */:\n                item.target.alpha = value.f1;\n                break;\n            case 5 /* Rotation */:\n                item.target.rotation = value.i;\n                break;\n            case 2 /* Scale */:\n                item.target.setScale(value.f1, value.f2);\n                break;\n            case 13 /* Skew */:\n                item.target.setSkew(value.f1, value.f2);\n                break;\n            case 6 /* Color */:\n                if (isColorGear(item.target))\n                    item.target.color = value.c;\n                break;\n            case 7 /* Animation */:\n                if (isAnimationGear(item.target)) {\n                    if (!value.b1)\n                        value.i = item.target.frame;\n                    item.target.frame = value.i;\n                    item.target.playing = value.b;\n                }\n                break;\n            case 8 /* Visible */:\n                item.target.visible = value.b;\n                break;\n            case 10 /* Transition */:\n                let trans = item.target.getTransition(value.s);\n                if (trans != null) {\n                    if (value.i == 0)\n                        trans.stop(false, true);\n                    else if (trans.playing)\n                        trans.$totalTimes = value.i == -1 ? Number.MAX_VALUE : value.i;\n                    else {\n                        item.completed = false;\n                        this.$totalTasks++;\n                        if (this.$reversed)\n                            trans.playReverse(this.$playTransComplete, this, item, item.value.i);\n                        else\n                            trans.play(this.$playTransComplete, this, item, item.value.i);\n                    }\n                }\n                break;\n            case 9 /* Sound */:\n                if (this.$playing && item.time >= this.$startTime) {\n                    if (!value.audioClip) {\n                        var pi = UIPackage.getItemByURL(value.s);\n                        if (pi)\n                            value.audioClip = pi.owner.getItemAsset(pi);\n                    }\n                    if (value.audioClip) {\n                        Decls$1.GRoot.inst.playOneShotSound(value.audioClip, value.f1);\n                    }\n                }\n                break;\n            case 11 /* Shake */:\n                item.startValue.f1 = 0; //offsetX\n                item.startValue.f2 = 0; //offsetY\n                item.startValue.f3 = item.value.f2; //shakePeriod\n                GTimer.inst.add(1, 0, item.$shake, item, [this]);\n                this.$totalTasks++;\n                item.completed = false;\n                break;\n            case 12 /* ColorFilter */:\n                item.target.updateColorComponents(value.f1, value.f2, value.f3, value.f4);\n                break;\n        }\n        item.target.$gearLocked = false;\n    }\n    /**@internal */\n    $shakeItem(item, elapsedMS) {\n        let r = Math.ceil((item.value.f1 * item.startValue.f3) / item.value.f2);\n        let rx = (Math.random() * 2 - 1) * r;\n        let ry = (Math.random() * 2 - 1) * r;\n        rx = rx > 0 ? Math.ceil(rx) : Math.floor(rx);\n        ry = ry > 0 ? Math.ceil(ry) : Math.floor(ry);\n        item.target.$gearLocked = true;\n        item.target.setXY(item.target.x - item.startValue.f1 + rx, item.target.y - item.startValue.f2 + ry);\n        item.target.$gearLocked = false;\n        item.startValue.f1 = rx;\n        item.startValue.f2 = ry;\n        item.startValue.f3 -= elapsedMS / 1000;\n        if (item.startValue.f3 <= 0) {\n            item.target.$gearLocked = true;\n            item.target.setXY(item.target.x - item.startValue.f1, item.target.y - item.startValue.f2);\n            item.target.$gearLocked = false;\n            item.completed = true;\n            this.$totalTasks--;\n            GTimer.inst.remove(item.$shake, item);\n            this.checkAllComplete();\n        }\n    }\n    setup(xml) {\n        this.name = xml.attributes.name;\n        let str = xml.attributes.options;\n        if (str)\n            this.$options = parseInt(str);\n        this.$autoPlay = xml.attributes.autoPlay == 'true';\n        if (this.$autoPlay) {\n            str = xml.attributes.autoPlayRepeat;\n            if (str)\n                this.autoPlayRepeat = parseInt(str);\n            str = xml.attributes.autoPlayDelay;\n            if (str)\n                this.autoPlayDelay = parseFloat(str);\n        }\n        let col = xml.children;\n        col.forEach(cxml => {\n            if (cxml.nodeName != 'item')\n                return;\n            let item = new TransitionItem();\n            this.$items.push(item);\n            item.time = parseInt(cxml.attributes.time) / Transition.FRAME_RATE;\n            item.targetId = cxml.attributes.target;\n            str = cxml.attributes.type;\n            switch (str) {\n                case 'XY':\n                    item.type = 0 /* XY */;\n                    break;\n                case 'Size':\n                    item.type = 1 /* Size */;\n                    break;\n                case 'Scale':\n                    item.type = 2 /* Scale */;\n                    break;\n                case 'Pivot':\n                    item.type = 3 /* Pivot */;\n                    break;\n                case 'Alpha':\n                    item.type = 4 /* Alpha */;\n                    break;\n                case 'Rotation':\n                    item.type = 5 /* Rotation */;\n                    break;\n                case 'Color':\n                    item.type = 6 /* Color */;\n                    break;\n                case 'Animation':\n                    item.type = 7 /* Animation */;\n                    break;\n                case 'Visible':\n                    item.type = 8 /* Visible */;\n                    break;\n                case 'Sound':\n                    item.type = 9 /* Sound */;\n                    break;\n                case 'Transition':\n                    item.type = 10 /* Transition */;\n                    break;\n                case 'Shake':\n                    item.type = 11 /* Shake */;\n                    break;\n                case 'ColorFilter':\n                    item.type = 12 /* ColorFilter */;\n                    break;\n                case 'Skew':\n                    item.type = 13 /* Skew */;\n                    break;\n                default:\n                    item.type = 14 /* Unknown */;\n                    break;\n            }\n            item.tween = cxml.attributes.tween == 'true';\n            item.label = cxml.attributes.label;\n            if (item.tween) {\n                item.duration = parseInt(cxml.attributes.duration) / Transition.FRAME_RATE;\n                if (item.time + item.duration > this.$maxTime)\n                    this.$maxTime = item.time + item.duration;\n                str = cxml.attributes.ease;\n                if (str)\n                    item.easeType = ParseEaseType(str);\n                str = cxml.attributes.repeat;\n                if (str)\n                    item.repeat = parseInt(str);\n                item.yoyo = cxml.attributes.yoyo == 'true';\n                item.label2 = cxml.attributes.label2;\n                let v = cxml.attributes.endValue;\n                if (v) {\n                    this.decodeValue(item.type, cxml.attributes.startValue, item.startValue);\n                    this.decodeValue(item.type, v, item.endValue);\n                }\n                else {\n                    item.tween = false;\n                    this.decodeValue(item.type, cxml.attributes.startValue, item.value);\n                }\n            }\n            else {\n                if (item.time > this.$maxTime)\n                    this.$maxTime = item.time;\n                this.decodeValue(item.type, cxml.attributes.value, item.value);\n            }\n        }, this);\n    }\n    decodeValue(type, str, value) {\n        let arr;\n        switch (type) {\n            case 0 /* XY */:\n            case 1 /* Size */:\n            case 3 /* Pivot */:\n            case 13 /* Skew */:\n                arr = str.split(',');\n                if (arr[0] == '-') {\n                    value.b1 = false;\n                }\n                else {\n                    value.f1 = parseFloat(arr[0]);\n                    value.b1 = true;\n                }\n                if (arr[1] == '-') {\n                    value.b2 = false;\n                }\n                else {\n                    value.f2 = parseFloat(arr[1]);\n                    value.b2 = true;\n                }\n                break;\n            case 4 /* Alpha */:\n                value.f1 = parseFloat(str);\n                break;\n            case 5 /* Rotation */:\n                value.i = parseInt(str);\n                break;\n            case 2 /* Scale */:\n                arr = str.split(',');\n                value.f1 = parseFloat(arr[0]);\n                value.f2 = parseFloat(arr[1]);\n                break;\n            case 6 /* Color */:\n                value.c = StringUtil.HEX2RGB(str);\n                break;\n            case 7 /* Animation */:\n                arr = str.split(',');\n                if (arr[0] == '-') {\n                    value.b1 = false;\n                }\n                else {\n                    value.i = parseInt(arr[0]);\n                    value.b1 = true;\n                }\n                value.b = arr[1] == 'p';\n                break;\n            case 8 /* Visible */:\n                value.b = str == 'true';\n                break;\n            case 9 /* Sound */:\n                arr = str.split(',');\n                value.s = arr[0];\n                if (arr.length > 1) {\n                    let intv = parseInt(arr[1]);\n                    if (intv == 0 || intv == 100)\n                        value.f1 = 1;\n                    else\n                        value.f1 = intv / 100;\n                }\n                else\n                    value.f1 = 1;\n                break;\n            case 10 /* Transition */:\n                arr = str.split(',');\n                value.s = arr[0];\n                if (arr.length > 1)\n                    value.i = parseInt(arr[1]);\n                else\n                    value.i = 1;\n                break;\n            case 11 /* Shake */:\n                arr = str.split(',');\n                value.f1 = parseFloat(arr[0]);\n                value.f2 = parseFloat(arr[1]);\n                break;\n            case 12 /* ColorFilter */:\n                arr = str.split(',');\n                value.f1 = parseFloat(arr[0]);\n                value.f2 = parseFloat(arr[1]);\n                value.f3 = parseFloat(arr[2]);\n                value.f4 = parseFloat(arr[3]);\n                break;\n        }\n    }\n}\nTransition.OPTION_IGNORE_DISPLAY_CONTROLLER = 1;\nTransition.OPTION_AUTO_STOP_DISABLED = 1 >> 1;\nTransition.OPTION_AUTO_STOP_AT_END = 1 >> 2;\nTransition.FRAME_RATE = 24;\nclass TransitionItem {\n    constructor() {\n        this.time = 0;\n        this.type = 0;\n        this.duration = 0;\n        this.repeat = 0;\n        this.yoyo = false;\n        this.tween = false;\n        this.tweenTimes = 0;\n        this.completed = false;\n        this.lockToken = 0;\n        this.easeType = ParseEaseType('Quad.Out');\n        this.value = new TransitionValue();\n        this.startValue = new TransitionValue();\n        this.endValue = new TransitionValue();\n    }\n    /**@internal */\n    $shake(trans, elapsedMS) {\n        trans.$shakeItem(this, elapsedMS);\n    }\n}\nclass TransitionValue {\n    constructor() {\n        this.f1 = 0;\n        this.f2 = 0;\n        this.f3 = 0;\n        this.f4 = 0;\n        this.i = 0;\n        this.b = false;\n        this.b1 = true;\n        this.b2 = true;\n    }\n}\n\nclass Margin {\n    constructor() {\n        this.left = 0;\n        this.right = 0;\n        this.top = 0;\n        this.bottom = 0;\n    }\n    parse(str) {\n        if (!str) {\n            this.left = this.right = this.top = this.bottom = 0;\n            return;\n        }\n        let arr = str.split(\",\");\n        if (arr.length == 1) {\n            let k = parseInt(arr[0]);\n            this.left = this.right = this.top = this.bottom = k;\n        }\n        else {\n            this.top = parseInt(arr[0]);\n            this.bottom = parseInt(arr[1]);\n            this.left = parseInt(arr[2]);\n            this.right = parseInt(arr[3]);\n        }\n    }\n    copy(source) {\n        this.top = source.top;\n        this.bottom = source.bottom;\n        this.left = source.left;\n        this.right = source.right;\n    }\n}\n\nclass GComponent extends GObject {\n    constructor() {\n        super();\n        this.$sortingChildCount = 0;\n        this.$children = [];\n        this.$controllers = [];\n        this.$transitions = [];\n        this.$margin = new Margin();\n        this.$alignOffset = new createjs.Point();\n    }\n    createDisplayObject() {\n        this.$rootContainer = new UIContainer(this);\n        this.setDisplayObject(this.$rootContainer);\n        this.$container = this.$rootContainer;\n    }\n    dispose() {\n        GTimer.inst.remove(this.$validate, this);\n        this.off('added', this.$added);\n        this.off('removed', this.$removed);\n        this.$transitions.forEach((trans) => {\n            trans.dispose();\n        });\n        let numChildren = this.$children.length;\n        for (let i = numChildren - 1; i >= 0; --i) {\n            let obj = this.$children[i];\n            obj.parent = null; //avoid removeFromParent call\n            obj.dispose();\n        }\n        this.$boundsChanged = false;\n        if (this.$scrollPane)\n            this.$scrollPane.dispose();\n        super.dispose();\n    }\n    get displayListContainer() {\n        return this.$container;\n    }\n    addChild(child) {\n        this.addChildAt(child, this.$children.length);\n        return child;\n    }\n    addChildAt(child, index = 0) {\n        if (!child)\n            throw new Error('Invalid child');\n        let numChildren = this.$children.length;\n        if (index >= 0 && index <= numChildren) {\n            if (child.parent == this)\n                this.setChildIndex(child, index);\n            else {\n                child.removeFromParent();\n                child.parent = this;\n                let cnt = this.$children.length;\n                if (child.sortingOrder != 0) {\n                    this.$sortingChildCount++;\n                    index = this.getInsertPosForSortingChild(child);\n                }\n                else if (this.$sortingChildCount > 0) {\n                    if (index > cnt - this.$sortingChildCount)\n                        index = cnt - this.$sortingChildCount;\n                }\n                if (index == cnt)\n                    this.$children.push(child);\n                else\n                    this.$children.splice(index, 0, child);\n                this.childStateChanged(child);\n                this.setBoundsChangedFlag();\n            }\n            return child;\n        }\n        else\n            throw new Error('Invalid child index');\n    }\n    getInsertPosForSortingChild(target) {\n        let cnt = this.$children.length;\n        let i = 0;\n        for (i = 0; i < cnt; i++) {\n            let child = this.$children[i];\n            if (child == target)\n                continue;\n            if (target.sortingOrder < child.sortingOrder)\n                break;\n        }\n        return i;\n    }\n    removeChild(child, dispose = false) {\n        let childIndex = this.$children.indexOf(child);\n        if (childIndex != -1)\n            this.removeChildAt(childIndex, dispose);\n        return child;\n    }\n    removeChildAt(index, dispose = false) {\n        if (index >= 0 && index < this.numChildren) {\n            let child = this.$children[index];\n            child.parent = null;\n            if (child.sortingOrder != 0)\n                this.$sortingChildCount--;\n            this.$children.splice(index, 1);\n            if (child.inContainer)\n                this.$container.removeChild(child.displayObject);\n            if (dispose === true)\n                child.dispose();\n            this.setBoundsChangedFlag();\n            return child;\n        }\n        else\n            throw new Error('Invalid child index');\n    }\n    removeChildren(beginIndex = 0, endIndex = -1, dispose = false) {\n        if (endIndex < 0 || endIndex >= this.numChildren)\n            endIndex = this.numChildren - 1;\n        for (let i = beginIndex; i <= endIndex; ++i)\n            this.removeChildAt(beginIndex, dispose);\n    }\n    getChildAt(index = 0) {\n        if (index >= 0 && index < this.numChildren)\n            return this.$children[index];\n        else\n            throw new Error('Invalid child index');\n    }\n    getChild(name) {\n        let cnt = this.$children.length;\n        for (let i = 0; i < cnt; ++i) {\n            if (this.$children[i].name == name)\n                return this.$children[i];\n        }\n        return null;\n    }\n    getChildInGroup(name, group) {\n        let cnt = this.$children.length;\n        for (let i = 0; i < cnt; ++i) {\n            let child = this.$children[i];\n            if (child.group == group && child.name == name)\n                return child;\n        }\n        return null;\n    }\n    getChildById(id) {\n        let cnt = this.$children.length;\n        for (let i = 0; i < cnt; ++i) {\n            if (this.$children[i].id == id)\n                return this.$children[i];\n        }\n        return null;\n    }\n    getChildIndex(child) {\n        return this.$children.indexOf(child);\n    }\n    setChildIndex(child, index = 0) {\n        let oldIndex = this.$children.indexOf(child);\n        if (oldIndex == -1)\n            throw new Error('no such child found');\n        if (child.sortingOrder != 0)\n            //no effect\n            return;\n        let cnt = this.$children.length;\n        if (this.$sortingChildCount > 0) {\n            if (index > cnt - this.$sortingChildCount - 1)\n                index = cnt - this.$sortingChildCount - 1;\n        }\n        this.$setChildIndex(child, oldIndex, index);\n    }\n    setChildIndexBefore(child, index) {\n        let oldIndex = this.$children.indexOf(child);\n        if (oldIndex == -1)\n            throw new Error('no such child found');\n        if (child.sortingOrder != 0)\n            //no effect\n            return oldIndex;\n        let cnt = this.$children.length;\n        if (this.$sortingChildCount > 0) {\n            if (index > cnt - this.$sortingChildCount - 1)\n                index = cnt - this.$sortingChildCount - 1;\n        }\n        if (oldIndex < index)\n            return this.$setChildIndex(child, oldIndex, index - 1);\n        else\n            return this.$setChildIndex(child, oldIndex, index);\n    }\n    $setChildIndex(child, oldIndex, index = 0) {\n        let cnt = this.$children.length;\n        if (index > cnt)\n            index = cnt;\n        if (oldIndex == index)\n            return oldIndex;\n        this.$children.splice(oldIndex, 1);\n        this.$children.splice(index, 0, child);\n        if (child.inContainer) {\n            let displayIndex = 0;\n            let childCount = this.$container.children.length;\n            for (let i = 0; i < index; i++) {\n                let g = this.$children[i];\n                if (g.inContainer)\n                    displayIndex++;\n            }\n            if (displayIndex == childCount)\n                displayIndex--;\n            this.$container.setChildIndex(child.displayObject, displayIndex);\n            this.setBoundsChangedFlag();\n        }\n        return index;\n    }\n    swapChildren(child1, child2) {\n        let index1 = this.$children.indexOf(child1);\n        let index2 = this.$children.indexOf(child2);\n        if (index1 == -1 || index2 == -1)\n            throw new Error('no such child found');\n        this.swapChildrenAt(index1, index2);\n    }\n    swapChildrenAt(index1, index2 = 0) {\n        let child1 = this.$children[index1];\n        let child2 = this.$children[index2];\n        this.setChildIndex(child1, index2);\n        this.setChildIndex(child2, index1);\n    }\n    get numChildren() {\n        return this.$children.length;\n    }\n    isAncestorOf(child) {\n        if (child == null)\n            return false;\n        let p = child.parent;\n        while (p) {\n            if (p == this)\n                return true;\n            p = p.parent;\n        }\n        return false;\n    }\n    addController(controller) {\n        this.$controllers.push(controller);\n        controller.$parent = this;\n        this.applyController(controller);\n    }\n    getControllerAt(index) {\n        return this.$controllers[index];\n    }\n    getController(name) {\n        let cnt = this.$controllers.length;\n        for (let i = 0; i < cnt; ++i) {\n            let c = this.$controllers[i];\n            if (c.name == name)\n                return c;\n        }\n        return null;\n    }\n    removeController(c) {\n        let index = this.$controllers.indexOf(c);\n        if (index == -1)\n            throw new Error('controller not exists');\n        c.$parent = null;\n        this.$controllers.splice(index, 1);\n        this.$children.forEach(child => {\n            child.handleControllerChanged(c);\n        });\n    }\n    get controllers() {\n        return this.$controllers;\n    }\n    childStateChanged(child) {\n        if (this.$buildingDisplayList)\n            return;\n        if (child instanceof GGroup) {\n            this.$children.forEach(g => {\n                if (g.group == child)\n                    this.childStateChanged(g);\n            }, this);\n            return;\n        }\n        if (!child.displayObject)\n            return;\n        if (child.finalVisible) {\n            if (!child.displayObject.parent) {\n                let index = 0;\n                let len = this.$children.length;\n                for (let i1 = 0; i1 < len; i1++) {\n                    let g = this.$children[i1];\n                    if (g == child)\n                        break;\n                    if (g.displayObject && g.displayObject.parent)\n                        index++;\n                }\n                this.$container.addChildAt(child.displayObject, index);\n            }\n        }\n        else {\n            if (child.displayObject.parent)\n                this.$container.removeChild(child.displayObject);\n        }\n    }\n    applyController(c) {\n        this.$applyingController = c;\n        this.$children.forEach(child => {\n            child.handleControllerChanged(c);\n        });\n        this.$applyingController = null;\n        c.executeActions();\n    }\n    applyAllControllers() {\n        this.$controllers.forEach(c => {\n            this.applyController(c);\n        }, this);\n    }\n    adjustRadioGroupDepth(obj, c) {\n        let myIndex = -1, maxIndex = -1;\n        this.$children.forEach((child, i) => {\n            if (child == obj) {\n                myIndex = i;\n            }\n            else if ((\"relatedController\" in child) && child.relatedController == c) {\n                if (i > maxIndex)\n                    maxIndex = i;\n            }\n        });\n        if (myIndex < maxIndex) {\n            if (this.$applyingController != null)\n                this.$children[maxIndex].handleControllerChanged(this.$applyingController); //TODO: twice\n            this.swapChildrenAt(myIndex, maxIndex);\n        }\n    }\n    getTransitionAt(index) {\n        return this.$transitions[index];\n    }\n    getTransition(transName) {\n        let cnt = this.$transitions.length;\n        for (let i = 0; i < cnt; ++i) {\n            let trans = this.$transitions[i];\n            if (trans.name == transName)\n                return trans;\n        }\n        return null;\n    }\n    isChildInView(child) {\n        if (this.$rootContainer.scrollRect != null) {\n            return (child.x + child.width >= 0 &&\n                child.x <= this.width &&\n                child.y + child.height >= 0 &&\n                child.y <= this.height);\n        }\n        else if (this.$scrollPane != null) {\n            return this.$scrollPane.isChildInView(child);\n        }\n        else\n            return true;\n    }\n    getFirstChildInView() {\n        let cnt = this.$children.length;\n        for (let i = 0; i < cnt; ++i) {\n            let child = this.$children[i];\n            if (this.isChildInView(child))\n                return i;\n        }\n        return -1;\n    }\n    get scrollPane() {\n        return this.$scrollPane;\n    }\n    get opaque() {\n        return this.$opaque;\n    }\n    set opaque(value) {\n        if (this.$opaque != value) {\n            this.$opaque = value;\n            if (this.$opaque) {\n                this.updateOpaque();\n            }\n            else {\n                if (this.$rootContainer.hitArea &&\n                    this.$rootContainer.hitArea instanceof createjs.DisplayObject) {\n                    this.$rootContainer.hitArea = null;\n                }\n            }\n        }\n    }\n    get margin() {\n        return this.$margin;\n    }\n    set margin(value) {\n        this.$margin.copy(value);\n        if (this.$rootContainer.scrollRect != null) {\n            this.$container.x = this.$margin.left + this.$alignOffset.x;\n            this.$container.y = this.$margin.top + this.$alignOffset.y;\n        }\n        this.handleSizeChanged();\n    }\n    get mask() {\n        return this.$rootContainer.mask;\n    }\n    set mask(obj) {\n        if (!obj)\n            return;\n        if (obj instanceof createjs.Shape)\n            this.$rootContainer.mask = obj;\n    }\n    updateOpaque() {\n        // todo\n        // If hitArea set on a Container, children of the Container will not receive mouse events.  \n        // if (!this.$hitArea) {\n        //     this.$hitArea = new createjs.Shape();\n        // }\n        // this.$hitArea.graphics.beginFill('#000').drawRect(0, 0, this.width, this.height); \n        // (<createjs.Shape>this.$rootContainer.hitArea) = this.$hitArea;\n    }\n    updateScrollRect() {\n        let rect = this.$rootContainer.scrollRect;\n        if (rect == null)\n            rect = new createjs.Rectangle();\n        let w = this.width - this.$margin.right;\n        let h = this.height - this.$margin.bottom;\n        rect.x = rect.y = 0;\n        rect.width = w;\n        rect.height = h;\n        this.$rootContainer.scrollRect = rect;\n    }\n    setupScroll(scrollBarMargin, scroll, scrollBarDisplay, flags, vtScrollBarRes, hzScrollBarRes, headerRes, footerRes) {\n        if (this.$rootContainer == this.$container) {\n            this.$container = new createjs.Container();\n            this.$rootContainer.addChild(this.$container);\n        }\n        this.$scrollPane = new ScrollPane(this, scroll, scrollBarMargin, scrollBarDisplay, flags, vtScrollBarRes, hzScrollBarRes, headerRes, footerRes);\n    }\n    setupOverflow(overflow) {\n        if (overflow == 1 /* Hidden */) {\n            if (this.$rootContainer == this.$container) {\n                this.$container = new createjs.Container();\n                this.$rootContainer.addChild(this.$container);\n            }\n            this.updateScrollRect();\n            this.$container.x = this.$margin.left;\n            this.$container.y = this.$margin.top;\n        }\n        else if (this.$margin.left != 0 || this.$margin.top != 0) {\n            if (this.$rootContainer == this.$container) {\n                this.$container = new createjs.Container();\n                this.$rootContainer.addChild(this.$container);\n            }\n            this.$container.x = this.$margin.left;\n            this.$container.y = this.$margin.top;\n        }\n        this.setBoundsChangedFlag();\n    }\n    handleSizeChanged() {\n        if (this.$scrollPane)\n            this.$scrollPane.onOwnerSizeChanged();\n        else if (this.$rootContainer.scrollRect != null)\n            this.updateScrollRect();\n        if (this.$hitArea)\n            this.$hitArea.graphics.drawRect(this.x, this.y, this.width, this.height);\n        if (this.parent && this.parent.$hitArea) {\n            console.log(1);\n            this.parent.$displayObject.hitArea = null;\n        }\n        if (this.$opaque)\n            this.updateOpaque();\n    }\n    handleGrayedChanged() {\n        let c = this.getController('grayed');\n        if (c != null)\n            c.selectedIndex = this.grayed ? 1 : 0;\n        else\n            super.handleGrayedChanged();\n    }\n    setBoundsChangedFlag() {\n        if (!this.$scrollPane && !this.$trackBounds)\n            return;\n        if (!this.$boundsChanged) {\n            this.$boundsChanged = true;\n            GTimer.inst.callLater(this.$validate, this);\n        }\n    }\n    $validate(dt) {\n        if (this.$boundsChanged)\n            this.updateBounds();\n    }\n    ensureBoundsCorrect() {\n        if (this.$boundsChanged)\n            this.updateBounds();\n    }\n    updateBounds() {\n        let ax = 0, ay = 0, aw = 0, ah = 0;\n        let len = this.$children.length;\n        if (len > 0) {\n            (ax = Number.POSITIVE_INFINITY), (ay = Number.POSITIVE_INFINITY);\n            let ar = Number.NEGATIVE_INFINITY, ab = Number.NEGATIVE_INFINITY;\n            let tmp = 0;\n            this.$children.forEach(child => {\n                child.ensureSizeCorrect();\n                tmp = child.x;\n                if (tmp < ax)\n                    ax = tmp;\n                tmp = child.y;\n                if (tmp < ay)\n                    ay = tmp;\n                tmp = child.x + child.actualWidth;\n                if (tmp > ar)\n                    ar = tmp;\n                tmp = child.y + child.actualHeight;\n                if (tmp > ab)\n                    ab = tmp;\n            });\n            aw = ar - ax;\n            ah = ab - ay;\n        }\n        this.setBounds(ax, ay, aw, ah);\n    }\n    setBounds(ax, ay, aw, ah = 0) {\n        this.$boundsChanged = false;\n        if (this.$scrollPane)\n            this.$scrollPane.setContentSize(Math.round(ax + aw), Math.round(ay + ah));\n    }\n    get viewWidth() {\n        if (this.$scrollPane != null)\n            return this.$scrollPane.viewWidth;\n        else\n            return this.width - this.$margin.left - this.$margin.right;\n    }\n    set viewWidth(value) {\n        if (this.$scrollPane != null)\n            this.$scrollPane.viewWidth = value;\n        else\n            this.width = value + this.$margin.left + this.$margin.right;\n    }\n    get viewHeight() {\n        if (this.$scrollPane != null)\n            return this.$scrollPane.viewHeight;\n        else\n            return this.height - this.$margin.top - this.$margin.bottom;\n    }\n    set viewHeight(value) {\n        if (this.$scrollPane != null)\n            this.$scrollPane.viewHeight = value;\n        else\n            this.height = value + this.$margin.top + this.$margin.bottom;\n    }\n    getSnappingPosition(xValue, yValue, resultPoint) {\n        if (!resultPoint)\n            resultPoint = new createjs.Point();\n        let cnt = this.$children.length;\n        if (cnt <= 0) {\n            resultPoint.x = 0;\n            resultPoint.y = 0;\n            return resultPoint;\n        }\n        this.ensureBoundsCorrect();\n        let obj = null;\n        let prev = null;\n        let i = 0;\n        if (yValue != 0) {\n            for (; i < cnt; i++) {\n                obj = this.$children[i];\n                if (yValue < obj.y) {\n                    if (i == 0) {\n                        yValue = 0;\n                        break;\n                    }\n                    else {\n                        prev = this.$children[i - 1];\n                        if (yValue < prev.y + prev.actualHeight / 2)\n                            //top half part\n                            yValue = prev.y;\n                        //bottom half part\n                        else\n                            yValue = obj.y;\n                        break;\n                    }\n                }\n            }\n            if (i == cnt)\n                yValue = obj.y;\n        }\n        if (xValue != 0) {\n            if (i > 0)\n                i--;\n            for (; i < cnt; i++) {\n                obj = this.$children[i];\n                if (xValue < obj.x) {\n                    if (i == 0) {\n                        xValue = 0;\n                        break;\n                    }\n                    else {\n                        prev = this.$children[i - 1];\n                        if (xValue < prev.x + prev.actualWidth / 2)\n                            //top half part\n                            xValue = prev.x;\n                        //bottom half part\n                        else\n                            xValue = obj.x;\n                        break;\n                    }\n                }\n            }\n            if (i == cnt)\n                xValue = obj.x;\n        }\n        resultPoint.x = xValue;\n        resultPoint.y = yValue;\n        return resultPoint;\n    }\n    childSortingOrderChanged(child, oldValue, newValue = 0) {\n        if (newValue == 0) {\n            this.$sortingChildCount--;\n            this.setChildIndex(child, this.$children.length);\n        }\n        else {\n            if (oldValue == 0)\n                this.$sortingChildCount++;\n            let oldIndex = this.$children.indexOf(child);\n            let index = this.getInsertPosForSortingChild(child);\n            if (oldIndex < index)\n                this.$setChildIndex(child, oldIndex, index - 1);\n            else\n                this.$setChildIndex(child, oldIndex, index);\n        }\n    }\n    /**@internal */\n    constructFromResource() {\n        this.constructInternal(null, 0);\n    }\n    constructInternal(objectPool, poolIndex) {\n        let xml = this.packageItem.owner.getItemAsset(this.packageItem);\n        this.$inProgressBuilding = true;\n        let str;\n        let arr;\n        str = xml.attributes.size;\n        arr = str.split(',');\n        this.$sourceWidth = parseInt(arr[0]);\n        this.$sourceHeight = parseInt(arr[1]);\n        this.$initWidth = this.$sourceWidth;\n        this.$initHeight = this.$sourceHeight;\n        this.setSize(this.$sourceWidth, this.$sourceHeight);\n        str = xml.attributes.pivot;\n        if (str) {\n            arr = str.split(',');\n            str = xml.attributes.anchor;\n            this.internalSetPivot(parseFloat(arr[0]), parseFloat(arr[1]), str == 'true');\n        }\n        str = xml.attributes.opaque; // default false\n        this.opaque = str != 'false';\n        let overflow;\n        str = xml.attributes.overflow;\n        if (str)\n            overflow = ParseOverflowType(str);\n        else\n            overflow = 0 /* Visible */;\n        str = xml.attributes.margin;\n        if (str)\n            this.$margin.parse(str);\n        if (overflow == 2 /* Scroll */) {\n            let scroll;\n            str = xml.attributes.scroll;\n            if (str)\n                scroll = ParseScrollType(str);\n            else\n                scroll = 1 /* Vertical */;\n            let scrollBarDisplay;\n            str = xml.attributes.scrollBar;\n            if (str)\n                scrollBarDisplay = ParseScrollBarDisplayType(str);\n            else\n                scrollBarDisplay = 0 /* Default */;\n            let scrollBarFlags;\n            str = xml.attributes.scrollBarFlags;\n            if (str)\n                scrollBarFlags = parseInt(str);\n            else\n                scrollBarFlags = 0;\n            let scrollBarMargin = new Margin();\n            str = xml.attributes.scrollBarMargin;\n            if (str)\n                scrollBarMargin.parse(str);\n            let vtScrollBarRes;\n            let hzScrollBarRes;\n            str = xml.attributes.scrollBarRes;\n            if (str) {\n                arr = str.split(',');\n                vtScrollBarRes = arr[0];\n                hzScrollBarRes = arr[1];\n            }\n            let headerRes, footerRes;\n            str = xml.attributes.ptrRes;\n            if (str) {\n                arr = str.split(',');\n                headerRes = arr[0];\n                footerRes = arr[1];\n            }\n            this.setupScroll(scrollBarMargin, scroll, scrollBarDisplay, scrollBarFlags, vtScrollBarRes, hzScrollBarRes, headerRes, footerRes);\n        }\n        else\n            this.setupOverflow(overflow);\n        this.$buildingDisplayList = true;\n        let col = xml.children;\n        col.forEach(cxml => {\n            if (cxml.nodeName == 'controller') {\n                let c = new Controller();\n                this.$controllers.push(c);\n                c.$parent = this;\n                c.setup(cxml);\n            }\n        });\n        let displayList = this.packageItem.displayList;\n        displayList.forEach((di, i) => {\n            let child;\n            if (objectPool != null)\n                child = objectPool[poolIndex + i];\n            else if (di.packageItem) {\n                child = Decls.UIObjectFactory.newObject(di.packageItem);\n                child.packageItem = di.packageItem;\n                child.constructFromResource();\n            }\n            else\n                child = Decls.UIObjectFactory.newObjectDirectly(di.type);\n            child.$inProgressBuilding = true;\n            child.setupBeforeAdd(di.desc);\n            child.parent = this;\n            this.$children.push(child);\n            if (child instanceof GComponent) {\n                if (child.mask) {\n                    child.mask.set({ x: child.mask.x + child.x, y: child.mask.y + child.y });\n                }\n            }\n        }, this);\n        this.relations.setup(xml);\n        this.$children.forEach((child, i) => {\n            child.relations.setup(displayList[i].desc);\n            child.setupAfterAdd(displayList[i].desc);\n            child.$inProgressBuilding = false;\n        });\n        str = xml.attributes.mask;\n        if (str) {\n            let obj = this.getChildById(str);\n            let maskObj = obj.displayObject;\n            this.removeChild(obj);\n            if (maskObj instanceof createjs.Shape) {\n                this.mask = maskObj;\n            }\n            else if (maskObj['$disp'] instanceof Sprite) ;\n            else\n                throw new Error('only Sprite or Graphics can be applied as mask object');\n        }\n        col.forEach(cxml => {\n            if (cxml.nodeName == 'transition') {\n                let trans = new Transition(this);\n                this.$transitions.push(trans);\n                trans.setup(cxml);\n            }\n        }, this);\n        if (this.$transitions.length > 0) {\n            this.on('added', this.$added, this);\n            this.on('removed', this.$removed, this);\n        }\n        this.applyAllControllers();\n        this.$buildingDisplayList = false;\n        this.$inProgressBuilding = false;\n        this.appendChildrenList();\n        this.setBoundsChangedFlag();\n        this.constructFromXML(xml);\n    }\n    appendChildrenList() {\n        this.$children.forEach(child => {\n            if (child.displayObject != null && child.finalVisible)\n                this.$container.addChild(child.displayObject);\n        }, this);\n    }\n    constructFromXML(xml) { }\n    $added(d) {\n        this.$transitions.forEach(trans => {\n            if (trans.autoPlay)\n                trans.play({ times: trans.autoPlayRepeat, delay: trans.autoPlayDelay });\n        });\n    }\n    $removed(d) {\n        this.$transitions.forEach(trans => {\n            trans.stop(false, false);\n        });\n    }\n}\n\nclass Window extends GComponent {\n    constructor() {\n        super();\n        this.$requestingCmd = 0;\n        this.focusable = true;\n        this.$uiSources = [];\n        this.bringToFrontOnClick = UIConfig.bringWindowToFrontOnClick;\n        this.on('added', this.$onShown, this);\n        this.on('removed', this.$onHidden, this);\n        this.on(InteractiveEvents.Down, this.$mouseDown, this);\n    }\n    addUISource(source) {\n        this.$uiSources.push(source);\n    }\n    set contentPane(val) {\n        if (this.$contentPane != val) {\n            if (this.$contentPane != null)\n                this.removeChild(this.$contentPane);\n            this.$contentPane = val;\n            if (this.$contentPane != null) {\n                this.addChild(this.$contentPane);\n                this.setSize(this.$contentPane.width, this.$contentPane.height);\n                this.$contentPane.addRelation(this, 24 /* Size */);\n                this.$frame = this.$contentPane.getChild('frame');\n                if (this.$frame != null) {\n                    this.closeButton = this.$frame.getChild('closeButton');\n                    this.dragArea = this.$frame.getChild('dragArea');\n                    this.contentArea = this.$frame.getChild('contentArea');\n                }\n            }\n        }\n    }\n    get contentPane() {\n        return this.$contentPane;\n    }\n    get frame() {\n        return this.$frame;\n    }\n    get closeButton() {\n        return this.$closeButton;\n    }\n    set closeButton(value) {\n        if (this.$closeButton != null)\n            this.$closeButton.removeClick(this.closeEventHandler);\n        this.$closeButton = value;\n        if (this.$closeButton != null)\n            this.$closeButton.click(this.closeEventHandler, this);\n    }\n    get dragArea() {\n        return this.$dragArea;\n    }\n    set dragArea(value) {\n        if (this.$dragArea != value) {\n            if (this.$dragArea != null) {\n                this.$dragArea.draggable = false;\n                this.$dragArea.off(\"__dragStart\" /* START */, this.$dragStart);\n            }\n            this.$dragArea = value;\n            if (this.$dragArea != null) {\n                if (this.$dragArea instanceof GGraph)\n                    this.$dragArea.drawRect(0, '#000', '#000');\n                this.$dragArea.draggable = true;\n                this.$dragArea.on(\"__dragStart\" /* START */, this.$dragStart, this);\n            }\n        }\n    }\n    get contentArea() {\n        return this.$contentArea;\n    }\n    set contentArea(value) {\n        this.$contentArea = value;\n    }\n    show() {\n        Decls$1.GRoot.inst.showWindow(this);\n    }\n    showOn(root) {\n        root.showWindow(this);\n    }\n    hide() {\n        if (this.isShowing)\n            this.doHideAnimation();\n    }\n    hideImmediately() {\n        Decls$1.GRoot.inst.hideWindowImmediately(this);\n    }\n    centerOn(r, autoUpdate = false) {\n        this.setXY(Math.round((r.width - this.width) * 0.5), Math.round((r.height - this.height) * 0.5));\n        if (autoUpdate) {\n            this.addRelation(r, 3 /* Center_Center */);\n            this.addRelation(r, 10 /* Middle_Middle */);\n        }\n    }\n    toggleVisible() {\n        if (this.isTop)\n            this.hide();\n        else\n            this.show();\n    }\n    get isShowing() {\n        return this.parent != null;\n    }\n    get isTop() {\n        return this.parent != null && this.parent.getChildIndex(this) == this.parent.numChildren - 1;\n    }\n    get modal() {\n        return this.$modal;\n    }\n    set modal(val) {\n        this.$modal = val;\n    }\n    bringToFront() {\n        Decls$1.GRoot.inst.bringToFront(this);\n    }\n    showModalWait(msg, cmd = 0) {\n        if (cmd != 0)\n            this.$requestingCmd = cmd;\n        if (UIConfig.windowModalWaiting) {\n            if (!this.$modalWaitPane)\n                this.$modalWaitPane = UIPackage.createObjectFromURL(UIConfig.windowModalWaiting);\n            this.layoutModalWaitPane(msg);\n            this.addChild(this.$modalWaitPane);\n        }\n    }\n    layoutModalWaitPane(msg) {\n        if (this.$contentArea != null) {\n            let pt = this.$frame.localToGlobal();\n            pt = this.globalToLocal(pt.x, pt.y, pt);\n            this.$modalWaitPane.setXY(pt.x + this.$contentArea.x, pt.y + this.$contentArea.y);\n            this.$modalWaitPane.setSize(this.$contentArea.width, this.$contentArea.height);\n            if (msg && msg.length)\n                this.$modalWaitPane.text = msg;\n        }\n        else\n            this.$modalWaitPane.setSize(this.width, this.height);\n    }\n    closeModalWait(cmd = 0) {\n        if (cmd != 0) {\n            if (this.$requestingCmd != cmd)\n                return false;\n        }\n        this.$requestingCmd = 0;\n        if (this.$modalWaitPane && this.$modalWaitPane.parent != null)\n            this.removeChild(this.$modalWaitPane);\n        return true;\n    }\n    get modalWaiting() {\n        return this.$modalWaitPane && this.$modalWaitPane.parent != null;\n    }\n    init() {\n        if (this.$inited || this.$loading)\n            return;\n        if (this.$uiSources.length > 0) {\n            this.$loading = false;\n            this.$uiSources.forEach(o => {\n                if (!o.loaded) {\n                    o.load(this.$uiLoadComplete, this);\n                    this.$loading = true;\n                }\n            }, this);\n            if (!this.$loading)\n                this.$init();\n        }\n        else\n            this.$init();\n    }\n    onInit() { }\n    onShown() { }\n    onHide() { }\n    doShowAnimation() {\n        this.onShown();\n    }\n    doHideAnimation() {\n        this.hideImmediately();\n    }\n    $uiLoadComplete() {\n        let cnt = this.$uiSources.length;\n        for (let i = 0; i < cnt; i++) {\n            if (!this.$uiSources[i].loaded)\n                return;\n        }\n        this.$loading = false;\n        this.$init();\n    }\n    $init() {\n        this.$inited = true;\n        this.onInit();\n        if (this.isShowing)\n            this.doShowAnimation();\n    }\n    dispose() {\n        this.off('added', this.$onShown);\n        this.off('removed', this.$onHidden);\n        this.off(InteractiveEvents.Down, this.$mouseDown);\n        if (this.$dragArea)\n            this.$dragArea.off(\"__dragStart\" /* START */, this.$dragStart);\n        if (this.parent != null)\n            this.hideImmediately();\n        if (this.$modalWaitPane)\n            this.$modalWaitPane.dispose();\n        if (this.$contentPane)\n            this.$contentPane.dispose();\n        super.dispose();\n    }\n    closeEventHandler(evt) {\n        this.hide();\n    }\n    $onShown(target) {\n        if (!this.$inited)\n            this.init();\n        else\n            this.doShowAnimation();\n    }\n    $onHidden(target) {\n        this.closeModalWait();\n        this.onHide();\n    }\n    $mouseDown(evt) {\n        if (this.isShowing && this.bringToFrontOnClick)\n            this.bringToFront();\n    }\n    $dragStart(evt) {\n        let currentTarget = evt.data.currentTarget;\n        GObject.castFromNativeObject(currentTarget).stopDrag();\n        this.startDrag(evt.data.pointerID);\n    }\n}\n\nlet _inst;\nclass GRootMouseStatus {\n    constructor() {\n        this.touchDown = false;\n        this.mouseX = 0;\n        this.mouseY = 0;\n    }\n}\nclass GRoot extends GComponent {\n    constructor() {\n        super();\n        this.$volumeScale = 1;\n        if (_inst == null)\n            _inst = this;\n        this.opaque = false;\n        this.$popupStack = [];\n        this.$justClosedPopups = [];\n        this.$uid = GRoot.uniqueID++;\n        DOMEventManager.inst.on(\"__mouseWheel\" /* MOUSE_WHEEL */, this.dispatchMouseWheel, this);\n    }\n    static findFor(obj) {\n        if (obj instanceof GRoot)\n            return obj;\n        if (!obj)\n            return _inst;\n        var p = obj.parent;\n        while (p) {\n            if (p instanceof GRoot)\n                return p;\n            p = p.parent;\n        }\n        return _inst;\n    }\n    /**\n     * the singleton instance of the GRoot object\n     */\n    static get inst() {\n        if (_inst == null)\n            _inst = new GRoot();\n        return _inst;\n    }\n    /**\n     * the current mouse/pointer data\n     */\n    static get globalMouseStatus() {\n        return GRoot.$gmStatus;\n    }\n    /**\n     * the main entry to lauch the UI root, e.g.: GRoot.inst.attachTo(app, options)\n     * @param app your createjs.Stage instance to be used in this GRoot instance\n     * @param stageOptions stage rotation / resize options\n     */\n    attachTo(stage, stageOptions) {\n        createjs.Touch.enable(stage);\n        stage.mouseEnabled = true;\n        stage.mouseChildren = true;\n        stage.enableMouseOver(50);\n        // if (this.$uiStage) {\n        //     this.$uiStage.off(DisplayObjectEvent.SIZE_CHANGED, this.$winResize);\n        //     this.$uiStage.nativeStage.off(InteractiveEvents.Down, this.$stageDown);\n        //     this.$uiStage.nativeStage.off(InteractiveEvents.Up, this.$stageUp);\n        //     this.$uiStage.nativeStage.off(InteractiveEvents.Move, this.$stageMove);\n        //     this.$uiStage.nativeStage.off(this.$displayObject);\n        //     this.$uiStage.dispose();\n        // }\n        this.$uiStage = new UIStage(stage, stageOptions);\n        this.$uiStage.on(\"__sizeChanged\" /* SIZE_CHANGED */, this.$winResize, this);\n        this.$uiStage.nativeStage.on(InteractiveEvents.Down, this.$stageDown, this);\n        this.$uiStage.nativeStage.on(InteractiveEvents.Up, this.$stageUp, this);\n        this.$uiStage.nativeStage.on(InteractiveEvents.Move, this.$stageMove, this);\n        this.$uiStage.nativeStage.on(InteractiveEvents.Click, this.$click, this);\n        this.$uiStage.nativeStage.addChild(this.$displayObject);\n        this.$winResize(this.$uiStage);\n        if (!this.$modalLayer) {\n            this.$modalLayer = new GGraph();\n            this.$modalLayer.setSize(this.width, this.height);\n            this.$modalLayer.drawRect(0, '', UIConfig.modalLayerColor);\n            this.$modalLayer.addRelation(this, 24 /* Size */);\n        }\n    }\n    get uniqueID() {\n        return this.$uid;\n    }\n    get stageWidth() {\n        return this.$uiStage.stageWidth;\n    }\n    get stageHeight() {\n        return this.$uiStage.stageHeight;\n    }\n    get contentScaleFactor() {\n        return this.$uiStage.resolution;\n    }\n    get applicationContext() {\n        return this.$uiStage.applicationContext;\n    }\n    get nativeStage() {\n        return this.$uiStage.nativeStage;\n    }\n    get orientation() {\n        return this.$uiStage.orientation;\n    }\n    get stageWrapper() {\n        return this.$uiStage;\n    }\n    dispatchMouseWheel(evt) {\n        let event = evt.data.event;\n        let childUnderMouse = this.getObjectUnderPoint(GRoot.globalMouseStatus.mouseX, GRoot.globalMouseStatus.mouseY);\n        if (childUnderMouse != null) {\n            //bubble\n            while (childUnderMouse.parent && childUnderMouse.parent != this) {\n                let mouseWheelEvent = new createjs.Event(\"__mouseWheel\" /* MOUSE_WHEEL */, true, false);\n                mouseWheelEvent.data = { event };\n                childUnderMouse.dispatchEvent(mouseWheelEvent);\n                childUnderMouse = childUnderMouse.parent;\n            }\n        }\n    }\n    /**\n     * get the objects which are placed underneath the given stage coordinate\n     * @param globalX the stage X\n     * @param globalY the stage Y\n     */\n    getObjectUnderPoint(globalX, globalY) {\n        GRoot.sHelperPoint.setValues(globalX, globalY);\n        window['test'] = true;\n        let ret = this.$uiStage.applicationContext.getObjectUnderPoint(GRoot.sHelperPoint.x, GRoot.sHelperPoint.y, 0);\n        return GObject.castFromNativeObject(ret);\n    }\n    showWindow(win) {\n        this.addChild(win);\n        win.requestFocus();\n        if (win.x > this.width)\n            win.x = this.width - win.width;\n        else if (win.x + win.width < 0)\n            win.x = 0;\n        if (win.y > this.height)\n            win.y = this.height - win.height;\n        else if (win.y + win.height < 0)\n            win.y = 0;\n        this.adjustModalLayer();\n    }\n    hideWindow(win) {\n        win.hide();\n    }\n    hideWindowImmediately(win) {\n        if (win.parent == this)\n            this.removeChild(win);\n        this.adjustModalLayer();\n    }\n    bringToFront(win) {\n        let i;\n        if (this.$modalLayer.parent != null && !win.modal)\n            i = this.getChildIndex(this.$modalLayer) - 1;\n        else\n            i = this.numChildren - 1;\n        for (; i >= 0; i--) {\n            let g = this.getChildAt(i);\n            if (g == win)\n                return;\n            if (g instanceof Window)\n                break;\n        }\n        if (i >= 0)\n            this.setChildIndex(win, i);\n    }\n    showModalWait(msg = null) {\n        if (UIConfig.globalModalWaiting != null) {\n            if (this.$modalWaitPane == null) {\n                this.$modalWaitPane = UIPackage.createObjectFromURL(UIConfig.globalModalWaiting);\n                this.$modalWaitPane.addRelation(this, 24 /* Size */);\n            }\n            this.$modalWaitPane.setSize(this.width, this.height);\n            this.addChild(this.$modalWaitPane);\n            this.$modalWaitPane.text = msg;\n        }\n    }\n    closeModalWait() {\n        if (this.$modalWaitPane != null && this.$modalWaitPane.parent != null)\n            this.removeChild(this.$modalWaitPane);\n    }\n    closeAllExceptModals() {\n        let arr = this.$children.slice();\n        arr.forEach(g => {\n            if (g instanceof Window && !g.modal)\n                g.hide();\n        }, this);\n    }\n    closeAllWindows() {\n        let arr = this.$children.slice();\n        arr.forEach(g => {\n            if (g instanceof Window)\n                g.hide();\n        }, this);\n    }\n    getTopWindow() {\n        let cnt = this.numChildren;\n        for (let i = cnt - 1; i >= 0; i--) {\n            let g = this.getChildAt(i);\n            if (g instanceof Window) {\n                return g;\n            }\n        }\n        return null;\n    }\n    get hasModalWindow() {\n        return this.$modalLayer.parent != null;\n    }\n    get modalWaiting() {\n        return this.$modalWaitPane && this.$modalWaitPane.inContainer;\n    }\n    showPopup(popup, target = null, dir = 0 /* Auto */) {\n        if (this.$popupStack.length > 0) {\n            let k = this.$popupStack.indexOf(popup);\n            if (k != -1) {\n                for (let i = this.$popupStack.length - 1; i >= k; i--)\n                    this.removeChild(this.$popupStack.pop());\n            }\n        }\n        this.$popupStack.push(popup);\n        this.addChild(popup);\n        this.adjustModalLayer();\n        let pos;\n        let sizeW = 0, sizeH = 0;\n        if (target) {\n            pos = target.localToRoot();\n            sizeW = target.width;\n            sizeH = target.height;\n        }\n        else\n            pos = this.globalToLocal(GRoot.$gmStatus.mouseX, GRoot.$gmStatus.mouseY);\n        let xx, yy;\n        xx = pos.x;\n        if (xx + popup.width > this.width)\n            xx = xx + sizeW - popup.width;\n        yy = pos.y + sizeH;\n        if ((dir == 0 /* Auto */ && yy + popup.height > this.height) ||\n            dir == 2 /* Up */) {\n            yy = pos.y - popup.height - 1;\n            if (yy < 0) {\n                yy = 0;\n                xx += sizeW * 0.5;\n            }\n        }\n        popup.x = xx;\n        popup.y = yy;\n    }\n    togglePopup(popup, target = null, dir) {\n        if (this.$justClosedPopups.indexOf(popup) != -1)\n            return;\n        this.showPopup(popup, target, dir);\n    }\n    hidePopup(popup = null) {\n        let i;\n        if (popup != null) {\n            let k = this.$popupStack.indexOf(popup);\n            if (k != -1) {\n                for (i = this.$popupStack.length - 1; i >= k; i--)\n                    this.closePopup(this.$popupStack.pop());\n            }\n        }\n        else {\n            let cnt = this.$popupStack.length;\n            for (i = cnt - 1; i >= 0; i--)\n                this.closePopup(this.$popupStack[i]);\n            this.$popupStack.length = 0;\n        }\n    }\n    get hasAnyPopup() {\n        return this.$popupStack.length != 0;\n    }\n    closePopup(target) {\n        if (target.parent != null) {\n            if (target instanceof Window)\n                target.hide();\n            else\n                this.removeChild(target);\n        }\n    }\n    showTooltips(msg) {\n        if (this.$defaultTooltipWin == null) {\n            let resourceURL = UIConfig.tooltipsWin;\n            if (!resourceURL) {\n                console.error('UIConfig.tooltipsWin not defined');\n                return;\n            }\n            this.$defaultTooltipWin = UIPackage.createObjectFromURL(resourceURL);\n        }\n        this.$defaultTooltipWin.text = msg;\n        this.showTooltipsWin(this.$defaultTooltipWin);\n    }\n    showTooltipsWin(tooltipWin, position = null) {\n        this.hideTooltips();\n        this.$tooltipWin = tooltipWin;\n        let xx = 0;\n        let yy = 0;\n        if (position == null) {\n            xx = GRoot.$gmStatus.mouseX + 10;\n            yy = GRoot.$gmStatus.mouseY + 20;\n        }\n        else {\n            xx = position.x;\n            yy = position.y;\n        }\n        let pt = this.globalToLocal(xx, yy);\n        xx = pt.x;\n        yy = pt.y;\n        if (xx + this.$tooltipWin.width > this.width) {\n            xx = xx - this.$tooltipWin.width - 1;\n            if (xx < 0)\n                xx = 10;\n        }\n        if (yy + this.$tooltipWin.height > this.height) {\n            yy = yy - this.$tooltipWin.height - 1;\n            if (xx - this.$tooltipWin.width - 1 > 0)\n                xx = xx - this.$tooltipWin.width - 1;\n            if (yy < 0)\n                yy = 10;\n        }\n        this.$tooltipWin.x = xx;\n        this.$tooltipWin.y = yy;\n        this.addChild(this.$tooltipWin);\n    }\n    hideTooltips() {\n        if (this.$tooltipWin != null) {\n            if (this.$tooltipWin.parent)\n                this.removeChild(this.$tooltipWin);\n            this.$tooltipWin = null;\n        }\n    }\n    get focus() {\n        if (this.$focusedObject && !this.$focusedObject.onStage)\n            this.$focusedObject = null;\n        return this.$focusedObject;\n    }\n    set focus(value) {\n        if (value && (!value.focusable || !value.onStage))\n            throw new Error('Invalid target to focus');\n        this.setFocus(value);\n    }\n    setFocus(value) {\n        if (this.$focusedObject != value) {\n            this.$focusedObject = value;\n            let evt = new createjs.Event(\"__focusChanged\" /* CHANGED */, true, false);\n            this.dispatchEvent(evt, this);\n        }\n    }\n    get volumeScale() {\n        return this.$volumeScale;\n    }\n    set volumeScale(value) {\n        this.$volumeScale = value;\n    }\n    playOneShotSound(sound, volumeScale = 1) {\n        var vs = this.$volumeScale * volumeScale;\n        sound.play({ volume: vs });\n    }\n    adjustModalLayer() {\n        let cnt = this.numChildren;\n        if (this.$modalWaitPane != null && this.$modalWaitPane.parent != null)\n            this.setChildIndex(this.$modalWaitPane, cnt - 1);\n        for (let i = cnt - 1; i >= 0; i--) {\n            let g = this.getChildAt(i);\n            if (g instanceof Window && g.modal) {\n                if (this.$modalLayer.parent == null)\n                    this.addChildAt(this.$modalLayer, i);\n                else\n                    this.setChildIndexBefore(this.$modalLayer, i);\n                return;\n            }\n        }\n        if (this.$modalLayer.parent != null)\n            this.removeChild(this.$modalLayer);\n    }\n    $stageDown(evt) {\n        // see Drag & Drop\n        GRoot.$gmStatus.mouseX = evt.stageX;\n        GRoot.$gmStatus.mouseY = evt.stageY;\n        GRoot.$gmStatus.touchDown = true;\n        //check focus\n        let mc = evt.target;\n        while (mc && mc != this.nativeStage) {\n            if (isUIObject(mc)) {\n                let g = mc.UIOwner;\n                if (g.touchable && g.focusable) {\n                    this.setFocus(g);\n                    break;\n                }\n            }\n            mc = mc.parent;\n        }\n        if (this.$tooltipWin != null)\n            this.hideTooltips();\n        this.checkPopups(evt.target);\n    }\n    checkPopups(target) {\n        if (this.$checkingPopups)\n            return;\n        this.$checkingPopups = true;\n        this.$justClosedPopups.length = 0;\n        if (this.$popupStack.length > 0) {\n            let mc = target;\n            while (mc && mc != this.nativeStage) {\n                if (isUIObject(mc)) {\n                    let pindex = this.$popupStack.indexOf(mc.UIOwner);\n                    if (pindex != -1) {\n                        let popup;\n                        for (let i = this.$popupStack.length - 1; i > pindex; i--) {\n                            popup = this.$popupStack.pop();\n                            this.closePopup(popup);\n                            this.$justClosedPopups.push(popup);\n                        }\n                        return;\n                    }\n                }\n                mc = mc.parent;\n            }\n            let cnt = this.$popupStack.length;\n            let popup;\n            for (let i = cnt - 1; i >= 0; i--) {\n                popup = this.$popupStack[i];\n                this.closePopup(popup);\n                this.$justClosedPopups.push(popup);\n            }\n            this.$popupStack.length = 0;\n        }\n    }\n    $stageMove(evt) {\n        GRoot.$gmStatus.mouseX = evt.stageX;\n        GRoot.$gmStatus.mouseY = evt.stageY;\n    }\n    $stageUp(evt) {\n        GRoot.$gmStatus.touchDown = false;\n        this.$checkingPopups = false;\n    }\n    $click(evt) { }\n    $winResize(stage) {\n        this.setSize(stage.stageWidth, stage.stageHeight);\n    }\n}\nGRoot.uniqueID = 0;\nGRoot.$gmStatus = new GRootMouseStatus();\nDecls$1.GRoot = GRoot;\n\nvar TEXT_GRADIENT;\n(function (TEXT_GRADIENT) {\n    TEXT_GRADIENT[TEXT_GRADIENT[\"LINEAR_VERTICAL\"] = 0] = \"LINEAR_VERTICAL\";\n    TEXT_GRADIENT[TEXT_GRADIENT[\"LINEAR_HORIZONTAL\"] = 1] = \"LINEAR_HORIZONTAL\";\n})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));\nconst defaultStyle = {\n    align: 'left',\n    breakWords: false,\n    dropShadow: false,\n    dropShadowAlpha: 1,\n    dropShadowAngle: Math.PI / 6,\n    dropShadowBlur: 0,\n    dropShadowColor: 'black',\n    dropShadowDistance: 5,\n    dropShadowOffsetX: 0,\n    dropShadowOffsetY: 0,\n    fill: 'black',\n    fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,\n    fillGradientStops: [],\n    fontFamily: 'Arial',\n    fontSize: 26,\n    fontStyle: 'normal',\n    fontVariant: 'normal',\n    fontWeight: 'normal',\n    letterSpacing: 0,\n    lineHeight: 0,\n    lineJoin: 'miter',\n    miterLimit: 10,\n    padding: 0,\n    stroke: 'black',\n    strokeThickness: 0,\n    textBaseline: 'alphabetic',\n    trim: false,\n    whiteSpace: 'pre',\n    wordWrap: false,\n    wordWrapWidth: 100,\n    leading: 0\n};\nconst genericFontFamilies = ['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy', 'system-ui'];\nclass TextStyle {\n    constructor(style) {\n        this.styleID = 0;\n        this.reset();\n        Utils.deepCopyProperties(this, style, style);\n    }\n    clone() {\n        const clonedProperties = {};\n        Utils.deepCopyProperties(clonedProperties, this, defaultStyle);\n        return new TextStyle(clonedProperties);\n    }\n    /**\n     * Resets all properties to the defaults specified in TextStyle.prototype._default\n     */\n    reset() {\n        Utils.deepCopyProperties(this, defaultStyle, defaultStyle);\n    }\n    /**\n     * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n     *\n     * @member {string}\n     */\n    get align() {\n        return this._align;\n    }\n    set align(align) {\n        if (this._align !== align) {\n            this._align = align;\n            this.styleID++;\n        }\n    }\n    /**\n     * Indicates if lines can be wrapped within words, it needs wordWrap to be set to true\n     *\n     * @member {boolean}\n     */\n    get breakWords() {\n        return this._breakWords;\n    }\n    set breakWords(breakWords) {\n        if (this._breakWords !== breakWords) {\n            this._breakWords = breakWords;\n            this.styleID++;\n        }\n    }\n    /**\n     * Set a drop shadow for the text\n     *\n     * @member {boolean}\n     */\n    get dropShadow() {\n        return this._dropShadow;\n    }\n    set dropShadow(dropShadow) {\n        if (this._dropShadow !== dropShadow) {\n            this._dropShadow = dropShadow;\n            this.styleID++;\n        }\n    }\n    /**\n     * Set alpha for the drop shadow\n     *\n     * @member {number}\n     */\n    get dropShadowAlpha() {\n        return this._dropShadowAlpha;\n    }\n    set dropShadowAlpha(dropShadowAlpha) {\n        if (this._dropShadowAlpha !== dropShadowAlpha) {\n            this._dropShadowAlpha = dropShadowAlpha;\n            this.styleID++;\n        }\n    }\n    /**\n     * Set a angle of the drop shadow\n     *\n     * @member {number}\n     */\n    get dropShadowAngle() {\n        return this._dropShadowAngle;\n    }\n    set dropShadowAngle(dropShadowAngle) {\n        if (this._dropShadowAngle !== dropShadowAngle) {\n            this._dropShadowAngle = dropShadowAngle;\n            this.styleID++;\n        }\n    }\n    /**\n     * Set a shadow blur radius\n     *\n     * @member {number}\n     */\n    get dropShadowBlur() {\n        return this._dropShadowBlur;\n    }\n    set dropShadowBlur(dropShadowBlur) {\n        if (this._dropShadowBlur !== dropShadowBlur) {\n            this._dropShadowBlur = dropShadowBlur;\n            this.styleID++;\n        }\n    }\n    /**\n     * A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n     *\n     * @member {string|number}\n     */\n    get dropShadowColor() {\n        return this._dropShadowColor;\n    }\n    set dropShadowColor(dropShadowColor) {\n        const outputColor = getColor(dropShadowColor);\n        if (this._dropShadowColor !== outputColor) {\n            this._dropShadowColor = outputColor;\n            this.styleID++;\n        }\n    }\n    /**\n     * Set a distance of the drop shadow\n     *\n     * @member {number}\n     */\n    get dropShadowDistance() {\n        return this._dropShadowDistance;\n    }\n    set dropShadowDistance(dropShadowDistance) {\n        if (this._dropShadowDistance !== dropShadowDistance) {\n            this._dropShadowDistance = dropShadowDistance;\n            this.styleID++;\n        }\n    }\n    /**\n     * Set a offsetX of the drop shadow\n     *\n     * @member {number}\n     */\n    get dropShadowOffsetX() {\n        return this._dropShadowOffsetX;\n    }\n    set dropShadowOffsetX(dropShadowOffsetX) {\n        if (this._dropShadowOffsetX !== dropShadowOffsetX) {\n            this._dropShadowOffsetX = dropShadowOffsetX;\n            this.styleID++;\n        }\n    }\n    /**\n     * Set a offsetY of the drop shadow\n     *\n     * @member {number}\n     */\n    get dropShadowOffsetY() {\n        return this._dropShadowOffsetY;\n    }\n    set dropShadowOffsetY(dropShadowOffsetY) {\n        if (this._dropShadowOffsetY !== dropShadowOffsetY) {\n            this._dropShadowOffsetY = dropShadowOffsetY;\n            this.styleID++;\n        }\n    }\n    /**\n     * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.\n     * Can be an array to create a gradient eg ['#000000','#FFFFFF']\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     *\n     * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n     */\n    get fill() {\n        return this._fill;\n    }\n    set fill(fill) {\n        const outputColor = getColor(fill);\n        if (this._fill !== outputColor) {\n            this._fill = outputColor;\n            this.styleID++;\n        }\n    }\n    get fillGradientType() {\n        return this._fillGradientType;\n    }\n    set fillGradientType(fillGradientType) {\n        if (this._fillGradientType !== fillGradientType) {\n            this._fillGradientType = fillGradientType;\n            this.styleID++;\n        }\n    }\n    get fillGradientStops() {\n        return this._fillGradientStops;\n    }\n    set fillGradientStops(fillGradientStops) {\n        if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {\n            this._fillGradientStops = fillGradientStops;\n            this.styleID++;\n        }\n    }\n    get fontFamily() {\n        return this._fontFamily;\n    }\n    set fontFamily(fontFamily) {\n        if (this.fontFamily !== fontFamily) {\n            this._fontFamily = fontFamily;\n            this.styleID++;\n        }\n    }\n    get fontSize() {\n        return this._fontSize;\n    }\n    set fontSize(fontSize) {\n        if (this._fontSize !== fontSize) {\n            this._fontSize = fontSize;\n            this.styleID++;\n        }\n    }\n    get fontStyle() {\n        return this._fontStyle;\n    }\n    set fontStyle(fontStyle) {\n        if (this._fontStyle !== fontStyle) {\n            this._fontStyle = fontStyle;\n            this.styleID++;\n        }\n    }\n    /**\n     * The font variant\n     * ('normal' or 'small-caps')\n     *\n     * @member {string}\n     */\n    get fontVariant() {\n        return this._fontVariant;\n    }\n    set fontVariant(fontVariant) {\n        if (this._fontVariant !== fontVariant) {\n            this._fontVariant = fontVariant;\n            this.styleID++;\n        }\n    }\n    /**\n     * The font weight\n     * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')\n     *\n     * @member {string}\n     */\n    get fontWeight() {\n        return this._fontWeight;\n    }\n    set fontWeight(fontWeight) {\n        if (this._fontWeight !== fontWeight) {\n            this._fontWeight = fontWeight;\n            this.styleID++;\n        }\n    }\n    /**\n     * The amount of spacing between letters, default is 0\n     *\n     * @member {number}\n     */\n    get letterSpacing() {\n        return this._letterSpacing;\n    }\n    set letterSpacing(letterSpacing) {\n        if (this._letterSpacing !== letterSpacing) {\n            this._letterSpacing = letterSpacing;\n            this.styleID++;\n        }\n    }\n    /**\n     * The line height, a number that represents the vertical space that a letter uses\n     *\n     * @member {number}\n     */\n    get lineHeight() {\n        return this._lineHeight;\n    }\n    set lineHeight(lineHeight) {\n        if (this._lineHeight !== lineHeight) {\n            this._lineHeight = lineHeight;\n            this.styleID++;\n        }\n    }\n    /**\n     * The space between lines\n     *\n     * @member {number}\n     */\n    get leading() {\n        return this._leading;\n    }\n    set leading(leading) {\n        if (this._leading !== leading) {\n            this._leading = leading;\n            this.styleID++;\n        }\n    }\n    /**\n     * The lineJoin property sets the type of corner created, it can resolve spiked text issues.\n     * Default is 'miter' (creates a sharp corner).\n     *\n     * @member {string}\n     */\n    get lineJoin() {\n        return this._lineJoin;\n    }\n    set lineJoin(lineJoin) {\n        if (this._lineJoin !== lineJoin) {\n            this._lineJoin = lineJoin;\n            this.styleID++;\n        }\n    }\n    /**\n     * The miter limit to use when using the 'miter' lineJoin mode\n     * This can reduce or increase the spikiness of rendered text.\n     *\n     * @member {number}\n     */\n    get miterLimit() {\n        return this._miterLimit;\n    }\n    set miterLimit(miterLimit) {\n        if (this._miterLimit !== miterLimit) {\n            this._miterLimit = miterLimit;\n            this.styleID++;\n        }\n    }\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     *\n     * @member {number}\n     */\n    get padding() {\n        return this._padding;\n    }\n    set padding(padding) {\n        if (this._padding !== padding) {\n            this._padding = padding;\n            this.styleID++;\n        }\n    }\n    /**\n     * A canvas fillstyle that will be used on the text stroke\n     * e.g 'blue', '#FCFF00'\n     *\n     * @member {string}\n     */\n    get stroke() {\n        return this._stroke;\n    }\n    set stroke(stroke) {\n        // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n        //       the setter converts to string. See this thread for more details:\n        //       https://github.com/microsoft/TypeScript/issues/2521\n        const outputColor = getColor(stroke);\n        if (this._stroke !== outputColor) {\n            this._stroke = outputColor;\n            this.styleID++;\n        }\n    }\n    /**\n     * A number that represents the thickness of the stroke.\n     * Default is 0 (no stroke)\n     *\n     * @member {number}\n     */\n    get strokeThickness() {\n        return this._strokeThickness;\n    }\n    set strokeThickness(strokeThickness) {\n        if (this._strokeThickness !== strokeThickness) {\n            this._strokeThickness = strokeThickness;\n            this.styleID++;\n        }\n    }\n    /**\n     * The baseline of the text that is rendered.\n     *\n     * @member {string}\n     */\n    get textBaseline() {\n        return this._textBaseline;\n    }\n    set textBaseline(textBaseline) {\n        if (this._textBaseline !== textBaseline) {\n            this._textBaseline = textBaseline;\n            this.styleID++;\n        }\n    }\n    /**\n     * Trim transparent borders\n     *\n     * @member {boolean}\n     */\n    get trim() {\n        return this._trim;\n    }\n    set trim(trim) {\n        if (this._trim !== trim) {\n            this._trim = trim;\n            this.styleID++;\n        }\n    }\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     *\n     * @member {string}\n     */\n    get whiteSpace() {\n        return this._whiteSpace;\n    }\n    set whiteSpace(whiteSpace) {\n        if (this._whiteSpace !== whiteSpace) {\n            this._whiteSpace = whiteSpace;\n            this.styleID++;\n        }\n    }\n    /**\n     * Indicates if word wrap should be used\n     *\n     * @member {boolean}\n     */\n    get wordWrap() {\n        return this._wordWrap;\n    }\n    set wordWrap(wordWrap) {\n        if (this._wordWrap !== wordWrap) {\n            this._wordWrap = wordWrap;\n            this.styleID++;\n        }\n    }\n    /**\n     * The width at which text will wrap, it needs wordWrap to be set to true\n     *\n     * @member {number}\n     */\n    get wordWrapWidth() {\n        return this._wordWrapWidth;\n    }\n    set wordWrapWidth(wordWrapWidth) {\n        if (this._wordWrapWidth !== wordWrapWidth) {\n            this._wordWrapWidth = wordWrapWidth;\n            this.styleID++;\n        }\n    }\n    /**\n     * Generates a font style string to use for `TextMetrics.measureFont()`.\n     *\n     * @return {string} Font style string, for passing to `TextMetrics.measureFont()`\n     */\n    toFontString() {\n        // build canvas api font setting from individual components. Convert a numeric this.fontSize to px\n        const fontSizeString = typeof this.fontSize === 'number' ? `${this.fontSize}px` : this.fontSize;\n        // Clean-up fontFamily property by quoting each font name\n        // this will support font names with spaces\n        let fontFamilies = this.fontFamily;\n        if (!Array.isArray(this.fontFamily)) {\n            fontFamilies = this.fontFamily.split(',');\n        }\n        for (let i = fontFamilies.length - 1; i >= 0; i--) {\n            // Trim any extra white-space\n            let fontFamily = fontFamilies[i].trim();\n            // Check if font already contains strings\n            if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {\n                fontFamily = `\"${fontFamily}\"`;\n            }\n            fontFamilies[i] = fontFamily;\n        }\n        return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(',')}`;\n    }\n}\nfunction getSingleColor(color) {\n    if (typeof color === 'number') {\n        return StringUtil.convertToHtmlColor(color);\n        // // todo\n        // return color\n    }\n    else if (typeof color === 'string') {\n        if (color.indexOf('0x') === 0) {\n            color = color.replace('0x', '#');\n        }\n    }\n    return color;\n}\nfunction getColor(color) {\n    if (!Array.isArray(color)) {\n        return getSingleColor(color);\n    }\n    else {\n        for (let i = 0; i < color.length; ++i) {\n            color[i] = getSingleColor(color[i]);\n        }\n        return color;\n    }\n}\nfunction areArraysEqual(array1, array2) {\n    if (!Array.isArray(array1) || !Array.isArray(array2)) {\n        return false;\n    }\n    if (array1.length !== array2.length) {\n        return false;\n    }\n    for (let i = 0; i < array1.length; ++i) {\n        if (array1[i] !== array2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nclass UITextField extends createjs.Text {\n    constructor(owner) {\n        super();\n        this.$minHeightID = -1;\n        this.UIOwner = owner;\n        this.style = new TextStyle({});\n        // this.mouseEnabled = false;\n        // this.interactive = this.interactiveChildren = false;\n        // this._texture.noFrame = false;\n        // this._width = this._texture.frame.width;\n        // this._height = this._texture.frame.height;\n        // this.$minHeight = -1;\n        // this._texture.on(\"update\", this.updateFrame, this);\n    }\n    get minHeight() {\n        return this.$minHeight;\n    }\n    applyStyle() {\n        let canvas = Decls$1.GRoot.inst.applicationContext.canvas;\n        this.font = this.style.toFontString();\n        this.color = this.style.fill;\n        let letterSpacing = this.style.letterSpacing;\n        if (letterSpacing) {\n            canvas.style.letterSpacing = `${letterSpacing}px`;\n        }\n        else {\n            canvas.style.letterSpacing = `0px`;\n        }\n        let leading = this.style.leading;\n        if (leading) {\n            this.lineHeight = this.getMeasuredLineHeight() + leading;\n        }\n        else {\n            this.lineHeight = this.getMeasuredLineHeight();\n        }\n        let strokeThickness = this.style.strokeThickness;\n        if (strokeThickness) {\n            if (!this.multiple) {\n                this.multiple = new createjs.Text(this.text, this.font, this.color);\n                this.UIOwner.parent.displayObject.addChild(this.multiple);\n            }\n            this.multiple.outline = strokeThickness;\n            if (this.style.stroke != this.color) {\n                this.multiple.color = this.style.stroke;\n            }\n            this.multiple.lineHeight = this.lineHeight;\n            this.multiple.lineWidth = this.lineWidth;\n        }\n        let shadow = new createjs.Shadow(this.style.dropShadowColor, this.style.dropShadowOffsetX, this.style.dropShadowOffsetY, this.style.dropShadowBlur);\n        this.shadow = shadow;\n        let { x, y, width, height } = this;\n        this.setBounds(x, y, width, height);\n    }\n    /**@internal */\n    $updateMinHeight() {\n        this.$minHeight = this.getMeasuredLineHeight();\n    }\n    // protected updateFrame(): void {\n    //     GTimer.inst.callLater(this.internalUpdateFrame, this);\n    // }\n    // private internalUpdateFrame(): void {\n    // if(this._texture) {\n    //     let frm = this._texture.frame;\n    //     this._height = Math.max(this._height, this.$minHeight);\n    //     let w = frm.x + this._width, h = frm.y + this._height;\n    //     if(w > this._texture.baseTexture.width)\n    //         w = this._texture.baseTexture.width - frm.x;\n    //     if(h > this._texture.baseTexture.height)\n    //         h = this._texture.baseTexture.height - frm.y;\n    //     frm.width = w / this.resolution;\n    //     frm.height = h / this.resolution;\n    //     this._texture.trim.width = frm.width;\n    //     this._texture.trim.height = frm.height;\n    //     let padding = this._style.trim ? 0 : this._style.padding;\n    //     this._texture.trim.x = -padding;\n    //     this._texture.trim.y = -padding;\n    //     this._texture.frame = frm;\n    // }\n    // }\n    //cancel scaling update\n    // protected _onTextureUpdate(): void {\n    // this._textureID = -1;\n    // this._textureTrimmedID = -1;\n    // }\n    get width() {\n        return this.getMetrics()['width'];\n    }\n    set width(v) {\n        this.lineWidth = v;\n        if (this.multiple) {\n            this.multiple.lineWidth = v;\n        }\n    }\n    get height() {\n        return this.lineHeight;\n    }\n    set height(v) {\n        this.lineHeight = v;\n        if (this.multiple) {\n            this.multiple.lineHeight = v;\n        }\n    }\n    get textHeight() {\n        return this.getMeasuredHeight();\n    }\n    set textHeight(v) { }\n    get textWidth() {\n        return this.getMeasuredWidth();\n    }\n    set content(v) {\n        this.text = v;\n        if (this.multiple) {\n            this.multiple.text = v;\n        }\n    }\n    get content() {\n        return this.text;\n    }\n    updateMultiplePosition(x, y) {\n        if (this.multiple) {\n            this.multiple.x = x;\n            this.multiple.y = y;\n        }\n    }\n}\n\nclass TextMetrics {\n    constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n    static measureText(text, style, wordWrap, canvas = TextMetrics._canvas) {\n        wordWrap = wordWrap === undefined || wordWrap === null ? style.wordWrap : wordWrap;\n        const font = style.toFontString();\n        const fontProperties = TextMetrics.measureFont(font);\n        // fallback in case UA disallow canvas data extraction\n        // (toDataURI, getImageData functions)\n        if (fontProperties.fontSize === 0) {\n            fontProperties.fontSize = style.fontSize;\n            fontProperties.ascent = style.fontSize;\n        }\n        const context = canvas.getContext('2d');\n        context.font = font;\n        const outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array(lines.length);\n        let maxLineWidth = 0;\n        for (let i = 0; i < lines.length; i++) {\n            const lineWidth = context.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n        let width = maxLineWidth + style.strokeThickness;\n        if (style.dropShadow) {\n            width += style.dropShadowDistance;\n        }\n        const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n        let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) +\n            (lines.length - 1) * (lineHeight + style.leading);\n        if (style.dropShadow) {\n            height += style.dropShadowDistance;\n        }\n        return new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);\n    }\n    static wordWrap(text, style, canvas = TextMetrics._canvas) {\n        const context = canvas.getContext('2d');\n        let width = 0;\n        let line = '';\n        let lines = '';\n        const cache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n        // How to handle whitespaces\n        const collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);\n        const collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n        // break text into words, spaces and newline chars\n        const tokens = TextMetrics.tokenize(text);\n        for (let i = 0; i < tokens.length; i++) {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n            // if word is a new line\n            if (TextMetrics.isNewline(token)) {\n                // keep the new line\n                if (!collapseNewlines) {\n                    lines += TextMetrics.addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces) {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = TextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = TextMetrics.isBreakingSpace(line[line.length - 1]);\n                if (currIsBreakingSpace && lastIsBreakingSpace) {\n                    continue;\n                }\n            }\n            // get word width from cache if possible\n            const tokenWidth = TextMetrics.getFromCache(token, letterSpacing, cache, context);\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth) {\n                // if we are not already at the beginning of a line\n                if (line !== '') {\n                    // start newlines for overflow words\n                    lines += TextMetrics.addLine(line);\n                    line = '';\n                    width = 0;\n                }\n                // break large word over multiple lines\n                if (TextMetrics.canBreakWords(token, style.breakWords)) {\n                    // break word into characters\n                    const characters = TextMetrics.wordWrapSplit(token);\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++) {\n                        let char = characters[j];\n                        let k = 1;\n                        // we are not at the end of the token\n                        while (characters[j + k]) {\n                            const nextChar = characters[j + k];\n                            const lastChar = char[char.length - 1];\n                            // should not split chars\n                            if (!TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else {\n                                break;\n                            }\n                            k++;\n                        }\n                        j += char.length - 1;\n                        const characterWidth = TextMetrics.getFromCache(char, letterSpacing, cache, context);\n                        if (characterWidth + width > wordWrapWidth) {\n                            lines += TextMetrics.addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n                // run word out of the bounds\n                else {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0) {\n                        lines += TextMetrics.addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n                    const isLastToken = i === tokens.length - 1;\n                    // give it its own line if it's not the end\n                    lines += TextMetrics.addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n            // word could fit\n            else {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth) {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n                    // add a new line\n                    lines += TextMetrics.addLine(line);\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !TextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n                    // add the word to the current line\n                    line += token;\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n        lines += TextMetrics.addLine(line, false);\n        return lines;\n    }\n    static addLine(line, newLine = true) {\n        line = TextMetrics.trimRight(line);\n        line = newLine ? `${line}\\n` : line;\n        return line;\n    }\n    static getFromCache(key, letterSpacing, cache, context) {\n        let width = cache[key];\n        if (typeof width !== 'number') {\n            const spacing = key.length * letterSpacing;\n            width = context.measureText(key).width + spacing;\n            cache[key] = width;\n        }\n        return width;\n    }\n    static collapseSpaces(whiteSpace) {\n        return whiteSpace === 'normal' || whiteSpace === 'pre-line';\n    }\n    static collapseNewlines(whiteSpace) {\n        return whiteSpace === 'normal';\n    }\n    static trimRight(text) {\n        if (typeof text !== 'string') {\n            return '';\n        }\n        for (let i = text.length - 1; i >= 0; i--) {\n            const char = text[i];\n            if (!TextMetrics.isBreakingSpace(char)) {\n                break;\n            }\n            text = text.slice(0, -1);\n        }\n        return text;\n    }\n    static isNewline(char) {\n        if (typeof char !== 'string') {\n            return false;\n        }\n        return TextMetrics._newlines.indexOf(char.charCodeAt(0)) >= 0;\n    }\n    static isBreakingSpace(char, _nextChar) {\n        if (typeof char !== 'string') {\n            return false;\n        }\n        return TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;\n    }\n    static tokenize(text) {\n        const tokens = [];\n        let token = '';\n        if (typeof text !== 'string') {\n            return tokens;\n        }\n        for (let i = 0; i < text.length; i++) {\n            const char = text[i];\n            const nextChar = text[i + 1];\n            if (TextMetrics.isBreakingSpace(char, nextChar) || TextMetrics.isNewline(char)) {\n                if (token !== '') {\n                    tokens.push(token);\n                    token = '';\n                }\n                tokens.push(char);\n                continue;\n            }\n            token += char;\n        }\n        if (token !== '') {\n            tokens.push(token);\n        }\n        return tokens;\n    }\n    static canBreakWords(_token, breakWords) {\n        return breakWords;\n    }\n    static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n        return true;\n    }\n    static wordWrapSplit(token) {\n        return token.split('');\n    }\n    static measureFont(font) {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (TextMetrics._fonts[font]) {\n            return TextMetrics._fonts[font];\n        }\n        const properties = {\n            ascent: 0,\n            descent: 0,\n            fontSize: 0\n        };\n        const canvas = TextMetrics._canvas;\n        const context = TextMetrics._context;\n        context.font = font;\n        const metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;\n        const width = Math.ceil(context.measureText(metricsString).width);\n        let baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);\n        const height = 2 * baseline;\n        baseline = (baseline * TextMetrics.BASELINE_MULTIPLIER) | 0;\n        canvas.width = width;\n        canvas.height = height;\n        context.fillStyle = '#f00';\n        context.fillRect(0, 0, width, height);\n        context.font = font;\n        context.textBaseline = 'alphabetic';\n        context.fillStyle = '#000';\n        context.fillText(metricsString, 0, baseline);\n        const imagedata = context.getImageData(0, 0, width, height).data;\n        const pixels = imagedata.length;\n        const line = width * 4;\n        let i = 0;\n        let idx = 0;\n        let stop = false;\n        // ascent. scan from top to bottom until we find a non red pixel\n        for (i = 0; i < baseline; ++i) {\n            for (let j = 0; j < line; j += 4) {\n                if (imagedata[idx + j] !== 255) {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop) {\n                idx += line;\n            }\n            else {\n                break;\n            }\n        }\n        properties.ascent = baseline - i;\n        idx = pixels - line;\n        stop = false;\n        // descent. scan from bottom to top until we find a non red pixel\n        for (i = height; i > baseline; --i) {\n            for (let j = 0; j < line; j += 4) {\n                if (imagedata[idx + j] !== 255) {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop) {\n                idx -= line;\n            }\n            else {\n                break;\n            }\n        }\n        properties.descent = i - baseline;\n        properties.fontSize = properties.ascent + properties.descent;\n        TextMetrics._fonts[font] = properties;\n        return properties;\n    }\n    /**\n     * Clear font metrics in metrics cache.\n     *\n     * @static\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    static clearMetrics(font = '') {\n        if (font) {\n            delete TextMetrics._fonts[font];\n        }\n        else {\n            TextMetrics._fonts = {};\n        }\n    }\n}\nconst canvas = (() => {\n    try {\n        // OffscreenCanvas2D measureText can be up to 40% faster.\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext('2d');\n        if (context && context.measureText) {\n            return c;\n        }\n        return document.createElement('canvas');\n    }\n    catch (ex) {\n        return document.createElement('canvas');\n    }\n})();\ncanvas.width = canvas.height = 10;\nTextMetrics._canvas = canvas;\nTextMetrics._context = canvas.getContext('2d');\nTextMetrics._fonts = {};\nTextMetrics.METRICS_STRING = '|ÉqÅ';\nTextMetrics.BASELINE_SYMBOL = 'M';\nTextMetrics.BASELINE_MULTIPLIER = 1.4;\nTextMetrics._newlines = [\n    0x000a,\n    0x000d // carriage return\n];\nTextMetrics._breakingSpaces = [\n    0x0009,\n    0x0020,\n    0x2000,\n    0x2001,\n    0x2002,\n    0x2003,\n    0x2004,\n    0x2005,\n    0x2006,\n    0x2008,\n    0x2009,\n    0x200a,\n    0x205f,\n    0x3000 // ideographic space\n];\n\nclass LineInfo {\n    constructor() {\n        this.width = 0;\n        this.height = 0;\n        this.textHeight = 0;\n        this.y = 0;\n    }\n    static get() {\n        if (LineInfo.pool.length) {\n            let ret = LineInfo.pool.pop();\n            ret.width = 0;\n            ret.height = 0;\n            ret.textHeight = 0;\n            ret.text = null;\n            ret.y = 0;\n            return ret;\n        }\n        else\n            return new LineInfo();\n    }\n    static recycle(value) {\n        LineInfo.pool.push(value);\n    }\n    static recycleMany(value) {\n        if (value && value.length) {\n            value.forEach(v => {\n                LineInfo.pool.push(v);\n            }, this);\n        }\n        value.length = 0;\n    }\n}\nLineInfo.pool = [];\nclass GTextField extends GObject {\n    constructor() {\n        super();\n        this.$verticalAlign = 0 /* Top */;\n        this.$offset = new createjs.Point();\n        this.$singleLine = true;\n        this.$text = '';\n        this.$textWidth = 0;\n        this.$textHeight = 0;\n        this.$style = new TextStyle({\n            fontSize: 12,\n            fontFamily: UIConfig.defaultFont,\n            align: \"left\" /* Left */,\n            leading: 3,\n            fill: 0\n        });\n        this.$verticalAlign = 0 /* Top */;\n        this.$text = '';\n        this.$autoSize = 1 /* Both */;\n        this.$widthAutoSize = true;\n        this.$heightAutoSize = true;\n        this.$bitmapPool = [];\n        this.touchable = false; //base GTextField has no interaction\n    }\n    createDisplayObject() {\n        this.$textField = new UITextField(this);\n        this.setDisplayObject(this.$textField);\n    }\n    switchBitmapMode(val) {\n        if (val && this.displayObject == this.$textField) {\n            if (this.$btContainer == null)\n                this.$btContainer = new UIContainer(this);\n            this.switchDisplayObject(this.$btContainer);\n        }\n        else if (!val && this.displayObject == this.$btContainer)\n            this.switchDisplayObject(this.$textField);\n    }\n    dispose() {\n        GTimer.inst.remove(this.$render, this);\n        this.$bitmapFont = null;\n        this.$bitmapPool.length = 0;\n        this.$bitmapPool = null;\n        this.$style = null;\n        super.dispose();\n    }\n    set text(value) {\n        this.setText(value);\n    }\n    setText(value) {\n        if (value == null)\n            value = '';\n        if (this.$text == value)\n            return;\n        this.$text = value;\n        this.updateGear(6 /* Text */);\n        if (this.parent && this.parent.$inProgressBuilding)\n            this.renderNow();\n        else\n            this.render();\n    }\n    get text() {\n        return this.getText();\n    }\n    getText() {\n        return this.$text;\n    }\n    get color() {\n        return this.getColor();\n    }\n    getColor() {\n        return this.$color;\n    }\n    setColor(value) {\n        if (this.$color != value) {\n            this.$color = value;\n            this.updateGear(4 /* Color */);\n            this.$style.fill = this.$color;\n            this.render();\n        }\n    }\n    set color(value) {\n        this.setColor(value);\n    }\n    get titleColor() {\n        return this.color;\n    }\n    set titleColor(value) {\n        this.color = value;\n    }\n    get lineHeight() {\n        if (this.$style.lineHeight > 0)\n            return this.$style.lineHeight;\n        if (!this.$fontProperties)\n            return +this.$style.fontSize + this.$style.strokeThickness; //rough value\n        return this.$fontProperties.fontSize + this.$style.strokeThickness + this.$style.leading;\n    }\n    set lineHeight(lh) {\n        this.$style.lineHeight = lh;\n    }\n    get font() {\n        return this.$font || UIConfig.defaultFont;\n    }\n    set font(value) {\n        if (this.$font != value) {\n            this.$font = value;\n            if (this.$font && StringUtil.startsWith(this.$font, 'ui://'))\n                this.$bitmapFont = UIPackage.getBitmapFontByURL(this.$font);\n            else\n                this.$style.fontFamily = this.$font || UIConfig.defaultFont;\n            this.render();\n        }\n    }\n    get fontSize() {\n        return +this.$style.fontSize;\n    }\n    set fontSize(value) {\n        if (value <= 0)\n            return;\n        if (this.$style.fontSize != value) {\n            this.$style.fontSize = value;\n            this.render();\n        }\n    }\n    get align() {\n        return this.$style.align;\n    }\n    set align(value) {\n        if (this.$style.align != value) {\n            this.$style.align = value;\n            this.render();\n        }\n    }\n    get verticalAlign() {\n        return this.$verticalAlign;\n    }\n    set verticalAlign(value) {\n        if (this.$verticalAlign != value) {\n            this.$verticalAlign = value;\n            if (!this.$inProgressBuilding)\n                this.layoutAlign();\n        }\n    }\n    get leading() {\n        return this.$style.leading;\n    }\n    set leading(value) {\n        if (this.$style.leading != value) {\n            this.$style.leading = value;\n            this.render();\n        }\n    }\n    get letterSpacing() {\n        return this.$style.letterSpacing;\n    }\n    set letterSpacing(value) {\n        if (this.$style.letterSpacing != value) {\n            this.$style.letterSpacing = value;\n            this.render();\n        }\n    }\n    get underline() {\n        return false; //TODO: not supported yet\n    }\n    set underline(value) {\n        //TODO: not supported yet\n    }\n    get bold() {\n        return this.$style.fontWeight == 'bold';\n    }\n    set bold(value) {\n        let v = value === true ? 'bold' : 'normal';\n        if (this.$style.fontWeight != v) {\n            this.$style.fontWeight = v;\n            this.render();\n        }\n    }\n    get weight() {\n        return this.$style.fontWeight;\n    }\n    set weight(v) {\n        if (this.$style.fontWeight != v) {\n            this.$style.fontWeight = v;\n            this.render();\n        }\n    }\n    get variant() {\n        return this.$style.fontVariant;\n    }\n    set variant(v) {\n        if (this.$style.fontVariant != v) {\n            this.$style.fontVariant = v;\n            this.render();\n        }\n    }\n    get italic() {\n        return this.$style.fontStyle == 'italic';\n    }\n    set italic(value) {\n        let v = value === true ? 'italic' : 'normal';\n        if (this.$style.fontStyle != v) {\n            this.$style.fontStyle = v;\n            this.render();\n        }\n    }\n    get multipleLine() {\n        return !this.$singleLine;\n    }\n    set multipleLine(value) {\n        value = !value;\n        if (this.$singleLine != value) {\n            this.$singleLine = value;\n            this.render();\n        }\n    }\n    get stroke() {\n        return +this.$style.strokeThickness;\n    }\n    set stroke(value) {\n        if (this.$style.strokeThickness != value)\n            this.$style.strokeThickness = value;\n    }\n    get strokeColor() {\n        return this.$style.stroke;\n    }\n    set strokeColor(value) {\n        if (this.$style.stroke != value)\n            this.$style.stroke = value;\n    }\n    set autoSize(value) {\n        if (this.$autoSize != value) {\n            this.$autoSize = value;\n            this.$widthAutoSize = value == 1 /* Both */ || value == 3 /* Shrink */;\n            this.$heightAutoSize = value == 1 /* Both */ || value == 2 /* Height */;\n            this.render();\n        }\n    }\n    get autoSize() {\n        return this.$autoSize;\n    }\n    get textWidth() {\n        if (this.$requireRender)\n            this.renderNow();\n        return this.$textWidth;\n    }\n    get textHeight() {\n        if (this.$requireRender)\n            this.renderNow();\n        return this.$textHeight;\n    }\n    ensureSizeCorrect() {\n        if (this.$sizeDirty && this.$requireRender)\n            this.renderNow();\n    }\n    render() {\n        if (!this.$requireRender) {\n            this.$requireRender = true;\n            GTimer.inst.callLater(this.$render, this);\n        }\n        if (!this.$sizeDirty && (this.$widthAutoSize || this.$heightAutoSize)) {\n            this.$sizeDirty = true;\n            let evt = new createjs.Event(\"__sizeDelayChange\" /* SIZE_DELAY_CHANGE */, true, false);\n            this.dispatchEvent(evt, this);\n        }\n    }\n    applyStyle() {\n        this.$textField.style.stroke = this.$style.stroke;\n        this.$textField.style.strokeThickness = this.$style.strokeThickness;\n        this.$textField.style.fontStyle = this.$style.fontStyle;\n        this.$textField.style.fontVariant = this.$style.fontVariant;\n        this.$textField.style.fontWeight = this.$style.fontWeight;\n        this.$textField.style.letterSpacing = this.$style.letterSpacing;\n        this.$textField.style.align = this.$style.align;\n        this.$textField.style.fontSize = this.$style.fontSize;\n        this.$textField.style.fontFamily = this.$style.fontFamily;\n        this.$textField.style.fill = this.$style.fill;\n        this.$textField.style.dropShadowColor = this.$style.dropShadowColor;\n        this.$textField.style.dropShadowOffsetX = this.$style.dropShadowOffsetX;\n        this.$textField.style.dropShadowOffsetY = this.$style.dropShadowOffsetY;\n        this.$textField.style.leading = this.$style.leading;\n        this.$textField.applyStyle();\n    }\n    $render() {\n        if (this.$requireRender)\n            this.renderNow();\n    }\n    renderNow(updateBounds = true) {\n        this.$requireRender = false;\n        this.$sizeDirty = false;\n        if (this.$bitmapFont != null) {\n            this.renderWithBitmapFont(updateBounds);\n            return;\n        }\n        this.switchBitmapMode(false);\n        this.applyStyle();\n        this.$textField.$updateMinHeight();\n        let wordWrap = !this.$widthAutoSize && this.multipleLine;\n        this.$textField.width = this.$textField.style.wordWrapWidth =\n            wordWrap || this.autoSize == 0 /* None */ ? Math.ceil(this.width) : 10000;\n        this.$textField.style.wordWrap = wordWrap;\n        this.$textField.style.breakWords = wordWrap;\n        this.$textField.content = this.$text; //trigger t.dirty = true\n        this.$fontProperties = TextMetrics.measureFont(this.$style.toFontString());\n        this.$textWidth = Math.ceil(this.$textField.textWidth);\n        if (this.$textWidth > 0)\n            this.$textWidth += GTextField.GUTTER_X * 2; //margin gap\n        this.$textHeight = Math.ceil(this.$textField.textHeight);\n        if (this.$textHeight > 0)\n            this.$textHeight += GTextField.GUTTER_Y * 2; //margin gap\n        let w = this.width, h = this.height;\n        if (this.autoSize == 3 /* Shrink */) {\n            this.shrinkTextField();\n        }\n        else {\n            this.$textField.set({ scaleX: 1, scaleY: 1 });\n            if (this.$widthAutoSize) {\n                w = this.$textWidth;\n                this.$textField.width = w;\n            }\n            if (this.$heightAutoSize) {\n                h = this.$textHeight;\n                if (this.$textField.height != this.$textHeight)\n                    this.$textField.height = this.$textHeight;\n            }\n            else {\n                h = this.height;\n                if (this.$textHeight > h)\n                    this.$textHeight = h;\n            }\n        }\n        if (updateBounds) {\n            this.$updatingSize = true;\n            this.setSize(w, h);\n            this.$updatingSize = false;\n        }\n        this.layoutAlign();\n    }\n    renderWithBitmapFont(updateBounds) {\n        this.switchBitmapMode(true);\n        /**\n         * todo\n         */\n        this.$btContainer.children.forEach((c, i) => {\n            this.$bitmapPool.push(this.$btContainer.getChildAt(i));\n        }, this);\n        this.$btContainer.removeAllChildren();\n        if (!this.$lines)\n            this.$lines = [];\n        else\n            LineInfo.recycleMany(this.$lines);\n        let letterSpacing = this.letterSpacing;\n        let lineSpacing = this.leading - 1;\n        let rectWidth = this.width - GTextField.GUTTER_X * 2;\n        let lineWidth = 0, lineHeight = 0, lineTextHeight = 0;\n        let glyphWidth = 0, glyphHeight = 0;\n        let wordChars = 0, wordStart = 0, wordEnd = 0;\n        let lastLineHeight = 0;\n        let lineBuffer = '';\n        let lineY = GTextField.GUTTER_Y;\n        let line;\n        let wordWrap = !this.$widthAutoSize && this.multipleLine;\n        let fontScale = this.$bitmapFont.resizable ? this.fontSize / this.$bitmapFont.size : 1;\n        let glyph;\n        this.$textWidth = 0;\n        this.$textHeight = 0;\n        let textLength = this.text.length;\n        for (let offset = 0; offset < textLength; ++offset) {\n            let ch = this.$text.charAt(offset);\n            let cc = ch.charCodeAt(offset);\n            if (ch == '\\n') {\n                lineBuffer += ch;\n                line = LineInfo.get();\n                line.width = lineWidth;\n                if (lineTextHeight == 0) {\n                    if (lastLineHeight == 0)\n                        lastLineHeight = Math.ceil(this.fontSize * fontScale);\n                    if (lineHeight == 0)\n                        lineHeight = lastLineHeight;\n                    lineTextHeight = lineHeight;\n                }\n                line.height = lineHeight;\n                lastLineHeight = lineHeight;\n                line.textHeight = lineTextHeight;\n                line.text = lineBuffer;\n                line.y = lineY;\n                lineY += line.height + lineSpacing;\n                if (line.width > this.$textWidth)\n                    this.$textWidth = line.width;\n                this.$lines.push(line);\n                lineBuffer = '';\n                lineWidth = 0;\n                lineHeight = 0;\n                lineTextHeight = 0;\n                wordChars = 0;\n                wordStart = 0;\n                wordEnd = 0;\n                continue;\n            }\n            if (cc > 256 || cc <= 32) {\n                if (wordChars > 0)\n                    wordEnd = lineWidth;\n                wordChars = 0;\n            }\n            else {\n                if (wordChars == 0)\n                    wordStart = lineWidth;\n                wordChars++;\n            }\n            if (ch == ' ') {\n                glyphWidth = Math.ceil(this.fontSize / 2);\n                glyphHeight = Math.ceil(this.fontSize);\n            }\n            else {\n                glyph = this.$bitmapFont.glyphs[ch];\n                if (glyph) {\n                    glyphWidth = Math.ceil(glyph.advance * fontScale);\n                    glyphHeight = Math.ceil(glyph.lineHeight * fontScale);\n                }\n                else if (ch == ' ') {\n                    glyphWidth = Math.ceil((this.$bitmapFont.size * fontScale) / 2);\n                    glyphHeight = Math.ceil(this.$bitmapFont.size * fontScale);\n                }\n                else {\n                    glyphWidth = 0;\n                    glyphHeight = 0;\n                }\n            }\n            if (glyphHeight > lineTextHeight)\n                lineTextHeight = glyphHeight;\n            if (glyphHeight > lineHeight)\n                lineHeight = glyphHeight;\n            if (lineWidth != 0)\n                lineWidth += letterSpacing;\n            lineWidth += glyphWidth;\n            if (!wordWrap || lineWidth <= rectWidth) {\n                lineBuffer += ch;\n            }\n            else {\n                line = LineInfo.get();\n                line.height = lineHeight;\n                line.textHeight = lineTextHeight;\n                if (lineBuffer.length == 0) {\n                    //the line cannt fit even a char\n                    line.text = ch;\n                }\n                else if (wordChars > 0 && wordEnd > 0) {\n                    //if word had broken, move it to new line\n                    lineBuffer += ch;\n                    let len = lineBuffer.length - wordChars;\n                    line.text = StringUtil.trimRight(lineBuffer.substr(0, len));\n                    line.width = wordEnd;\n                    lineBuffer = lineBuffer.substr(len + 1);\n                    lineWidth -= wordStart;\n                }\n                else {\n                    line.text = lineBuffer;\n                    line.width = lineWidth - (glyphWidth + letterSpacing);\n                    lineBuffer = ch;\n                    lineWidth = glyphWidth;\n                    lineHeight = glyphHeight;\n                    lineTextHeight = glyphHeight;\n                }\n                line.y = lineY;\n                lineY += line.height + lineSpacing;\n                if (line.width > this.$textWidth)\n                    this.$textWidth = line.width;\n                wordChars = 0;\n                wordStart = 0;\n                wordEnd = 0;\n                this.$lines.push(line);\n            }\n        }\n        if (lineBuffer.length > 0 ||\n            (this.$lines.length > 0 &&\n                StringUtil.endsWith(this.$lines[this.$lines.length - 1].text, '\\n'))) {\n            line = LineInfo.get();\n            line.width = lineWidth;\n            if (lineHeight == 0)\n                lineHeight = lastLineHeight;\n            if (lineTextHeight == 0)\n                lineTextHeight = lineHeight;\n            line.height = lineHeight;\n            line.textHeight = lineTextHeight;\n            line.text = lineBuffer;\n            line.y = lineY;\n            if (line.width > this.$textWidth)\n                this.$textWidth = line.width;\n            this.$lines.push(line);\n        }\n        if (this.$textWidth > 0)\n            this.$textWidth += GTextField.GUTTER_X * 2;\n        let count = this.$lines.length;\n        if (count == 0) {\n            this.$textHeight = 0;\n        }\n        else {\n            line = this.$lines[this.$lines.length - 1];\n            this.$textHeight = line.y + line.height + GTextField.GUTTER_Y;\n        }\n        let w, h = 0;\n        if (this.$widthAutoSize) {\n            if (this.$textWidth == 0)\n                w = 0;\n            else\n                w = this.$textWidth;\n        }\n        else\n            w = this.width;\n        if (this.$heightAutoSize) {\n            if (this.$textHeight == 0)\n                h = 0;\n            else\n                h = this.$textHeight;\n        }\n        else\n            h = this.height;\n        if (updateBounds) {\n            this.$updatingSize = true;\n            this.setSize(w, h);\n            this.$updatingSize = false;\n        }\n        if (w == 0 || h == 0)\n            return;\n        rectWidth = this.width - GTextField.GUTTER_X * 2;\n        this.$lines.forEach(line => {\n            let charX = GTextField.GUTTER_X;\n            let lineIndent = 0;\n            let charIndent = 0;\n            if (this.align == \"center\" /* Center */)\n                lineIndent = (rectWidth - line.width) / 2;\n            else if (this.align == \"right\" /* Right */)\n                lineIndent = rectWidth - line.width;\n            else\n                lineIndent = 0;\n            textLength = line.text.length;\n            for (let j = 0; j < textLength; j++) {\n                let ch = line.text.charAt(j);\n                glyph = this.$bitmapFont.glyphs[ch];\n                if (glyph != null) {\n                    charIndent = (line.height + line.textHeight) / 2 - Math.ceil(glyph.lineHeight * fontScale);\n                    let bm;\n                    if (this.$bitmapPool.length)\n                        bm = this.$bitmapPool.pop();\n                    else\n                        bm = new Bitmap();\n                    bm.x = charX + lineIndent + Math.ceil(glyph.offsetX * fontScale);\n                    bm.y = line.y + charIndent + Math.ceil(glyph.offsetY * fontScale);\n                    bm.texture = glyph.texture.image;\n                    bm.textureRect = glyph.texture.rect;\n                    let { x, y, width, height } = glyph;\n                    bm.sourceRect = new createjs.Rectangle(x, y, width, height);\n                    bm.set({ scaleX: fontScale, scaleY: fontScale });\n                    bm.tint = this.$bitmapFont.colorable === true ? this.$color : '0xFFFFFF';\n                    this.$btContainer.addChild(bm);\n                    charX += letterSpacing + Math.ceil(glyph.advance * fontScale);\n                }\n                else if (ch == ' ') {\n                    charX += letterSpacing + Math.ceil((this.$bitmapFont.size * fontScale) / 2);\n                }\n                else {\n                    charX += letterSpacing;\n                }\n            }\n        });\n    }\n    localToGlobal(ax = 0, ay = 0, resultPoint) {\n        ax -= this.$offset.x;\n        ay -= this.$offset.y;\n        return super.localToGlobal(ax, ay, resultPoint);\n    }\n    globalToLocal(ax = 0, ay = 0, resultPoint) {\n        let r = super.globalToLocal(ax, ay, resultPoint);\n        r.x -= this.$offset.x;\n        r.y -= this.$offset.y;\n        return r;\n    }\n    handleSizeChanged() {\n        if (this.$updatingSize)\n            return;\n        if (this.$bitmapFont != null) {\n            if (!this.$widthAutoSize)\n                this.render();\n        }\n        else {\n            if (this.$inProgressBuilding) {\n                this.$textField.width = this.width;\n                this.$textField.height = this.height;\n            }\n            else {\n                if (this.$autoSize == 3 /* Shrink */)\n                    this.shrinkTextField();\n                else {\n                    if (!this.$widthAutoSize) {\n                        if (!this.$heightAutoSize) {\n                            this.$textField.width = this.width;\n                            this.$textField.height = this.height;\n                        }\n                        else\n                            this.$textField.width = this.width;\n                    }\n                }\n            }\n        }\n        this.layoutAlign();\n    }\n    shrinkTextField() {\n        let fitScale = Math.min(1, this.width / this.$textWidth);\n        this.$textField.set({ scaleX: fitScale, scaleY: fitScale });\n    }\n    layoutAlign() {\n        let tw = this.$textWidth, th = this.$textHeight;\n        if (this.autoSize == 3 /* Shrink */) {\n            tw *= this.displayObject.scaleX;\n            th *= this.displayObject.scaleY;\n        }\n        if (this.$verticalAlign == 0 /* Top */ || th == 0)\n            this.$offset.y = GTextField.GUTTER_Y;\n        else {\n            let dh = Math.max(0, this.height - th);\n            if (this.$verticalAlign == 1 /* Middle */)\n                this.$offset.y = dh * 0.5;\n            else if (this.$verticalAlign == 2 /* Bottom */)\n                this.$offset.y = dh;\n        }\n        let xPos = 0;\n        switch (this.$style.align) {\n            case 'center':\n                xPos = (this.width - tw) * 0.5;\n                break;\n            case 'right':\n                xPos = this.width - tw;\n                break;\n        }\n        this.$offset.x = xPos;\n        this.updatePosition();\n    }\n    updatePosition() {\n        let x = Math.floor(this.x + this.$offset.x);\n        let y = Math.floor(this.y + this.$offset.y);\n        this.displayObject.set({ x, y });\n        this.$textField.updateMultiplePosition(x, y);\n    }\n    handleXYChanged() {\n        super.handleXYChanged();\n        if (this.$displayObject)\n            this.updatePosition();\n    }\n    setupBeforeAdd(xml) {\n        super.setupBeforeAdd(xml);\n        let str = xml.attributes.font;\n        if (str)\n            this.font = str;\n        str = xml.attributes.vAlign;\n        if (str)\n            this.verticalAlign = ParseVertAlignType(str);\n        str = xml.attributes.leading;\n        if (str)\n            this.$style.leading = parseInt(str);\n        str = xml.attributes.letterSpacing;\n        if (str)\n            this.$style.letterSpacing = parseInt(str);\n        str = xml.attributes.fontSize;\n        if (str)\n            this.$style.fontSize = parseInt(str);\n        str = xml.attributes.color;\n        if (str) {\n            this.color = str;\n        }\n        str = xml.attributes.shadowColor;\n        if (str) {\n            this.$style.dropShadowColor = str;\n        }\n        let arr;\n        str = xml.attributes.shadowOffset;\n        if (str) {\n            arr = str.split(',');\n            if (arr.length > 1) {\n                this.$style.dropShadowOffsetX = parseInt(arr[0]);\n                this.$style.dropShadowOffsetY = parseInt(arr[1]);\n            }\n        }\n        str = xml.attributes.align;\n        if (str)\n            this.align = ParseAlignType(str);\n        str = xml.attributes.autoSize;\n        if (str) {\n            this.autoSize = ParseAutoSizeType(str);\n            this.$widthAutoSize =\n                this.$autoSize == 1 /* Both */ || this.$autoSize == 3 /* Shrink */;\n            this.$heightAutoSize =\n                this.$autoSize == 1 /* Both */ || this.$autoSize == 2 /* Height */;\n        }\n        this.underline = xml.attributes.underline == 'true';\n        this.italic = xml.attributes.italic == 'true';\n        this.bold = xml.attributes.bold == 'true';\n        this.multipleLine = xml.attributes.singleLine != 'true';\n        str = xml.attributes.strokeColor;\n        if (str) {\n            this.strokeColor = str;\n            str = xml.attributes.strokeSize;\n            if (str)\n                this.stroke = parseInt(str);\n            else\n                this.stroke = 1;\n        }\n    }\n    setupAfterAdd(xml) {\n        super.setupAfterAdd(xml);\n        let str = xml.attributes.text;\n        if (str != null && str.length > 0)\n            this.text = str;\n        this.$sizeDirty = false;\n    }\n}\nGTextField.GUTTER_X = 2;\nGTextField.GUTTER_Y = 2;\n\n//TOOD: impl\nclass GRichTextField extends GTextField {\n    constructor() {\n        super();\n        // this.$textField.interactive = true;\n        // this.$textField.interactiveChildren = false;\n        this.on(\"__linkClick\" /* LinkClick */, this.$clickLink, this);\n    }\n    set ubbEnabled(value) {\n        if (this.$ubbEnabled != value) {\n            this.$ubbEnabled = value;\n            this.render();\n        }\n    }\n    get ubbEnabled() {\n        return this.$ubbEnabled;\n    }\n    setupBeforeAdd(xml) {\n        super.setupBeforeAdd(xml);\n        this.$ubbEnabled = xml.attributes.ubb == 'true';\n    }\n    set textFlow(flow) {\n        this.$textFlow = flow;\n        this.render();\n    }\n    set text(value) {\n        this.$text = value;\n        if (this.$text == null)\n            this.$text = '';\n        this.$textField.width = this.width;\n        // if(this.$ubbEnabled)\n        // this.textFlow = StringUtil.parseUBB(this.$text);   //TODO: parser impl\n        this.updateGear(6 /* Text */);\n        this.render();\n    }\n    $clickLink(block) {\n        let event = new createjs.Event(\"__linkClick\" /* LinkClick */, true, false);\n        event.data = block.text;\n        this.dispatchEvent(event, this);\n    }\n    dispose() {\n        this.off(\"__linkClick\" /* LinkClick */, this.$clickLink);\n        super.dispose();\n    }\n}\n\nclass InputElement extends createjs.EventDispatcher {\n    constructor(tf) {\n        super();\n        this.$requestToShow = false;\n        //private $requestToHide:boolean = false;\n        this.inputElement = null;\n        this.inputDiv = null;\n        this.$scaleX = 0;\n        this.$scaleY = 0;\n        this.textValue = '';\n        this.colorValue = '0xffffff';\n        this.$attrsCache = {};\n        this.$textfield = tf;\n    }\n    /**@internal */\n    $addToStage() {\n        this.htmlInput = HTMLInput.inst; //take multiple canvas on webpage into account?\n    }\n    initElement() {\n        let point = this.$textfield.localToGlobal(0, 0);\n        let x = point.x;\n        let y = point.y;\n        let scaleX = this.htmlInput.$scaleX;\n        let scaleY = this.htmlInput.$scaleY;\n        if (!this.$textfield.multipleLine)\n            this.inputElement.style.top = -this.$textfield.leading * scaleY + 'px';\n        this.inputDiv.style.top = (y + 1) * scaleY + 'px';\n        this.inputDiv.style.left = x * scaleX + 'px';\n        let node = this.$textfield;\n        let cX = 1;\n        let cY = 1;\n        let rotation = 0;\n        while (node.parent) {\n            cX *= node.scaleX;\n            cY *= node.scaleY;\n            rotation += node.rotation;\n            node = node.parent;\n        }\n        let style = this.inputDiv.style;\n        style.transform = style.webkitTransform = style.msTransform = style.mozTransform = style.oTransform =\n            'rotate(' + rotation + 'deg)';\n        this.$scaleX = scaleX * cX;\n        this.$scaleY = scaleY * cY;\n    }\n    get textField() {\n        return this.$textfield;\n    }\n    /**@internal */\n    $show() {\n        if (!this.htmlInput.isCurrentInput(this)) {\n            this.inputElement = this.htmlInput.requestInput(this);\n            if (!this.$textfield.multipleLine)\n                this.inputElement.type = this.$textfield.type;\n            for (let key in this.$attrsCache)\n                this.inputElement.setAttribute(key, this.$attrsCache[key]);\n            this.inputDiv = this.htmlInput.$wrapper;\n        }\n        else\n            this.inputElement.onblur = null;\n        this.htmlInput.$requestToShow = true;\n        this.$requestToShow = true;\n        this.initElement();\n    }\n    $hide() { }\n    onBlurHandler() {\n        this.htmlInput.clearInputElement();\n        this.htmlInput.clearAttributes(this.$attrsCache);\n        window.scrollTo(0, 0);\n    }\n    get text() {\n        if (!this.textValue)\n            this.textValue = '';\n        return this.textValue;\n    }\n    set text(value) {\n        this.textValue = value;\n        if (this.inputElement)\n            this.inputElement.value = this.textValue;\n    }\n    setColor(value) {\n        this.colorValue = value;\n        if (this.inputElement)\n            this.setElementStyle('color', StringUtil.HEX2RGB(this.colorValue));\n    }\n    /**@internal */\n    $onBlur() {\n        // this.dispatchEvent(\"updateText\");\n    }\n    onInputHandler() {\n        window.setTimeout(() => {\n            if (this.inputElement && this.inputElement.selectionStart == this.inputElement.selectionEnd) {\n                this.textValue = this.inputElement.value;\n                this.dispatchEvent('updateText');\n            }\n        }, 0);\n    }\n    setAreaHeight() {\n        let tf = this.$textfield;\n        if (tf.multipleLine) {\n            let textheight = tf.textHeight;\n            if (tf.height <= tf.fontSize) {\n                this.setElementStyle('height', tf.fontSize * this.$scaleY + 'px');\n                this.setElementStyle('padding', '0px');\n                this.setElementStyle('lineHeight', tf.lineHeight * this.$scaleY + 'px');\n            }\n            else if (tf.height < textheight) {\n                this.setElementStyle('height', tf.height * this.$scaleY + 'px');\n                this.setElementStyle('padding', '0px');\n                this.setElementStyle('lineHeight', tf.lineHeight * this.$scaleY + 'px');\n            }\n            else {\n                this.setElementStyle('height', (textheight + tf.leading) * this.$scaleY + 'px');\n                let rap = (tf.height - textheight) * this.$scaleY;\n                let valign = this.getVAlignFactor(tf);\n                let top = rap * valign;\n                let bottom = rap - top;\n                this.setElementStyle('padding', top + 'px 0px ' + bottom + 'px 0px');\n                this.setElementStyle('lineHeight', tf.lineHeight * this.$scaleY + 'px');\n            }\n        }\n    }\n    getVAlignFactor(textfield) {\n        let vao = 0;\n        switch (textfield.verticalAlign) {\n            case 0 /* Top */:\n                break;\n            case 1 /* Middle */:\n                vao = 0.5;\n                break;\n            case 2 /* Bottom */:\n                vao = 1;\n                break;\n        }\n        return vao;\n    }\n    onClickHandler(e) {\n        if (this.$requestToShow) {\n            //e.stopImmediatePropagation();\n            this.$requestToShow = false;\n            this.inputElement.value = this.text;\n            if (this.inputElement.onblur == null)\n                this.inputElement.onblur = Binder.create(this.onBlurHandler, this);\n            this.resetInput();\n            if (this.$textfield.maxLength > 0)\n                this.inputElement.setAttribute('maxlength', String(this.$textfield.maxLength));\n            else\n                this.inputElement.removeAttribute('maxlength');\n            this.inputElement.selectionStart = this.inputElement.value.length;\n            this.inputElement.selectionEnd = this.inputElement.value.length;\n            this.inputElement.focus();\n            let evt = new createjs.Event(\"__focusChanged\" /* CHANGED */, true, false);\n            evt.data = 'focus';\n            this.dispatchEvent(evt);\n        }\n    }\n    onDisconnect() {\n        this.inputElement = null;\n        let evt = new createjs.Event(\"__focusChanged\" /* CHANGED */, true, false);\n        evt.data = 'blur';\n        this.dispatchEvent(evt);\n    }\n    setElementStyle(style, value) {\n        if (value == null)\n            return;\n        if (this.inputElement) {\n            let ss = this.inputElement.style;\n            ss[style] = value;\n        }\n    }\n    setAttribute(name, value) {\n        if (name == null || value == null)\n            return;\n        this.$attrsCache[name] = value;\n    }\n    getAttribute(name) {\n        return this.$attrsCache[name];\n    }\n    /**@internal */\n    $removeFromStage() {\n        if (this.inputElement)\n            this.htmlInput.disconnect(this);\n    }\n    resetInput() {\n        if (this.inputElement) {\n            let textfield = this.$textfield;\n            this.setElementStyle('fontFamily', textfield.font);\n            this.setElementStyle('fontStyle', textfield.italic ? 'italic' : 'normal');\n            this.setElementStyle('fontWeight', textfield.bold ? 'bold' : 'normal');\n            this.setElementStyle('textAlign', textfield.align);\n            this.setElementStyle('fontSize', textfield.fontSize * this.$scaleY + 'px');\n            this.setElementStyle('color', StringUtil.convertToHtmlColor(+textfield.color));\n            this.setElementStyle('width', textfield.width * this.$scaleX + 'px'); //take 'maxWidth' into account\n            let va = 'middle', vao = 0;\n            switch (textfield.verticalAlign) {\n                case 0 /* Top */:\n                    va = 'top';\n                    break;\n                case 1 /* Middle */:\n                    va = 'middle';\n                    vao = 0.5;\n                    break;\n                case 2 /* Bottom */:\n                    va = 'bottom';\n                    vao = 1;\n                    break;\n            }\n            this.setElementStyle('verticalAlign', va);\n            if (textfield.multipleLine)\n                this.setAreaHeight();\n            else {\n                this.setElementStyle('lineHeight', textfield.lineHeight * this.$scaleY + 'px');\n                if (textfield.height < textfield.fontSize) {\n                    this.setElementStyle('height', textfield.fontSize * this.$scaleY + 'px');\n                    this.setElementStyle('padding', '0px 0px ' + textfield.fontSize * 0.5 * this.$scaleX + 'px 0px');\n                }\n                else {\n                    this.setElementStyle('height', textfield.fontSize * this.$scaleY + 'px');\n                    let rap = (textfield.height - textfield.fontSize) * this.$scaleY;\n                    let top = rap * vao;\n                    let bottom = rap - top, fsy = textfield.fontSize * 0.5 * this.$scaleY;\n                    if (bottom < fsy)\n                        bottom = fsy;\n                    this.setElementStyle('padding', top + 'px 0px ' + bottom + 'px 0px');\n                }\n            }\n            this.inputDiv.style.clip =\n                'rect(0px ' +\n                    textfield.width * this.$scaleX +\n                    'px ' +\n                    textfield.height * this.$scaleY +\n                    'px 0px)';\n            this.inputDiv.style.height = textfield.height * this.$scaleY + 'px';\n            this.inputDiv.style.width = textfield.width * this.$scaleX + 'px'; //take 'maxWidth' into account\n        }\n    }\n}\n\nclass InputDelegate {\n    constructor(tf) {\n        this.$inited = false;\n        this.$restrictString = null;\n        this.$restrictRegex = null;\n        this.$focused = false;\n        this.$textField = tf;\n        this.$input = new InputElement(tf);\n    }\n    initialize() {\n        if (this.$inited)\n            return;\n        this.$input.$addToStage();\n        this.$input.on('updateText', this.updateText, this);\n        this.$input.on(\"__focusChanged\" /* CHANGED */, this.focusHandler, this);\n        this.$textField.on(InteractiveEvents.Down, this.textFieldDownHandler, this);\n        this.$inited = true;\n    }\n    textFieldDownHandler() {\n        this.$onFocus();\n    }\n    destroy() {\n        if (!this.$inited)\n            return;\n        this.$input.$removeFromStage();\n        this.$textField.off(InteractiveEvents.Down, this.textFieldDownHandler);\n        GRoot.inst.off(InteractiveEvents.Down, this.onStageDown);\n        this.$input.off('updateText', this.updateText);\n        this.$input.off(\"__focusChanged\" /* CHANGED */, this.focusHandler);\n        this.$inited = false;\n    }\n    get text() {\n        return this.$input.text;\n    }\n    set text(v) {\n        this.$input.text = v;\n    }\n    setColor(v) {\n        return this.$input.setColor(v);\n    }\n    updateText() {\n        let textValue = this.$input.text;\n        let isChanged = false;\n        if (this.$restrictRegex != null) {\n            let result = textValue.match(this.$restrictRegex);\n            if (result)\n                textValue = result.join('');\n            else\n                textValue = '';\n            isChanged = true;\n        }\n        if (isChanged && this.$input.text != textValue)\n            this.$input.text = textValue;\n        this.$textField.text = this.$input.text;\n        let evt = new createjs.Event(\"__textChange\" /* Change */, true, false);\n        evt.data = { textField: this.$textField };\n        this.$textField.dispatchEvent(evt, this);\n    }\n    onStageDown(e) {\n        let target = GObject.castFromNativeObject(e.currentTarget);\n        if (target != this.$textField)\n            this.$input.$hide();\n    }\n    focusHandler(evt) {\n        let { data } = evt;\n        if (data == 'focus') {\n            if (!this.$focused) {\n                this.$focused = true;\n                this.$textField.$isTyping = true;\n                this.$textField.alpha = 0.01;\n                this.$textField.dispatchEvent(\"__focusChanged\" /* CHANGED */, 'focus');\n                this.$textField.dispatchEvent(\"__textFocusIn\" /* FocusIn */, this.$textField);\n            }\n        }\n        else if (data == 'blur') {\n            if (this.$focused) {\n                this.$focused = false;\n                GRoot.inst.off(InteractiveEvents.Down, this.onStageDown);\n                this.$textField.$isTyping = false;\n                this.$textField.alpha = 1;\n                this.$input.$onBlur();\n                this.$textField.dispatchEvent(\"__focusChanged\" /* CHANGED */, 'blur');\n                this.$textField.dispatchEvent(\"__textFocusOut\" /* FocusOut */, this.$textField);\n            }\n        }\n    }\n    get isFocused() {\n        return this.$focused;\n    }\n    /**@internal */\n    $getProperty(name) {\n        return (this.$inited && this.$input.getAttribute(name)) || null;\n    }\n    /**@internal */\n    $setProperty(name, value) {\n        if (!this.$inited)\n            return;\n        this.$input.setAttribute(name, value);\n    }\n    get $restrict() {\n        return this.$restrictString;\n    }\n    set $restrict(v) {\n        this.$restrictString = v;\n        if (this.$restrictString != null && this.$restrictString.length > 0)\n            this.$restrictRegex = new RegExp(this.$restrictString);\n        else\n            this.$restrictRegex = null;\n    }\n    get type() {\n        return this.$type;\n    }\n    set type(v) {\n        if (v != this.$type)\n            this.$type = v;\n    }\n    tryHideInput() {\n        if (!this.$textField.visible && this.$input)\n            this.$input.$removeFromStage();\n    }\n    /**@internal */\n    $updateProperties() {\n        if (this.isFocused) {\n            this.$input.resetInput();\n            this.tryHideInput();\n            return;\n        }\n        this.$input.text = this.$textField.text;\n        this.$input.resetInput();\n        this.tryHideInput();\n    }\n    /**@internal */\n    $onFocus() {\n        if (!this.$textField.visible || this.$focused)\n            return;\n        GRoot.inst.off(InteractiveEvents.Down, this.onStageDown);\n        GTimer.inst.callLater(() => {\n            GRoot.inst.on(InteractiveEvents.Down, this.onStageDown, this);\n        }, this);\n        this.$input.$show();\n    }\n}\n\nclass GTextInput extends GTextField {\n    constructor() {\n        super();\n        this.$util = null;\n        /**@internal */\n        this.$isTyping = false;\n        this.focusable = true;\n        this.editable = true; //init\n        this.type = \"text\" /* TEXT */;\n        this.on('removed', this.removed, this);\n        this.on('added', this.added, this);\n        this.$util.initialize();\n    }\n    createDisplayObject() {\n        super.createDisplayObject();\n        this.$hitArea = new createjs.Shape();\n        this.$hitArea.graphics.beginFill('#000').drawRect(0, 0, this.$width, this.$height);\n        this.$displayObject.hitArea = this.$hitArea;\n    }\n    handleSizeChanged() {\n        super.handleSizeChanged();\n        this.$hitArea.graphics.drawRect(0, 0, this.$width, this.$height);\n        this.$displayObject.hitArea = this.$hitArea;\n    }\n    removed(disp) {\n        if (this.$util)\n            this.$util.destroy();\n    }\n    added(disp) {\n        if (this.$util)\n            this.$util.initialize();\n    }\n    requestFocus() {\n        //tab or call actively\n        Decls$1.GRoot.inst.focus = this;\n        this.$util.$onFocus();\n    }\n    get editable() {\n        return this.$editable;\n    }\n    set editable(v) {\n        if (v != this.$editable) {\n            this.$editable = v;\n            if (this.$editable) {\n                if (!this.$util)\n                    this.$util = new InputDelegate(this);\n                this.$util.initialize();\n            }\n            else {\n                if (this.$util)\n                    this.$util.destroy();\n            }\n            this.touchable = this.$editable;\n        }\n    }\n    changeToPassText(text) {\n        let passText = '';\n        for (let i = 0, num = text.length; i < num; i++) {\n            switch (text.charAt(i)) {\n                case '\\n':\n                    passText += '\\n';\n                    break;\n                case '\\r':\n                    break;\n                default:\n                    passText += '*';\n            }\n        }\n        return passText;\n    }\n    getText() {\n        return this.$util.text;\n    }\n    setText(value) {\n        if (value == null)\n            value = '';\n        if (this.$text == value)\n            return;\n        this.$util.text = value;\n        super.setText(value);\n    }\n    setColor(value) {\n        super.setColor(value);\n        this.$util.setColor(value);\n    }\n    get promptText() {\n        return this.$util.$getProperty('placeholder');\n    }\n    set promptText(v) {\n        if (v == null)\n            v = '';\n        this.$util.$setProperty('placeholder', v);\n    }\n    get maxLength() {\n        return parseInt(this.$util.$getProperty('maxlength')) || 0;\n    }\n    set maxLength(v) {\n        this.$util.$setProperty('maxlength', String(v));\n    }\n    get restrict() {\n        return this.$util.$restrict;\n    }\n    set restrict(v) {\n        this.$util.$restrict = v;\n    }\n    get password() {\n        return this.type == \"password\" /* PASSWORD */;\n    }\n    set password(v) {\n        this.type = \"password\" /* PASSWORD */;\n    }\n    get type() {\n        return this.$util.type;\n    }\n    set type(t) {\n        this.$util.type = t;\n    }\n    dispose() {\n        super.dispose();\n        this.off('removed', this.removed);\n        this.off('added', this.added);\n        this.$util.destroy();\n        this.$util = null;\n    }\n    renderNow(updateBounds = true) {\n        this.$requireRender = false;\n        this.$sizeDirty = false;\n        this.$util.$updateProperties();\n        if (this.$isTyping)\n            this.decorateInputbox();\n        let origText = this.$text;\n        if (this.type == \"password\" /* PASSWORD */)\n            this.$text = this.changeToPassText(this.$text);\n        super.renderNow(updateBounds);\n        this.$text = origText;\n    }\n    decorateInputbox() {\n        //draw underlines?\n    }\n    setupBeforeAdd(xml) {\n        super.setupBeforeAdd(xml);\n        //this.promptText = xml.attributes.prompt;  //this will be available once UBB has implemented.\n        var str = xml.attributes.maxLength;\n        if (str != null)\n            this.maxLength = parseInt(str);\n        str = xml.attributes.restrict;\n        if (str != null)\n            this.restrict = str;\n        str = xml.attributes.password;\n        if (str == 'true')\n            this.password = true;\n        else {\n            str = xml.attributes.keyboardType;\n            if (str == '4')\n                this.type = \"number\" /* NUMBER */;\n            else if (str == '3')\n                this.type = \"url\" /* URL */;\n            else if (str == '5')\n                this.type = \"tel\" /* TEL */;\n            else if (str == '6')\n                this.type = \"email\" /* EMAIL */;\n        }\n    }\n}\n\nclass Recycler {\n    constructor() {\n        this.$count = 0;\n        this.$pool = {};\n    }\n    get count() {\n        return this.$count;\n    }\n    clear() {\n        for (let key in this.$pool) {\n            let arr = this.$pool[key];\n            if (arr) {\n                arr.length = 0;\n                arr = null;\n            }\n        }\n        this.$pool = {};\n        this.$count = 0;\n    }\n    get(id) {\n        let arr = this.$pool[id];\n        if (arr == null) {\n            arr = [];\n            this.$pool[id] = arr;\n        }\n        if (arr.length) {\n            this.$count--;\n            return arr.shift();\n        }\n        return this.createObject(id);\n    }\n    recycle(id, obj) {\n        if (!id)\n            return;\n        let arr = this.$pool[id];\n        if (arr == null) {\n            arr = [];\n            this.$pool[id] = arr;\n        }\n        this.$count++;\n        arr.push(obj);\n    }\n}\n\nclass GObjectRecycler extends Recycler {\n    constructor() {\n        super();\n    }\n    clear() {\n        for (let key in this.$pool) {\n            let arr = this.$pool[key];\n            if (arr) {\n                arr.forEach((v) => {\n                    v.dispose();\n                });\n            }\n        }\n        super.clear();\n    }\n    createObject(id) {\n        return UIPackage.createObjectFromURL(id); //id = url\n    }\n}\n\nclass GLoader extends GObject {\n    constructor() {\n        super();\n        this.$frame = 0;\n        this.$color = '#fff';\n        this.$contentSourceWidth = 0;\n        this.$contentSourceHeight = 0;\n        this.$contentWidth = 0;\n        this.$contentHeight = 0;\n        this.$loadingTexture = null;\n        this.$playing = true;\n        this.$url = '';\n        this.$fill = 0 /* None */;\n        this.$align = \"left\" /* Left */;\n        this.$verticalAlign = 0 /* Top */;\n        this.$showErrorSign = true;\n        this.$color = '#fff';\n    }\n    createDisplayObject() {\n        this.$container = new UIContainer(this);\n        this.$hitArea = new createjs.Shape();\n        this.$hitArea.graphics.beginFill('#000').drawRect(0, 0, 0, 0);\n        this.$container.hitArea = this.$hitArea;\n        this.setDisplayObject(this.$container);\n        // this.$container.mouseChildren = false\n    }\n    dispose() {\n        this.clearContent();\n        super.dispose();\n    }\n    get url() {\n        return this.$url;\n    }\n    set url(value) {\n        if (this.$url == value)\n            return;\n        this.$url = value;\n        this.loadContent();\n        this.updateGear(7 /* Icon */);\n    }\n    get icon() {\n        return this.$url;\n    }\n    set icon(value) {\n        this.url = value;\n    }\n    get align() {\n        return this.$align;\n    }\n    set align(value) {\n        if (this.$align != value) {\n            this.$align = value;\n            this.updateLayout();\n        }\n    }\n    get verticalAlign() {\n        return this.$verticalAlign;\n    }\n    set verticalAlign(value) {\n        if (this.$verticalAlign != value) {\n            this.$verticalAlign = value;\n            this.updateLayout();\n        }\n    }\n    get fill() {\n        return this.$fill;\n    }\n    set fill(value) {\n        if (this.$fill != value) {\n            this.$fill = value;\n            this.updateLayout();\n        }\n    }\n    get autoSize() {\n        return this.$autoSize;\n    }\n    set autoSize(value) {\n        if (this.$autoSize != value) {\n            this.$autoSize = value;\n            this.updateLayout();\n        }\n    }\n    get playing() {\n        return this.$playing;\n    }\n    set playing(value) {\n        if (this.$playing != value) {\n            this.$playing = value;\n            if (this.$content instanceof MovieClip)\n                this.$content.playing = value;\n            this.updateGear(5 /* Animation */);\n        }\n    }\n    get frame() {\n        return this.$frame;\n    }\n    set frame(value) {\n        if (this.$frame != value) {\n            this.$frame = value;\n            if (this.$content instanceof MovieClip)\n                this.$content.currentFrame = value;\n            this.updateGear(5 /* Animation */);\n        }\n    }\n    get color() {\n        return this.$color;\n    }\n    set color(value) {\n        if (this.$color != value) {\n            this.$color = value;\n            this.updateGear(4 /* Color */);\n            this.applyColor();\n        }\n    }\n    applyColor() {\n        if (this.$content)\n            this.$content.tint = this.$color;\n    }\n    get showErrorSign() {\n        return this.$showErrorSign;\n    }\n    set showErrorSign(value) {\n        this.$showErrorSign = value;\n    }\n    get content() {\n        return this.$content;\n    }\n    get texture() {\n        if (this.$content instanceof UIImage)\n            return this.$content.texture;\n        else\n            return null;\n    }\n    set texture(value) {\n        this.url = null;\n        this.switchToMovieMode(false);\n        if (this.$content instanceof UIImage)\n            this.$content.texture = value;\n        if (value) {\n            this.$contentSourceWidth = value.width;\n            this.$contentSourceHeight = value.height;\n        }\n        else\n            this.$contentSourceWidth = this.$contentHeight = 0;\n        this.updateLayout();\n    }\n    loadContent() {\n        this.clearContent();\n        if (!this.$url)\n            return;\n        if (StringUtil.startsWith(this.$url, 'ui://'))\n            this.loadFromPackage(this.$url);\n        else\n            this.loadExternal();\n    }\n    loadFromPackage(itemURL) {\n        this.$contentItem = UIPackage.getItemByURL(itemURL);\n        if (this.$contentItem) {\n            this.$contentItem.load();\n            if (this.$contentItem.type == 0 /* Image */) {\n                if (this.$contentItem.texture == null) {\n                    this.setErrorState();\n                }\n                else {\n                    this.switchToMovieMode(false);\n                    this.$content.$initDisp(this.$contentItem);\n                    this.$contentSourceWidth = this.$contentItem.width;\n                    this.$contentSourceHeight = this.$contentItem.height;\n                    this.updateLayout();\n                }\n            }\n            else if (this.$contentItem.type == 2 /* MovieClip */) {\n                this.switchToMovieMode(true);\n                this.$contentSourceWidth = this.$contentItem.width;\n                this.$contentSourceHeight = this.$contentItem.height;\n                let mc = this.$content;\n                mc.interval = this.$contentItem.interval;\n                mc.swing = this.$contentItem.swing;\n                mc.repeatDelay = this.$contentItem.repeatDelay;\n                mc.frames = this.$contentItem.frames;\n                mc.boundsRect = new createjs.Rectangle(0, 0, this.$contentSourceWidth, this.$contentSourceHeight);\n                this.updateLayout();\n            }\n            else\n                this.setErrorState();\n        }\n        else\n            this.setErrorState();\n    }\n    switchToMovieMode(value) {\n        this.$container.removeAllChildren();\n        if (value) {\n            if (!(this.$content instanceof MovieClip))\n                this.$content = new MovieClip(this);\n        }\n        else {\n            if (!(this.$content instanceof UIImage))\n                this.$content = new UIImage(null);\n        }\n        this.$container.addChild(this.$content);\n    }\n    /**overwrite this method if you need to load resources by your own way*/\n    loadExternal() {\n        // let texture = Bitmap.fromImage(this.$url, true);\n        let texture = new Bitmap();\n        this.$loadingTexture = texture;\n        //TODO: Texture does not have error event... monitor error event on baseTexture will casue cross-error-event problem.\n        // texture.once(\"update\", () => {\n        //     if (!texture.width || !texture.height)\n        //         this.$loadResCompleted(null);\n        //     else\n        //         this.$loadResCompleted(texture);\n        // });\n    }\n    /**free the resource you loaded */\n    freeExternal(texture) {\n        // Bitmap.removeFromCache(texture);\n        // texture.destroy(texture.baseTexture != null);\n    }\n    $loadResCompleted(res) {\n        if (res)\n            this.onExternalLoadSuccess(res);\n        else {\n            this.onExternalLoadFailed();\n            // this.$loadingTexture.removeAllListeners();\n            this.freeExternal(this.$loadingTexture);\n            this.$loadingTexture = null;\n        }\n        this.$loadingTexture = null;\n    }\n    /**content loaded */\n    onExternalLoadSuccess(texture) {\n        this.$container.removeAllChildren();\n        if (!this.$content || !(this.$content instanceof UIImage)) {\n            this.$content = new UIImage(null);\n            this.$content.$initDisp();\n            this.$container.addChild(this.$content);\n        }\n        else\n            this.$container.addChild(this.$content);\n        //baseTexture loaded, so update frame info  // todo\n        this.$content.texture = texture.texture;\n        this.$contentSourceWidth = texture.sourceRect.width;\n        this.$contentSourceHeight = texture.sourceRect.height;\n        this.updateLayout();\n    }\n    onExternalLoadFailed() {\n        this.setErrorState();\n    }\n    setErrorState() {\n        if (!this.$showErrorSign)\n            return;\n        if (this.$errorSign == null) {\n            if (UIConfig.loaderErrorSign) {\n                this.$errorSign = GLoader.$errorSignPool.get(UIConfig.loaderErrorSign);\n            }\n        }\n        if (this.$errorSign) {\n            this.$errorSign.width = this.width;\n            this.$errorSign.height = this.height;\n            this.$container.addChild(this.$errorSign.displayObject);\n        }\n    }\n    clearErrorState() {\n        if (this.$errorSign) {\n            this.$container.removeChild(this.$errorSign.displayObject);\n            GLoader.$errorSignPool.recycle(this.$errorSign.resourceURL, this.$errorSign);\n            this.$errorSign = null;\n        }\n    }\n    updateLayout() {\n        if (this.$content == null) {\n            if (this.$autoSize) {\n                this.$updatingLayout = true;\n                this.setSize(50, 30);\n                this.$updatingLayout = false;\n            }\n            return;\n        }\n        this.$content.set({ x: 0, y: 0 });\n        this.$content.set({ scaleX: 1, scaleY: 1 });\n        this.$contentWidth = this.$contentSourceWidth;\n        this.$contentHeight = this.$contentSourceHeight;\n        if (this.$autoSize) {\n            this.$updatingLayout = true;\n            if (this.$contentWidth == 0)\n                this.$contentWidth = 50;\n            if (this.$contentHeight == 0)\n                this.$contentHeight = 30;\n            this.setSize(this.$contentWidth, this.$contentHeight);\n            this.$updatingLayout = false;\n        }\n        else {\n            let sx = 1, sy = 1;\n            if (this.$fill != 0 /* None */) {\n                sx = this.width / this.$contentSourceWidth;\n                sy = this.height / this.$contentSourceHeight;\n                if (sx != 1 || sy != 1) {\n                    if (this.$fill == 2 /* ScaleMatchHeight */)\n                        sx = sy;\n                    else if (this.$fill == 3 /* ScaleMatchWidth */)\n                        sy = sx;\n                    else if (this.$fill == 1 /* Scale */) {\n                        if (sx > sy)\n                            sx = sy;\n                        else\n                            sy = sx;\n                    }\n                    else if (this.$fill == 5 /* ScaleNoBorder */) {\n                        if (sx > sy)\n                            sy = sx;\n                        else\n                            sx = sy;\n                    }\n                    this.$contentWidth = this.$contentSourceWidth * sx;\n                    this.$contentHeight = this.$contentSourceHeight * sy;\n                }\n            }\n            if (this.$content instanceof UIImage) {\n                this.$content.width = this.$contentWidth;\n                this.$content.height = this.$contentHeight;\n            }\n            else\n                this.$content.set({ scaleX: sx, scaleY: sy });\n            if (this.$align == \"center\" /* Center */)\n                this.$content.x = Math.floor((this.width - this.$contentWidth) / 2);\n            else if (this.$align == \"right\" /* Right */)\n                this.$content.x = this.width - this.$contentWidth;\n            if (this.$verticalAlign == 1 /* Middle */)\n                this.$content.y = Math.floor((this.height - this.$contentHeight) / 2);\n            else if (this.$verticalAlign == 2 /* Bottom */)\n                this.$content.y = this.height - this.$contentHeight;\n        }\n    }\n    clearContent() {\n        this.clearErrorState();\n        if (this.$content && this.$content.parent)\n            this.$container.removeChild(this.$content);\n        if (this.$loadingTexture) {\n            // this.$loadingTexture.removeAllListeners();// todo\n            this.freeExternal(this.$loadingTexture);\n            this.$loadingTexture = null;\n        }\n        // if (this.$contentItem == null && this.$content instanceof UIImage)\n        //     this.freeExternal(this.$content.texture); // todo\n        this.$content && this.$content.destroy();\n        this.$content = null;\n        this.$contentItem = null;\n    }\n    handleSizeChanged() {\n        if (!this.$updatingLayout)\n            this.updateLayout();\n        this.$hitArea.graphics.drawRect(0, 0, this.width, this.height);\n    }\n    setupBeforeAdd(xml) {\n        super.setupBeforeAdd(xml);\n        let str;\n        str = xml.attributes.url;\n        if (str)\n            this.$url = str;\n        str = xml.attributes.align;\n        if (str)\n            this.$align = ParseAlignType(str);\n        str = xml.attributes.vAlign;\n        if (str)\n            this.$verticalAlign = ParseVertAlignType(str);\n        str = xml.attributes.fill;\n        if (str)\n            this.$fill = ParseLoaderFillType(str);\n        this.$autoSize = xml.attributes.autoSize == 'true';\n        str = xml.attributes.errorSign;\n        if (str)\n            this.$showErrorSign = str == 'true';\n        this.$playing = xml.attributes.playing != 'false';\n        str = xml.attributes.color;\n        if (str)\n            this.color = str;\n        if (this.$url)\n            this.loadContent();\n    }\n}\nGLoader.$errorSignPool = new GObjectRecycler();\n\nlet isColorableTitle = function (obj) {\n    return obj && \"titleColor\" in obj && \"fontSize\" in obj;\n};\n\nclass GLabel extends GComponent {\n    constructor() {\n        super();\n    }\n    get icon() {\n        if (this.$iconObject != null)\n            return this.$iconObject.icon;\n        return null;\n    }\n    set icon(value) {\n        if (this.$iconObject != null)\n            this.$iconObject.icon = value;\n        this.updateGear(7 /* Icon */);\n    }\n    get title() {\n        if (this.$titleObject)\n            return this.$titleObject.text;\n        else\n            return null;\n    }\n    set title(value) {\n        if (this.$titleObject)\n            this.$titleObject.text = value;\n        this.updateGear(6 /* Text */);\n    }\n    get text() {\n        return this.title;\n    }\n    set text(value) {\n        this.title = value;\n    }\n    get titleColor() {\n        if (isColorableTitle(this.$titleObject))\n            return this.$titleObject.titleColor;\n        return '';\n    }\n    set titleColor(value) {\n        if (isColorableTitle(this.$titleObject))\n            this.$titleObject.titleColor = value;\n    }\n    get fontSize() {\n        if (isColorableTitle(this.$titleObject))\n            return this.$titleObject.fontSize;\n        return 0;\n    }\n    set fontSize(value) {\n        if (isColorableTitle(this.$titleObject))\n            this.$titleObject.fontSize = value;\n    }\n    set editable(val) {\n        if (this.$titleObject)\n            this.$titleObject.editable = val;\n    }\n    get editable() {\n        if (this.$titleObject && this.$titleObject instanceof GTextInput)\n            return this.$titleObject.editable;\n        else\n            return false;\n    }\n    constructFromXML(xml) {\n        super.constructFromXML(xml);\n        this.$titleObject = this.getChild('title');\n        this.$iconObject = this.getChild('icon');\n    }\n    setupAfterAdd(xml) {\n        super.setupAfterAdd(xml);\n        let cs = XmlParser.getChildNodes(xml, 'Label');\n        if (cs && cs.length > 0) {\n            xml = cs[0];\n            let str;\n            str = xml.attributes.title;\n            if (str)\n                this.text = str;\n            str = xml.attributes.icon;\n            if (str)\n                this.icon = str;\n            str = xml.attributes.titleColor;\n            if (str)\n                this.titleColor = str;\n            if (this.$titleObject instanceof GTextInput) {\n                str = xml.attributes.prompt;\n                let ti = this.$titleObject;\n                if (str)\n                    ti.promptText = str;\n                str = xml.attributes.maxLength;\n                if (str)\n                    ti.maxLength = parseInt(str);\n                str = xml.attributes.restrict;\n                if (str)\n                    ti.restrict = str;\n                str = xml.attributes.password;\n                if (str)\n                    ti.password = str == 'true';\n            }\n        }\n    }\n}\n\nclass PageOption {\n    set controller(val) {\n        this.$controller = val;\n    }\n    set name(pageName) {\n        this.$id = this.$controller.getPageIdByName(pageName);\n    }\n    get name() {\n        if (this.$id)\n            return this.$controller.getPageNameById(this.$id);\n        else\n            return null;\n    }\n    set index(pageIndex) {\n        this.$id = this.$controller.getPageId(pageIndex);\n    }\n    get index() {\n        if (this.$id)\n            return this.$controller.getPageIndexById(this.$id);\n        else\n            return -1;\n    }\n    clear() {\n        this.$id = null;\n    }\n    set id(id) {\n        this.$id = id;\n    }\n    get id() {\n        return this.$id;\n    }\n}\n\nclass GButton extends GComponent {\n    constructor() {\n        super();\n        this.$mode = 0 /* Common */;\n        this.$title = '';\n        this.$icon = '';\n        this.$sound = UIConfig.buttonSound;\n        this.$soundVolumeScale = UIConfig.buttonSoundVolumeScale;\n        this.$pageOption = new PageOption();\n        this.$changeStateOnClick = true;\n        this.$downEffect = 0;\n        this.$downEffectValue = 0.8;\n        this.$container.cursor = 'pointer';\n    }\n    setDisplayObject(value) {\n        super.setDisplayObject(value);\n        // this.$displayObject.buttonMode = true; //todo\n    }\n    get icon() {\n        return this.$icon;\n    }\n    set icon(value) {\n        this.$icon = value;\n        value = this.$selected && this.$selectedIcon ? this.$selectedIcon : this.$icon;\n        if (this.$iconObject != null)\n            this.$iconObject.icon = value;\n        this.updateGear(7 /* Icon */);\n    }\n    get selectedIcon() {\n        return this.$selectedIcon;\n    }\n    set selectedIcon(value) {\n        this.$selectedIcon = value;\n        value = this.$selected && this.$selectedIcon ? this.$selectedIcon : this.$icon;\n        if (this.$iconObject != null)\n            this.$iconObject.icon = value;\n    }\n    get title() {\n        return this.$title;\n    }\n    set title(value) {\n        this.$title = value;\n        if (this.$titleObject)\n            this.$titleObject.text =\n                this.$selected && this.$selectedTitle ? this.$selectedTitle : this.$title;\n        this.updateGear(6 /* Text */);\n    }\n    get text() {\n        return this.title;\n    }\n    set text(value) {\n        this.title = value;\n    }\n    get selectedTitle() {\n        return this.$selectedTitle;\n    }\n    set selectedTitle(value) {\n        this.$selectedTitle = value;\n        if (this.$titleObject)\n            this.$titleObject.text =\n                this.$selected && this.$selectedTitle ? this.$selectedTitle : this.$title;\n    }\n    get titleColor() {\n        if (isColorableTitle(this.$titleObject))\n            return this.$titleObject.titleColor;\n    }\n    set titleColor(value) {\n        if (isColorableTitle(this.$titleObject))\n            this.$titleObject.titleColor = value;\n    }\n    get fontSize() {\n        if (isColorableTitle(this.$titleObject))\n            return this.$titleObject.fontSize;\n        return 0;\n    }\n    set fontSize(value) {\n        if (isColorableTitle(this.$titleObject))\n            this.$titleObject.fontSize = value;\n    }\n    get sound() {\n        return this.$sound;\n    }\n    set sound(val) {\n        this.$sound = val;\n    }\n    get soundVolumeScale() {\n        return this.$soundVolumeScale;\n    }\n    set soundVolumeScale(value) {\n        this.$soundVolumeScale = value;\n    }\n    set selected(val) {\n        if (this.$mode == 0 /* Common */)\n            return;\n        if (this.$selected != val) {\n            this.$selected = val;\n            if (this.grayed &&\n                this.$buttonController &&\n                this.$buttonController.hasPage(GButton.DISABLED)) {\n                if (this.$selected)\n                    this.setState(GButton.SELECTED_DISABLED);\n                else\n                    this.setState(GButton.DISABLED);\n            }\n            else {\n                if (this.$selected)\n                    this.setState(this.$over ? GButton.SELECTED_OVER : GButton.DOWN);\n                else\n                    this.setState(this.$over ? GButton.OVER : GButton.UP);\n            }\n            if (this.$selectedTitle && this.$titleObject)\n                this.$titleObject.text = this.$selected ? this.$selectedTitle : this.$title;\n            if (this.$selectedIcon) {\n                let str = this.$selected ? this.$selectedIcon : this.$icon;\n                if (this.$iconObject != null)\n                    this.$iconObject.icon = str;\n            }\n            if (this.$relatedController && this.$parent && !this.$parent.$buildingDisplayList) {\n                if (this.$selected) {\n                    this.$relatedController.selectedPageId = this.$pageOption.id;\n                    if (this.$relatedController.$autoRadioGroupDepth)\n                        this.$parent.adjustRadioGroupDepth(this, this.$relatedController);\n                }\n                else if (this.$mode == 1 /* Check */ &&\n                    this.$relatedController.selectedPageId == this.$pageOption.id)\n                    this.$relatedController.oppositePageId = this.$pageOption.id;\n            }\n        }\n    }\n    get selected() {\n        return this.$selected;\n    }\n    get mode() {\n        return this.$mode;\n    }\n    set mode(value) {\n        if (this.$mode != value) {\n            if (value == 0 /* Common */)\n                this.selected = false;\n            this.$mode = value;\n        }\n    }\n    get relatedController() {\n        return this.$relatedController;\n    }\n    set relatedController(val) {\n        if (val != this.$relatedController) {\n            this.$relatedController = val;\n            this.$pageOption.controller = val;\n            this.$pageOption.clear();\n        }\n    }\n    get pageOption() {\n        return this.$pageOption;\n    }\n    get changeStateOnClick() {\n        return this.$changeStateOnClick;\n    }\n    set changeStateOnClick(value) {\n        this.$changeStateOnClick = value;\n    }\n    get linkedPopup() {\n        return this.$linkedPopup;\n    }\n    set linkedPopup(value) {\n        this.$linkedPopup = value;\n    }\n    addStateListener(listener, thisObj) {\n        this.on(\"__stateChanged\" /* CHANGED */, listener, thisObj);\n    }\n    removeStateListener(listener) {\n        this.off(\"__stateChanged\" /* CHANGED */, listener);\n    }\n    fireClick(downEffect = true) {\n        if (downEffect && this.$mode == 0 /* Common */) {\n            this.setState(GButton.OVER);\n            GTimer.inst.add(100, 1, this.setState, this, GButton.DOWN);\n            GTimer.inst.add(200, 1, this.setState, this, GButton.UP);\n        }\n        this.$click(null);\n    }\n    setState(val) {\n        if (this.$buttonController)\n            this.$buttonController.selectedPage = val;\n        if (this.$downEffect == 1) {\n            if (val == GButton.DOWN || val == GButton.SELECTED_OVER || val == GButton.SELECTED_DISABLED) {\n                let r = this.$downEffectValue * 255;\n                let color = (r << 16) + (r << 8) + r;\n                this.$children.forEach(obj => {\n                    if (isColorGear(obj))\n                        obj.color = color;\n                });\n            }\n            else {\n                this.$children.forEach(obj => {\n                    if (isColorGear(obj))\n                        obj.color = 0xffffff;\n                });\n            }\n        }\n        else if (this.$downEffect == 2) {\n            if (val == GButton.DOWN || val == GButton.SELECTED_OVER || val == GButton.SELECTED_DISABLED)\n                this.setScale(this.$downEffectValue, this.$downEffectValue);\n            else\n                this.setScale(1, 1);\n        }\n    }\n    handleControllerChanged(c) {\n        super.handleControllerChanged(c);\n        if (this.$relatedController == c)\n            this.selected = this.$pageOption.id == c.selectedPageId;\n    }\n    handleGrayedChanged() {\n        if (this.$buttonController && this.$buttonController.hasPage(GButton.DISABLED)) {\n            if (this.grayed) {\n                if (this.$selected && this.$buttonController.hasPage(GButton.SELECTED_DISABLED))\n                    this.setState(GButton.SELECTED_DISABLED);\n                else\n                    this.setState(GButton.DISABLED);\n            }\n            else if (this.$selected)\n                this.setState(GButton.DOWN);\n            else\n                this.setState(GButton.UP);\n        }\n        else\n            super.handleGrayedChanged();\n    }\n    constructFromXML(xml) {\n        super.constructFromXML(xml);\n        xml = XmlParser.getChildNodes(xml, 'Button')[0];\n        let str;\n        str = xml.attributes.mode;\n        if (str)\n            this.$mode = ParseButtonMode(str);\n        str = xml.attributes.sound;\n        if (str != null)\n            this.$sound = str;\n        str = xml.attributes.volume;\n        if (str)\n            this.$soundVolumeScale = parseInt(str) / 100;\n        str = xml.attributes.downEffect;\n        if (str) {\n            this.$downEffect = str == 'dark' ? 1 : str == 'scale' ? 2 : 0;\n            str = xml.attributes.downEffectValue;\n            this.$downEffectValue = parseFloat(str);\n            if (this.$downEffect == 2)\n                this.setPivot(0.5, 0.5);\n        }\n        this.$buttonController = this.getController('button');\n        this.$titleObject = this.getChild('title');\n        this.$iconObject = this.getChild('icon');\n        if (this.$titleObject != null)\n            this.$title = this.$titleObject.text;\n        if (this.$iconObject != null)\n            this.$icon = this.$iconObject.icon;\n        if (this.$mode == 0 /* Common */)\n            this.setState(GButton.UP);\n        this.on(InteractiveEvents.Over, this.$rollover, this);\n        this.on(InteractiveEvents.Out, this.$rollout, this);\n        this.on(InteractiveEvents.Down, this.$mousedown, this);\n        this.on(InteractiveEvents.Click, this.$click, this);\n        this.$hitArea = new createjs.Shape();\n        this.$hitArea.graphics.beginFill(\"#fff\").drawRect(0, 0, this.width, this.height);\n        this.$displayObject.hitArea = this.$hitArea;\n    }\n    setupAfterAdd(xml) {\n        super.setupAfterAdd(xml);\n        xml = XmlParser.getChildNodes(xml, 'Button')[0];\n        if (xml) {\n            let str;\n            str = xml.attributes.title;\n            if (str)\n                this.title = str;\n            str = xml.attributes.icon;\n            if (str)\n                this.icon = str;\n            str = xml.attributes.selectedTitle;\n            if (str)\n                this.selectedTitle = str;\n            str = xml.attributes.selectedIcon;\n            if (str)\n                this.selectedIcon = str;\n            str = xml.attributes.titleColor;\n            if (str)\n                this.titleColor = StringUtil.HEX2RGB(str);\n            str = xml.attributes.sound;\n            if (str != null)\n                this.$sound = str;\n            str = xml.attributes.volume;\n            if (str)\n                this.$soundVolumeScale = parseInt(str) / 100;\n            str = xml.attributes.titleFontSize;\n            if (str)\n                this.fontSize = parseInt(str);\n            str = xml.attributes.controller;\n            if (str)\n                this.$relatedController = this.$parent.getController(str);\n            else\n                this.$relatedController = null;\n            this.$pageOption.id = xml.attributes.page;\n            this.selected = xml.attributes.checked == 'true';\n        }\n    }\n    $rollover(evt) {\n        if (!this.$buttonController || !this.$buttonController.hasPage(GButton.OVER))\n            return;\n        this.$over = true;\n        if (this.$down)\n            return;\n        this.setState(this.$selected ? GButton.SELECTED_OVER : GButton.OVER);\n    }\n    $rollout(evt) {\n        if (!this.$buttonController || !this.$buttonController.hasPage(GButton.OVER))\n            return;\n        this.$over = false;\n        if (this.$down)\n            return;\n        this.setState(this.$selected ? GButton.DOWN : GButton.UP);\n    }\n    $mousedown(evt) {\n        this.$down = true;\n        this.$mouseUpEvent = Decls$1.GRoot.inst.nativeStage.on(InteractiveEvents.Up, this.$mouseup, this);\n        if (this.$mode == 0 /* Common */) {\n            if (this.grayed && this.$buttonController && this.$buttonController.hasPage(GButton.DISABLED))\n                this.setState(GButton.SELECTED_DISABLED);\n            else\n                this.setState(GButton.DOWN);\n        }\n        if (this.$linkedPopup != null) {\n            if (this.$linkedPopup instanceof Window)\n                this.$linkedPopup.toggleVisible();\n            else\n                Decls$1.GRoot.inst.togglePopup(this.$linkedPopup, this);\n        }\n    }\n    $mouseup(evt) {\n        if (this.$down) {\n            Decls$1.GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$mouseUpEvent);\n            this.$down = false;\n            if (this.$mode == 0 /* Common */) {\n                if (this.grayed &&\n                    this.$buttonController &&\n                    this.$buttonController.hasPage(GButton.DISABLED))\n                    this.setState(GButton.DISABLED);\n                else if (this.$over)\n                    this.setState(GButton.OVER);\n                else\n                    this.setState(GButton.UP);\n            }\n        }\n    }\n    $click(evt) {\n        if (this.$sound) {\n            var pi = UIPackage.getItemByURL(this.$sound);\n            if (pi) {\n                var sound = pi.owner.getItemAsset(pi);\n                if (sound)\n                    Decls$1.GRoot.inst.playOneShotSound(sound, this.$soundVolumeScale);\n            }\n        }\n        if (!this.$changeStateOnClick)\n            return;\n        if (this.$mode == 1 /* Check */) {\n            this.selected = !this.$selected;\n            let evt = new createjs.Event(\"__stateChanged\" /* CHANGED */, true, false);\n            evt.data = { selected: this.selected };\n            this.dispatchEvent(evt, this);\n        }\n        else if (this.$mode == 2 /* Radio */) {\n            if (!this.$selected) {\n                this.selected = true;\n                let evt = new createjs.Event(\"__stateChanged\" /* CHANGED */, true, false);\n                evt.data = { selected: this.selected };\n                this.dispatchEvent(evt, this);\n            }\n        }\n    }\n    dispose() {\n        GTimer.inst.remove(this.setState, this);\n        GTimer.inst.remove(this.setState, this);\n        Decls$1.GRoot.inst.off(InteractiveEvents.Up, this.$mouseup);\n        super.dispose();\n    }\n}\nGButton.UP = 'up';\nGButton.DOWN = 'down';\nGButton.OVER = 'over';\nGButton.SELECTED_OVER = 'selectedOver';\nGButton.DISABLED = 'disabled';\nGButton.SELECTED_DISABLED = 'selectedDisabled';\n\nclass GComboBox extends GComponent {\n    constructor() {\n        super();\n        this.$visibleItemCount = 0;\n        this.$selectedIndex = 0;\n        this.$popupDir = 1 /* Down */;\n        this.$visibleItemCount = UIConfig.defaultComboBoxVisibleItemCount;\n        this.$itemsUpdated = true;\n        this.$selectedIndex = -1;\n        this.$items = [];\n        this.$values = [];\n    }\n    get text() {\n        if (this.$titleObject)\n            return this.$titleObject.text;\n        else\n            return null;\n    }\n    set text(value) {\n        if (this.$titleObject)\n            this.$titleObject.text = value;\n        this.updateGear(6 /* Text */);\n    }\n    get icon() {\n        if (this.$iconObject)\n            return this.$iconObject.icon;\n        else\n            return null;\n    }\n    set icon(value) {\n        if (this.$iconObject)\n            this.$iconObject.icon = value;\n        this.updateGear(7 /* Icon */);\n    }\n    get titleColor() {\n        if (isColorableTitle(this.$titleObject))\n            return this.$titleObject.titleColor;\n        // return 0;\n    }\n    set titleColor(value) {\n        if (isColorableTitle(this.$titleObject))\n            this.$titleObject.titleColor = value;\n    }\n    get visibleItemCount() {\n        return this.$visibleItemCount;\n    }\n    set visibleItemCount(value) {\n        this.$visibleItemCount = value;\n    }\n    get popupDirection() {\n        return this.$popupDir;\n    }\n    set popupDirection(value) {\n        this.$popupDir = value;\n    }\n    get items() {\n        return this.$items;\n    }\n    set items(value) {\n        if (!value)\n            this.$items.length = 0;\n        else\n            this.$items = value.concat();\n        if (this.$items.length > 0) {\n            if (this.$selectedIndex >= this.$items.length)\n                this.$selectedIndex = this.$items.length - 1;\n            else if (this.$selectedIndex == -1)\n                this.$selectedIndex = 0;\n            this.text = this.$items[this.$selectedIndex];\n            if (this.$icons != null && this.$selectedIndex < this.$icons.length)\n                this.icon = this.$icons[this.$selectedIndex];\n        }\n        else {\n            this.text = '';\n            if (this.$icons != null)\n                this.icon = null;\n            this.$selectedIndex = -1;\n        }\n        this.$itemsUpdated = true;\n    }\n    get icons() {\n        return this.$icons;\n    }\n    set icons(value) {\n        this.$icons = value;\n        if (this.$icons != null &&\n            this.$selectedIndex != -1 &&\n            this.$selectedIndex < this.$icons.length)\n            this.icon = this.$icons[this.$selectedIndex];\n    }\n    get values() {\n        return this.$values;\n    }\n    set values(value) {\n        if (!value)\n            this.$values.length = 0;\n        else\n            this.$values = value.concat();\n    }\n    get selectedIndex() {\n        return this.$selectedIndex;\n    }\n    set selectedIndex(val) {\n        if (this.$selectedIndex == val)\n            return;\n        this.$selectedIndex = val;\n        if (this.selectedIndex >= 0 && this.selectedIndex < this.$items.length) {\n            this.text = this.$items[this.$selectedIndex];\n            if (this.$icons != null && this.$selectedIndex < this.$icons.length)\n                this.icon = this.$icons[this.$selectedIndex];\n        }\n        else {\n            this.text = '';\n            if (this.$icons != null)\n                this.icon = null;\n        }\n    }\n    get value() {\n        return this.$values[this.$selectedIndex];\n    }\n    set value(val) {\n        this.selectedIndex = this.$values.indexOf(val);\n    }\n    setState(val) {\n        if (this.$buttonController)\n            this.$buttonController.selectedPage = val;\n    }\n    constructFromXML(xml) {\n        super.constructFromXML(xml);\n        xml = XmlParser.getChildNodes(xml, 'ComboBox')[0];\n        let str;\n        this.$buttonController = this.getController('button');\n        this.$titleObject = this.getChild('title');\n        this.$iconObject = this.getChild('icon');\n        str = xml.attributes.dropdown;\n        if (str) {\n            this.$dropdown = UIPackage.createObjectFromURL(str);\n            if (!this.$dropdown)\n                throw new Error(\"the 'dropdown' is not specified, it must be a component definied in the package pool\");\n            this.$dropdown.name = 'this.dropdown';\n            this.$list = this.$dropdown.getChild('list');\n            if (this.$list == null)\n                throw new Error(`${this.resourceURL}: the dropdown component must have a GList child and named 'list'.`);\n            this.$list.on(\"__itemClick\" /* ItemClick */, this.$clickItem, this);\n            this.$list.addRelation(this.$dropdown, 14 /* Width */);\n            this.$list.removeRelation(this.$dropdown, 15 /* Height */);\n            this.$dropdown.addRelation(this.$list, 15 /* Height */);\n            this.$dropdown.removeRelation(this.$list, 14 /* Width */);\n            this.$dropdown.on('removed', this.$popupWinClosed, this);\n        }\n        if (!fairygui_module_isMobile.any) {\n            this.on(InteractiveEvents.Over, this.$rollover, this);\n            this.on(InteractiveEvents.Out, this.$rollout, this);\n        }\n        this.on(InteractiveEvents.Down, this.$mousedown, this);\n    }\n    dispose() {\n        GTimer.inst.remove(this.delayedClickItem, this);\n        this.$list.off(\"__itemClick\" /* ItemClick */, this.$clickItem);\n        this.$dropdown.off('removed', this.$popupWinClosed);\n        GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$mouseUpEvent);\n        this.$popupWinClosed(null);\n        if (this.$dropdown) {\n            this.$dropdown.dispose();\n            this.$dropdown = null;\n        }\n        super.dispose();\n    }\n    setupAfterAdd(xml) {\n        super.setupAfterAdd(xml);\n        xml = XmlParser.getChildNodes(xml, 'ComboBox')[0];\n        if (xml) {\n            let str;\n            str = xml.attributes.titleColor;\n            if (str)\n                this.titleColor = str;\n            str = xml.attributes.visibleItemCount;\n            if (str)\n                this.$visibleItemCount = parseInt(str);\n            let col = xml.children;\n            if (col) {\n                col.forEach((x, i) => {\n                    if (x.nodeName == 'item') {\n                        this.$items.push(x.attributes.title);\n                        this.$values.push(x.attributes.value);\n                        str = x.attributes.icon;\n                        if (str) {\n                            if (!this.$icons)\n                                this.$icons = new Array(length);\n                            this.$icons[i] = str;\n                        }\n                    }\n                });\n            }\n            str = xml.attributes.title;\n            if (str) {\n                this.text = str;\n                this.$selectedIndex = this.$items.indexOf(str);\n            }\n            else if (this.$items.length > 0) {\n                this.$selectedIndex = 0;\n                this.text = this.$items[0];\n            }\n            else\n                this.$selectedIndex = -1;\n            str = xml.attributes.icon;\n            if (str)\n                this.icon = str;\n            str = xml.attributes.direction;\n            if (str) {\n                if (str == 'up')\n                    this.$popupDir = 2 /* Up */;\n                else if (str == 'auto')\n                    this.$popupDir = 0 /* Auto */;\n            }\n        }\n    }\n    showDropdown() {\n        if (this.$itemsUpdated) {\n            this.$itemsUpdated = false;\n            this.$list.removeChildrenToPool();\n            this.$items.forEach((o, i) => {\n                let item = this.$list.addItemFromPool();\n                item.name = i < this.$values.length ? this.$values[i] : '';\n                item.text = this.$items[i];\n                item.icon = this.$icons != null && i < this.$icons.length ? this.$icons[i] : null;\n            }, this);\n            this.$list.resizeToFit(this.$visibleItemCount);\n        }\n        this.$list.selectedIndex = -1;\n        this.$dropdown.width = this.width;\n        GRoot.findFor(this).togglePopup(this.$dropdown, this, this.$popupDir);\n        if (this.$dropdown.parent)\n            this.setState(GButton.DOWN);\n    }\n    $popupWinClosed(evt) {\n        if (this.$over)\n            this.setState(GButton.OVER);\n        else\n            this.setState(GButton.UP);\n    }\n    $clickItem(evt) {\n        let item = evt.data.item;\n        let index = this.$list.getChildIndex(item);\n        GTimer.inst.add(100, 1, this.delayedClickItem, this, index);\n    }\n    delayedClickItem(index) {\n        if (this.$dropdown.parent instanceof GRoot)\n            this.$dropdown.parent.hidePopup();\n        this.$selectedIndex = index;\n        if (this.$selectedIndex >= 0)\n            this.text = this.$items[this.$selectedIndex];\n        else\n            this.text = '';\n        let evt = new createjs.Event(\"__stateChanged\" /* CHANGED */, true, false);\n        evt.data = { selectedIndex: this.$selectedIndex };\n        this.dispatchEvent(evt, this);\n    }\n    $rollover(evt) {\n        this.$over = true;\n        if (this.$down || (this.$dropdown && this.$dropdown.parent))\n            return;\n        this.setState(GButton.OVER);\n    }\n    $rollout(evt) {\n        this.$over = false;\n        if (this.$down || (this.$dropdown && this.$dropdown.parent))\n            return;\n        this.setState(GButton.UP);\n    }\n    $mousedown(evt) {\n        evt.stopPropagation();\n        GRoot.inst.checkPopups(evt.target);\n        this.$down = true;\n        this.$mouseUpEvent = GRoot.inst.nativeStage.on(InteractiveEvents.Up, this.$mouseup, this);\n        if (this.$dropdown)\n            this.showDropdown();\n    }\n    $mouseup(evt) {\n        if (this.$down) {\n            this.$down = false;\n            GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$mouseUpEvent);\n            if (this.$dropdown && !this.$dropdown.parent) {\n                if (this.$over)\n                    this.setState(GButton.OVER);\n                else\n                    this.setState(GButton.UP);\n            }\n        }\n    }\n}\n\nclass GSlider extends GComponent {\n    constructor() {\n        super();\n        this.$max = 0;\n        this.$value = 0;\n        this.$barMaxWidth = 0;\n        this.$barMaxHeight = 0;\n        this.$barMaxWidthDelta = 0;\n        this.$barMaxHeightDelta = 0;\n        this.$titleType = 0 /* Percent */;\n        this.$value = 50;\n        this.$max = 100;\n        this.$clickPos = new createjs.Point();\n    }\n    get titleType() {\n        return this.$titleType;\n    }\n    set titleType(value) {\n        this.$titleType = value;\n    }\n    get max() {\n        return this.$max;\n    }\n    set max(value) {\n        if (this.$max != value) {\n            this.$max = value;\n            this.update();\n        }\n    }\n    get value() {\n        return this.$value;\n    }\n    set value(value) {\n        if (this.$value != value) {\n            this.$value = value;\n            this.update();\n        }\n    }\n    update() {\n        let percent = Math.min(this.$value / this.$max, 1);\n        this.updateWidthPercent(percent);\n    }\n    updateWidthPercent(percent) {\n        if (this.$titleObject) {\n            switch (this.$titleType) {\n                case 0 /* Percent */:\n                    this.$titleObject.text = `${Math.round(percent * 100)}%`;\n                    break;\n                case 1 /* ValueAndMax */:\n                    this.$titleObject.text = `${this.$value}/${this.$max}`;\n                    break;\n                case 2 /* Value */:\n                    this.$titleObject.text = `${this.$value}`;\n                    break;\n                case 3 /* Max */:\n                    this.$titleObject.text = `${this.$max}`;\n                    break;\n            }\n        }\n        if (this.$barObjectH)\n            this.$barObjectH.width = (this.width - this.$barMaxWidthDelta) * percent;\n        if (this.$barObjectV)\n            this.$barObjectV.height = (this.height - this.$barMaxHeightDelta) * percent;\n        if (this.$aniObject instanceof GMovieClip)\n            this.$aniObject.frame = Math.round(percent * 100);\n    }\n    handleSizeChanged() {\n        super.handleSizeChanged();\n        if (this.$barObjectH)\n            this.$barMaxWidth = this.width - this.$barMaxWidthDelta;\n        if (this.$barObjectV)\n            this.$barMaxHeight = this.height - this.$barMaxHeightDelta;\n        if (!this.$inProgressBuilding)\n            this.update();\n    }\n    setupAfterAdd(xml) {\n        super.setupAfterAdd(xml);\n        xml = XmlParser.getChildNodes(xml, 'Slider')[0];\n        if (xml) {\n            this.$value = parseInt(xml.attributes.value);\n            this.$max = parseInt(xml.attributes.max);\n        }\n        this.update();\n    }\n    constructFromXML(xml) {\n        super.constructFromXML(xml);\n        xml = XmlParser.getChildNodes(xml, 'Slider')[0];\n        let str;\n        if (xml) {\n            str = xml.attributes.titleType;\n            if (str)\n                this.$titleType = ParseProgressTitleType(str);\n        }\n        this.$titleObject = this.getChild('title');\n        this.$barObjectH = this.getChild('bar');\n        this.$barObjectV = this.getChild('bar_v');\n        this.$aniObject = this.getChild('ani');\n        this.$gripObject = this.getChild('grip');\n        if (this.$barObjectH) {\n            this.$barMaxWidth = this.$barObjectH.width;\n            this.$barMaxWidthDelta = this.width - this.$barMaxWidth;\n        }\n        if (this.$barObjectV) {\n            this.$barMaxHeight = this.$barObjectV.height;\n            this.$barMaxHeightDelta = this.height - this.$barMaxHeight;\n        }\n        if (this.$gripObject)\n            this.$gripObject.on(InteractiveEvents.Down, this.$gripMouseDown, this);\n    }\n    $gripMouseDown(evt) {\n        this.$clickPos = this.globalToLocal(evt.stageX, evt.stageY);\n        this.$clickPercent = this.$value / this.$max;\n        this.$mouseMoveEvent = GRoot.inst.nativeStage.on(InteractiveEvents.Move, this.$gripMouseMove, this);\n        this.$mouseUpEvent = GRoot.inst.nativeStage.on(InteractiveEvents.Up, this.$gripMouseUp, this);\n    }\n    $gripMouseMove(evt) {\n        let pt = this.globalToLocal(evt.stageX, evt.stageY, GSlider.sSilderHelperPoint);\n        let deltaX = pt.x - this.$clickPos.x;\n        let deltaY = pt.y - this.$clickPos.y;\n        let percent;\n        if (this.$barObjectH)\n            percent = this.$clickPercent + deltaX / this.$barMaxWidth;\n        else\n            percent = this.$clickPercent + deltaY / this.$barMaxHeight;\n        if (percent > 1)\n            percent = 1;\n        else if (percent < 0)\n            percent = 0;\n        let newValue = Math.round(this.$max * percent);\n        if (newValue != this.$value) {\n            this.$value = newValue;\n            let evt = new createjs.Event(\"__stateChanged\" /* CHANGED */, true, false);\n            this.dispatchEvent(evt, this);\n        }\n        this.updateWidthPercent(percent);\n    }\n    $gripMouseUp(evt) {\n        let percent = this.$value / this.$max;\n        this.updateWidthPercent(percent);\n        GRoot.inst.nativeStage.off(InteractiveEvents.Move, this.$mouseMoveEvent);\n        GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$mouseUpEvent);\n    }\n    dispose() {\n        if (this.$gripObject)\n            this.$gripObject.off(InteractiveEvents.Down, this.$gripMouseDown);\n        GRoot.inst.nativeStage.off(InteractiveEvents.Move, this.$mouseMoveEvent);\n        GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$mouseUpEvent);\n        super.dispose();\n    }\n}\nGSlider.sSilderHelperPoint = new createjs.Point();\n\nclass GProgressBar extends GComponent {\n    constructor() {\n        super();\n        this.$max = 0;\n        this.$value = 0;\n        this.$barMaxWidth = 0;\n        this.$barMaxHeight = 0;\n        this.$barMaxWidthDelta = 0;\n        this.$barMaxHeightDelta = 0;\n        this.$barStartX = 0;\n        this.$barStartY = 0;\n        this.$tweenValue = 0;\n        this.$titleType = 0 /* Percent */;\n        this.$value = 50;\n        this.$max = 100;\n    }\n    get titleType() {\n        return this.$titleType;\n    }\n    set titleType(value) {\n        if (this.$titleType != value) {\n            this.$titleType = value;\n            this.update(this.$value);\n        }\n    }\n    get max() {\n        return this.$max;\n    }\n    set max(value) {\n        if (this.$max != value) {\n            this.$max = value;\n            this.update(this.$value);\n        }\n    }\n    get value() {\n        return this.$value;\n    }\n    set value(value) {\n        if (this.$tweener != null) {\n            this.$tweener.paused = true;\n            this.$tweener = null;\n        }\n        if (this.$value != value) {\n            this.$value = value;\n            this.update(this.$value);\n        }\n    }\n    tweenValue(value, duration) {\n        if (this.$value != value) {\n            if (this.$tweener) {\n                this.$tweener.paused = true;\n                this.$tweener.removeAllEventListeners();\n                createjs.Tween.removeTweens(this);\n            }\n            this.$tweenValue = this.$value;\n            this.$value = value;\n            this.$tweener = createjs.Tween.get(this, {\n                onChange: Binder.create(this.onUpdateTween, this)\n            }).to({ $tweenValue: value }, duration * 1000, GProgressBar.easeLinear);\n            return this.$tweener;\n        }\n        else\n            return null;\n    }\n    onUpdateTween() {\n        this.update(this.$tweenValue);\n    }\n    update(val) {\n        let percent = this.$max != 0 ? Math.min(val / this.$max, 1) : 0;\n        if (this.$titleObject) {\n            switch (this.$titleType) {\n                case 0 /* Percent */:\n                    this.$titleObject.text = `${Math.round(percent * 100)}%`;\n                    break;\n                case 1 /* ValueAndMax */:\n                    this.$titleObject.text = `${Math.round(val)}/${Math.round(this.$max)}`;\n                    break;\n                case 2 /* Value */:\n                    this.$titleObject.text = `${Math.round(val)}`;\n                    break;\n                case 3 /* Max */:\n                    this.$titleObject.text = `${Math.round(this.$max)}`;\n                    break;\n            }\n        }\n        let fullWidth = this.width - this.$barMaxWidthDelta;\n        let fullHeight = this.height - this.$barMaxHeightDelta;\n        if (!this.$reverse) {\n            if (this.$barObjectH)\n                this.$barObjectH.width = fullWidth * percent;\n            if (this.$barObjectV)\n                this.$barObjectV.height = fullHeight * percent;\n        }\n        else {\n            if (this.$barObjectH) {\n                this.$barObjectH.width = fullWidth * percent;\n                this.$barObjectH.x = this.$barStartX + (fullWidth - this.$barObjectH.width);\n            }\n            if (this.$barObjectV) {\n                this.$barObjectV.height = fullHeight * percent;\n                this.$barObjectV.y = this.$barStartY + (fullHeight - this.$barObjectV.height);\n            }\n        }\n        if (this.$aniObject instanceof GMovieClip)\n            this.$aniObject.frame = Math.round(percent * 100);\n    }\n    constructFromXML(xml) {\n        super.constructFromXML(xml);\n        xml = XmlParser.getChildNodes(xml, 'ProgressBar')[0];\n        let str;\n        str = xml.attributes.titleType;\n        if (str)\n            this.$titleType = ParseProgressTitleType(str);\n        this.$reverse = xml.attributes.reverse == 'true';\n        this.$titleObject = this.getChild('title');\n        this.$barObjectH = this.getChild('bar');\n        this.$barObjectV = this.getChild('bar_v');\n        this.$aniObject = this.getChild('ani');\n        if (this.$barObjectH) {\n            this.$barMaxWidth = this.$barObjectH.width;\n            this.$barMaxWidthDelta = this.width - this.$barMaxWidth;\n            this.$barStartX = this.$barObjectH.x;\n        }\n        if (this.$barObjectV) {\n            this.$barMaxHeight = this.$barObjectV.height;\n            this.$barMaxHeightDelta = this.height - this.$barMaxHeight;\n            this.$barStartY = this.$barObjectV.y;\n        }\n    }\n    handleSizeChanged() {\n        super.handleSizeChanged();\n        if (this.$barObjectH)\n            this.$barMaxWidth = this.width - this.$barMaxWidthDelta;\n        if (this.$barObjectV)\n            this.$barMaxHeight = this.height - this.$barMaxHeightDelta;\n        if (!this.$inProgressBuilding)\n            this.update(this.$value);\n    }\n    setupAfterAdd(xml) {\n        super.setupAfterAdd(xml);\n        xml = XmlParser.getChildNodes(xml, 'ProgressBar')[0];\n        if (xml) {\n            this.$value = parseInt(xml.attributes.value) || 0;\n            this.$max = parseInt(xml.attributes.max) || 0;\n        }\n        this.update(this.$value);\n    }\n    dispose() {\n        if (this.$tweener) {\n            this.$tweener.paused = true;\n            this.$tweener.removeAllEventListeners();\n        }\n        createjs.Tween.removeTweens(this);\n        this.$tweener = null;\n        super.dispose();\n    }\n}\nGProgressBar.easeLinear = ParseEaseType('linear'); // createjs.Ease.getPowIn(1);\n\nclass GScrollBar extends GComponent {\n    constructor() {\n        super();\n        this.$dragOffset = new createjs.Point();\n        this.$scrollPerc = 0;\n    }\n    setScrollPane(target, vertical) {\n        this.$target = target;\n        this.$vertical = vertical;\n    }\n    set displayPerc(val) {\n        if (this.$vertical) {\n            if (!this.$fixedGripSize)\n                this.$grip.height = val * this.$bar.height;\n            this.$grip.y = this.$bar.y + (this.$bar.height - this.$grip.height) * this.$scrollPerc;\n        }\n        else {\n            if (!this.$fixedGripSize)\n                this.$grip.width = val * this.$bar.width;\n            this.$grip.x = this.$bar.x + (this.$bar.width - this.$grip.width) * this.$scrollPerc;\n        }\n    }\n    get scrollPerc() {\n        return this.$scrollPerc;\n    }\n    set scrollPerc(val) {\n        this.$scrollPerc = val;\n        if (this.$vertical)\n            this.$grip.y = this.$bar.y + (this.$bar.height - this.$grip.height) * this.$scrollPerc;\n        else\n            this.$grip.x = this.$bar.x + (this.$bar.width - this.$grip.width) * this.$scrollPerc;\n    }\n    get minSize() {\n        if (this.$vertical)\n            return ((this.$arrowButton1 != null ? this.$arrowButton1.height : 0) +\n                (this.$arrowButton2 != null ? this.$arrowButton2.height : 0));\n        else\n            return ((this.$arrowButton1 != null ? this.$arrowButton1.width : 0) +\n                (this.$arrowButton2 != null ? this.$arrowButton2.width : 0));\n    }\n    constructFromXML(xml) {\n        super.constructFromXML(xml);\n        xml = XmlParser.getChildNodes(xml, 'ScrollBar')[0];\n        if (xml != null)\n            this.$fixedGripSize = xml.attributes.fixedGripSize == 'true';\n        this.$grip = this.getChild('grip');\n        if (!this.$grip) {\n            console.error(\"please create and define 'grip' in the Editor for the scrollbar\");\n            return;\n        }\n        this.$bar = this.getChild('bar');\n        if (!this.$bar) {\n            console.error(\"please create and define 'bar' in the Editor for the scrollbar\");\n            return;\n        }\n        this.$arrowButton1 = this.getChild('arrow1');\n        this.$arrowButton2 = this.getChild('arrow2');\n        this.$grip.on(InteractiveEvents.Down, this.$gripMouseDown, this);\n        if (this.$arrowButton1)\n            this.$arrowButton1.on(InteractiveEvents.Down, this.$arrowButton1Click, this);\n        if (this.$arrowButton2)\n            this.$arrowButton2.on(InteractiveEvents.Down, this.$arrowButton2Click, this);\n        this.on(InteractiveEvents.Down, this.$barMouseDown, this);\n    }\n    $gripMouseDown(evt) {\n        if (!this.$bar)\n            return;\n        evt.stopPropagation();\n        // this.$dragOffset = evt.data.getLocalPosition(this.displayObject, this.$dragOffset);\n        this.$dragOffset = new createjs.Point(evt.localX, evt.localY);\n        this.$dragOffset.x -= this.$grip.x;\n        this.$dragOffset.y -= this.$grip.y;\n        this.$mouseMoveEvent = GRoot.inst.nativeStage.on(InteractiveEvents.Move, this.$gripDragging, this);\n        this.$mouseUpEvent = GRoot.inst.nativeStage.on(InteractiveEvents.Up, this.$gripDraggingEnd, this);\n    }\n    $gripDragging(evt) {\n        let pt = evt.target.localToLocal(evt.localX, evt.localY, this.$displayObject); // todo\n        if (GScrollBar.sScrollbarHelperPoint.x == 0 && GScrollBar.sScrollbarHelperPoint.y == 0) {\n            GScrollBar.sScrollbarHelperPoint.x = this.$target['$xPos'];\n            GScrollBar.sScrollbarHelperPoint.y = this.$target['$yPos'];\n        }\n        pt.x -= GScrollBar.sScrollbarHelperPoint.x;\n        pt.y -= GScrollBar.sScrollbarHelperPoint.y;\n        if (this.$vertical) {\n            let curY = pt.y - this.$dragOffset.y;\n            this.$target.setPercY((curY - this.$bar.y) / (this.$bar.height - this.$grip.height), false);\n        }\n        else {\n            let curX = pt.x - this.$dragOffset.x;\n            this.$target.setPercX((curX - this.$bar.x) / (this.$bar.width - this.$grip.width), false);\n        }\n    }\n    $gripDraggingEnd(evt) {\n        GScrollBar.sScrollbarHelperPoint = new createjs.Point();\n        GRoot.inst.nativeStage.off(InteractiveEvents.Move, this.$mouseMoveEvent);\n        GRoot.inst.nativeStage.off(InteractiveEvents.Up, this.$mouseUpEvent);\n    }\n    $arrowButton1Click(evt) {\n        evt.stopPropagation();\n        if (this.$vertical)\n            this.$target.scrollUp();\n        else\n            this.$target.scrollLeft();\n    }\n    $arrowButton2Click(evt) {\n        evt.stopPropagation();\n        if (this.$vertical)\n            this.$target.scrollDown();\n        else\n            this.$target.scrollRight();\n    }\n    $barMouseDown(evt) {\n        let pt = new createjs.Point(evt.localX, evt.localY);\n        // let pt: createjs.Point = evt.data.getLocalPosition(this.$grip.displayObject, GScrollBar.sScrollbarHelperPoint);\n        if (this.$vertical) {\n            if (pt.y < 0)\n                this.$target.scrollUp(4);\n            else\n                this.$target.scrollDown(4);\n        }\n        else {\n            if (pt.x < 0)\n                this.$target.scrollLeft(4);\n            else\n                this.$target.scrollRight(4);\n        }\n    }\n    dispose() {\n        this.off(InteractiveEvents.Down, this.$barMouseDown);\n        GScrollBar.sScrollbarHelperPoint = new createjs.Point();\n        if (this.$arrowButton1)\n            this.$arrowButton1.off(InteractiveEvents.Down, this.$arrowButton1Click);\n        if (this.$arrowButton2)\n            this.$arrowButton2.off(InteractiveEvents.Down, this.$arrowButton2Click);\n        this.$grip.off(InteractiveEvents.Down, this.$gripMouseDown);\n        this.$gripDraggingEnd(null);\n        super.dispose();\n    }\n}\nGScrollBar.sScrollbarHelperPoint = new createjs.Point();\n\nclass ItemInfo {\n    constructor() {\n        this.width = 0;\n        this.height = 0;\n        this.updateFlag = 0;\n        this.selected = false;\n    }\n}\nclass GList extends GComponent {\n    constructor() {\n        super();\n        this.$lineCount = 0;\n        this.$columnCount = 0;\n        this.$lineGap = 0;\n        this.$columnGap = 0;\n        this.$lastSelectedIndex = 0;\n        this.$numItems = 0;\n        this.$firstIndex = 0; //top left index\n        this.$curLineItemCount = 0; //item count in one line\n        this.$virtualListChanged = 0 /* None */;\n        //render sorting type\n        this.$apexIndex = 0;\n        this.$childrenRenderOrder = 0 /* Ascent */;\n        this.$itemInfoVer = 0; //is the item used in the current handling or not\n        this.$enterCounter = 0; //because the handleScroll function can be re-entered, so this variable is used to avoid dead-lock\n        this.$trackBounds = true;\n        this.$pool = new GObjectRecycler();\n        this.$layout = 0 /* SingleColumn */;\n        this.$autoResizeItem = true;\n        this.$lastSelectedIndex = -1;\n        this.$selectionMode = 0 /* Single */;\n        this.opaque = true;\n        this.scrollItemToViewOnClick = true;\n        this.$align = \"left\" /* Left */;\n        this.$verticalAlign = 0 /* Top */;\n        this.$container = new createjs.Container();\n        this.$rootContainer.addChild(this.$container);\n        this.$container.cursor = 'pointer';\n    }\n    get childrenRenderOrder() {\n        return this.$childrenRenderOrder;\n    }\n    set childrenRenderOrder(value) {\n        if (this.$childrenRenderOrder != value) {\n            this.$childrenRenderOrder = value;\n            this.appendChildrenList();\n        }\n    }\n    get apexIndex() {\n        return this.$apexIndex;\n    }\n    set apexIndex(value) {\n        if (this.$apexIndex != value) {\n            this.$apexIndex = value;\n            if (this.$childrenRenderOrder == 2 /* Arch */)\n                this.appendChildrenList();\n        }\n    }\n    /**@override */\n    appendChildrenList() {\n        const cnt = this.$children.length;\n        if (cnt == 0)\n            return;\n        let i;\n        let child;\n        switch (this.$childrenRenderOrder) {\n            case 0 /* Ascent */:\n                {\n                    for (i = 0; i < cnt; i++) {\n                        child = this.$children[i];\n                        if (child.displayObject != null && child.finalVisible)\n                            this.$container.addChild(child.displayObject);\n                    }\n                }\n                break;\n            case 1 /* Descent */:\n                {\n                    for (i = cnt - 1; i >= 0; i--) {\n                        child = this.$children[i];\n                        if (child.displayObject != null && child.finalVisible)\n                            this.$container.addChild(child.displayObject);\n                    }\n                }\n                break;\n            case 2 /* Arch */:\n                {\n                    for (i = 0; i < this.$apexIndex; i++) {\n                        child = this.$children[i];\n                        if (child.displayObject != null && child.finalVisible)\n                            this.$container.addChild(child.displayObject);\n                    }\n                    for (i = cnt - 1; i >= this.$apexIndex; i--) {\n                        child = this.$children[i];\n                        if (child.displayObject != null && child.finalVisible)\n                            this.$container.addChild(child.displayObject);\n                    }\n                }\n                break;\n        }\n    }\n    /**@override */\n    setXY(xv, yv) {\n        if (this.$x != xv || this.$y != yv) {\n            this.$x = xv;\n            this.$y = yv;\n            this.handleXYChanged();\n            this.updateGear(1 /* XY */);\n            if (GObject.draggingObject == this && !GObject.sUpdatingWhileDragging)\n                this.localToGlobalRect(0, 0, this.width, this.height, GObject.sGlobalRect);\n        }\n    }\n    /**@override */\n    $setChildIndex(child, oldIndex, index = 0) {\n        let cnt = this.$children.length;\n        if (index > cnt)\n            index = cnt;\n        if (oldIndex == index)\n            return oldIndex;\n        this.$children.splice(oldIndex, 1);\n        this.$children.splice(index, 0, child);\n        if (child.inContainer) {\n            let displayIndex = 0;\n            let g;\n            let i;\n            if (this.$childrenRenderOrder == 0 /* Ascent */) {\n                for (i = 0; i < index; i++) {\n                    g = this.$children[i];\n                    if (g.inContainer)\n                        displayIndex++;\n                }\n                if (displayIndex == this.$container.children.length)\n                    displayIndex--;\n                this.$container.setChildIndex(child.displayObject, displayIndex);\n            }\n            else if (this.$childrenRenderOrder == 1 /* Descent */) {\n                for (i = cnt - 1; i > index; i--) {\n                    g = this.$children[i];\n                    if (g.inContainer)\n                        displayIndex++;\n                }\n                if (displayIndex == this.$container.children.length)\n                    displayIndex--;\n                this.$container.setChildIndex(child.displayObject, displayIndex);\n            }\n            else\n                GTimer.inst.callLater(this.appendChildrenList, this);\n            this.setBoundsChangedFlag();\n        }\n        return index;\n    }\n    /**@override */\n    childStateChanged(child) {\n        if (this.$buildingDisplayList)\n            return;\n        if (child instanceof GGroup) {\n            this.$children.forEach(g => {\n                if (g.group == child)\n                    this.childStateChanged(g);\n            }, this);\n            return;\n        }\n        if (!child.displayObject)\n            return;\n        if (child.finalVisible) {\n            let i, g;\n            let cnt = this.$children.length;\n            if (!child.displayObject.parent) {\n                let index = 0;\n                if (this.$childrenRenderOrder == 0 /* Ascent */) {\n                    for (let i = 0; i < cnt; i++) {\n                        g = this.$children[i];\n                        if (g == child)\n                            break;\n                        if (g.displayObject != null && g.displayObject.parent != null)\n                            index++;\n                    }\n                    this.$container.addChildAt(child.displayObject, index);\n                }\n                else if (this.$childrenRenderOrder == 1 /* Descent */) {\n                    for (i = cnt - 1; i >= 0; i--) {\n                        g = this.$children[i];\n                        if (g == child)\n                            break;\n                        if (g.displayObject != null && g.displayObject.parent != null)\n                            index++;\n                    }\n                    this.$container.addChildAt(child.displayObject, index);\n                }\n                else {\n                    this.$container.addChild(child.displayObject);\n                    GTimer.inst.callLater(this.appendChildrenList, this);\n                }\n            }\n        }\n        else {\n            if (child.displayObject.parent)\n                this.$container.removeChild(child.displayObject);\n        }\n    }\n    dispose() {\n        GTimer.inst.remove(this.$refreshVirtualList, this);\n        this.$pool.clear();\n        if (this.$scrollPane)\n            this.$scrollPane.off(\"__scroll\" /* SCROLL */, this.$scrolled);\n        super.dispose();\n    }\n    get layout() {\n        return this.$layout;\n    }\n    set layout(value) {\n        if (this.$layout != value) {\n            this.$layout = value;\n            this.setBoundsChangedFlag();\n            if (this.$virtual)\n                this.setVirtualListChangedFlag(true);\n        }\n    }\n    get lineCount() {\n        return this.$lineCount;\n    }\n    set lineCount(value) {\n        if (this.$lineCount != value) {\n            this.$lineCount = value;\n            if (this.$layout == 3 /* FlowVertical */ ||\n                this.$layout == 4 /* Pagination */) {\n                this.setBoundsChangedFlag();\n                if (this.$virtual)\n                    this.setVirtualListChangedFlag(true);\n            }\n        }\n    }\n    get columnCount() {\n        return this.$columnCount;\n    }\n    set columnCount(value) {\n        if (this.$columnCount != value) {\n            this.$columnCount = value;\n            if (this.$layout == 2 /* FlowHorizontal */ ||\n                this.$layout == 4 /* Pagination */) {\n                this.setBoundsChangedFlag();\n                if (this.$virtual)\n                    this.setVirtualListChangedFlag(true);\n            }\n        }\n    }\n    get lineGap() {\n        return this.$lineGap;\n    }\n    set lineGap(value) {\n        if (this.$lineGap != value) {\n            this.$lineGap = value;\n            this.setBoundsChangedFlag();\n            if (this.$virtual)\n                this.setVirtualListChangedFlag(true);\n        }\n    }\n    get columnGap() {\n        return this.$columnGap;\n    }\n    set columnGap(value) {\n        if (this.$columnGap != value) {\n            this.$columnGap = value;\n            this.setBoundsChangedFlag();\n            if (this.$virtual)\n                this.setVirtualListChangedFlag(true);\n        }\n    }\n    get align() {\n        return this.$align;\n    }\n    set align(value) {\n        if (this.$align != value) {\n            this.$align = value;\n            this.setBoundsChangedFlag();\n            if (this.$virtual)\n                this.setVirtualListChangedFlag(true);\n        }\n    }\n    get verticalAlign() {\n        return this.$verticalAlign;\n    }\n    set verticalAlign(value) {\n        if (this.$verticalAlign != value) {\n            this.$verticalAlign = value;\n            this.setBoundsChangedFlag();\n            if (this.$virtual)\n                this.setVirtualListChangedFlag(true);\n        }\n    }\n    get virtualItemSize() {\n        return this.$itemSize;\n    }\n    set virtualItemSize(value) {\n        if (this.$virtual) {\n            if (this.$itemSize == null)\n                this.$itemSize = new createjs.Point();\n            this.$itemSize.copy(value);\n            this.setVirtualListChangedFlag(true);\n        }\n    }\n    get defaultItem() {\n        return this.$defaultItem;\n    }\n    set defaultItem(val) {\n        this.$defaultItem = val;\n    }\n    get autoResizeItem() {\n        return this.$autoResizeItem;\n    }\n    set autoResizeItem(value) {\n        if (this.$autoResizeItem != value) {\n            this.$autoResizeItem = value;\n            this.setBoundsChangedFlag();\n            if (this.$virtual)\n                this.setVirtualListChangedFlag(true);\n        }\n    }\n    get selectionMode() {\n        return this.$selectionMode;\n    }\n    set selectionMode(value) {\n        this.$selectionMode = value;\n    }\n    get selectionController() {\n        return this.$selectionController;\n    }\n    set selectionController(value) {\n        this.$selectionController = value;\n    }\n    get itemPool() {\n        return this.$pool;\n    }\n    getFromPool(url = null) {\n        if (!url)\n            url = this.$defaultItem;\n        let obj = this.$pool.get(url);\n        if (obj != null)\n            obj.visible = true;\n        return obj;\n    }\n    returnToPool(obj) {\n        this.$pool.recycle(obj.resourceURL, obj);\n    }\n    addChildAt(child, index = 0) {\n        super.addChildAt(child, index);\n        if (child instanceof GButton) {\n            child.selected = false;\n            child.changeStateOnClick = false;\n        }\n        child.click(this.$clickItem, this);\n        return child;\n    }\n    addItem(url = null) {\n        if (!url)\n            url = this.$defaultItem;\n        return this.addChild(UIPackage.createObjectFromURL(url));\n    }\n    addItemFromPool(url = null) {\n        return this.addChild(this.getFromPool(url));\n    }\n    removeChildAt(index, dispose = false) {\n        if (index >= 0 && index < this.numChildren) {\n            let child = this.$children[index];\n            child.parent = null;\n            if (child.sortingOrder != 0)\n                this.$sortingChildCount--;\n            this.$children.splice(index, 1);\n            if (child.inContainer) {\n                this.$container.removeChild(child.displayObject);\n                if (this.$childrenRenderOrder == 2 /* Arch */)\n                    GTimer.inst.callLater(this.appendChildrenList, this);\n            }\n            if (dispose === true)\n                child.dispose();\n            this.setBoundsChangedFlag();\n            child.removeClick(this.$clickItem);\n            return child;\n        }\n        else\n            throw new Error('Invalid child index');\n    }\n    removeChildToPoolAt(index) {\n        let child = this.removeChildAt(index);\n        this.returnToPool(child);\n    }\n    removeChildToPool(child) {\n        super.removeChild(child);\n        this.returnToPool(child);\n    }\n    removeChildrenToPool(beginIndex = 0, endIndex = -1) {\n        if (endIndex < 0 || endIndex >= this.$children.length)\n            endIndex = this.$children.length - 1;\n        for (let i = beginIndex; i <= endIndex; ++i)\n            this.removeChildToPoolAt(beginIndex);\n    }\n    get selectedIndex() {\n        let i;\n        if (this.$virtual) {\n            for (i = 0; i < this.$realNumItems; i++) {\n                const ii = this.$virtualItems[i];\n                if ((ii.obj instanceof GButton && ii.obj.selected) || (ii.obj == null && ii.selected)) {\n                    if (this.$loop)\n                        return i % this.$numItems;\n                    else\n                        return i;\n                }\n            }\n        }\n        else {\n            const cnt = this.$children.length;\n            for (i = 0; i < cnt; i++) {\n                const obj = this.$children[i];\n                if (obj != null && obj.selected)\n                    return i;\n            }\n        }\n        return -1;\n    }\n    set selectedIndex(value) {\n        if (value >= 0 && value < this.numItems) {\n            if (this.selectionMode != 0 /* Single */)\n                this.clearSelection();\n            this.addSelection(value);\n        }\n        else\n            this.clearSelection();\n    }\n    getSelection() {\n        let ret = [];\n        let i;\n        if (this.$virtual) {\n            for (i = 0; i < this.$realNumItems; i++) {\n                const ii = this.$virtualItems[i];\n                if ((ii.obj instanceof GButton && ii.obj.selected) || (ii.obj == null && ii.selected)) {\n                    let j = i;\n                    if (this.$loop) {\n                        j = i % this.$numItems;\n                        if (ret.indexOf(j) != -1)\n                            continue;\n                    }\n                    ret.push(j);\n                }\n            }\n        }\n        else {\n            const cnt = this.$children.length;\n            for (i = 0; i < cnt; i++) {\n                const obj = this.$children[i];\n                if (obj != null && obj.selected)\n                    ret.push(i);\n            }\n        }\n        return ret;\n    }\n    addSelection(index, scrollIntoView = false) {\n        if (this.$selectionMode == 3 /* None */)\n            return;\n        this.checkVirtualList();\n        if (this.$selectionMode == 0 /* Single */)\n            this.clearSelection();\n        if (scrollIntoView)\n            this.scrollToView(index);\n        this.$lastSelectedIndex = index;\n        let obj = null;\n        if (this.$virtual) {\n            const ii = this.$virtualItems[index];\n            if (ii.obj != null)\n                obj = ii.obj;\n            ii.selected = true;\n        }\n        else\n            obj = this.getChildAt(index);\n        if (obj != null && !obj.selected) {\n            obj.selected = true;\n            this.updateSelectionController(index);\n        }\n    }\n    removeSelection(index) {\n        if (this.$selectionMode == 3 /* None */)\n            return;\n        let obj = null;\n        if (this.$virtual) {\n            const ii = this.$virtualItems[index];\n            if (ii.obj != null)\n                obj = ii.obj;\n            ii.selected = false;\n        }\n        else\n            obj = this.getChildAt(index);\n        if (obj != null)\n            obj.selected = false;\n    }\n    clearSelection() {\n        let i;\n        if (this.$virtual) {\n            for (i = 0; i < this.$realNumItems; i++) {\n                const ii = this.$virtualItems[i];\n                if (ii.obj instanceof GButton)\n                    ii.obj.selected = false;\n                ii.selected = false;\n            }\n        }\n        else {\n            const cnt = this.$children.length;\n            for (i = 0; i < cnt; i++) {\n                const obj = this.$children[i];\n                if (obj != null)\n                    obj.selected = false;\n            }\n        }\n    }\n    clearSelectionExcept(g) {\n        let i;\n        if (this.$virtual) {\n            for (i = 0; i < this.$realNumItems; i++) {\n                const ii = this.$virtualItems[i];\n                if (ii.obj != g) {\n                    if (ii.obj instanceof GButton)\n                        ii.obj.selected = false;\n                    ii.selected = false;\n                }\n            }\n        }\n        else {\n            const cnt = this.$children.length;\n            for (i = 0; i < cnt; i++) {\n                const obj = this.$children[i];\n                if (obj != null && obj != g)\n                    obj.selected = false;\n            }\n        }\n    }\n    selectAll() {\n        this.checkVirtualList();\n        let last = -1;\n        let i;\n        if (this.$virtual) {\n            for (i = 0; i < this.$realNumItems; i++) {\n                const ii = this.$virtualItems[i];\n                if (ii.obj instanceof GButton && !ii.obj.selected) {\n                    ii.obj.selected = true;\n                    last = i;\n                }\n                ii.selected = true;\n            }\n        }\n        else {\n            const cnt = this.$children.length;\n            for (i = 0; i < cnt; i++) {\n                const obj = this.$children[i];\n                if (obj != null && !obj.selected) {\n                    obj.selected = true;\n                    last = i;\n                }\n            }\n        }\n        if (last != -1)\n            this.updateSelectionController(last);\n    }\n    selectNone() {\n        this.clearSelection();\n    }\n    selectReverse() {\n        this.checkVirtualList();\n        let last = -1;\n        let i;\n        if (this.$virtual) {\n            for (i = 0; i < this.$realNumItems; i++) {\n                const ii = this.$virtualItems[i];\n                if (ii.obj instanceof GButton) {\n                    ii.obj.selected = !ii.obj.selected;\n                    if (ii.obj.selected)\n                        last = i;\n                }\n                ii.selected = !ii.selected;\n            }\n        }\n        else {\n            const cnt = this.$children.length;\n            for (i = 0; i < cnt; i++) {\n                const obj = this.$children[i];\n                if (obj != null) {\n                    obj.selected = !obj.selected;\n                    if (obj.selected)\n                        last = i;\n                }\n            }\n        }\n        if (last != -1)\n            this.updateSelectionController(last);\n    }\n    handleArrowKey(key) {\n        let index = this.selectedIndex;\n        if (index == -1)\n            return;\n        let current;\n        let k, i;\n        let obj;\n        switch (key) {\n            case 38 /* Up */:\n                if (this.$layout == 0 /* SingleColumn */ ||\n                    this.$layout == 3 /* FlowVertical */) {\n                    index--;\n                    if (index >= 0) {\n                        this.clearSelection();\n                        this.addSelection(index, true);\n                    }\n                }\n                else if (this.$layout == 2 /* FlowHorizontal */ ||\n                    this.$layout == 4 /* Pagination */) {\n                    current = this.$children[index];\n                    k = 0;\n                    for (i = index - 1; i >= 0; i--) {\n                        obj = this.$children[i];\n                        if (obj.y != current.y) {\n                            current = obj;\n                            break;\n                        }\n                        k++;\n                    }\n                    for (; i >= 0; i--) {\n                        obj = this.$children[i];\n                        if (obj.y != current.y) {\n                            this.clearSelection();\n                            this.addSelection(i + k + 1, true);\n                            break;\n                        }\n                    }\n                }\n                break;\n            case 39 /* Right */:\n                if (this.$layout == 1 /* SingleRow */ ||\n                    this.$layout == 2 /* FlowHorizontal */ ||\n                    this.$layout == 4 /* Pagination */) {\n                    index++;\n                    if (index < this.$children.length) {\n                        this.clearSelection();\n                        this.addSelection(index, true);\n                    }\n                }\n                else if (this.$layout == 3 /* FlowVertical */) {\n                    current = this.$children[index];\n                    k = 0;\n                    const cnt = this.$children.length;\n                    for (i = index + 1; i < cnt; i++) {\n                        obj = this.$children[i];\n                        if (obj.x != current.x) {\n                            current = obj;\n                            break;\n                        }\n                        k++;\n                    }\n                    for (; i < cnt; i++) {\n                        obj = this.$children[i];\n                        if (obj.x != current.x) {\n                            this.clearSelection();\n                            this.addSelection(i - k - 1, true);\n                            break;\n                        }\n                    }\n                }\n                break;\n            case 40 /* Down */:\n                if (this.$layout == 0 /* SingleColumn */ ||\n                    this.$layout == 3 /* FlowVertical */) {\n                    index++;\n                    if (index < this.$children.length) {\n                        this.clearSelection();\n                        this.addSelection(index, true);\n                    }\n                }\n                else if (this.$layout == 2 /* FlowHorizontal */ ||\n                    this.$layout == 4 /* Pagination */) {\n                    current = this.$children[index];\n                    k = 0;\n                    const cnt = this.$children.length;\n                    for (i = index + 1; i < cnt; i++) {\n                        obj = this.$children[i];\n                        if (obj.y != current.y) {\n                            current = obj;\n                            break;\n                        }\n                        k++;\n                    }\n                    for (; i < cnt; i++) {\n                        obj = this.$children[i];\n                        if (obj.y != current.y) {\n                            this.clearSelection();\n                            this.addSelection(i - k - 1, true);\n                            break;\n                        }\n                    }\n                }\n                break;\n            case 37 /* Left */:\n                if (this.$layout == 1 /* SingleRow */ ||\n                    this.$layout == 2 /* FlowHorizontal */ ||\n                    this.$layout == 4 /* Pagination */) {\n                    index--;\n                    if (index >= 0) {\n                        this.clearSelection();\n                        this.addSelection(index, true);\n                    }\n                }\n                else if (this.$layout == 3 /* FlowVertical */) {\n                    current = this.$children[index];\n                    k = 0;\n                    for (i = index - 1; i >= 0; i--) {\n                        obj = this.$children[i];\n                        if (obj.x != current.x) {\n                            current = obj;\n                            break;\n                        }\n                        k++;\n                    }\n                    for (; i >= 0; i--) {\n                        obj = this.$children[i];\n                        if (obj.x != current.x) {\n                            this.clearSelection();\n                            this.addSelection(i + k + 1, true);\n                            break;\n                        }\n                    }\n                }\n                break;\n        }\n    }\n    $clickItem(evt) {\n        if (this.$scrollPane != null && this.$scrollPane.isDragging)\n            return;\n        const item = GObject.castFromNativeObject(evt.currentTarget);\n        if (!item)\n            return;\n        this.setSelectionOnEvent(item);\n        if (this.$scrollPane && this.scrollItemToViewOnClick)\n            this.$scrollPane.scrollToView(item, true);\n        let event = new createjs.Event(\"__itemClick\" /* ItemClick */, true, false);\n        event.data = { item };\n        this.dispatchEvent(event, this);\n    }\n    setSelectionOnEvent(button) {\n        if (!(button instanceof GButton) || this.$selectionMode == 3 /* None */)\n            return;\n        let dontChangeLastIndex = false;\n        let index = this.childIndexToItemIndex(this.getChildIndex(button));\n        if (this.$selectionMode == 0 /* Single */) {\n            if (!button.selected) {\n                this.clearSelectionExcept(button);\n                button.selected = true;\n            }\n        }\n        else {\n            if (DOMEventManager.inst.isKeyPressed(16 /* Shift */)) {\n                if (!button.selected) {\n                    if (this.$lastSelectedIndex != -1) {\n                        const min = Math.min(this.$lastSelectedIndex, index);\n                        const max = Math.min(Math.max(this.$lastSelectedIndex, index), this.numItems - 1);\n                        let i;\n                        if (this.$virtual) {\n                            for (i = min; i <= max; i++) {\n                                const ii = this.$virtualItems[i];\n                                if (ii.obj instanceof GButton)\n                                    ii.obj.selected = true;\n                                ii.selected = true;\n                            }\n                        }\n                        else {\n                            for (i = min; i <= max; i++) {\n                                const obj = this.getChildAt(i);\n                                if (obj != null)\n                                    obj.selected = true;\n                            }\n                        }\n                        dontChangeLastIndex = true;\n                    }\n                    else\n                        button.selected = true;\n                }\n            }\n            else if (DOMEventManager.inst.isKeyPressed(17 /* Ctrl */) ||\n                this.$selectionMode == 2 /* Multiple_SingleClick */)\n                button.selected = !button.selected;\n            else {\n                if (!button.selected) {\n                    this.clearSelectionExcept(button);\n                    button.selected = true;\n                }\n                else\n                    this.clearSelectionExcept(button);\n            }\n        }\n        if (!dontChangeLastIndex)\n            this.$lastSelectedIndex = index;\n        if (button.selected)\n            this.updateSelectionController(index);\n    }\n    resizeToFit(itemCount = 1000000, minSize = 0) {\n        this.ensureBoundsCorrect();\n        const curCount = this.numItems;\n        if (itemCount > curCount)\n            itemCount = curCount;\n        if (this.$virtual) {\n            const lineCount = Math.ceil(itemCount / this.$curLineItemCount);\n            if (this.$layout == 0 /* SingleColumn */ ||\n                this.$layout == 2 /* FlowHorizontal */)\n                this.viewHeight = lineCount * this.$itemSize.y + Math.max(0, lineCount - 1) * this.$lineGap;\n            else\n                this.viewWidth = lineCount * this.$itemSize.x + Math.max(0, lineCount - 1) * this.$columnGap;\n        }\n        else if (itemCount == 0) {\n            if (this.$layout == 0 /* SingleColumn */ ||\n                this.$layout == 2 /* FlowHorizontal */)\n                this.viewHeight = minSize;\n            else\n                this.viewWidth = minSize;\n        }\n        else {\n            let i = itemCount - 1;\n            let obj;\n            while (i >= 0) {\n                obj = this.getChildAt(i);\n                if (!this.foldInvisibleItems || obj.visible)\n                    break;\n                i--;\n            }\n            if (i < 0) {\n                if (this.$layout == 0 /* SingleColumn */ ||\n                    this.$layout == 2 /* FlowHorizontal */)\n                    this.viewHeight = minSize;\n                else\n                    this.viewWidth = minSize;\n            }\n            else {\n                let size = 0;\n                if (this.$layout == 0 /* SingleColumn */ ||\n                    this.$layout == 2 /* FlowHorizontal */) {\n                    size = obj.y + obj.height;\n                    if (size < minSize)\n                        size = minSize;\n                    this.viewHeight = size;\n                }\n                else {\n                    size = obj.x + obj.width;\n                    if (size < minSize)\n                        size = minSize;\n                    this.viewWidth = size;\n                }\n            }\n        }\n    }\n    getMaxItemWidth() {\n        const cnt = this.$children.length;\n        let max = 0;\n        for (let i = 0; i < cnt; i++) {\n            const child = this.getChildAt(i);\n            if (child.width > max)\n                max = child.width;\n        }\n        return max;\n    }\n    handleSizeChanged() {\n        super.handleSizeChanged();\n        this.setBoundsChangedFlag();\n        if (this.$virtual)\n            this.setVirtualListChangedFlag(true);\n    }\n    handleControllerChanged(c) {\n        super.handleControllerChanged(c);\n        if (this.$selectionController == c)\n            this.selectedIndex = c.selectedIndex;\n    }\n    updateSelectionController(index) {\n        if (this.$selectionController != null &&\n            !this.$selectionController.$updating &&\n            index < this.selectionController.pageCount) {\n            const c = this.$selectionController;\n            this.$selectionController = null;\n            c.selectedIndex = index;\n            this.$selectionController = c;\n        }\n    }\n    getSnappingPosition(xValue, yValue, resultPoint = null) {\n        if (this.$virtual) {\n            if (!resultPoint)\n                resultPoint = new createjs.Point();\n            let saved;\n            let index;\n            if (this.$layout == 0 /* SingleColumn */ ||\n                this.$layout == 2 /* FlowHorizontal */) {\n                saved = yValue;\n                GList.$lastPosHelper = yValue;\n                index = this.getIndexOnPos1(false);\n                yValue = GList.$lastPosHelper;\n                if (index < this.$virtualItems.length &&\n                    saved - yValue > this.$virtualItems[index].height / 2 &&\n                    index < this.$realNumItems)\n                    yValue += this.$virtualItems[index].height + this.$lineGap;\n            }\n            else if (this.$layout == 1 /* SingleRow */ ||\n                this.$layout == 3 /* FlowVertical */) {\n                saved = xValue;\n                GList.$lastPosHelper = xValue;\n                index = this.getIndexOnPos2(false);\n                xValue = GList.$lastPosHelper;\n                if (index < this.$virtualItems.length &&\n                    saved - xValue > this.$virtualItems[index].width / 2 &&\n                    index < this.$realNumItems)\n                    xValue += this.$virtualItems[index].width + this.$columnGap;\n            }\n            else {\n                saved = xValue;\n                GList.$lastPosHelper = xValue;\n                index = this.getIndexOnPos3(false);\n                xValue = GList.$lastPosHelper;\n                if (index < this.$virtualItems.length &&\n                    saved - xValue > this.$virtualItems[index].width / 2 &&\n                    index < this.$realNumItems)\n                    xValue += this.$virtualItems[index].width + this.$columnGap;\n            }\n            resultPoint.x = xValue;\n            resultPoint.y = yValue;\n            return resultPoint;\n        }\n        else\n            return super.getSnappingPosition(xValue, yValue, resultPoint);\n    }\n    scrollToView(index, ani = false, snapToFirst = false) {\n        if (this.$virtual) {\n            if (this.$numItems == 0)\n                return;\n            this.checkVirtualList();\n            if (index >= this.$virtualItems.length)\n                throw new Error(`Invalid child index: ${index} is larger than max length: ${this.$virtualItems.length}`);\n            if (this.$loop)\n                index = Math.floor(this.$firstIndex / this.$numItems) * this.$numItems + index;\n            let rect;\n            const ii = this.$virtualItems[index];\n            let pos = 0;\n            let i;\n            if (this.$layout == 0 /* SingleColumn */ ||\n                this.$layout == 2 /* FlowHorizontal */) {\n                for (i = 0; i < index; i += this.$curLineItemCount)\n                    pos += this.$virtualItems[i].height + this.$lineGap;\n                rect = new createjs.Rectangle(0, pos, this.$itemSize.x, ii.height);\n            }\n            else if (this.$layout == 1 /* SingleRow */ ||\n                this.$layout == 3 /* FlowVertical */) {\n                for (i = 0; i < index; i += this.$curLineItemCount)\n                    pos += this.$virtualItems[i].width + this.$columnGap;\n                rect = new createjs.Rectangle(pos, 0, ii.width, this.$itemSize.y);\n            }\n            else {\n                const page = index / (this.$curLineItemCount * this.$curLineItemCount2);\n                rect = new createjs.Rectangle(page * this.viewWidth + (index % this.$curLineItemCount) * (ii.width + this.$columnGap), ((index / this.$curLineItemCount) % this.$curLineItemCount2) *\n                    (ii.height + this.$lineGap), ii.width, ii.height);\n            }\n            //the position will be also changed if the height of its parent (if changeable) is being changed, so here we need to forcely set this to true\n            snapToFirst = true;\n            if (this.$scrollPane != null)\n                this.$scrollPane.scrollToView(rect, ani, snapToFirst);\n        }\n        else {\n            const obj = this.getChildAt(index);\n            if (this.$scrollPane != null)\n                this.$scrollPane.scrollToView(obj, ani, snapToFirst);\n            else if (this.parent != null && this.parent.scrollPane != null)\n                this.parent.scrollPane.scrollToView(obj, ani, snapToFirst);\n        }\n    }\n    getFirstChildInView() {\n        return this.childIndexToItemIndex(super.getFirstChildInView());\n    }\n    childIndexToItemIndex(index) {\n        if (!this.$virtual)\n            return index;\n        if (this.$layout == 4 /* Pagination */) {\n            for (let i = this.$firstIndex; i < this.$realNumItems; i++) {\n                if (this.$virtualItems[i].obj != null) {\n                    index--;\n                    if (index < 0)\n                        return i;\n                }\n            }\n            return index;\n        }\n        else {\n            index += this.$firstIndex;\n            if (this.$loop && this.$numItems > 0)\n                index = index % this.$numItems;\n            return index;\n        }\n    }\n    itemIndexToChildIndex(index) {\n        if (!this.$virtual)\n            return index;\n        if (this.$layout == 4 /* Pagination */)\n            return this.getChildIndex(this.$virtualItems[index].obj);\n        else {\n            if (this.$loop && this.$numItems > 0) {\n                const j = this.$firstIndex % this.$numItems;\n                if (index >= j)\n                    index = this.$firstIndex + (index - j);\n                else\n                    index = this.$firstIndex + this.$numItems + (j - index);\n            }\n            else\n                index -= this.$firstIndex;\n            return index;\n        }\n    }\n    setVirtual() {\n        this.$setVirtual(false);\n    }\n    setVirtualAndLoop() {\n        this.$setVirtual(true);\n    }\n    $setVirtual(loop) {\n        if (!this.$virtual) {\n            if (this.$scrollPane == null)\n                throw new Error('Virtual list must be scrollable');\n            if (loop) {\n                if (this.$layout == 2 /* FlowHorizontal */ ||\n                    this.$layout == 3 /* FlowVertical */)\n                    throw new Error('Virtual list with loop mode is not supported for both FlowHorizontal and FlowVertical layout');\n                this.$scrollPane.bouncebackEffect = false;\n            }\n            this.$virtual = true;\n            this.$loop = loop;\n            this.$virtualItems = [];\n            this.removeChildrenToPool();\n            if (this.$itemSize == null) {\n                this.$itemSize = new createjs.Point();\n                const obj = this.getFromPool(null);\n                if (obj == null)\n                    throw new Error('Virtual list must have a default list item resource specified through list.defaultItem = resUrl.');\n                else {\n                    this.$itemSize.x = obj.width;\n                    this.$itemSize.y = obj.height;\n                }\n                this.returnToPool(obj);\n            }\n            if (this.$layout == 0 /* SingleColumn */ ||\n                this.$layout == 2 /* FlowHorizontal */) {\n                this.$scrollPane.scrollSpeed = this.$itemSize.y;\n                if (this.$loop)\n                    this.$scrollPane.$loop = 2;\n            }\n            else {\n                this.$scrollPane.scrollSpeed = this.$itemSize.x;\n                if (this.$loop)\n                    this.$scrollPane.$loop = 1;\n            }\n            this.$scrollPane.on(\"__scroll\" /* SCROLL */, this.$scrolled, this);\n            this.setVirtualListChangedFlag(true);\n        }\n    }\n    get numItems() {\n        if (this.$virtual)\n            return this.$numItems;\n        else\n            return this.$children.length;\n    }\n    set numItems(value) {\n        let i;\n        if (this.$virtual) {\n            if (this.itemRenderer == null)\n                throw new Error('list.itemRenderer is required');\n            this.$numItems = value;\n            if (this.$loop)\n                this.$realNumItems = this.$numItems * 6;\n            //enlarge for loop\n            else\n                this.$realNumItems = this.$numItems;\n            //increase only\n            const oldCount = this.$virtualItems.length;\n            if (this.$realNumItems > oldCount) {\n                for (i = oldCount; i < this.$realNumItems; i++) {\n                    let ii = new ItemInfo();\n                    ii.width = this.$itemSize.x;\n                    ii.height = this.$itemSize.y;\n                    this.$virtualItems.push(ii);\n                }\n            }\n            else {\n                for (i = this.$realNumItems; i < oldCount; i++)\n                    this.$virtualItems[i].selected = false;\n            }\n            if (this.$virtualListChanged != 0 /* None */)\n                GTimer.inst.remove(this.$refreshVirtualList, this);\n            //refresh now\n            this.$refreshVirtualList();\n        }\n        else {\n            const cnt = this.$children.length;\n            if (value > cnt) {\n                for (i = cnt; i < value; i++) {\n                    if (this.itemProvider == null)\n                        this.addItemFromPool();\n                    else\n                        this.addItemFromPool(this.itemProvider(i));\n                }\n            }\n            else\n                this.removeChildrenToPool(value, cnt);\n            if (this.itemRenderer != null) {\n                for (i = 0; i < value; i++)\n                    this.itemRenderer(i, this.getChildAt(i));\n            }\n        }\n    }\n    refreshVirtualList() {\n        this.setVirtualListChangedFlag(false);\n    }\n    checkVirtualList() {\n        if (this.$virtualListChanged != 0 /* None */) {\n            this.$refreshVirtualList();\n            GTimer.inst.remove(this.$refreshVirtualList, this);\n        }\n    }\n    setVirtualListChangedFlag(layoutChanged = false) {\n        if (layoutChanged)\n            this.$virtualListChanged = 2 /* SizeChanged */;\n        else if (this.$virtualListChanged == 0 /* None */)\n            this.$virtualListChanged = 1 /* ContentChanged */;\n        GTimer.inst.callLater(this.$refreshVirtualList, this);\n    }\n    $refreshVirtualList() {\n        const layoutChanged = this.$virtualListChanged == 2 /* SizeChanged */;\n        this.$virtualListChanged = 0 /* None */;\n        this.$eventLocked = true;\n        if (layoutChanged) {\n            if (this.$layout == 0 /* SingleColumn */ || this.$layout == 1 /* SingleRow */)\n                this.$curLineItemCount = 1;\n            else if (this.$layout == 2 /* FlowHorizontal */) {\n                if (this.$columnCount > 0)\n                    this.$curLineItemCount = this.$columnCount;\n                else {\n                    this.$curLineItemCount = Math.floor((this.$scrollPane.viewWidth + this.$columnGap) / (this.$itemSize.x + this.$columnGap));\n                    if (this.$curLineItemCount <= 0)\n                        this.$curLineItemCount = 1;\n                }\n            }\n            else if (this.$layout == 3 /* FlowVertical */) {\n                if (this.$lineCount > 0)\n                    this.$curLineItemCount = this.$lineCount;\n                else {\n                    this.$curLineItemCount = Math.floor((this.$scrollPane.viewHeight + this.$lineGap) / (this.$itemSize.y + this.$lineGap));\n                    if (this.$curLineItemCount <= 0)\n                        this.$curLineItemCount = 1;\n                }\n            } //pagination\n            else {\n                if (this.$columnCount > 0)\n                    this.$curLineItemCount = this.$columnCount;\n                else {\n                    this.$curLineItemCount = Math.floor((this.$scrollPane.viewWidth + this.$columnGap) / (this.$itemSize.x + this.$columnGap));\n                    if (this.$curLineItemCount <= 0)\n                        this.$curLineItemCount = 1;\n                }\n                if (this.$lineCount > 0)\n                    this.$curLineItemCount2 = this.$lineCount;\n                else {\n                    this.$curLineItemCount2 = Math.floor((this.$scrollPane.viewHeight + this.$lineGap) / (this.$itemSize.y + this.$lineGap));\n                    if (this.$curLineItemCount2 <= 0)\n                        this.$curLineItemCount2 = 1;\n                }\n            }\n        }\n        let ch = 0, cw = 0;\n        if (this.$realNumItems > 0) {\n            let i;\n            let len = Math.ceil(this.$realNumItems / this.$curLineItemCount) * this.$curLineItemCount;\n            let len2 = Math.min(this.$curLineItemCount, this.$realNumItems);\n            if (this.$layout == 0 /* SingleColumn */ ||\n                this.$layout == 2 /* FlowHorizontal */) {\n                for (i = 0; i < len; i += this.$curLineItemCount)\n                    ch += this.$virtualItems[i].height + this.$lineGap;\n                if (ch > 0)\n                    ch -= this.$lineGap;\n                if (this.$autoResizeItem)\n                    cw = this.$scrollPane.viewWidth;\n                else {\n                    for (i = 0; i < len2; i++)\n                        cw += this.$virtualItems[i].width + this.$columnGap;\n                    if (cw > 0)\n                        cw -= this.$columnGap;\n                }\n            }\n            else if (this.$layout == 1 /* SingleRow */ ||\n                this.$layout == 3 /* FlowVertical */) {\n                for (i = 0; i < len; i += this.$curLineItemCount)\n                    cw += this.$virtualItems[i].width + this.$columnGap;\n                if (cw > 0)\n                    cw -= this.$columnGap;\n                if (this.$autoResizeItem)\n                    ch = this.$scrollPane.viewHeight;\n                else {\n                    for (i = 0; i < len2; i++)\n                        ch += this.$virtualItems[i].height + this.$lineGap;\n                    if (ch > 0)\n                        ch -= this.$lineGap;\n                }\n            }\n            else {\n                const pageCount = Math.ceil(len / (this.$curLineItemCount * this.$curLineItemCount2));\n                cw = pageCount * this.viewWidth;\n                ch = this.viewHeight;\n            }\n        }\n        this.handleAlign(cw, ch);\n        this.$scrollPane.setContentSize(cw, ch);\n        this.$eventLocked = false;\n        this.handleScroll(true);\n    }\n    $scrolled() {\n        this.handleScroll(false);\n    }\n    getIndexOnPos1(forceUpdate) {\n        if (this.$realNumItems < this.$curLineItemCount) {\n            GList.$lastPosHelper = 0;\n            return 0;\n        }\n        let i;\n        let pos2;\n        let pos3;\n        if (this.numChildren > 0 && !forceUpdate) {\n            pos2 = this.getChildAt(0).y;\n            if (pos2 > GList.$lastPosHelper) {\n                for (i = this.$firstIndex - this.$curLineItemCount; i >= 0; i -= this.$curLineItemCount) {\n                    pos2 -= this.$virtualItems[i].height + this.$lineGap;\n                    if (pos2 <= GList.$lastPosHelper) {\n                        GList.$lastPosHelper = pos2;\n                        return i;\n                    }\n                }\n                GList.$lastPosHelper = 0;\n                return 0;\n            }\n            else {\n                for (i = this.$firstIndex; i < this.$realNumItems; i += this.$curLineItemCount) {\n                    pos3 = pos2 + this.$virtualItems[i].height + this.$lineGap;\n                    if (pos3 > GList.$lastPosHelper) {\n                        GList.$lastPosHelper = pos2;\n                        return i;\n                    }\n                    pos2 = pos3;\n                }\n                GList.$lastPosHelper = pos2;\n                return this.$realNumItems - this.$curLineItemCount;\n            }\n        }\n        else {\n            pos2 = 0;\n            for (i = 0; i < this.$realNumItems; i += this.$curLineItemCount) {\n                pos3 = pos2 + this.$virtualItems[i].height + this.$lineGap;\n                if (pos3 > GList.$lastPosHelper) {\n                    GList.$lastPosHelper = pos2;\n                    return i;\n                }\n                pos2 = pos3;\n            }\n            GList.$lastPosHelper = pos2;\n            return this.$realNumItems - this.$curLineItemCount;\n        }\n    }\n    getIndexOnPos2(forceUpdate) {\n        if (this.$realNumItems < this.$curLineItemCount) {\n            GList.$lastPosHelper = 0;\n            return 0;\n        }\n        let i;\n        let pos2;\n        let pos3;\n        if (this.numChildren > 0 && !forceUpdate) {\n            pos2 = this.getChildAt(0).x;\n            if (pos2 > GList.$lastPosHelper) {\n                for (i = this.$firstIndex - this.$curLineItemCount; i >= 0; i -= this.$curLineItemCount) {\n                    pos2 -= this.$virtualItems[i].width + this.$columnGap;\n                    if (pos2 <= GList.$lastPosHelper) {\n                        GList.$lastPosHelper = pos2;\n                        return i;\n                    }\n                }\n                GList.$lastPosHelper = 0;\n                return 0;\n            }\n            else {\n                for (i = this.$firstIndex; i < this.$realNumItems; i += this.$curLineItemCount) {\n                    pos3 = pos2 + this.$virtualItems[i].width + this.$columnGap;\n                    if (pos3 > GList.$lastPosHelper) {\n                        GList.$lastPosHelper = pos2;\n                        return i;\n                    }\n                    pos2 = pos3;\n                }\n                GList.$lastPosHelper = pos2;\n                return this.$realNumItems - this.$curLineItemCount;\n            }\n        }\n        else {\n            pos2 = 0;\n            for (i = 0; i < this.$realNumItems; i += this.$curLineItemCount) {\n                pos3 = pos2 + this.$virtualItems[i].width + this.$columnGap;\n                if (pos3 > GList.$lastPosHelper) {\n                    GList.$lastPosHelper = pos2;\n                    return i;\n                }\n                pos2 = pos3;\n            }\n            GList.$lastPosHelper = pos2;\n            return this.$realNumItems - this.$curLineItemCount;\n        }\n    }\n    getIndexOnPos3(forceUpdate) {\n        if (this.$realNumItems < this.$curLineItemCount) {\n            GList.$lastPosHelper = 0;\n            return 0;\n        }\n        const viewWidth = this.viewWidth;\n        const page = Math.floor(GList.$lastPosHelper / viewWidth);\n        const startIndex = page * (this.$curLineItemCount * this.$curLineItemCount2);\n        let i;\n        let pos3;\n        let pos2 = page * viewWidth;\n        for (i = 0; i < this.$curLineItemCount; i++) {\n            pos3 = pos2 + this.$virtualItems[startIndex + i].width + this.$columnGap;\n            if (pos3 > GList.$lastPosHelper) {\n                GList.$lastPosHelper = pos2;\n                return startIndex + i;\n            }\n            pos2 = pos3;\n        }\n        GList.$lastPosHelper = pos2;\n        return startIndex + this.$curLineItemCount - 1;\n    }\n    handleScroll(forceUpdate) {\n        if (this.$eventLocked)\n            return;\n        this.$enterCounter = 0;\n        if (this.$layout == 0 /* SingleColumn */ ||\n            this.$layout == 2 /* FlowHorizontal */) {\n            this.handleScroll1(forceUpdate);\n            this.handleArchOrder1();\n        }\n        else if (this.$layout == 1 /* SingleRow */ ||\n            this.$layout == 3 /* FlowVertical */) {\n            this.handleScroll2(forceUpdate);\n            this.handleArchOrder2();\n        }\n        else\n            this.handleScroll3(forceUpdate);\n        this.$boundsChanged = false;\n    }\n    handleScroll1(forceUpdate) {\n        this.$enterCounter++;\n        if (this.$enterCounter > 3) {\n            console.warn('this list view cannot be filled full as the itemRenderer function always returns an item with different size.');\n            return;\n        }\n        let pos = this.$scrollPane.scrollingPosY;\n        let max = pos + this.$scrollPane.viewHeight;\n        const end = max == this.$scrollPane.contentHeight; //indicates we need to scroll to end in spite of content size changing\n        //find the first item from current pos\n        GList.$lastPosHelper = pos;\n        const newFirstIndex = this.getIndexOnPos1(forceUpdate);\n        if (newFirstIndex == this.$firstIndex && !forceUpdate)\n            return;\n        pos = GList.$lastPosHelper;\n        const oldFirstIndex = this.$firstIndex;\n        this.$firstIndex = newFirstIndex;\n        let curIndex = newFirstIndex;\n        const forward = oldFirstIndex > newFirstIndex;\n        const oldCount = this.numChildren;\n        const lastIndex = oldFirstIndex + oldCount - 1;\n        let reuseIndex = forward ? lastIndex : oldFirstIndex;\n        let curX = 0, curY = pos;\n        let needRender;\n        let deltaSize = 0;\n        let firstItemDeltaSize = 0;\n        let url = this.defaultItem;\n        let ii, ii2;\n        let i, j;\n        const partSize = (this.$scrollPane.viewWidth - this.$columnGap * (this.$curLineItemCount - 1)) /\n            this.$curLineItemCount;\n        this.$itemInfoVer++;\n        while (curIndex < this.$realNumItems && (end || curY < max)) {\n            ii = this.$virtualItems[curIndex];\n            if (ii.obj == null || forceUpdate) {\n                if (this.itemProvider != null) {\n                    url = this.itemProvider(curIndex % this.$numItems);\n                    if (url == null)\n                        url = this.$defaultItem;\n                    url = UIPackage.normalizeURL(url);\n                }\n                if (ii.obj != null && ii.obj.resourceURL != url) {\n                    if (ii.obj instanceof GButton)\n                        ii.selected = ii.obj.selected;\n                    this.removeChildToPool(ii.obj);\n                    ii.obj = null;\n                }\n            }\n            if (ii.obj == null) {\n                //search for a most suitable item to reuse in order to render or create less item when refresh\n                if (forward) {\n                    for (j = reuseIndex; j >= oldFirstIndex; j--) {\n                        ii2 = this.$virtualItems[j];\n                        if (ii2.obj != null &&\n                            ii2.updateFlag != this.$itemInfoVer &&\n                            ii2.obj.resourceURL == url) {\n                            if (ii2.obj instanceof GButton)\n                                ii2.selected = ii2.obj.selected;\n                            ii.obj = ii2.obj;\n                            ii2.obj = null;\n                            if (j == reuseIndex)\n                                reuseIndex--;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    for (j = reuseIndex; j <= lastIndex; j++) {\n                        ii2 = this.$virtualItems[j];\n                        if (ii2.obj != null &&\n                            ii2.updateFlag != this.$itemInfoVer &&\n                            ii2.obj.resourceURL == url) {\n                            if (ii2.obj instanceof GButton)\n                                ii2.selected = ii2.obj.selected;\n                            ii.obj = ii2.obj;\n                            ii2.obj = null;\n                            if (j == reuseIndex)\n                                reuseIndex++;\n                            break;\n                        }\n                    }\n                }\n                if (ii.obj != null)\n                    this.setChildIndex(ii.obj, forward ? curIndex - newFirstIndex : this.numChildren);\n                else {\n                    ii.obj = this.$pool.get(url);\n                    if (forward)\n                        this.addChildAt(ii.obj, curIndex - newFirstIndex);\n                    else\n                        this.addChild(ii.obj);\n                }\n                if (ii.obj instanceof GButton)\n                    ii.obj.selected = ii.selected;\n                needRender = true;\n            }\n            else\n                needRender = forceUpdate;\n            if (needRender) {\n                if (this.$autoResizeItem &&\n                    (this.$layout == 0 /* SingleColumn */ || this.$columnCount > 0))\n                    ii.obj.setSize(partSize, ii.obj.height, true);\n                this.itemRenderer(curIndex % this.$numItems, ii.obj);\n                if (curIndex % this.$curLineItemCount == 0) {\n                    deltaSize += Math.ceil(ii.obj.height) - ii.height;\n                    if (curIndex == newFirstIndex && oldFirstIndex > newFirstIndex) {\n                        //when scrolling down, we need to make compensation for the position to avoid flickering if the item's size changes\n                        firstItemDeltaSize = Math.ceil(ii.obj.height) - ii.height;\n                    }\n                }\n                ii.width = Math.ceil(ii.obj.width);\n                ii.height = Math.ceil(ii.obj.height);\n            }\n            ii.updateFlag = this.$itemInfoVer;\n            ii.obj.setXY(curX, curY);\n            if (curIndex == newFirstIndex)\n                //pad one more\n                max += ii.height;\n            curX += ii.width + this.$columnGap;\n            if (curIndex % this.$curLineItemCount == this.$curLineItemCount - 1) {\n                curX = 0;\n                curY += ii.height + this.$lineGap;\n            }\n            curIndex++;\n        }\n        for (i = 0; i < oldCount; i++) {\n            ii = this.$virtualItems[oldFirstIndex + i];\n            if (ii.updateFlag != this.$itemInfoVer && ii.obj != null) {\n                if (ii.obj instanceof GButton)\n                    ii.selected = ii.obj.selected;\n                this.removeChildToPool(ii.obj);\n                ii.obj = null;\n            }\n        }\n        if (deltaSize != 0 || firstItemDeltaSize != 0)\n            this.$scrollPane.changeContentSizeOnScrolling(0, deltaSize, 0, firstItemDeltaSize);\n        if (curIndex > 0 &&\n            this.numChildren > 0 &&\n            this.$container.y < 0 &&\n            this.getChildAt(0).y > -this.$container.y)\n            //last page is not full\n            this.handleScroll1(false); //recursive\n    }\n    handleScroll2(forceUpdate) {\n        this.$enterCounter++;\n        if (this.$enterCounter > 3) {\n            console.warn('this list view cannot be filled full as the itemRenderer function always returns an item with different size.');\n            return;\n        }\n        let pos = this.$scrollPane.scrollingPosX;\n        let max = pos + this.$scrollPane.viewWidth;\n        const end = pos == this.$scrollPane.contentWidth;\n        GList.$lastPosHelper = pos;\n        const newFirstIndex = this.getIndexOnPos2(forceUpdate);\n        if (newFirstIndex == this.$firstIndex && !forceUpdate)\n            return;\n        pos = GList.$lastPosHelper;\n        const oldFirstIndex = this.$firstIndex;\n        this.$firstIndex = newFirstIndex;\n        let curIndex = newFirstIndex;\n        const forward = oldFirstIndex > newFirstIndex;\n        const oldCount = this.numChildren;\n        let lastIndex = oldFirstIndex + oldCount - 1;\n        let reuseIndex = forward ? lastIndex : oldFirstIndex;\n        let curX = pos, curY = 0;\n        let needRender;\n        let deltaSize = 0;\n        let firstItemDeltaSize = 0;\n        let url = this.defaultItem;\n        let ii, ii2;\n        let i, j;\n        const partSize = (this.$scrollPane.viewHeight - this.$lineGap * (this.$curLineItemCount - 1)) /\n            this.$curLineItemCount;\n        this.$itemInfoVer++;\n        while (curIndex < this.$realNumItems && (end || curX < max)) {\n            ii = this.$virtualItems[curIndex];\n            if (ii.obj == null || forceUpdate) {\n                if (this.itemProvider != null) {\n                    url = this.itemProvider(curIndex % this.$numItems);\n                    if (url == null)\n                        url = this.$defaultItem;\n                    url = UIPackage.normalizeURL(url);\n                }\n                if (ii.obj != null && ii.obj.resourceURL != url) {\n                    if (ii.obj instanceof GButton)\n                        ii.selected = ii.obj.selected;\n                    this.removeChildToPool(ii.obj);\n                    ii.obj = null;\n                }\n            }\n            if (ii.obj == null) {\n                if (forward) {\n                    for (j = reuseIndex; j >= oldFirstIndex; j--) {\n                        ii2 = this.$virtualItems[j];\n                        if (ii2.obj != null &&\n                            ii2.updateFlag != this.$itemInfoVer &&\n                            ii2.obj.resourceURL == url) {\n                            if (ii2.obj instanceof GButton)\n                                ii2.selected = ii2.obj.selected;\n                            ii.obj = ii2.obj;\n                            ii2.obj = null;\n                            if (j == reuseIndex)\n                                reuseIndex--;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    for (j = reuseIndex; j <= lastIndex; j++) {\n                        ii2 = this.$virtualItems[j];\n                        if (ii2.obj != null &&\n                            ii2.updateFlag != this.$itemInfoVer &&\n                            ii2.obj.resourceURL == url) {\n                            if (ii2.obj instanceof GButton)\n                                ii2.selected = ii2.obj.selected;\n                            ii.obj = ii2.obj;\n                            ii2.obj = null;\n                            if (j == reuseIndex)\n                                reuseIndex++;\n                            break;\n                        }\n                    }\n                }\n                if (ii.obj != null)\n                    this.setChildIndex(ii.obj, forward ? curIndex - newFirstIndex : this.numChildren);\n                else {\n                    ii.obj = this.$pool.get(url);\n                    if (forward)\n                        this.addChildAt(ii.obj, curIndex - newFirstIndex);\n                    else\n                        this.addChild(ii.obj);\n                }\n                if (ii.obj instanceof GButton)\n                    ii.obj.selected = ii.selected;\n                needRender = true;\n            }\n            else\n                needRender = forceUpdate;\n            if (needRender) {\n                if (this.$autoResizeItem &&\n                    (this.$layout == 1 /* SingleRow */ || this.$lineCount > 0))\n                    ii.obj.setSize(ii.obj.width, partSize, true);\n                this.itemRenderer(curIndex % this.$numItems, ii.obj);\n                if (curIndex % this.$curLineItemCount == 0) {\n                    deltaSize += Math.ceil(ii.obj.width) - ii.width;\n                    if (curIndex == newFirstIndex && oldFirstIndex > newFirstIndex)\n                        firstItemDeltaSize = Math.ceil(ii.obj.width) - ii.width;\n                }\n                ii.width = Math.ceil(ii.obj.width);\n                ii.height = Math.ceil(ii.obj.height);\n            }\n            ii.updateFlag = this.$itemInfoVer;\n            ii.obj.setXY(curX, curY);\n            if (curIndex == newFirstIndex)\n                max += ii.width;\n            curY += ii.height + this.$lineGap;\n            if (curIndex % this.$curLineItemCount == this.$curLineItemCount - 1) {\n                curY = 0;\n                curX += ii.width + this.$columnGap;\n            }\n            curIndex++;\n        }\n        for (i = 0; i < oldCount; i++) {\n            ii = this.$virtualItems[oldFirstIndex + i];\n            if (ii.updateFlag != this.$itemInfoVer && ii.obj != null) {\n                if (ii.obj instanceof GButton)\n                    ii.selected = ii.obj.selected;\n                this.removeChildToPool(ii.obj);\n                ii.obj = null;\n            }\n        }\n        if (deltaSize != 0 || firstItemDeltaSize != 0)\n            this.$scrollPane.changeContentSizeOnScrolling(deltaSize, 0, firstItemDeltaSize, 0);\n        if (curIndex > 0 &&\n            this.numChildren > 0 &&\n            this.$container.x < 0 &&\n            this.getChildAt(0).x > -this.$container.x)\n            this.handleScroll2(false);\n    }\n    handleScroll3(forceUpdate) {\n        let pos = this.$scrollPane.scrollingPosX;\n        GList.$lastPosHelper = pos;\n        const newFirstIndex = this.getIndexOnPos3(forceUpdate);\n        if (newFirstIndex == this.$firstIndex && !forceUpdate)\n            return;\n        pos = GList.$lastPosHelper;\n        const oldFirstIndex = this.$firstIndex;\n        this.$firstIndex = newFirstIndex;\n        //height-sync is not supported in pagnation mode, so just only render 1 page\n        let reuseIndex = oldFirstIndex;\n        const virtualItemCount = this.$virtualItems.length;\n        const pageSize = this.$curLineItemCount * this.$curLineItemCount2;\n        const startCol = newFirstIndex % this.$curLineItemCount;\n        const viewWidth = this.viewWidth;\n        const page = Math.floor(newFirstIndex / pageSize);\n        const startIndex = page * pageSize;\n        const lastIndex = startIndex + pageSize * 2;\n        let needRender;\n        let i;\n        let ii, ii2;\n        let col;\n        let url = this.$defaultItem;\n        const partWidth = (this.$scrollPane.viewWidth - this.$columnGap * (this.$curLineItemCount - 1)) /\n            this.$curLineItemCount;\n        const partHeight = (this.$scrollPane.viewHeight - this.$lineGap * (this.$curLineItemCount2 - 1)) /\n            this.$curLineItemCount2;\n        this.$itemInfoVer++;\n        //add mark for items used this time\n        for (i = startIndex; i < lastIndex; i++) {\n            if (i >= this.$realNumItems)\n                continue;\n            col = i % this.$curLineItemCount;\n            if (i - startIndex < pageSize) {\n                if (col < startCol)\n                    continue;\n            }\n            else {\n                if (col > startCol)\n                    continue;\n            }\n            ii = this.$virtualItems[i];\n            ii.updateFlag = this.$itemInfoVer;\n        }\n        let lastObj = null;\n        let insertIndex = 0;\n        for (i = startIndex; i < lastIndex; i++) {\n            if (i >= this.$realNumItems)\n                continue;\n            ii = this.$virtualItems[i];\n            if (ii.updateFlag != this.$itemInfoVer)\n                continue;\n            if (ii.obj == null) {\n                //find if any free item can be used\n                while (reuseIndex < virtualItemCount) {\n                    ii2 = this.$virtualItems[reuseIndex];\n                    if (ii2.obj != null && ii2.updateFlag != this.$itemInfoVer) {\n                        if (ii2.obj instanceof GButton)\n                            ii2.selected = ii2.obj.selected;\n                        ii.obj = ii2.obj;\n                        ii2.obj = null;\n                        break;\n                    }\n                    reuseIndex++;\n                }\n                if (insertIndex == -1)\n                    insertIndex = this.getChildIndex(lastObj) + 1;\n                if (ii.obj == null) {\n                    if (this.itemProvider != null) {\n                        url = this.itemProvider(i % this.$numItems);\n                        if (url == null)\n                            url = this.$defaultItem;\n                        url = UIPackage.normalizeURL(url);\n                    }\n                    ii.obj = this.$pool.get(url);\n                    this.addChildAt(ii.obj, insertIndex);\n                }\n                else\n                    insertIndex = this.setChildIndexBefore(ii.obj, insertIndex);\n                insertIndex++;\n                if (ii.obj instanceof GButton)\n                    ii.obj.selected = ii.selected;\n                needRender = true;\n            }\n            else {\n                needRender = forceUpdate;\n                insertIndex = -1;\n                lastObj = ii.obj;\n            }\n            if (needRender) {\n                if (this.$autoResizeItem) {\n                    if (this.$curLineItemCount == this.$columnCount &&\n                        this.$curLineItemCount2 == this.$lineCount)\n                        ii.obj.setSize(partWidth, partHeight, true);\n                    else if (this.$curLineItemCount == this.$columnCount)\n                        ii.obj.setSize(partWidth, ii.obj.height, true);\n                    else if (this.$curLineItemCount2 == this.$lineCount)\n                        ii.obj.setSize(ii.obj.width, partHeight, true);\n                }\n                this.itemRenderer(i % this.$numItems, ii.obj);\n                ii.width = Math.ceil(ii.obj.width);\n                ii.height = Math.ceil(ii.obj.height);\n            }\n        }\n        //layout\n        let borderX = (startIndex / pageSize) * viewWidth;\n        let xx = borderX;\n        let yy = 0;\n        let lineHeight = 0;\n        for (i = startIndex; i < lastIndex; i++) {\n            if (i >= this.$realNumItems)\n                continue;\n            ii = this.$virtualItems[i];\n            if (ii.updateFlag == this.$itemInfoVer)\n                ii.obj.setXY(xx, yy);\n            if (ii.height > lineHeight)\n                lineHeight = ii.height;\n            if (i % this.$curLineItemCount == this.$curLineItemCount - 1) {\n                xx = borderX;\n                yy += lineHeight + this.$lineGap;\n                lineHeight = 0;\n                if (i == startIndex + pageSize - 1) {\n                    borderX += viewWidth;\n                    xx = borderX;\n                    yy = 0;\n                }\n            }\n            else\n                xx += ii.width + this.$columnGap;\n        }\n        //release items not used\n        for (i = reuseIndex; i < virtualItemCount; i++) {\n            ii = this.$virtualItems[i];\n            if (ii.updateFlag != this.$itemInfoVer && ii.obj != null) {\n                if (ii.obj instanceof GButton)\n                    ii.selected = ii.obj.selected;\n                this.removeChildToPool(ii.obj);\n                ii.obj = null;\n            }\n        }\n    }\n    handleArchOrder1() {\n        if (this.$childrenRenderOrder == 2 /* Arch */) {\n            const mid = this.$scrollPane.posY + this.viewHeight / 2;\n            let minDist = Number.POSITIVE_INFINITY;\n            let dist = 0;\n            let apexIndex = 0;\n            const cnt = this.numChildren;\n            for (let i = 0; i < cnt; i++) {\n                const obj = this.getChildAt(i);\n                if (!this.foldInvisibleItems || obj.visible) {\n                    dist = Math.abs(mid - obj.y - obj.height / 2);\n                    if (dist < minDist) {\n                        minDist = dist;\n                        apexIndex = i;\n                    }\n                }\n            }\n            this.apexIndex = apexIndex;\n        }\n    }\n    handleArchOrder2() {\n        if (this.childrenRenderOrder == 2 /* Arch */) {\n            const mid = this.$scrollPane.posX + this.viewWidth / 2;\n            let minDist = Number.POSITIVE_INFINITY;\n            let dist = 0;\n            let apexIndex = 0;\n            const cnt = this.numChildren;\n            for (let i = 0; i < cnt; i++) {\n                const obj = this.getChildAt(i);\n                if (!this.foldInvisibleItems || obj.visible) {\n                    dist = Math.abs(mid - obj.x - obj.width / 2);\n                    if (dist < minDist) {\n                        minDist = dist;\n                        apexIndex = i;\n                    }\n                }\n            }\n            this.apexIndex = apexIndex;\n        }\n    }\n    handleAlign(contentWidth, contentHeight) {\n        let newOffsetX = 0;\n        let newOffsetY = 0;\n        if (contentHeight < this.viewHeight) {\n            if (this.$verticalAlign == 1 /* Middle */)\n                newOffsetY = Math.floor((this.viewHeight - contentHeight) / 2);\n            else if (this.$verticalAlign == 2 /* Bottom */)\n                newOffsetY = this.viewHeight - contentHeight;\n        }\n        if (contentWidth < this.viewWidth) {\n            if (this.$align == \"center\" /* Center */)\n                newOffsetX = Math.floor((this.viewWidth - contentWidth) / 2);\n            else if (this.$align == \"right\" /* Right */)\n                newOffsetX = this.viewWidth - contentWidth;\n        }\n        if (newOffsetX != this.$alignOffset.x || newOffsetY != this.$alignOffset.y) {\n            this.$alignOffset.setValues(newOffsetX, newOffsetY);\n            if (this.$scrollPane != null)\n                this.$scrollPane.adjustMaskContainer();\n            else {\n                this.$container.x = this.$margin.left + this.$alignOffset.x;\n                this.$container.y = this.$margin.top + this.$alignOffset.y;\n            }\n        }\n    }\n    /**@override */\n    updateBounds() {\n        if (this.$virtual)\n            return;\n        let i;\n        let child;\n        let curX = 0;\n        let curY = 0;\n        let maxWidth = 0;\n        let maxHeight = 0;\n        let cw = 0, ch = 0;\n        let j = 0;\n        let page = 0;\n        let k = 0;\n        const cnt = this.$children.length;\n        const viewWidth = this.viewWidth;\n        const viewHeight = this.viewHeight;\n        let lineSize = 0;\n        let lineStart = 0;\n        let ratio;\n        if (this.$layout == 0 /* SingleColumn */) {\n            for (i = 0; i < cnt; i++) {\n                child = this.getChildAt(i);\n                if (this.foldInvisibleItems && !child.visible)\n                    continue;\n                if (curY != 0)\n                    curY += this.$lineGap;\n                child.y = curY;\n                if (this.$autoResizeItem)\n                    child.setSize(viewWidth, child.height, true);\n                curY += Math.ceil(child.height);\n                if (child.width > maxWidth)\n                    maxWidth = child.width;\n            }\n            cw = Math.ceil(maxWidth);\n            ch = curY;\n        }\n        else if (this.$layout == 1 /* SingleRow */) {\n            for (i = 0; i < cnt; i++) {\n                child = this.getChildAt(i);\n                if (this.foldInvisibleItems && !child.visible)\n                    continue;\n                if (curX != 0)\n                    curX += this.$columnGap;\n                child.x = curX;\n                if (this.$autoResizeItem)\n                    child.setSize(child.width, viewHeight, true);\n                curX += Math.ceil(child.width);\n                if (child.height > maxHeight)\n                    maxHeight = child.height;\n            }\n            cw = curX;\n            ch = Math.ceil(maxHeight);\n        }\n        else if (this.$layout == 2 /* FlowHorizontal */) {\n            if (this.$autoResizeItem && this.$columnCount > 0) {\n                for (i = 0; i < cnt; i++) {\n                    child = this.getChildAt(i);\n                    if (this.foldInvisibleItems && !child.visible)\n                        continue;\n                    lineSize += child.sourceWidth;\n                    j++;\n                    if (j == this.$columnCount || i == cnt - 1) {\n                        ratio = (viewWidth - lineSize - (j - 1) * this.$columnGap) / lineSize;\n                        curX = 0;\n                        for (j = lineStart; j <= i; j++) {\n                            child = this.getChildAt(j);\n                            if (this.foldInvisibleItems && !child.visible)\n                                continue;\n                            child.setXY(curX, curY);\n                            if (j < i) {\n                                child.setSize(child.sourceWidth + Math.round(child.sourceWidth * ratio), child.height, true);\n                                curX += Math.ceil(child.width) + this.$columnGap;\n                            }\n                            else\n                                child.setSize(viewWidth - curX, child.height, true);\n                            if (child.height > maxHeight)\n                                maxHeight = child.height;\n                        }\n                        //new line\n                        curY += Math.ceil(maxHeight) + this.$lineGap;\n                        maxHeight = 0;\n                        j = 0;\n                        lineStart = i + 1;\n                        lineSize = 0;\n                    }\n                }\n                ch = curY + Math.ceil(maxHeight);\n                cw = viewWidth;\n            }\n            else {\n                for (i = 0; i < cnt; i++) {\n                    child = this.getChildAt(i);\n                    if (this.foldInvisibleItems && !child.visible)\n                        continue;\n                    if (curX != 0)\n                        curX += this.$columnGap;\n                    if ((this.$columnCount != 0 && j >= this.$columnCount) ||\n                        (this.$columnCount == 0 && curX + child.width > viewWidth && maxHeight != 0)) {\n                        //new line\n                        curX = 0;\n                        curY += Math.ceil(maxHeight) + this.$lineGap;\n                        maxHeight = 0;\n                        j = 0;\n                    }\n                    child.setXY(curX, curY);\n                    curX += Math.ceil(child.width);\n                    if (curX > maxWidth)\n                        maxWidth = curX;\n                    if (child.height > maxHeight)\n                        maxHeight = child.height;\n                    j++;\n                }\n                ch = curY + Math.ceil(maxHeight);\n                cw = Math.ceil(maxWidth);\n            }\n        }\n        else if (this.$layout == 3 /* FlowVertical */) {\n            if (this.$autoResizeItem && this.$lineCount > 0) {\n                for (i = 0; i < cnt; i++) {\n                    child = this.getChildAt(i);\n                    if (this.foldInvisibleItems && !child.visible)\n                        continue;\n                    lineSize += child.sourceHeight;\n                    j++;\n                    if (j == this.$lineCount || i == cnt - 1) {\n                        ratio = (viewHeight - lineSize - (j - 1) * this.$lineGap) / lineSize;\n                        curY = 0;\n                        for (j = lineStart; j <= i; j++) {\n                            child = this.getChildAt(j);\n                            if (this.foldInvisibleItems && !child.visible)\n                                continue;\n                            child.setXY(curX, curY);\n                            if (j < i) {\n                                child.setSize(child.width, child.sourceHeight + Math.round(child.sourceHeight * ratio), true);\n                                curY += Math.ceil(child.height) + this.$lineGap;\n                            }\n                            else\n                                child.setSize(child.width, viewHeight - curY, true);\n                            if (child.width > maxWidth)\n                                maxWidth = child.width;\n                        }\n                        //new line\n                        curX += Math.ceil(maxWidth) + this.$columnGap;\n                        maxWidth = 0;\n                        j = 0;\n                        lineStart = i + 1;\n                        lineSize = 0;\n                    }\n                }\n                cw = curX + Math.ceil(maxWidth);\n                ch = viewHeight;\n            }\n            else {\n                for (i = 0; i < cnt; i++) {\n                    child = this.getChildAt(i);\n                    if (this.foldInvisibleItems && !child.visible)\n                        continue;\n                    if (curY != 0)\n                        curY += this.$lineGap;\n                    if ((this.$lineCount != 0 && j >= this.$lineCount) ||\n                        (this.$lineCount == 0 && curY + child.height > viewHeight && maxWidth != 0)) {\n                        curY = 0;\n                        curX += Math.ceil(maxWidth) + this.$columnGap;\n                        maxWidth = 0;\n                        j = 0;\n                    }\n                    child.setXY(curX, curY);\n                    curY += Math.ceil(child.height);\n                    if (curY > maxHeight)\n                        maxHeight = curY;\n                    if (child.width > maxWidth)\n                        maxWidth = child.width;\n                    j++;\n                }\n                cw = curX + Math.ceil(maxWidth);\n                ch = Math.ceil(maxHeight);\n            }\n        } //pagination\n        else {\n            let eachHeight;\n            if (this.$autoResizeItem && this.$lineCount > 0)\n                eachHeight = Math.floor((viewHeight - (this.$lineCount - 1) * this.$lineGap) / this.$lineCount);\n            if (this.$autoResizeItem && this.$columnCount > 0) {\n                for (i = 0; i < cnt; i++) {\n                    child = this.getChildAt(i);\n                    if (this.foldInvisibleItems && !child.visible)\n                        continue;\n                    lineSize += child.sourceWidth;\n                    j++;\n                    if (j == this.$columnCount || i == cnt - 1) {\n                        ratio = (viewWidth - lineSize - (j - 1) * this.$columnGap) / lineSize;\n                        curX = 0;\n                        for (j = lineStart; j <= i; j++) {\n                            child = this.getChildAt(j);\n                            if (this.foldInvisibleItems && !child.visible)\n                                continue;\n                            child.setXY(page * viewWidth + curX, curY);\n                            if (j < i) {\n                                child.setSize(child.sourceWidth + Math.round(child.sourceWidth * ratio), this.$lineCount > 0 ? eachHeight : child.height, true);\n                                curX += Math.ceil(child.width) + this.$columnGap;\n                            }\n                            else\n                                child.setSize(viewWidth - curX, this.$lineCount > 0 ? eachHeight : child.height, true);\n                            if (child.height > maxHeight)\n                                maxHeight = child.height;\n                        }\n                        //new line\n                        curY += Math.ceil(maxHeight) + this.$lineGap;\n                        maxHeight = 0;\n                        j = 0;\n                        lineStart = i + 1;\n                        lineSize = 0;\n                        k++;\n                        if ((this.$lineCount != 0 && k >= this.$lineCount) ||\n                            (this.$lineCount == 0 && curY + child.height > viewHeight)) {\n                            //new page\n                            page++;\n                            curY = 0;\n                            k = 0;\n                        }\n                    }\n                }\n            }\n            else {\n                for (i = 0; i < cnt; i++) {\n                    child = this.getChildAt(i);\n                    if (this.foldInvisibleItems && !child.visible)\n                        continue;\n                    if (curX != 0)\n                        curX += this.$columnGap;\n                    if (this.$autoResizeItem && this.$lineCount > 0)\n                        child.setSize(child.width, eachHeight, true);\n                    if ((this.$columnCount != 0 && j >= this.$columnCount) ||\n                        (this.$columnCount == 0 && curX + child.width > viewWidth && maxHeight != 0)) {\n                        //new line\n                        curX = 0;\n                        curY += Math.ceil(maxHeight) + this.$lineGap;\n                        maxHeight = 0;\n                        j = 0;\n                        k++;\n                        if ((this.$lineCount != 0 && k >= this.$lineCount) ||\n                            (this.$lineCount == 0 && curY + child.height > viewHeight && maxWidth != 0)) {\n                            //new page\n                            page++;\n                            curY = 0;\n                            k = 0;\n                        }\n                    }\n                    child.setXY(page * viewWidth + curX, curY);\n                    curX += Math.ceil(child.width);\n                    if (curX > maxWidth)\n                        maxWidth = curX;\n                    if (child.height > maxHeight)\n                        maxHeight = child.height;\n                    j++;\n                }\n            }\n            ch = page > 0 ? viewHeight : curY + Math.ceil(maxHeight);\n            cw = (page + 1) * viewWidth;\n        }\n        this.handleAlign(cw, ch);\n        this.setBounds(0, 0, cw, ch);\n    }\n    setupBeforeAdd(xml) {\n        super.setupBeforeAdd(xml);\n        let str;\n        let arr;\n        str = xml.attributes.layout;\n        if (str)\n            this.$layout = ParseListLayoutType(str);\n        let overflow;\n        str = xml.attributes.overflow;\n        if (str)\n            overflow = ParseOverflowType(str);\n        else\n            overflow = 0 /* Visible */;\n        str = xml.attributes.margin;\n        if (str)\n            this.$margin.parse(str);\n        str = xml.attributes.align;\n        if (str)\n            this.$align = ParseAlignType(str);\n        str = xml.attributes.vAlign;\n        if (str)\n            this.$verticalAlign = ParseVertAlignType(str);\n        if (overflow == 2 /* Scroll */) {\n            let scroll;\n            str = xml.attributes.scroll;\n            if (str)\n                scroll = ParseScrollType(str);\n            else\n                scroll = 1 /* Vertical */;\n            let scrollBarDisplay;\n            str = xml.attributes.scrollBar;\n            if (str)\n                scrollBarDisplay = ParseScrollBarDisplayType(str);\n            else\n                scrollBarDisplay = 0 /* Default */;\n            let scrollBarFlags;\n            str = xml.attributes.scrollBarFlags;\n            if (str)\n                scrollBarFlags = parseInt(str);\n            else\n                scrollBarFlags = 0;\n            let scrollBarMargin = new Margin();\n            str = xml.attributes.scrollBarMargin;\n            if (str)\n                scrollBarMargin.parse(str);\n            let vtScrollBarRes;\n            let hzScrollBarRes;\n            str = xml.attributes.scrollBarRes;\n            if (str) {\n                arr = str.split(',');\n                vtScrollBarRes = arr[0];\n                hzScrollBarRes = arr[1];\n            }\n            let headerRes;\n            let footerRes;\n            str = xml.attributes.ptrRes;\n            if (str) {\n                arr = str.split(',');\n                headerRes = arr[0];\n                footerRes = arr[1];\n            }\n            this.setupScroll(scrollBarMargin, scroll, scrollBarDisplay, scrollBarFlags, vtScrollBarRes, hzScrollBarRes, headerRes, footerRes);\n        }\n        else\n            this.setupOverflow(overflow);\n        str = xml.attributes.lineGap;\n        if (str)\n            this.$lineGap = parseInt(str);\n        str = xml.attributes.colGap;\n        if (str)\n            this.$columnGap = parseInt(str);\n        str = xml.attributes.lineItemCount;\n        if (str) {\n            if (this.$layout == 2 /* FlowHorizontal */ ||\n                this.$layout == 4 /* Pagination */)\n                this.$columnCount = parseInt(str);\n            else if (this.$layout == 3 /* FlowVertical */)\n                this.$lineCount = parseInt(str);\n        }\n        str = xml.attributes.lineItemCount2;\n        if (str)\n            this.$lineCount = parseInt(str);\n        str = xml.attributes.selectionMode;\n        if (str)\n            this.$selectionMode = ParseListSelectionMode(str);\n        str = xml.attributes.defaultItem;\n        if (str)\n            this.$defaultItem = str;\n        str = xml.attributes.autoItemSize;\n        if (this.$layout == 1 /* SingleRow */ || this.$layout == 0 /* SingleColumn */)\n            this.$autoResizeItem = str != 'false';\n        else\n            this.$autoResizeItem = str == 'true';\n        str = xml.attributes.renderOrder;\n        if (str) {\n            this.$childrenRenderOrder = ParseListChildrenRenderOrder(str);\n            if (this.$childrenRenderOrder == 2 /* Arch */) {\n                str = xml.attributes.apex;\n                if (str)\n                    this.$apexIndex = parseInt(str);\n            }\n        }\n        let col = xml.children;\n        col.forEach(cxml => {\n            if (cxml.nodeName != 'item')\n                return;\n            let url = cxml.attributes.url;\n            if (!url)\n                url = this.$defaultItem;\n            if (!url)\n                return;\n            let obj = this.getFromPool(url);\n            if (obj != null) {\n                this.addChild(obj);\n                str = cxml.attributes.title;\n                if (str)\n                    obj.text = str;\n                str = cxml.attributes.icon;\n                if (str)\n                    obj.icon = str;\n                str = cxml.attributes.name;\n                if (str)\n                    obj.name = str;\n                str = cxml.attributes.selectedIcon;\n                if (str && obj instanceof GButton)\n                    obj.selectedIcon = str;\n            }\n        }, this);\n    }\n    setupAfterAdd(xml) {\n        super.setupAfterAdd(xml);\n        let str;\n        str = xml.attributes.selectionController;\n        if (str)\n            this.$selectionController = this.parent.getController(str);\n    }\n}\nGList.$lastPosHelper = 0;\n\nclass PopupMenu {\n    constructor(resourceURL = null) {\n        if (!resourceURL) {\n            resourceURL = UIConfig.popupMenu;\n            if (!resourceURL)\n                throw new Error('UIConfig.popupMenu not defined');\n        }\n        this.$contentPane = UIPackage.createObjectFromURL(resourceURL);\n        this.$contentPane.on('added', this.$addedToStage, this);\n        this.$list = this.$contentPane.getChild('list');\n        this.$list.removeChildrenToPool();\n        this.$list.addRelation(this.$contentPane, 14 /* Width */);\n        this.$list.removeRelation(this.$contentPane, 15 /* Height */);\n        this.$contentPane.addRelation(this.$list, 15 /* Height */);\n        this.$list.on(\"__itemClick\" /* ItemClick */, this.$clickItem, this);\n    }\n    dispose() {\n        GTimer.inst.remove(this.$delayClickItem, this);\n        this.$list.off(\"__itemClick\" /* ItemClick */, this.$clickItem);\n        this.$contentPane.off('added', this.$addedToStage);\n        this.$contentPane.dispose();\n    }\n    addItem(caption, handler) {\n        let item = this.$list.addItemFromPool();\n        item.title = caption;\n        item.data = handler;\n        item.grayed = false;\n        let c = item.getController('checked');\n        if (c != null)\n            c.selectedIndex = 0;\n        return item;\n    }\n    addItemAt(caption, index, handler) {\n        let item = this.$list.getFromPool();\n        this.$list.addChildAt(item, index);\n        item.title = caption;\n        item.data = handler;\n        item.grayed = false;\n        let c = item.getController('checked');\n        if (c != null)\n            c.selectedIndex = 0;\n        return item;\n    }\n    addSeperator() {\n        if (UIConfig.popupMenuSeperator == null)\n            throw new Error('UIConfig.popupMenuSeperator not defined');\n        this.$list.addItemFromPool(UIConfig.popupMenuSeperator);\n    }\n    getItemName(index) {\n        let item = this.$list.getChildAt(index);\n        return item.name;\n    }\n    setItemText(name, caption) {\n        let item = this.$list.getChild(name);\n        item.title = caption;\n    }\n    setItemVisible(name, visible) {\n        let item = this.$list.getChild(name);\n        if (item.visible != visible) {\n            item.visible = visible;\n            this.$list.setBoundsChangedFlag();\n        }\n    }\n    setItemGrayed(name, grayed) {\n        let item = this.$list.getChild(name);\n        item.grayed = grayed;\n    }\n    setItemCheckable(name, checkable) {\n        let item = this.$list.getChild(name);\n        let c = item.getController('checked');\n        if (c != null) {\n            if (checkable) {\n                if (c.selectedIndex == 0)\n                    c.selectedIndex = 1;\n            }\n            else\n                c.selectedIndex = 0;\n        }\n    }\n    setItemChecked(name, checked) {\n        let item = this.$list.getChild(name);\n        let c = item.getController('checked');\n        if (c != null)\n            c.selectedIndex = checked ? 2 : 1;\n    }\n    isItemChecked(name) {\n        let item = this.$list.getChild(name);\n        let c = item.getController('checked');\n        if (c != null)\n            return c.selectedIndex == 2;\n        else\n            return false;\n    }\n    removeItem(name) {\n        let item = this.$list.getChild(name);\n        if (item != null) {\n            let index = this.$list.getChildIndex(item);\n            this.$list.removeChildToPoolAt(index);\n            return true;\n        }\n        else\n            return false;\n    }\n    clearItems() {\n        this.$list.removeChildrenToPool();\n    }\n    get itemCount() {\n        return this.$list.numChildren;\n    }\n    get contentPane() {\n        return this.$contentPane;\n    }\n    get list() {\n        return this.$list;\n    }\n    show(target = null, dir) {\n        let r = target != null ? GRoot.findFor(target) : GRoot.inst;\n        r.showPopup(this.contentPane, target instanceof GRoot ? null : target, dir);\n    }\n    $clickItem(evt) {\n        let item = evt.data.item;\n        GTimer.inst.add(100, 1, this.$delayClickItem, this, item);\n    }\n    $delayClickItem(itemObject) {\n        if (!(itemObject instanceof GButton))\n            return;\n        if (itemObject.grayed) {\n            this.$list.selectedIndex = -1;\n            return;\n        }\n        let c = itemObject.getController('checked');\n        if (c != null && c.selectedIndex != 0) {\n            if (c.selectedIndex == 1)\n                c.selectedIndex = 2;\n            else\n                c.selectedIndex = 1;\n        }\n        let r = this.$contentPane.parent;\n        if (r)\n            r.hidePopup(this.contentPane);\n        if (itemObject.data != null)\n            itemObject.data.call(null);\n        GTimer.inst.remove(this.$delayClickItem, this);\n    }\n    $addedToStage() {\n        this.$list.selectedIndex = -1;\n        this.$list.resizeToFit(100000, 10);\n    }\n}\n\nclass UIObjectFactory {\n    static setPackageItemExtension(url, type) {\n        UIObjectFactory.packageItemExtensions[url.substring(5)] = type;\n    }\n    // public static setLoaderExtension(type: { new(): GLoader }): void {\n    //     UIObjectFactory.loaderExtension = type;\n    // }\n    static newObject(pi) {\n        switch (pi.type) {\n            case 0 /* Image */:\n                return new GImage();\n            case 2 /* MovieClip */:\n                return new GMovieClip();\n            case 4 /* Component */:\n                let cls = UIObjectFactory.packageItemExtensions[pi.owner.id + pi.id];\n                if (cls)\n                    return new cls();\n                let xml = pi.owner.getItemAsset(pi);\n                let extention = xml.attributes.extention;\n                if (extention != null) {\n                    switch (extention) {\n                        case 'Button':\n                            return new GButton();\n                        case 'ProgressBar':\n                            return new GProgressBar();\n                        case 'Label':\n                            return new GLabel();\n                        case 'Slider':\n                            return new GSlider();\n                        case 'ScrollBar':\n                            return new GScrollBar();\n                        case 'ComboBox':\n                            return new GComboBox();\n                        default:\n                            return new GComponent();\n                    }\n                }\n                else\n                    return new GComponent();\n        }\n        return null;\n    }\n    static newObjectDirectly(type) {\n        switch (type) {\n            case 'image':\n                return new GImage();\n            case 'movieclip':\n                return new GMovieClip();\n            case 'component':\n                return new GComponent();\n            case 'text':\n                return new GTextField();\n            case 'list':\n                return new GList();\n            case 'richtext':\n                return new GRichTextField();\n            case 'inputtext':\n                return new GTextInput();\n            case 'group':\n                return new GGroup();\n            case 'graph':\n                return new GGraph();\n            case 'loader':\n                if (UIObjectFactory.loaderExtension != null)\n                    return new UIObjectFactory.loaderExtension();\n                else\n                    return new GLoader();\n        }\n        return null;\n    }\n}\nUIObjectFactory.packageItemExtensions = {};\nDecls.UIObjectFactory = UIObjectFactory;\n\nclass DragIndicator {\n    constructor() {\n        this.$agent = new GLoader();\n        this.$agent.draggable = true;\n        this.$agent.touchable = false;\n        this.$agent.setSize(100, 100);\n        this.$agent.setPivot(0.5, 0.5, true);\n        this.$agent.align = \"center\" /* Center */;\n        this.$agent.verticalAlign = 1 /* Middle */;\n        this.$agent.sortingOrder = 1000000; //top most\n        this.$agent.on(\"__dragEnd\" /* END */, this.$dragEnd, this);\n    }\n    get dragAgent() {\n        return this.$agent;\n    }\n    get isDragging() {\n        return this.$agent.parent != null;\n    }\n    get sourceObject() {\n        return this.$sourceObject;\n    }\n    startDrag(source, icon, sourceData, touchPointID = -1) {\n        if (this.isDragging)\n            return;\n        this.$sourceObject = source;\n        this.$sourceData = sourceData;\n        this.$agent.url = icon;\n        GRoot.inst.addChild(this.$agent);\n        const pt = GRoot.inst.globalToLocal(GRoot.globalMouseStatus.mouseX, GRoot.globalMouseStatus.mouseY);\n        this.$agent.setXY(pt.x, pt.y);\n        this.$agent.startDrag(touchPointID);\n    }\n    cancel() {\n        if (this.$agent.parent != null) {\n            this.$agent.stopDrag();\n            GRoot.inst.removeChild(this.$agent);\n            this.$sourceData = null;\n        }\n    }\n    $dragEnd(evt) {\n        if (!this.isDragging)\n            return;\n        GRoot.inst.removeChild(this.$agent);\n        let sourceData = this.$sourceData;\n        this.$sourceData = null;\n        let obj = GRoot.inst.getObjectUnderPoint(evt.target.x, evt.target.y);\n        while (obj != null) {\n            if (obj.hasListener(\"__dragDrop\" /* DROP */)) {\n                obj.requestFocus();\n                let currentTarget = obj.displayObject;\n                let event = new createjs.Event(\"__dragDrop\" /* DROP */, true, false);\n                event.data = { currentTarget, sourceData };\n                obj.dispatchEvent(event, this);\n                return;\n            }\n            obj = obj.parent;\n        }\n    }\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/stats.js/build/stats.min.js\nvar stats_min = __webpack_require__(466);\n;// CONCATENATED MODULE: ./src/main.ts\n\r\n\r\n// import { WindowA } from './WindowA';\r\n// import { WindowB } from './WindowB';\r\n// import { WindowWait } from './WindowWait';\r\nclass Main {\r\n    constructor(canvas, manifest) {\r\n        this.manifest = [];\r\n        this.canvas = canvas;\r\n        this.manifest = manifest;\r\n        this.stage = new createjs.Stage(canvas);\r\n        this.init();\r\n    }\r\n    init() {\r\n        this.initStats();\r\n        this.createStage();\r\n        this.createLoader();\r\n    }\r\n    createStage() {\r\n        GRoot.inst.attachTo(this.stage, {\r\n            designWidth: 800,\r\n            designHeight: 600,\r\n            scaleMode: \"fixedWidth\" /* FIXED_WIDTH */,\r\n            orientation: \"landscape\" /* LANDSCAPE */,\r\n            alignV: 3 /* TOP */,\r\n            alignH: 0 /* LEFT */\r\n        });\r\n        createjs.Ticker.framerate = 60;\r\n        createjs.Ticker.timingMode = createjs.Ticker.RAF_SYNCHED;\r\n        createjs.Ticker.on('tick', this.tick, this);\r\n    }\r\n    tick(e) {\r\n        if (e.paused !== 1) {\r\n            this.stage.update();\r\n        }\r\n        else {\r\n            console.log('pause!');\r\n        }\r\n    }\r\n    createLoader() {\r\n        this.loader = new AssetLoader(false, \"\", \"Anonymous\");\r\n        createjs.Sound.alternateExtensions = [\"mp3\"];\r\n        this.loader.installPlugin(createjs.Sound);\r\n        this.loader.loadManifest(this.manifest);\r\n        // this.loader.on(\"progress\", this.loadProgress, this);\r\n        this.loader.on(\"complete\", this.resLoaded, this);\r\n    }\r\n    initStats() {\r\n        this.stats = new stats_min();\r\n        this.stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom\r\n        document.body.appendChild(this.stats.dom);\r\n    }\r\n    loadProgress(e) {\r\n        let p = e.progress * 100;\r\n        this.loadingView.setProgress(p);\r\n        if (p >= 100) {\r\n            this.loader.off(\"progress\", this.loadProgress);\r\n            this.loadingView.dispose();\r\n            this.loadingView = null;\r\n            this.contentlayer.dispose();\r\n            GRoot.inst.removeChild(this.contentlayer);\r\n        }\r\n    }\r\n    resLoaded() {\r\n        this.loader.destroy();\r\n        UIPackage.addPackage(\"uitest\");\r\n        let ins = UIPackage.createObject(\"uitest\", \"main\");\r\n        // console.log(fgui.UIPackage.addPackage(\"uitest\"));\r\n        ins.setSize(GRoot.inst.width, GRoot.inst.height);\r\n        ins.addRelation(GRoot.inst, 24 /* Size */);\r\n        GRoot.inst.addChild(ins);\r\n        this.animate();\r\n    }\r\n    animate() {\r\n        this.stats.begin();\r\n        this.stats.end();\r\n        requestAnimationFrame(this.animate.bind(this));\r\n    }\r\n}\r\nlet main_canvas = document.querySelector('#mainView');\r\nlet manifest = [\r\n    { id: \"uitest\", src: 'public/ui/uitest.fui', type: \"binary\" },\r\n    { id: 'uitest@atlas0', src: 'public/ui/uitest@atlas0.jpg', type: \"image\" },\r\n    // { id: 'test@atlas0_1', src: 'ui/test@atlas0_1.png', type: \"image\" }\r\n];\r\nnew Main(main_canvas, manifest);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDam1pQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBUUE7QUFMQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21haW4vLi9ub2RlX21vZHVsZXMvaXNtb2JpbGVqcy9lc20vaXNNb2JpbGUuanM/OWNiZSIsIndlYnBhY2s6Ly9tYWluLy4vbm9kZV9tb2R1bGVzL2ZhaXJ5Z3VpLWNyZWF0ZWpzL2Rpc3QvZmFpcnlndWkubW9kdWxlLmpzPzlhZDQiLCJ3ZWJwYWNrOi8vbWFpbi8uL3NyYy9tYWluLnRzP2NkNDkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwcGxlSXBob25lID0gL2lQaG9uZS9pO1xudmFyIGFwcGxlSXBvZCA9IC9pUG9kL2k7XG52YXIgYXBwbGVUYWJsZXQgPSAvaVBhZC9pO1xudmFyIGFwcGxlVW5pdmVyc2FsID0gL1xcYmlPUy11bml2ZXJzYWwoPzouKylNYWNcXGIvaTtcbnZhciBhbmRyb2lkUGhvbmUgPSAvXFxiQW5kcm9pZCg/Oi4rKU1vYmlsZVxcYi9pO1xudmFyIGFuZHJvaWRUYWJsZXQgPSAvQW5kcm9pZC9pO1xudmFyIGFtYXpvblBob25lID0gLyg/OlNENDkzMFVSfFxcYlNpbGsoPzouKylNb2JpbGVcXGIpL2k7XG52YXIgYW1hem9uVGFibGV0ID0gL1NpbGsvaTtcbnZhciB3aW5kb3dzUGhvbmUgPSAvV2luZG93cyBQaG9uZS9pO1xudmFyIHdpbmRvd3NUYWJsZXQgPSAvXFxiV2luZG93cyg/Oi4rKUFSTVxcYi9pO1xudmFyIG90aGVyQmxhY2tCZXJyeSA9IC9CbGFja0JlcnJ5L2k7XG52YXIgb3RoZXJCbGFja0JlcnJ5MTAgPSAvQkIxMC9pO1xudmFyIG90aGVyT3BlcmEgPSAvT3BlcmEgTWluaS9pO1xudmFyIG90aGVyQ2hyb21lID0gL1xcYihDcmlPU3xDaHJvbWUpKD86LispTW9iaWxlL2k7XG52YXIgb3RoZXJGaXJlZm94ID0gL01vYmlsZSg/Oi4rKUZpcmVmb3hcXGIvaTtcbnZhciBpc0FwcGxlVGFibGV0T25Jb3MxMyA9IGZ1bmN0aW9uIChuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gJ01hY0ludGVsJyAmJlxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxICYmXG4gICAgICAgIHR5cGVvZiBNU1N0cmVhbSA9PT0gJ3VuZGVmaW5lZCcpO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoKHVzZXJBZ2VudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVnZXgpIHsgcmV0dXJuIHJlZ2V4LnRlc3QodXNlckFnZW50KTsgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTW9iaWxlKHBhcmFtKSB7XG4gICAgdmFyIG5hdiA9IHtcbiAgICAgICAgdXNlckFnZW50OiAnJyxcbiAgICAgICAgcGxhdGZvcm06ICcnLFxuICAgICAgICBtYXhUb3VjaFBvaW50czogMFxuICAgIH07XG4gICAgaWYgKCFwYXJhbSAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBuYXYgPSB7XG4gICAgICAgICAgICB1c2VyQWdlbnQ6IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgICAgICBwbGF0Zm9ybTogbmF2aWdhdG9yLnBsYXRmb3JtLFxuICAgICAgICAgICAgbWF4VG91Y2hQb2ludHM6IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmF2LnVzZXJBZ2VudCA9IHBhcmFtO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJhbSAmJiBwYXJhbS51c2VyQWdlbnQpIHtcbiAgICAgICAgbmF2ID0ge1xuICAgICAgICAgICAgdXNlckFnZW50OiBwYXJhbS51c2VyQWdlbnQsXG4gICAgICAgICAgICBwbGF0Zm9ybTogcGFyYW0ucGxhdGZvcm0sXG4gICAgICAgICAgICBtYXhUb3VjaFBvaW50czogcGFyYW0ubWF4VG91Y2hQb2ludHMgfHwgMFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgdXNlckFnZW50ID0gbmF2LnVzZXJBZ2VudDtcbiAgICB2YXIgdG1wID0gdXNlckFnZW50LnNwbGl0KCdbRkJBTicpO1xuICAgIGlmICh0eXBlb2YgdG1wWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB1c2VyQWdlbnQgPSB0bXBbMF07XG4gICAgfVxuICAgIHRtcCA9IHVzZXJBZ2VudC5zcGxpdCgnVHdpdHRlcicpO1xuICAgIGlmICh0eXBlb2YgdG1wWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB1c2VyQWdlbnQgPSB0bXBbMF07XG4gICAgfVxuICAgIHZhciBtYXRjaCA9IGNyZWF0ZU1hdGNoKHVzZXJBZ2VudCk7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgYXBwbGU6IHtcbiAgICAgICAgICAgIHBob25lOiBtYXRjaChhcHBsZUlwaG9uZSkgJiYgIW1hdGNoKHdpbmRvd3NQaG9uZSksXG4gICAgICAgICAgICBpcG9kOiBtYXRjaChhcHBsZUlwb2QpLFxuICAgICAgICAgICAgdGFibGV0OiAhbWF0Y2goYXBwbGVJcGhvbmUpICYmXG4gICAgICAgICAgICAgICAgKG1hdGNoKGFwcGxlVGFibGV0KSB8fCBpc0FwcGxlVGFibGV0T25Jb3MxMyhuYXYpKSAmJlxuICAgICAgICAgICAgICAgICFtYXRjaCh3aW5kb3dzUGhvbmUpLFxuICAgICAgICAgICAgdW5pdmVyc2FsOiBtYXRjaChhcHBsZVVuaXZlcnNhbCksXG4gICAgICAgICAgICBkZXZpY2U6IChtYXRjaChhcHBsZUlwaG9uZSkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChhcHBsZUlwb2QpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2goYXBwbGVUYWJsZXQpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2goYXBwbGVVbml2ZXJzYWwpIHx8XG4gICAgICAgICAgICAgICAgaXNBcHBsZVRhYmxldE9uSW9zMTMobmF2KSkgJiZcbiAgICAgICAgICAgICAgICAhbWF0Y2god2luZG93c1Bob25lKVxuICAgICAgICB9LFxuICAgICAgICBhbWF6b246IHtcbiAgICAgICAgICAgIHBob25lOiBtYXRjaChhbWF6b25QaG9uZSksXG4gICAgICAgICAgICB0YWJsZXQ6ICFtYXRjaChhbWF6b25QaG9uZSkgJiYgbWF0Y2goYW1hem9uVGFibGV0KSxcbiAgICAgICAgICAgIGRldmljZTogbWF0Y2goYW1hem9uUGhvbmUpIHx8IG1hdGNoKGFtYXpvblRhYmxldClcbiAgICAgICAgfSxcbiAgICAgICAgYW5kcm9pZDoge1xuICAgICAgICAgICAgcGhvbmU6ICghbWF0Y2god2luZG93c1Bob25lKSAmJiBtYXRjaChhbWF6b25QaG9uZSkpIHx8XG4gICAgICAgICAgICAgICAgKCFtYXRjaCh3aW5kb3dzUGhvbmUpICYmIG1hdGNoKGFuZHJvaWRQaG9uZSkpLFxuICAgICAgICAgICAgdGFibGV0OiAhbWF0Y2god2luZG93c1Bob25lKSAmJlxuICAgICAgICAgICAgICAgICFtYXRjaChhbWF6b25QaG9uZSkgJiZcbiAgICAgICAgICAgICAgICAhbWF0Y2goYW5kcm9pZFBob25lKSAmJlxuICAgICAgICAgICAgICAgIChtYXRjaChhbWF6b25UYWJsZXQpIHx8IG1hdGNoKGFuZHJvaWRUYWJsZXQpKSxcbiAgICAgICAgICAgIGRldmljZTogKCFtYXRjaCh3aW5kb3dzUGhvbmUpICYmXG4gICAgICAgICAgICAgICAgKG1hdGNoKGFtYXpvblBob25lKSB8fFxuICAgICAgICAgICAgICAgICAgICBtYXRjaChhbWF6b25UYWJsZXQpIHx8XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoKGFuZHJvaWRQaG9uZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2goYW5kcm9pZFRhYmxldCkpKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKC9cXGJva2h0dHBcXGIvaSlcbiAgICAgICAgfSxcbiAgICAgICAgd2luZG93czoge1xuICAgICAgICAgICAgcGhvbmU6IG1hdGNoKHdpbmRvd3NQaG9uZSksXG4gICAgICAgICAgICB0YWJsZXQ6IG1hdGNoKHdpbmRvd3NUYWJsZXQpLFxuICAgICAgICAgICAgZGV2aWNlOiBtYXRjaCh3aW5kb3dzUGhvbmUpIHx8IG1hdGNoKHdpbmRvd3NUYWJsZXQpXG4gICAgICAgIH0sXG4gICAgICAgIG90aGVyOiB7XG4gICAgICAgICAgICBibGFja2JlcnJ5OiBtYXRjaChvdGhlckJsYWNrQmVycnkpLFxuICAgICAgICAgICAgYmxhY2tiZXJyeTEwOiBtYXRjaChvdGhlckJsYWNrQmVycnkxMCksXG4gICAgICAgICAgICBvcGVyYTogbWF0Y2gob3RoZXJPcGVyYSksXG4gICAgICAgICAgICBmaXJlZm94OiBtYXRjaChvdGhlckZpcmVmb3gpLFxuICAgICAgICAgICAgY2hyb21lOiBtYXRjaChvdGhlckNocm9tZSksXG4gICAgICAgICAgICBkZXZpY2U6IG1hdGNoKG90aGVyQmxhY2tCZXJyeSkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChvdGhlckJsYWNrQmVycnkxMCkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChvdGhlck9wZXJhKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKG90aGVyRmlyZWZveCkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChvdGhlckNocm9tZSlcbiAgICAgICAgfSxcbiAgICAgICAgYW55OiBmYWxzZSxcbiAgICAgICAgcGhvbmU6IGZhbHNlLFxuICAgICAgICB0YWJsZXQ6IGZhbHNlXG4gICAgfTtcbiAgICByZXN1bHQuYW55ID1cbiAgICAgICAgcmVzdWx0LmFwcGxlLmRldmljZSB8fFxuICAgICAgICAgICAgcmVzdWx0LmFuZHJvaWQuZGV2aWNlIHx8XG4gICAgICAgICAgICByZXN1bHQud2luZG93cy5kZXZpY2UgfHxcbiAgICAgICAgICAgIHJlc3VsdC5vdGhlci5kZXZpY2U7XG4gICAgcmVzdWx0LnBob25lID1cbiAgICAgICAgcmVzdWx0LmFwcGxlLnBob25lIHx8IHJlc3VsdC5hbmRyb2lkLnBob25lIHx8IHJlc3VsdC53aW5kb3dzLnBob25lO1xuICAgIHJlc3VsdC50YWJsZXQgPVxuICAgICAgICByZXN1bHQuYXBwbGUudGFibGV0IHx8IHJlc3VsdC5hbmRyb2lkLnRhYmxldCB8fCByZXN1bHQud2luZG93cy50YWJsZXQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzTW9iaWxlLmpzLm1hcCIsImltcG9ydCBpc01vYmlsZUNhbGwgZnJvbSAnaXNtb2JpbGVqcyc7XG5cbmNsYXNzIFVJQ29udGFpbmVyIGV4dGVuZHMgY3JlYXRlanMuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLlVJT3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy5tb3VzZUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm1vdXNlQ2hpbGRyZW4gPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgc2Nyb2xsUmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNjcm9sbFJlY3Q7XG4gICAgfVxuICAgIHNldCBzY3JvbGxSZWN0KHJlY3QpIHtcbiAgICAgICAgdGhpcy4kc2Nyb2xsUmVjdCA9IHJlY3Q7XG4gICAgICAgIGlmIChyZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kcmVjdE1hc2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWN0TWFzayA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpO1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSh0aGlzLiRyZWN0TWFzayk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXNrID0gc2hhcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRyZWN0TWFzay5jbGVhcigpO1xuICAgICAgICAgICAgaWYgKHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlY3RNYXNrLmJlZ2luRmlsbCgnIzAwMCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlY3RNYXNrLmRyYXdSZWN0KHRoaXMuJHNjcm9sbFJlY3QueCwgdGhpcy4kc2Nyb2xsUmVjdC55LCB0aGlzLiRzY3JvbGxSZWN0LndpZHRoLCB0aGlzLiRzY3JvbGxSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVjdE1hc2suZW5kRmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubWFzayA9IG51bGw7XG4gICAgfVxufVxuXG5jbGFzcyBJbnRlcmFjdGl2ZUV2ZW50cyB7XG59XG5JbnRlcmFjdGl2ZUV2ZW50cy5Eb3duID0gY3JlYXRlanMuVG91Y2guaXNTdXBwb3J0ZWQoKSA/ICdtb3VzZWRvd24nIDogJ21vdXNlZG93bic7XG5JbnRlcmFjdGl2ZUV2ZW50cy5DYW5jZWwgPSBjcmVhdGVqcy5Ub3VjaC5pc1N1cHBvcnRlZCgpID8gJ21vdXNlY2FuY2VsJyA6ICdtb3VzZWNhbmNlbCc7XG5JbnRlcmFjdGl2ZUV2ZW50cy5VcCA9IGNyZWF0ZWpzLlRvdWNoLmlzU3VwcG9ydGVkKCkgPyAnc3RhZ2Vtb3VzZXVwJyA6ICdzdGFnZW1vdXNldXAnO1xuSW50ZXJhY3RpdmVFdmVudHMuQ2xpY2sgPSBjcmVhdGVqcy5Ub3VjaC5pc1N1cHBvcnRlZCgpID8gJ2NsaWNrJyA6ICdjbGljayc7XG5JbnRlcmFjdGl2ZUV2ZW50cy5VcE91dHNpZGUgPSBjcmVhdGVqcy5Ub3VjaC5pc1N1cHBvcnRlZCgpXG4gICAgPyAnbW91c2V1cG91dHNpZGUnXG4gICAgOiAnbW91c2V1cG91dHNpZGUnO1xuSW50ZXJhY3RpdmVFdmVudHMuTW92ZSA9IGNyZWF0ZWpzLlRvdWNoLmlzU3VwcG9ydGVkKCkgPyAnc3RhZ2Vtb3VzZW1vdmUnIDogJ3N0YWdlbW91c2Vtb3ZlJztcbkludGVyYWN0aXZlRXZlbnRzLk92ZXIgPSBjcmVhdGVqcy5Ub3VjaC5pc1N1cHBvcnRlZCgpID8gJ21vdXNlb3ZlcicgOiAnbW91c2VvdmVyJztcbkludGVyYWN0aXZlRXZlbnRzLk91dCA9IGNyZWF0ZWpzLlRvdWNoLmlzU3VwcG9ydGVkKCkgPyAnbW91c2VvdXQnIDogJ21vdXNlb3V0Jztcbi8vbW91c2Ugb25seVxuSW50ZXJhY3RpdmVFdmVudHMuUmlnaHREb3duID0gJ3JpZ2h0ZG93bic7XG5JbnRlcmFjdGl2ZUV2ZW50cy5SaWdodFVwID0gJ3JpZ2h0dXAnO1xuSW50ZXJhY3RpdmVFdmVudHMuUmlnaHRDbGljayA9ICdyaWdodGNsaWNrJztcbkludGVyYWN0aXZlRXZlbnRzLlJpZ2h0VXBPdXRzaWRlID0gJ3JpZ2h0dXBvdXRzaWRlJztcbmxldCBHZWFyWE1MTm9kZU5hbWVNYXAgPSB7XG4gICAgZ2VhckRpc3BsYXk6IDAsXG4gICAgZ2VhclhZOiAxLFxuICAgIGdlYXJTaXplOiAyLFxuICAgIGdlYXJMb29rOiAzLFxuICAgIGdlYXJDb2xvcjogNCxcbiAgICBnZWFyQW5pOiA1LFxuICAgIGdlYXJUZXh0OiA2LFxuICAgIGdlYXJJY29uOiA3XG59O1xubGV0IEJsZW5kTW9kZU1hcCA9IFtcbiAgICAnTm9ybWFsJyxcbiAgICAnQWRkJyxcbiAgICAnTXVsdGlwbHknLFxuICAgICdTY3JlZW4nLFxuICAgICdPdmVybGF5JyxcbiAgICAnRGFya2VuJyxcbiAgICAnTGlnaHRlbicsXG4gICAgJ0NvbG9yRG9kZ2UnLFxuICAgICdDb2xvckJ1cm4nLFxuICAgICdIYXJkTGlnaHQnLFxuICAgICdTb2Z0TGlnaHQnLFxuICAgICdEaWZmZXJlbmNlJyxcbiAgICAnRXhjbHVzaW9uJyxcbiAgICAnSHVlJyxcbiAgICAnU2F0dXJhdGlvbicsXG4gICAgJ0NvbG9yJyxcbiAgICAnTHVtaW5vc2l0eScsXG4gICAgJ05vcm1hbE5QTScsXG4gICAgJ0FkZE5QTScsXG4gICAgJ1NjcmVlbk5QTScgLy8gIFNDUkVFTl9OUE1cbl07XG5mdW5jdGlvbiBQYXJzZU92ZXJmbG93VHlwZSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSAndmlzaWJsZSc6XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBWaXNpYmxlICovO1xuICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgcmV0dXJuIDEgLyogSGlkZGVuICovO1xuICAgICAgICBjYXNlICdzY3JvbGwnOlxuICAgICAgICAgICAgcmV0dXJuIDIgLyogU2Nyb2xsICovO1xuICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgICByZXR1cm4gMyAvKiBTY2FsZSAqLztcbiAgICAgICAgY2FzZSAnc2NhbGVGcmVlJzpcbiAgICAgICAgICAgIHJldHVybiA0IC8qIFNjYWxlRnJlZSAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIFZpc2libGUgKi87XG4gICAgfVxufVxuZnVuY3Rpb24gUGFyc2VTY3JvbGxUeXBlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIEhvcml6b250YWwgKi87XG4gICAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFZlcnRpY2FsICovO1xuICAgICAgICBjYXNlICdib3RoJzpcbiAgICAgICAgICAgIHJldHVybiAyIC8qIEJvdGggKi87XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBWZXJ0aWNhbCAqLztcbiAgICB9XG59XG5mdW5jdGlvbiBQYXJzZUxvYWRlckZpbGxUeXBlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgIGNhc2UgJ3NjYWxlJzpcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNjYWxlICovO1xuICAgICAgICBjYXNlICdzY2FsZU1hdGNoSGVpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiAyIC8qIFNjYWxlTWF0Y2hIZWlnaHQgKi87XG4gICAgICAgIGNhc2UgJ3NjYWxlTWF0Y2hXaWR0aCc6XG4gICAgICAgICAgICByZXR1cm4gMyAvKiBTY2FsZU1hdGNoV2lkdGggKi87XG4gICAgICAgIGNhc2UgJ3NjYWxlRnJlZSc6XG4gICAgICAgICAgICByZXR1cm4gNCAvKiBTY2FsZUZyZWUgKi87XG4gICAgICAgIGNhc2UgJ3NjYWxlTm9Cb3JkZXInOlxuICAgICAgICAgICAgcmV0dXJuIDUgLyogU2NhbGVOb0JvcmRlciAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxufVxuZnVuY3Rpb24gUGFyc2VMaXN0TGF5b3V0VHlwZSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSAnY29sdW1uJzpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIFNpbmdsZUNvbHVtbiAqLztcbiAgICAgICAgY2FzZSAncm93JzpcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNpbmdsZVJvdyAqLztcbiAgICAgICAgY2FzZSAnZmxvd19oeic6XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBGbG93SG9yaXpvbnRhbCAqLztcbiAgICAgICAgY2FzZSAnZmxvd192dCc6XG4gICAgICAgICAgICByZXR1cm4gMyAvKiBGbG93VmVydGljYWwgKi87XG4gICAgICAgIGNhc2UgJ3BhZ2luYXRpb24nOlxuICAgICAgICAgICAgcmV0dXJuIDQgLyogUGFnaW5hdGlvbiAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIFNpbmdsZUNvbHVtbiAqLztcbiAgICB9XG59XG5mdW5jdGlvbiBQYXJzZUxpc3RTZWxlY3Rpb25Nb2RlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogU2luZ2xlICovO1xuICAgICAgICBjYXNlICdtdWx0aXBsZSc6XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBNdWx0aXBsZSAqLztcbiAgICAgICAgY2FzZSAnbXVsdGlwbGVTaW5nbGVDbGljayc6XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBNdWx0aXBsZV9TaW5nbGVDbGljayAqLztcbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICByZXR1cm4gMyAvKiBOb25lICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogU2luZ2xlICovO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFBhcnNlUGFja2FnZUl0ZW1UeXBlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBJbWFnZSAqLztcbiAgICAgICAgY2FzZSAnbW92aWVjbGlwJzpcbiAgICAgICAgICAgIHJldHVybiAyIC8qIE1vdmllQ2xpcCAqLztcbiAgICAgICAgY2FzZSAnc291bmQnOlxuICAgICAgICAgICAgcmV0dXJuIDMgLyogU291bmQgKi87XG4gICAgICAgIGNhc2UgJ2NvbXBvbmVudCc6XG4gICAgICAgICAgICByZXR1cm4gNCAvKiBDb21wb25lbnQgKi87XG4gICAgICAgIGNhc2UgJ3N3Zic6XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTd2YgKi87XG4gICAgICAgIGNhc2UgJ2ZvbnQnOlxuICAgICAgICAgICAgcmV0dXJuIDYgLyogRm9udCAqLztcbiAgICAgICAgY2FzZSAnYXRsYXMnOlxuICAgICAgICAgICAgcmV0dXJuIDcgLyogQXRsYXMgKi87XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gNSAvKiBNaXNjICovO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFBhcnNlUHJvZ3Jlc3NUaXRsZVR5cGUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3BlcmNlbnQnOlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogUGVyY2VudCAqLztcbiAgICAgICAgY2FzZSAndmFsdWVBbmRtYXgnOlxuICAgICAgICAgICAgcmV0dXJuIDEgLyogVmFsdWVBbmRNYXggKi87XG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgIHJldHVybiAyIC8qIFZhbHVlICovO1xuICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgcmV0dXJuIDMgLyogTWF4ICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogUGVyY2VudCAqLztcbiAgICB9XG59XG5mdW5jdGlvbiBQYXJzZVNjcm9sbEJhckRpc3BsYXlUeXBlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIERlZmF1bHQgKi87XG4gICAgICAgIGNhc2UgJ3Zpc2libGUnOlxuICAgICAgICAgICAgcmV0dXJuIDEgLyogVmlzaWJsZSAqLztcbiAgICAgICAgY2FzZSAnYXV0byc6XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBBdXRvICovO1xuICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgcmV0dXJuIDMgLyogSGlkZGVuICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogRGVmYXVsdCAqLztcbiAgICB9XG59XG5mdW5jdGlvbiBQYXJzZUZsaXBUeXBlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICdoeic6XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBIb3Jpem9udGFsICovO1xuICAgICAgICBjYXNlICd2dCc6XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBWZXJ0aWNhbCAqLztcbiAgICAgICAgY2FzZSAnYm90aCc6XG4gICAgICAgICAgICByZXR1cm4gMyAvKiBCb3RoICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICB9XG59XG5mdW5jdGlvbiBQYXJzZUJ1dHRvbk1vZGUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ0NvbW1vbic6XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBDb21tb24gKi87XG4gICAgICAgIGNhc2UgJ0NoZWNrJzpcbiAgICAgICAgICAgIHJldHVybiAxIC8qIENoZWNrICovO1xuICAgICAgICBjYXNlICdSYWRpbyc6XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBSYWRpbyAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIENvbW1vbiAqLztcbiAgICB9XG59XG5mdW5jdGlvbiBQYXJzZUF1dG9TaXplVHlwZSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICBjYXNlICdib3RoJzpcbiAgICAgICAgICAgIHJldHVybiAxIC8qIEJvdGggKi87XG4gICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBIZWlnaHQgKi87XG4gICAgICAgIGNhc2UgJ3Nocmluayc6XG4gICAgICAgICAgICByZXR1cm4gMyAvKiBTaHJpbmsgKi87XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFBhcnNlQWxpZ25UeXBlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHJldHVybiBcImxlZnRcIiAvKiBMZWZ0ICovO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgcmV0dXJuIFwiY2VudGVyXCIgLyogQ2VudGVyICovO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICByZXR1cm4gXCJyaWdodFwiIC8qIFJpZ2h0ICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwibGVmdFwiIC8qIExlZnQgKi87XG4gICAgfVxufVxuZnVuY3Rpb24gUGFyc2VWZXJ0QWxpZ25UeXBlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogVG9wICovO1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgcmV0dXJuIDEgLyogTWlkZGxlICovO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgcmV0dXJuIDIgLyogQm90dG9tICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogVG9wICovO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFBhcnNlTGlzdENoaWxkcmVuUmVuZGVyT3JkZXIodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2FzY2VudCc6XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBBc2NlbnQgKi87XG4gICAgICAgIGNhc2UgJ2Rlc2NlbnQnOlxuICAgICAgICAgICAgcmV0dXJuIDEgLyogRGVzY2VudCAqLztcbiAgICAgICAgY2FzZSAnYXJjaCc6XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBBcmNoICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogQXNjZW50ICovO1xuICAgIH1cbn1cbmxldCBlYXNlTWFwID0ge1xuICAgIExpbmVhcjogY3JlYXRlanMuRWFzZS5saW5lYXIsXG4gICAgJ0VsYXN0aWMuSW4nOiBjcmVhdGVqcy5FYXNlLmVsYXN0aWNJbixcbiAgICAnRWxhc3RpYy5PdXQnOiBjcmVhdGVqcy5FYXNlLmVsYXN0aWNPdXQsXG4gICAgJ0VsYXN0aWMuSW5PdXQnOiBjcmVhdGVqcy5FYXNlLmVsYXN0aWNJbk91dCxcbiAgICAnUXVhZC5Jbic6IGNyZWF0ZWpzLkVhc2UucXVhZEluLFxuICAgICdRdWFkLk91dCc6IGNyZWF0ZWpzLkVhc2UucXVhZE91dCxcbiAgICAnUXVhZC5Jbk91dCc6IGNyZWF0ZWpzLkVhc2UucXVhZEluT3V0LFxuICAgICdDdWJlLkluJzogY3JlYXRlanMuRWFzZS5jdWJpY0luLFxuICAgICdDdWJlLk91dCc6IGNyZWF0ZWpzLkVhc2UuY3ViaWNPdXQsXG4gICAgJ0N1YmUuSW5PdXQnOiBjcmVhdGVqcy5FYXNlLmN1YmljSW5PdXQsXG4gICAgJ1F1YXJ0LkluJzogY3JlYXRlanMuRWFzZS5xdWFydEluLFxuICAgICdRdWFydC5PdXQnOiBjcmVhdGVqcy5FYXNlLnF1YXJ0T3V0LFxuICAgICdRdWFydC5Jbk91dCc6IGNyZWF0ZWpzLkVhc2UucXVhcnRJbk91dCxcbiAgICAnUXVpbnQuSW4nOiBjcmVhdGVqcy5FYXNlLnF1aW50SW4sXG4gICAgJ1F1aW50Lk91dCc6IGNyZWF0ZWpzLkVhc2UucXVpbnRPdXQsXG4gICAgJ1F1aW50LkluT3V0JzogY3JlYXRlanMuRWFzZS5xdWludEluT3V0LFxuICAgICdTaW5lLkluJzogY3JlYXRlanMuRWFzZS5zaW5lSW4sXG4gICAgJ1NpbmUuT3V0JzogY3JlYXRlanMuRWFzZS5zaW5lT3V0LFxuICAgICdTaW5lLkluT3V0JzogY3JlYXRlanMuRWFzZS5zaW5lSW5PdXQsXG4gICAgJ0JvdW5jZS5Jbic6IGNyZWF0ZWpzLkVhc2UuYm91bmNlSW4sXG4gICAgJ0JvdW5jZS5PdXQnOiBjcmVhdGVqcy5FYXNlLmJvdW5jZU91dCxcbiAgICAnQm91bmNlLkluT3V0JzogY3JlYXRlanMuRWFzZS5ib3VuY2VJbk91dCxcbiAgICAnQ2lyYy5Jbic6IGNyZWF0ZWpzLkVhc2UuY2lyY0luLFxuICAgICdDaXJjLk91dCc6IGNyZWF0ZWpzLkVhc2UuY2lyY091dCxcbiAgICAnQ2lyYy5Jbk91dCc6IGNyZWF0ZWpzLkVhc2UuY2lyY0luT3V0LFxuICAgICdFeHBvLkluJzogY3JlYXRlanMuRWFzZS5xdWFydEluLFxuICAgICdFeHBvLk91dCc6IGNyZWF0ZWpzLkVhc2UucXVhcnRPdXQsXG4gICAgJ0V4cG8uSW5PdXQnOiBjcmVhdGVqcy5FYXNlLnF1YXJ0SW5PdXQsXG4gICAgJ0JhY2suSW4nOiBjcmVhdGVqcy5FYXNlLmJhY2tJbixcbiAgICAnQmFjay5PdXQnOiBjcmVhdGVqcy5FYXNlLmJhY2tPdXQsXG4gICAgJ0JhY2suSW5PdXQnOiBjcmVhdGVqcy5FYXNlLmJhY2tJbk91dFxufTtcbmZ1bmN0aW9uIFBhcnNlRWFzZVR5cGUobmFtZSkge1xuICAgIHJldHVybiBlYXNlTWFwW25hbWVdIHx8IGVhc2VNYXBbJ0xpbmVhciddO1xufVxuXG4vKipnbG9iYWwgdWkgY29uZmlndXJhdGlvbiAqL1xuY2xhc3MgVUlDb25maWcge1xufVxuLyoqZGVmYXVsdCBmb250IG5hbWUgb2YgeW91ciBwcm9qZWN0LiAqL1xuVUlDb25maWcuZGVmYXVsdEZvbnQgPSBcIkFyaWFsXCI7XG4vKiogbW9kYWwgbGF5ZXIgYmFja2dyb3VuZCBjb25maWd1cmF0aW9uLiAqL1xuVUlDb25maWcubW9kYWxMYXllckNvbG9yID0gXCIjMzMzMzMzXCI7XG5VSUNvbmZpZy5tb2RhbExheWVyQWxwaGEgPSAwLjI7XG5VSUNvbmZpZy5idXR0b25Tb3VuZFZvbHVtZVNjYWxlID0gMTtcbi8qKiBzY3JvbGxpbmcgZGlzdGFuY2UgcGVyIGFjdGlvbiBpbiBwaXhlbCovXG5VSUNvbmZpZy5kZWZhdWx0U2Nyb2xsU3BlZWQgPSAyNTtcbi8qKiBkZWZhdWx0IHNjcm9sbGJhciBkaXNwbGF5IG1vZGUuIEl0J3MgcmVjb21tZW5kZWQgdG8gc2V0IFNjcm9sbEJhckRpc3BsYXlUeXBlLlZpc2libGUgZm9yIERlc2t0b3AgZW52aXJvbm1lbnQgYW5kIFNjcm9sbEJhckRpc3BsYXlUeXBlLkF1dG8gZm9yIG1vYmlsZSBlbnZpcm9ubWVudC4qL1xuVUlDb25maWcuZGVmYXVsdFNjcm9sbEJhckRpc3BsYXkgPSAxIC8qIFZpc2libGUgKi87XG4vKiogYWxsb3cgdXNlciB0byBkcmFnIHRoZSBjb250ZW50IG9mIGEgY29udGFpbmVyLiBTZXQgdG8gdHJ1ZSBmb3IgbW9iaWxlIGlzIHJlY29tbWVuZGVkLiovXG5VSUNvbmZpZy5kZWZhdWx0U2Nyb2xsVG91Y2hFZmZlY3QgPSB0cnVlO1xuLyoqIGVuYWJsZSBib3VuY2UgZWZmZWN0IHdoZW4gdGhlIHNjcm9sbGluZyByZWFjaGVzIHRvIHRoZSBlZGdlIG9mIGEgY29udGFpbmVyLiBTZXQgdG8gdHJ1ZSBmb3IgbW9iaWxlIGlzIHJlY29tbWVuZGVkLiovXG5VSUNvbmZpZy5kZWZhdWx0U2Nyb2xsQm91bmNlRWZmZWN0ID0gdHJ1ZTtcbi8qKiBEZWNlbGVyYXRpb24gcmF0aW8gb2Ygc2Nyb2xscGFuZSB3aGVuIGl0cyBpbiB0b3VjaCBkcmFnZ2luZy4qL1xuVUlDb25maWcuZGVmYXVsdFNjcm9sbERlY2VsZXJhdGlvblJhdGUgPSAuOTY3O1xuLyoqIG1heGltdW0gY291bnQgb2YgaXRlbXMgdG8gYmUgZGlzcGxheWVkIGluIHRoZSB2aXNpYmxlIHZpZXdwb3J0IG9mIHRoZSBHQ29tYm9ib3guKi9cblVJQ29uZmlnLmRlZmF1bHRDb21ib0JveFZpc2libGVJdGVtQ291bnQgPSAxMDtcbi8qKiB0aGUgZmluZ2VyIG1vdmluZyB0aHJlc2hvbGQgaW4gcGl4ZWwgdG8gdHJpZ2dlciB0aGUgc2Nyb2xsaW5nIGFjdGlvbi4qL1xuVUlDb25maWcudG91Y2hTY3JvbGxTZW5zaXRpdml0eSA9IDIwO1xuLyoqIHRoZSBmaW5nZXIgbW92aW5nIHRocmVzaG9sZCBpbiBwaXhlbCB0byB0cmlnZ2VyIHRoZSBkcmFnZ2luZyBldmVudC4qL1xuVUlDb25maWcudG91Y2hEcmFnU2Vuc2l0aXZpdHkgPSAxMDtcbi8qKiBhdXRvIGJyaW5nIHRoZSB3aW5kb3cgeW91IGNsaWNrZWQgdG8gdGhlIHRvcG1vc3QgbGV2ZWwgb2YgdGhlIEdSb290IGNoaWxkcmVuIGxpc3QuKi9cblVJQ29uZmlnLmJyaW5nV2luZG93VG9Gcm9udE9uQ2xpY2sgPSB0cnVlO1xuXG5jbGFzcyBHZWFyQmFzZSB7XG4gICAgY29uc3RydWN0b3Iob3duZXIpIHtcbiAgICAgICAgdGhpcy4kbG9ja1Rva2VuID0gMDtcbiAgICAgICAgdGhpcy4kb3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy4kZWFzZVR5cGUgPSBQYXJzZUVhc2VUeXBlKCdRdWFkLk91dCcpO1xuICAgICAgICB0aGlzLiR0d2VlblRpbWUgPSAwLjM7XG4gICAgICAgIHRoaXMuJHR3ZWVuRGVsYXkgPSAwO1xuICAgIH1cbiAgICBnZXQgY29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIHNldCBjb250cm9sbGVyKHZhbCkge1xuICAgICAgICBpZiAodmFsICE9IHRoaXMuJGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRyb2xsZXIgPSB2YWw7XG4gICAgICAgICAgICBpZiAodGhpcy4kY29udHJvbGxlcilcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdHdlZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0d2VlbjtcbiAgICB9XG4gICAgc2V0IHR3ZWVuKHZhbCkge1xuICAgICAgICB0aGlzLiR0d2VlbiA9IHZhbDtcbiAgICB9XG4gICAgZ2V0IHR3ZWVuRGVsYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0d2VlbkRlbGF5O1xuICAgIH1cbiAgICBzZXQgdHdlZW5EZWxheSh2YWwpIHtcbiAgICAgICAgdGhpcy4kdHdlZW5EZWxheSA9IHZhbDtcbiAgICB9XG4gICAgZ2V0IHR3ZWVuVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHR3ZWVuVGltZTtcbiAgICB9XG4gICAgc2V0IHR3ZWVuVGltZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiR0d2VlblRpbWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGVhc2VUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZWFzZVR5cGU7XG4gICAgfVxuICAgIHNldCBlYXNlVHlwZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiRlYXNlVHlwZSA9IHZhbHVlO1xuICAgIH1cbiAgICBzZXR1cCh4bWwpIHtcbiAgICAgICAgdGhpcy4kY29udHJvbGxlciA9IHRoaXMuJG93bmVyLnBhcmVudC5nZXRDb250cm9sbGVyKHhtbC5hdHRyaWJ1dGVzLmNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAodGhpcy4kY29udHJvbGxlciA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMudHdlZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLiR0d2VlbiA9IHRydWU7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmVhc2U7XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLiRlYXNlVHlwZSA9IFBhcnNlRWFzZVR5cGUoc3RyKTtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuZHVyYXRpb247XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLiR0d2VlblRpbWUgPSBwYXJzZUZsb2F0KHN0cik7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmRlbGF5O1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgdGhpcy4kdHdlZW5EZWxheSA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgICAgICAgaWYgKHRoaXNbJyR2aWQnXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5wYWdlcztcbiAgICAgICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICAgICAgdGhpc1sncGFnZXMnXSA9IHN0ci5zcGxpdCgnLCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBhZ2VzO1xuICAgICAgICAgICAgbGV0IHZhbHVlcztcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnBhZ2VzO1xuICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICBwYWdlcyA9IHN0ci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMudmFsdWVzO1xuICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBzdHIuc3BsaXQoJ3wnKTtcbiAgICAgICAgICAgIGlmIChwYWdlcyAmJiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgocywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFN0YXR1cyhwYWdlc1tpXSwgcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5kZWZhdWx0O1xuICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFN0YXR1cyhudWxsLCBzdHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUZyb21SZWxhdGlvbnMoZHgsIGR5KSB7IH1cbiAgICBhZGRTdGF0dXMocGFnZUlkLCB2YWx1ZSkgeyB9XG4gICAgaW5pdCgpIHsgfVxuICAgIGFwcGx5KCkgeyB9XG4gICAgdXBkYXRlU3RhdGUoKSB7IH1cbn1cbkdlYXJCYXNlLmRpc2FibGVBbGxUd2VlbkVmZmVjdCA9IGZhbHNlO1xuXG5jbGFzcyBHZWFyRGlzcGxheSBleHRlbmRzIEdlYXJCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcikge1xuICAgICAgICBzdXBlcihvd25lcik7XG4gICAgICAgIHRoaXMuJHZpZCA9IDA7XG4gICAgICAgIHRoaXMuJGxvY2tUb2tlbiA9IDE7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMucGFnZXMgPSBudWxsO1xuICAgIH1cbiAgICBsb2NrKCkge1xuICAgICAgICB0aGlzLiR2aWQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuJGxvY2tUb2tlbjtcbiAgICB9XG4gICAgcmVsZWFzZSh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4gPT0gdGhpcy4kbG9ja1Rva2VuKVxuICAgICAgICAgICAgdGhpcy4kdmlkLS07XG4gICAgfVxuICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXIgPT0gbnVsbCB8fCB0aGlzLiR2aWQgPiAwO1xuICAgIH1cbiAgICBhcHBseSgpIHtcbiAgICAgICAgdGhpcy4kbG9ja1Rva2VuKys7XG4gICAgICAgIGlmICh0aGlzLiRsb2NrVG9rZW4gPD0gMClcbiAgICAgICAgICAgIHRoaXMuJGxvY2tUb2tlbiA9IDE7XG4gICAgICAgIGlmICh0aGlzLnBhZ2VzID09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMucGFnZXMubGVuZ3RoID09IDAgfHxcbiAgICAgICAgICAgIHRoaXMucGFnZXMuaW5kZXhPZih0aGlzLiRjb250cm9sbGVyLnNlbGVjdGVkUGFnZUlkKSAhPSAtMSlcbiAgICAgICAgICAgIHRoaXMuJHZpZCA9IDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuJHZpZCA9IDA7XG4gICAgfVxufVxuXG5jbGFzcyBCTUdseXBoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXRYID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXRZID0gMDtcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5hZHZhbmNlID0gMDtcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gMDtcbiAgICB9XG59XG5jbGFzcyBCaXRtYXBGb250IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5nbHlwaHMgPSB7fTtcbiAgICB9XG59XG5cbmNsYXNzIEZyYW1lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hZGREZWxheSA9IDA7XG4gICAgfVxufVxuXG5jbGFzcyBBc3NldExvYWRlciBleHRlbmRzIGNyZWF0ZWpzLkxvYWRRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IocHJlZmVyWEhSLCBiYXNlUGF0aCwgY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgc3VwZXIocHJlZmVyWEhSLCBiYXNlUGF0aCk7XG4gICAgICAgIHRoaXMub24oJ2NvbXBsZXRlJywgdGhpcy5fb25Db21wbGV0ZSwgdGhpcyk7XG4gICAgfVxuICAgIF9vbkNvbXBsZXRlKGV2ZW50KSB7XG4gICAgICAgIHZhciBsb2FkZXIgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHZhciByZXN1bHQgPSBsb2FkZXJbXCJfbG9hZGVkUmVzdWx0c1wiXTtcbiAgICAgICAgQXNzZXRMb2FkZXIuYWRkUmVzb3VyY2VzKHJlc3VsdCk7XG4gICAgfVxuICAgIDtcbiAgICBzdGF0aWMgZ2V0IHJlc291cmNlc1Bvb2woKSB7XG4gICAgICAgIHJldHVybiBBc3NldExvYWRlci4kcmVzb3VyY2VzO1xuICAgIH1cbiAgICBzdGF0aWMgZGVzdHJveVJlc291cmNlKGtleSkge1xuICAgICAgICBsZXQgcmVzID0gQXNzZXRMb2FkZXIuJHJlc291cmNlc1trZXldO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBkZWxldGUgQXNzZXRMb2FkZXIuJHJlc291cmNlc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhZGRSZXNvdXJjZXMocmVzKSB7XG4gICAgICAgIGlmICghcmVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gcmVzKSAvL292ZXJyaWRlIHRoZSBpdGVtIHdoaWNoIGhhcyBzYW1lIGtleSBuYW1lXG4gICAgICAgICAgICBBc3NldExvYWRlci4kcmVzb3VyY2VzW2tleV0gPSByZXNba2V5XTtcbiAgICB9XG59XG5Bc3NldExvYWRlci4kcmVzb3VyY2VzID0ge307XG5cbmNsYXNzIEVuZGlhbiB7XG59XG5FbmRpYW4uTElUVExFX0VORElBTiA9IFwibGl0dGxlRW5kaWFuXCI7XG5FbmRpYW4uQklHX0VORElBTiA9IFwiYmlnRW5kaWFuXCI7XG5jbGFzcyBCeXRlQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgYnVmZmVyRXh0U2l6ZSA9IDApIHtcbiAgICAgICAgdGhpcy5idWZmZXJFeHRTaXplID0gMDsgLy9CdWZmZXIgZXhwYW5zaW9uIHNpemVcbiAgICAgICAgdGhpcy5FT0ZfYnl0ZSA9IC0xO1xuICAgICAgICB0aGlzLkVPRl9jb2RlX3BvaW50ID0gLTE7XG4gICAgICAgIGlmIChidWZmZXJFeHRTaXplIDwgMCkge1xuICAgICAgICAgICAgYnVmZmVyRXh0U2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJFeHRTaXplID0gYnVmZmVyRXh0U2l6ZTtcbiAgICAgICAgbGV0IGJ5dGVzLCB3cG9zID0gMDtcbiAgICAgICAgaWYgKGJ1ZmZlcikgeyAvL+acieaVsOaNru+8jOWImeWPr+WGmeWtl+iKguaVsOS7juWtl+iKguWwvuW8gOWni1xuICAgICAgICAgICAgbGV0IHVpbnQ4O1xuICAgICAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICB1aW50OCA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB3cG9zID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdwb3MgPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB1aW50OCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyRXh0U2l6ZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh3cG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtdWx0aSA9ICh3cG9zIC8gYnVmZmVyRXh0U2l6ZSB8IDApICsgMTtcbiAgICAgICAgICAgICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KG11bHRpICogYnVmZmVyRXh0U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieXRlcy5zZXQodWludDgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXJFeHRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlX3Bvc2l0aW9uID0gd3BvcztcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSAwO1xuICAgICAgICB0aGlzLl9ieXRlcyA9IGJ5dGVzO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5lbmRpYW4gPSBFbmRpYW4uQklHX0VORElBTjtcbiAgICB9XG4gICAgZ2V0IGVuZGlhbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVuZGlhbiA9PSAwIC8qIExJVFRMRV9FTkRJQU4gKi8gPyBFbmRpYW4uTElUVExFX0VORElBTiA6IEVuZGlhbi5CSUdfRU5ESUFOO1xuICAgIH1cbiAgICBzZXQgZW5kaWFuKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJGVuZGlhbiA9IHZhbHVlID09IEVuZGlhbi5MSVRUTEVfRU5ESUFOID8gMCAvKiBMSVRUTEVfRU5ESUFOICovIDogMSAvKiBCSUdfRU5ESUFOICovO1xuICAgIH1cbiAgICBnZXQgcmVhZEF2YWlsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVfcG9zaXRpb24gLSB0aGlzLl9wb3NpdGlvbjtcbiAgICB9XG4gICAgZ2V0IGJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5idWZmZXIuc2xpY2UoMCwgdGhpcy53cml0ZV9wb3NpdGlvbik7XG4gICAgfVxuICAgIGdldCByYXdCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBzZXQgYnVmZmVyKHZhbHVlKSB7XG4gICAgICAgIGxldCB3cG9zID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgbGV0IHVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICBsZXQgYnVmZmVyRXh0U2l6ZSA9IHRoaXMuYnVmZmVyRXh0U2l6ZTtcbiAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICBpZiAoYnVmZmVyRXh0U2l6ZSA9PSAwKSB7XG4gICAgICAgICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KHdwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG11bHRpID0gKHdwb3MgLyBidWZmZXJFeHRTaXplIHwgMCkgKyAxO1xuICAgICAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShtdWx0aSAqIGJ1ZmZlckV4dFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnNldCh1aW50OCk7XG4gICAgICAgIHRoaXMud3JpdGVfcG9zaXRpb24gPSB3cG9zO1xuICAgICAgICB0aGlzLl9ieXRlcyA9IGJ5dGVzO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyKTtcbiAgICB9XG4gICAgZ2V0IGJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZXM7XG4gICAgfVxuICAgIGdldCBkYXRhVmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9XG4gICAgc2V0IGRhdGFWaWV3KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gdmFsdWUuYnVmZmVyO1xuICAgIH1cbiAgICBnZXQgYnVmZmVyT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmJ5dGVPZmZzZXQ7XG4gICAgfVxuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuICAgIH1cbiAgICBzZXQgcG9zaXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlID4gdGhpcy53cml0ZV9wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy53cml0ZV9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlX3Bvc2l0aW9uO1xuICAgIH1cbiAgICBzZXQgbGVuZ3RoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5ieXRlTGVuZ3RoID4gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmFsaWRhdGVCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBfdmFsaWRhdGVCdWZmZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5ieXRlTGVuZ3RoIDwgdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBiZSA9IHRoaXMuYnVmZmVyRXh0U2l6ZTtcbiAgICAgICAgICAgIGxldCB0bXA7XG4gICAgICAgICAgICBpZiAoYmUgPT0gMCkge1xuICAgICAgICAgICAgICAgIHRtcCA9IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuTGVuID0gKCh2YWx1ZSAvIGJlID4+IDApICsgMSkgKiBiZTtcbiAgICAgICAgICAgICAgICB0bXAgPSBuZXcgVWludDhBcnJheShuTGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcC5zZXQodGhpcy5fYnl0ZXMpO1xuICAgICAgICAgICAgdGhpcy5fYnl0ZXMgPSB0bXA7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcodG1wLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGJ5dGVzQXZhaWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmJ5dGVMZW5ndGggLSB0aGlzLl9wb3NpdGlvbjtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGxldCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5idWZmZXJFeHRTaXplKTtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2J5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSAwO1xuICAgICAgICB0aGlzLndyaXRlX3Bvc2l0aW9uID0gMDtcbiAgICB9XG4gICAgcmVhZEJvb2xlYW4oKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRlKDEgLyogU0laRV9PRl9CT09MRUFOICovKSlcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX2J5dGVzW3RoaXMucG9zaXRpb24rK107XG4gICAgfVxuICAgIHJlYWRCeXRlKCkge1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZSgxIC8qIFNJWkVfT0ZfSU5UOCAqLykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmdldEludDgodGhpcy5wb3NpdGlvbisrKTtcbiAgICB9XG4gICAgcmVhZEJ5dGVzKGJ5dGVzLCBvZmZzZXQgPSAwLCBsZW5ndGggPSAwKSB7XG4gICAgICAgIGlmICghYnl0ZXMpIHsgLy/nlLHkuo5ieXRlc+S4jei/lOWbnu+8jOaJgOS7pW5ld+aWsOeahOaXoOaEj+S5iVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLl9wb3NpdGlvbjtcbiAgICAgICAgbGV0IGF2YWlsYWJsZSA9IHRoaXMud3JpdGVfcG9zaXRpb24gLSBwb3M7XG4gICAgICAgIGlmIChhdmFpbGFibGUgPCAwKSB7XG4gICAgICAgICAgICAvLyBlZ3JldC4kZXJyb3IoMTAyNSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBhdmFpbGFibGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID4gYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAvLyBlZ3JldC4kZXJyb3IoMTAyNSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBieXRlcy5fcG9zaXRpb247XG4gICAgICAgIGJ5dGVzLl9wb3NpdGlvbiA9IDA7XG4gICAgICAgIGJ5dGVzLnZhbGlkYXRlQnVmZmVyKG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIGJ5dGVzLl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICBieXRlcy5fYnl0ZXMuc2V0KHRoaXMuX2J5dGVzLnN1YmFycmF5KHBvcywgcG9zICsgbGVuZ3RoKSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGg7XG4gICAgfVxuICAgIHJlYWREb3VibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRlKDggLyogU0laRV9PRl9GTE9BVDY0ICovKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5kYXRhLmdldEZsb2F0NjQodGhpcy5fcG9zaXRpb24sIHRoaXMuJGVuZGlhbiA9PSAwIC8qIExJVFRMRV9FTkRJQU4gKi8pO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA4IC8qIFNJWkVfT0ZfRkxPQVQ2NCAqLztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkRmxvYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRlKDQgLyogU0laRV9PRl9GTE9BVDMyICovKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5kYXRhLmdldEZsb2F0MzIodGhpcy5fcG9zaXRpb24sIHRoaXMuJGVuZGlhbiA9PSAwIC8qIExJVFRMRV9FTkRJQU4gKi8pO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA0IC8qIFNJWkVfT0ZfRkxPQVQzMiAqLztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkSW50KCkge1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZSg0IC8qIFNJWkVfT0ZfSU5UMzIgKi8pKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5fcG9zaXRpb24sIHRoaXMuJGVuZGlhbiA9PSAwIC8qIExJVFRMRV9FTkRJQU4gKi8pO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA0IC8qIFNJWkVfT0ZfSU5UMzIgKi87XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZFNob3J0KCkge1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZSgyIC8qIFNJWkVfT0ZfSU5UMTYgKi8pKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5fcG9zaXRpb24sIHRoaXMuJGVuZGlhbiA9PSAwIC8qIExJVFRMRV9FTkRJQU4gKi8pO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyIC8qIFNJWkVfT0ZfSU5UMTYgKi87XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZFVuc2lnbmVkQnl0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGUoMSAvKiBTSVpFX09GX1VJTlQ4ICovKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ieXRlc1t0aGlzLnBvc2l0aW9uKytdO1xuICAgIH1cbiAgICByZWFkVW5zaWduZWRJbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRlKDQgLyogU0laRV9PRl9VSU5UMzIgKi8pKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGEuZ2V0VWludDMyKHRoaXMuX3Bvc2l0aW9uLCB0aGlzLiRlbmRpYW4gPT0gMCAvKiBMSVRUTEVfRU5ESUFOICovKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gNCAvKiBTSVpFX09GX1VJTlQzMiAqLztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkVW5zaWduZWRTaG9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGUoMiAvKiBTSVpFX09GX1VJTlQxNiAqLykpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGF0YS5nZXRVaW50MTYodGhpcy5fcG9zaXRpb24sIHRoaXMuJGVuZGlhbiA9PSAwIC8qIExJVFRMRV9FTkRJQU4gKi8pO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyIC8qIFNJWkVfT0ZfVUlOVDE2ICovO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRVVEYoKSB7XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLnJlYWRVbnNpZ25lZFNob3J0KCk7XG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkVVRGQnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRVVEZCeXRlcyhsZW5ndGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlKGxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCArIHRoaXMuX3Bvc2l0aW9uLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlVVRGOChieXRlcyk7XG4gICAgfVxuICAgIHdyaXRlQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlQnVmZmVyKDEgLyogU0laRV9PRl9CT09MRUFOICovKTtcbiAgICAgICAgdGhpcy5fYnl0ZXNbdGhpcy5wb3NpdGlvbisrXSA9ICt2YWx1ZTtcbiAgICB9XG4gICAgd3JpdGVCeXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVCdWZmZXIoMSAvKiBTSVpFX09GX0lOVDggKi8pO1xuICAgICAgICB0aGlzLl9ieXRlc1t0aGlzLnBvc2l0aW9uKytdID0gdmFsdWUgJiAweGZmO1xuICAgIH1cbiAgICB3cml0ZUJ5dGVzKGJ5dGVzLCBvZmZzZXQgPSAwLCBsZW5ndGggPSAwKSB7XG4gICAgICAgIGxldCB3cml0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZUxlbmd0aCA9IGJ5dGVzLmxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXRlTGVuZ3RoID0gTWF0aC5taW4oYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cml0ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVCdWZmZXIod3JpdGVMZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5fYnl0ZXMuc2V0KGJ5dGVzLl9ieXRlcy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHdyaXRlTGVuZ3RoKSwgdGhpcy5fcG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uICsgd3JpdGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVEb3VibGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUJ1ZmZlcig4IC8qIFNJWkVfT0ZfRkxPQVQ2NCAqLyk7XG4gICAgICAgIHRoaXMuZGF0YS5zZXRGbG9hdDY0KHRoaXMuX3Bvc2l0aW9uLCB2YWx1ZSwgdGhpcy4kZW5kaWFuID09IDAgLyogTElUVExFX0VORElBTiAqLyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gOCAvKiBTSVpFX09GX0ZMT0FUNjQgKi87XG4gICAgfVxuICAgIHdyaXRlRmxvYXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUJ1ZmZlcig0IC8qIFNJWkVfT0ZfRkxPQVQzMiAqLyk7XG4gICAgICAgIHRoaXMuZGF0YS5zZXRGbG9hdDMyKHRoaXMuX3Bvc2l0aW9uLCB2YWx1ZSwgdGhpcy4kZW5kaWFuID09IDAgLyogTElUVExFX0VORElBTiAqLyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNCAvKiBTSVpFX09GX0ZMT0FUMzIgKi87XG4gICAgfVxuICAgIHdyaXRlSW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVCdWZmZXIoNCAvKiBTSVpFX09GX0lOVDMyICovKTtcbiAgICAgICAgdGhpcy5kYXRhLnNldEludDMyKHRoaXMuX3Bvc2l0aW9uLCB2YWx1ZSwgdGhpcy4kZW5kaWFuID09IDAgLyogTElUVExFX0VORElBTiAqLyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNCAvKiBTSVpFX09GX0lOVDMyICovO1xuICAgIH1cbiAgICB3cml0ZVNob3J0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVCdWZmZXIoMiAvKiBTSVpFX09GX0lOVDE2ICovKTtcbiAgICAgICAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMuX3Bvc2l0aW9uLCB2YWx1ZSwgdGhpcy4kZW5kaWFuID09IDAgLyogTElUVExFX0VORElBTiAqLyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMiAvKiBTSVpFX09GX0lOVDE2ICovO1xuICAgIH1cbiAgICB3cml0ZVVuc2lnbmVkSW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVCdWZmZXIoNCAvKiBTSVpFX09GX1VJTlQzMiAqLyk7XG4gICAgICAgIHRoaXMuZGF0YS5zZXRVaW50MzIodGhpcy5fcG9zaXRpb24sIHZhbHVlLCB0aGlzLiRlbmRpYW4gPT0gMCAvKiBMSVRUTEVfRU5ESUFOICovKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA0IC8qIFNJWkVfT0ZfVUlOVDMyICovO1xuICAgIH1cbiAgICB3cml0ZVVuc2lnbmVkU2hvcnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUJ1ZmZlcigyIC8qIFNJWkVfT0ZfVUlOVDE2ICovKTtcbiAgICAgICAgdGhpcy5kYXRhLnNldFVpbnQxNih0aGlzLl9wb3NpdGlvbiwgdmFsdWUsIHRoaXMuJGVuZGlhbiA9PSAwIC8qIExJVFRMRV9FTkRJQU4gKi8pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDIgLyogU0laRV9PRl9VSU5UMTYgKi87XG4gICAgfVxuICAgIHdyaXRlVVRGKHZhbHVlKSB7XG4gICAgICAgIGxldCB1dGY4Ynl0ZXMgPSB0aGlzLmVuY29kZVVURjgodmFsdWUpO1xuICAgICAgICBsZXQgbGVuZ3RoID0gdXRmOGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUJ1ZmZlcigyIC8qIFNJWkVfT0ZfVUlOVDE2ICovICsgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5kYXRhLnNldFVpbnQxNih0aGlzLl9wb3NpdGlvbiwgbGVuZ3RoLCB0aGlzLiRlbmRpYW4gPT0gMCAvKiBMSVRUTEVfRU5ESUFOICovKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyIC8qIFNJWkVfT0ZfVUlOVDE2ICovO1xuICAgICAgICB0aGlzLl93cml0ZVVpbnQ4QXJyYXkodXRmOGJ5dGVzLCBmYWxzZSk7XG4gICAgfVxuICAgIHdyaXRlVVRGQnl0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fd3JpdGVVaW50OEFycmF5KHRoaXMuZW5jb2RlVVRGOCh2YWx1ZSkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiW0J5dGVBcnJheV0gbGVuZ3RoOlwiICsgdGhpcy5sZW5ndGggKyBcIiwgYnl0ZXNBdmFpbGFibGU6XCIgKyB0aGlzLmJ5dGVzQXZhaWxhYmxlO1xuICAgIH1cbiAgICBfd3JpdGVVaW50OEFycmF5KGJ5dGVzLCB2YWxpZGF0ZUJ1ZmZlciA9IHRydWUpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuX3Bvc2l0aW9uO1xuICAgICAgICBsZXQgbnBvcyA9IHBvcyArIGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKHZhbGlkYXRlQnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQnVmZmVyKG5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnl0ZXMuc2V0KGJ5dGVzLCBwb3MpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gbnBvcztcbiAgICB9XG4gICAgdmFsaWRhdGUobGVuKSB7XG4gICAgICAgIGxldCBibCA9IHRoaXMuX2J5dGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGJsID4gMCAmJiB0aGlzLl9wb3NpdGlvbiArIGxlbiA8PSBibCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogIFBSSVZBVEUgTUVUSE9EUyAgICovXG4gICAgdmFsaWRhdGVCdWZmZXIobGVuKSB7XG4gICAgICAgIHRoaXMud3JpdGVfcG9zaXRpb24gPSBsZW4gPiB0aGlzLndyaXRlX3Bvc2l0aW9uID8gbGVuIDogdGhpcy53cml0ZV9wb3NpdGlvbjtcbiAgICAgICAgbGVuICs9IHRoaXMuX3Bvc2l0aW9uO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUJ1ZmZlcihsZW4pO1xuICAgIH1cbiAgICBlbmNvZGVVVEY4KHN0cikge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgbGV0IGNvZGVQb2ludHMgPSB0aGlzLnN0cmluZ1RvQ29kZVBvaW50cyhzdHIpO1xuICAgICAgICBsZXQgb3V0cHV0Qnl0ZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNvZGVQb2ludHMubGVuZ3RoID4gcG9zKSB7XG4gICAgICAgICAgICBsZXQgY29kZV9wb2ludCA9IGNvZGVQb2ludHNbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5SYW5nZShjb2RlX3BvaW50LCAweEQ4MDAsIDB4REZGRikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuY29kZXJFcnJvcihjb2RlX3BvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5SYW5nZShjb2RlX3BvaW50LCAweDAwMDAsIDB4MDA3ZikpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRCeXRlcy5wdXNoKGNvZGVfcG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50LCBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5SYW5nZShjb2RlX3BvaW50LCAweDAwODAsIDB4MDdGRikpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAweEMwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmluUmFuZ2UoY29kZV9wb2ludCwgMHgwODAwLCAweEZGRkYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMHhFMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pblJhbmdlKGNvZGVfcG9pbnQsIDB4MTAwMDAsIDB4MTBGRkZGKSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDB4RjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dEJ5dGVzLnB1c2godGhpcy5kaXYoY29kZV9wb2ludCwgTWF0aC5wb3coNjQsIGNvdW50KSkgKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXAgPSB0aGlzLmRpdihjb2RlX3BvaW50LCBNYXRoLnBvdyg2NCwgY291bnQgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEJ5dGVzLnB1c2goMHg4MCArICh0ZW1wICUgNjQpKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG91dHB1dEJ5dGVzKTtcbiAgICB9XG4gICAgZGVjb2RlVVRGOChkYXRhKSB7XG4gICAgICAgIGxldCBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGxldCBjb2RlX3BvaW50O1xuICAgICAgICBsZXQgdXRmOF9jb2RlX3BvaW50ID0gMDtcbiAgICAgICAgbGV0IHV0ZjhfYnl0ZXNfbmVlZGVkID0gMDtcbiAgICAgICAgbGV0IHV0ZjhfYnl0ZXNfc2VlbiA9IDA7XG4gICAgICAgIGxldCB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMDtcbiAgICAgICAgd2hpbGUgKGRhdGEubGVuZ3RoID4gcG9zKSB7XG4gICAgICAgICAgICBsZXQgX2J5dGUgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmIChfYnl0ZSA9PSB0aGlzLkVPRl9ieXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0ZjhfYnl0ZXNfbmVlZGVkICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZV9wb2ludCA9IHRoaXMuZGVjb2RlckVycm9yKGZhdGFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVfcG9pbnQgPSB0aGlzLkVPRl9jb2RlX3BvaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh1dGY4X2J5dGVzX25lZWRlZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluUmFuZ2UoX2J5dGUsIDB4MDAsIDB4N0YpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX3BvaW50ID0gX2J5dGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pblJhbmdlKF9ieXRlLCAweEMyLCAweERGKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMHg4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4X2NvZGVfcG9pbnQgPSBfYnl0ZSAtIDB4QzA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmluUmFuZ2UoX2J5dGUsIDB4RTAsIDB4RUYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOF9ieXRlc19uZWVkZWQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhfbG93ZXJfYm91bmRhcnkgPSAweDgwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4X2NvZGVfcG9pbnQgPSBfYnl0ZSAtIDB4RTA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmluUmFuZ2UoX2J5dGUsIDB4RjAsIDB4RjQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOF9ieXRlc19uZWVkZWQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhfbG93ZXJfYm91bmRhcnkgPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhfY29kZV9wb2ludCA9IF9ieXRlIC0gMHhGMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlckVycm9yKGZhdGFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhfY29kZV9wb2ludCA9IHV0ZjhfY29kZV9wb2ludCAqIE1hdGgucG93KDY0LCB1dGY4X2J5dGVzX25lZWRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX3BvaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5pblJhbmdlKF9ieXRlLCAweDgwLCAweEJGKSkge1xuICAgICAgICAgICAgICAgICAgICB1dGY4X2NvZGVfcG9pbnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB1dGY4X2J5dGVzX25lZWRlZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHV0ZjhfYnl0ZXNfc2VlbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHV0ZjhfbG93ZXJfYm91bmRhcnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgY29kZV9wb2ludCA9IHRoaXMuZGVjb2RlckVycm9yKGZhdGFsLCBfYnl0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGY4X2J5dGVzX3NlZW4gKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdXRmOF9jb2RlX3BvaW50ID0gdXRmOF9jb2RlX3BvaW50ICsgKF9ieXRlIC0gMHg4MCkgKiBNYXRoLnBvdyg2NCwgdXRmOF9ieXRlc19uZWVkZWQgLSB1dGY4X2J5dGVzX3NlZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXRmOF9ieXRlc19zZWVuICE9PSB1dGY4X2J5dGVzX25lZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9wb2ludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3AgPSB1dGY4X2NvZGVfcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbG93ZXJfYm91bmRhcnkgPSB1dGY4X2xvd2VyX2JvdW5kYXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRmOF9jb2RlX3BvaW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhfYnl0ZXNfc2VlbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluUmFuZ2UoY3AsIGxvd2VyX2JvdW5kYXJ5LCAweDEwRkZGRikgJiYgIXRoaXMuaW5SYW5nZShjcCwgMHhEODAwLCAweERGRkYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9wb2ludCA9IGNwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9wb2ludCA9IHRoaXMuZGVjb2RlckVycm9yKGZhdGFsLCBfYnl0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL0RlY29kZSBzdHJpbmdcbiAgICAgICAgICAgIGlmIChjb2RlX3BvaW50ICE9PSBudWxsICYmIGNvZGVfcG9pbnQgIT09IHRoaXMuRU9GX2NvZGVfcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZV9wb2ludCA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVfcG9pbnQgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZV9wb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlX3BvaW50IC09IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArICgoY29kZV9wb2ludCA+PiAxMCkgJiAweDNmZikpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweERDMDAgKyAoY29kZV9wb2ludCAmIDB4M2ZmKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZXJFcnJvcihjb2RlX3BvaW50KSB7XG4gICAgICAgIC8vIGVncmV0LiRlcnJvcigxMDI2LCBjb2RlX3BvaW50KTtcbiAgICB9XG4gICAgZGVjb2RlckVycm9yKGZhdGFsLCBvcHRfY29kZV9wb2ludCkge1xuICAgICAgICByZXR1cm4gb3B0X2NvZGVfcG9pbnQgfHwgMHhGRkZEO1xuICAgIH1cbiAgICBpblJhbmdlKGEsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBtaW4gPD0gYSAmJiBhIDw9IG1heDtcbiAgICB9XG4gICAgZGl2KG4sIGQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobiAvIGQpO1xuICAgIH1cbiAgICBzdHJpbmdUb0NvZGVQb2ludHMoc3RyaW5nKSB7XG4gICAgICAgIGxldCBjcHMgPSBbXTtcbiAgICAgICAgLy8gQmFzZWQgb24gaHR0cDovL3d3dy53My5vcmcvVFIvV2ViSURMLyNpZGwtRE9NU3RyaW5nXG4gICAgICAgIGxldCBpID0gMCwgbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pblJhbmdlKGMsIDB4RDgwMCwgMHhERkZGKSkge1xuICAgICAgICAgICAgICAgIGNwcy5wdXNoKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pblJhbmdlKGMsIDB4REMwMCwgMHhERkZGKSkge1xuICAgICAgICAgICAgICAgIGNwcy5wdXNoKDB4RkZGRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gKGluUmFuZ2UoYywgMHhEODAwLCAweERCRkYpKVxuICAgICAgICAgICAgICAgIGlmIChpID09IG4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNwcy5wdXNoKDB4RkZGRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5SYW5nZShkLCAweERDMDAsIDB4REZGRikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhID0gYyAmIDB4M0ZGO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGIgPSBkICYgMHgzRkY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHMucHVzaCgweDEwMDAwICsgKGEgPDwgMTApICsgYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHMucHVzaCgweEZGRkQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcHM7XG4gICAgfVxufVxuXG5jbGFzcyBSYXdCeXRlIHtcbiAgICBzdGF0aWMgaW5SYW5nZShhLCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gbWluIDw9IGEgJiYgYSA8PSBtYXg7XG4gICAgfVxuICAgIHN0YXRpYyBkZWNvZGVVVEY4KGRhdGEpIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBsZXQgY29kZV9wb2ludDtcbiAgICAgICAgbGV0IHV0ZjhfY29kZV9wb2ludCA9IDA7XG4gICAgICAgIGxldCB1dGY4X2J5dGVzX25lZWRlZCA9IDA7XG4gICAgICAgIGxldCB1dGY4X2J5dGVzX3NlZW4gPSAwO1xuICAgICAgICBsZXQgdXRmOF9sb3dlcl9ib3VuZGFyeSA9IDA7XG4gICAgICAgIHdoaWxlIChkYXRhLmxlbmd0aCA+IHBvcykge1xuICAgICAgICAgICAgbGV0IF9ieXRlID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBpZiAoX2J5dGUgPT0gLTEgLyogRU9GX2J5dGUgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodXRmOF9ieXRlc19uZWVkZWQgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlX3BvaW50ID0gNjU1MzMgLyogRmF0YWxfY29kZV9wb2ludCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVfcG9pbnQgPSAtMSAvKiBFT0ZfY29kZV9wb2ludCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodXRmOF9ieXRlc19uZWVkZWQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUmF3Qnl0ZS5pblJhbmdlKF9ieXRlLCAweDAwLCAweDdGKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9wb2ludCA9IF9ieXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJhd0J5dGUuaW5SYW5nZShfYnl0ZSwgMHhDMiwgMHhERikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4X2J5dGVzX25lZWRlZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOF9sb3dlcl9ib3VuZGFyeSA9IDB4ODA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOF9jb2RlX3BvaW50ID0gX2J5dGUgLSAweEMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoUmF3Qnl0ZS5pblJhbmdlKF9ieXRlLCAweEUwLCAweEVGKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMHg4MDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOF9jb2RlX3BvaW50ID0gX2J5dGUgLSAweEUwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoUmF3Qnl0ZS5pblJhbmdlKF9ieXRlLCAweEYwLCAweEY0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4X2NvZGVfcG9pbnQgPSBfYnl0ZSAtIDB4RjA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gZGVjb2RlIHRoZSByYXcgYmluYXJ5IGRhdGFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGY4X2NvZGVfcG9pbnQgPSB1dGY4X2NvZGVfcG9pbnQgKiBNYXRoLnBvdyg2NCwgdXRmOF9ieXRlc19uZWVkZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9wb2ludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIVJhd0J5dGUuaW5SYW5nZShfYnl0ZSwgMHg4MCwgMHhCRikpIHtcbiAgICAgICAgICAgICAgICAgICAgdXRmOF9jb2RlX3BvaW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdXRmOF9ieXRlc19uZWVkZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB1dGY4X2J5dGVzX3NlZW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9zLS07XG4gICAgICAgICAgICAgICAgICAgIGNvZGVfcG9pbnQgPSA2NTUzMyAvKiBGYXRhbF9jb2RlX3BvaW50ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRmOF9ieXRlc19zZWVuICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHV0ZjhfY29kZV9wb2ludCA9IHV0ZjhfY29kZV9wb2ludCArIChfYnl0ZSAtIDB4ODApICogTWF0aC5wb3coNjQsIHV0ZjhfYnl0ZXNfbmVlZGVkIC0gdXRmOF9ieXRlc19zZWVuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHV0ZjhfYnl0ZXNfc2VlbiAhPT0gdXRmOF9ieXRlc19uZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfcG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNwID0gdXRmOF9jb2RlX3BvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvd2VyX2JvdW5kYXJ5ID0gdXRmOF9sb3dlcl9ib3VuZGFyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhfY29kZV9wb2ludCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGY4X2J5dGVzX25lZWRlZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGY4X2J5dGVzX3NlZW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRmOF9sb3dlcl9ib3VuZGFyeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUmF3Qnl0ZS5pblJhbmdlKGNwLCBsb3dlcl9ib3VuZGFyeSwgMHgxMEZGRkYpICYmICF0aGlzLmluUmFuZ2UoY3AsIDB4RDgwMCwgMHhERkZGKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfcG9pbnQgPSBjcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfcG9pbnQgPSBfYnl0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vRGVjb2RlIHN0cmluZ1xuICAgICAgICAgICAgaWYgKGNvZGVfcG9pbnQgIT09IG51bGwgJiYgY29kZV9wb2ludCAhPT0gLTEgLyogRU9GX2NvZGVfcG9pbnQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZV9wb2ludCA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVfcG9pbnQgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZV9wb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlX3BvaW50IC09IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArICgoY29kZV9wb2ludCA+PiAxMCkgJiAweDNmZikpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweERDMDAgKyAoY29kZV9wb2ludCAmIDB4M2ZmKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG52YXIgQnVmZmVyVHlwZTtcbihmdW5jdGlvbiAoQnVmZmVyVHlwZSkge1xuICAgIEJ1ZmZlclR5cGVbQnVmZmVyVHlwZVtcIkJMT0NLXCJdID0gMF0gPSBcIkJMT0NLXCI7XG4gICAgQnVmZmVyVHlwZVtCdWZmZXJUeXBlW1wiQURBUFRJVkVcIl0gPSAxXSA9IFwiQURBUFRJVkVcIjtcbn0pKEJ1ZmZlclR5cGUgfHwgKEJ1ZmZlclR5cGUgPSB7fSkpO1xuLyoqIEBkZWZpbmUge251bWJlcn0gYnVmZmVyIGJsb2NrIHNpemUuICovXG5jb25zdCBaTElCX1JBV19JTkZMQVRFX0JVRkZFUl9TSVpFID0gMHg4MDAwOyAvLyBbIDB4ODAwMCA+PSBaTElCX0JVRkZFUl9CTE9DS19TSVpFIF1cbmNvbnN0IE1heEJhY2t3YXJkTGVuZ3RoID0gMzI3Njg7XG5jb25zdCBNYXhDb3B5TGVuZ3RoID0gMjU4O1xuY29uc3QgT3JkZXIgPSBuZXcgVWludDE2QXJyYXkoWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdKTtcbmNvbnN0IExlbmd0aENvZGVUYWJsZSA9IG5ldyBVaW50MTZBcnJheShbXG4gICAgMHgwMDAzLCAweDAwMDQsIDB4MDAwNSwgMHgwMDA2LCAweDAwMDcsIDB4MDAwOCwgMHgwMDA5LCAweDAwMGEsIDB4MDAwYixcbiAgICAweDAwMGQsIDB4MDAwZiwgMHgwMDExLCAweDAwMTMsIDB4MDAxNywgMHgwMDFiLCAweDAwMWYsIDB4MDAyMywgMHgwMDJiLFxuICAgIDB4MDAzMywgMHgwMDNiLCAweDAwNDMsIDB4MDA1MywgMHgwMDYzLCAweDAwNzMsIDB4MDA4MywgMHgwMGEzLCAweDAwYzMsXG4gICAgMHgwMGUzLCAweDAxMDIsIDB4MDEwMiwgMHgwMTAyXG5dKTtcbmNvbnN0IExlbmd0aEV4dHJhVGFibGUgPSBuZXcgVWludDhBcnJheShbXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSxcbiAgICA1LCA1LCAwLCAwLCAwXG5dKTtcbmNvbnN0IERpc3RDb2RlVGFibGUgPSBuZXcgVWludDE2QXJyYXkoW1xuICAgIDB4MDAwMSwgMHgwMDAyLCAweDAwMDMsIDB4MDAwNCwgMHgwMDA1LCAweDAwMDcsIDB4MDAwOSwgMHgwMDBkLCAweDAwMTEsXG4gICAgMHgwMDE5LCAweDAwMjEsIDB4MDAzMSwgMHgwMDQxLCAweDAwNjEsIDB4MDA4MSwgMHgwMGMxLCAweDAxMDEsIDB4MDE4MSxcbiAgICAweDAyMDEsIDB4MDMwMSwgMHgwNDAxLCAweDA2MDEsIDB4MDgwMSwgMHgwYzAxLCAweDEwMDEsIDB4MTgwMSwgMHgyMDAxLFxuICAgIDB4MzAwMSwgMHg0MDAxLCAweDYwMDFcbl0pO1xuY29uc3QgRGlzdEV4dHJhVGFibGUgPSBuZXcgVWludDhBcnJheShbXG4gICAgMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSxcbiAgICAxMSwgMTIsIDEyLCAxMywgMTNcbl0pO1xuY29uc3QgYnVpbGRIdWZmbWFuVGFibGUgPSAobGVuZ3RocykgPT4ge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBsZW5ndGggbGlzdCBzaXplLiAqL1xuICAgIHZhciBsaXN0U2l6ZSA9IGxlbmd0aHMubGVuZ3RoO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBtYXggY29kZSBsZW5ndGggZm9yIHRhYmxlIHNpemUuICovXG4gICAgdmFyIG1heENvZGVMZW5ndGggPSAwO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBtaW4gY29kZSBsZW5ndGggZm9yIHRhYmxlIHNpemUuICovXG4gICAgdmFyIG1pbkNvZGVMZW5ndGggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9IHRhYmxlIHNpemUuICovXG4gICAgdmFyIHNpemU7XG4gICAgLyoqIEB0eXBlIHshKEFycmF5fFVpbnQ4QXJyYXkpfSBodWZmbWFuIGNvZGUgdGFibGUuICovXG4gICAgdmFyIHRhYmxlO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBiaXQgbGVuZ3RoLiAqL1xuICAgIHZhciBiaXRMZW5ndGg7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9IGh1ZmZtYW4gY29kZS4gKi9cbiAgICB2YXIgY29kZTtcbiAgICAvKipcbiAgICAgKiDjgrXjgqTjgrrjgYwgMl5tYXhsZW5ndGgg5YCL44Gu44OG44O844OW44Or44KS5Z+L44KB44KL44Gf44KB44Gu44K544Kt44OD44OX6ZW3LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9IHNraXAgbGVuZ3RoIGZvciB0YWJsZSBmaWxsaW5nLlxuICAgICAqL1xuICAgIHZhciBza2lwO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSByZXZlcnNlZCBjb2RlLiAqL1xuICAgIHZhciByZXZlcnNlZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gcmV2ZXJzZSB0ZW1wLiAqL1xuICAgIHZhciBydGVtcDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gbG9vcCBjb3VudGVyLiAqL1xuICAgIHZhciBpO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBsb29wIGxpbWl0LiAqL1xuICAgIHZhciBpbDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gbG9vcCBjb3VudGVyLiAqL1xuICAgIHZhciBqO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSB0YWJsZSB2YWx1ZS4gKi9cbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gTWF0aC5tYXgg44Gv6YGF44GE44Gu44Gn5pyA6ZW344Gu5YCk44GvIGZvci1sb29wIOOBp+WPluW+l+OBmeOCi1xuICAgIGZvciAoaSA9IDAsIGlsID0gbGlzdFNpemU7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIGlmIChsZW5ndGhzW2ldID4gbWF4Q29kZUxlbmd0aCkge1xuICAgICAgICAgICAgbWF4Q29kZUxlbmd0aCA9IGxlbmd0aHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aHNbaV0gPCBtaW5Db2RlTGVuZ3RoKSB7XG4gICAgICAgICAgICBtaW5Db2RlTGVuZ3RoID0gbGVuZ3Roc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaXplID0gMSA8PCBtYXhDb2RlTGVuZ3RoO1xuICAgIHRhYmxlID0gbmV3IFVpbnQzMkFycmF5KHNpemUpO1xuICAgIC8vIOODk+ODg+ODiOmVt+OBruefreOBhOmghuOBi+OCieODj+ODleODnuODs+espuWPt+OCkuWJsuOCiuW9k+OBpuOCi1xuICAgIGZvciAoYml0TGVuZ3RoID0gMSwgY29kZSA9IDAsIHNraXAgPSAyOyBiaXRMZW5ndGggPD0gbWF4Q29kZUxlbmd0aDspIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RTaXplOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChsZW5ndGhzW2ldID09PSBiaXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyDjg5Pjg4Pjg4jjgqrjg7zjg4Djg7zjgYzpgIbjgavjgarjgovjgZ/jgoHjg5Pjg4Pjg4jplbfliIbkuKbjgbPjgpLlj43ou6LjgZnjgotcbiAgICAgICAgICAgICAgICBmb3IgKHJldmVyc2VkID0gMCwgcnRlbXAgPSBjb2RlLCBqID0gMDsgaiA8IGJpdExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VkID0gKHJldmVyc2VkIDw8IDEpIHwgKHJ0ZW1wICYgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJ0ZW1wID4+PSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyDmnIDlpKfjg5Pjg4Pjg4jplbfjgpLjgoLjgajjgavjg4bjg7zjg5bjg6vjgpLkvZzjgovjgZ/jgoHjgIFcbiAgICAgICAgICAgICAgICAvLyDmnIDlpKfjg5Pjg4Pjg4jplbfku6XlpJbjgafjga8gMCAvIDEg44Gp44Gh44KJ44Gn44KC6Imv44GE566H5omA44GM44Gn44GN44KLXG4gICAgICAgICAgICAgICAgLy8g44Gd44Gu44Gp44Gh44KJ44Gn44KC6Imv44GE5aC05omA44Gv5ZCM44GY5YCk44Gn5Z+L44KB44KL44GT44Go44GnXG4gICAgICAgICAgICAgICAgLy8g5pys5p2l44Gu44OT44OD44OI6ZW35Lul5LiK44Gu44OT44OD44OI5pWw5Y+W5b6X44GX44Gm44KC5ZWP6aGM44GM6LW344GT44KJ44Gq44GE44KI44GG44Gr44GZ44KLXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoYml0TGVuZ3RoIDw8IDE2KSB8IGk7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gcmV2ZXJzZWQ7IGogPCBzaXplOyBqICs9IHNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVbal0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOasoeOBruODk+ODg+ODiOmVt+OBuFxuICAgICAgICArK2JpdExlbmd0aDtcbiAgICAgICAgY29kZSA8PD0gMTtcbiAgICAgICAgc2tpcCA8PD0gMTtcbiAgICB9XG4gICAgcmV0dXJuIFt0YWJsZSwgbWF4Q29kZUxlbmd0aCwgbWluQ29kZUxlbmd0aF07XG59O1xuY29uc3QgRml4ZWRMaXRlcmFsTGVuZ3RoVGFibGUgPSAoKCkgPT4ge1xuICAgIGxldCBsZW5ndGhzID0gbmV3IFVpbnQ4QXJyYXkoMjg4KTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBsZW5ndGhzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgbGVuZ3Roc1tpXSA9XG4gICAgICAgICAgICAoaSA8PSAxNDMpID8gOCA6XG4gICAgICAgICAgICAgICAgKGkgPD0gMjU1KSA/IDkgOlxuICAgICAgICAgICAgICAgICAgICAoaSA8PSAyNzkpID8gNyA6XG4gICAgICAgICAgICAgICAgICAgICAgICA4O1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGRIdWZmbWFuVGFibGUobGVuZ3RocylbMF07XG59KSgpO1xuY29uc3QgRml4ZWREaXN0YW5jZVRhYmxlID0gKCgpID0+IHtcbiAgICBsZXQgbGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDMwKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBsZW5ndGhzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgbGVuZ3Roc1tpXSA9IDU7XG4gICAgfVxuICAgIHJldHVybiBidWlsZEh1ZmZtYW5UYWJsZShsZW5ndGhzKTtcbn0pKCk7XG5jbGFzcyBSYXdJbmZsYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCwgb3B0X3BhcmFtcykge1xuICAgICAgICB0aGlzLmJsb2NrcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBaTElCX1JBV19JTkZMQVRFX0JVRkZFUl9TSVpFO1xuICAgICAgICB0aGlzLnRvdGFscG9zID0gMDtcbiAgICAgICAgdGhpcy5pcCA9IDA7XG4gICAgICAgIHRoaXMuYml0c2J1ZiA9IDA7XG4gICAgICAgIHRoaXMuYml0c2J1ZmxlbiA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgICAgIHRoaXMuYmZpbmFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyVHlwZSA9IEJ1ZmZlclR5cGUuQURBUFRJVkU7XG4gICAgICAgIHRoaXMucmVzaXplID0gZmFsc2U7XG4gICAgICAgIC8vIG9wdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgIGlmIChvcHRfcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAob3B0X3BhcmFtc1snaW5kZXgnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXAgPSBvcHRfcGFyYW1zWydpbmRleCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdF9wYXJhbXNbJ2J1ZmZlclNpemUnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyU2l6ZSA9IG9wdF9wYXJhbXNbJ2J1ZmZlclNpemUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRfcGFyYW1zWydidWZmZXJUeXBlJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlclR5cGUgPSBvcHRfcGFyYW1zWydidWZmZXJUeXBlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0X3BhcmFtc1sncmVzaXplJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSA9IG9wdF9wYXJhbXNbJ3Jlc2l6ZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgICAgc3dpdGNoICh0aGlzLmJ1ZmZlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQnVmZmVyVHlwZS5CTE9DSzpcbiAgICAgICAgICAgICAgICB0aGlzLm9wID0gTWF4QmFja3dhcmRMZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSBuZXcgVWludDhBcnJheShNYXhCYWNrd2FyZExlbmd0aCArIHRoaXMuYnVmZmVyU2l6ZSArIE1heENvcHlMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWZmZXJUeXBlLkFEQVBUSVZFOlxuICAgICAgICAgICAgICAgIHRoaXMub3AgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXJTaXplKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluZmxhdGUgbW9kZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29tcHJlc3MoKSB7XG4gICAgICAgIHdoaWxlICghdGhpcy5iZmluYWwpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VCbG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5idWZmZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEJ1ZmZlclR5cGUuQkxPQ0s6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uY2F0QnVmZmVyQmxvY2soKTtcbiAgICAgICAgICAgIGNhc2UgQnVmZmVyVHlwZS5BREFQVElWRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25jYXRCdWZmZXJEeW5hbWljKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmZsYXRlIG1vZGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZUJsb2NrKCkge1xuICAgICAgICBsZXQgaGRyID0gdGhpcy5yZWFkQml0cygzKTtcbiAgICAgICAgaWYgKGhkciAmIDB4MSkge1xuICAgICAgICAgICAgdGhpcy5iZmluYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGhkciA+Pj49IDE7XG4gICAgICAgIHN3aXRjaCAoaGRyKSB7XG4gICAgICAgICAgICAvLyB1bmNvbXByZXNzZWRcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVW5jb21wcmVzc2VkQmxvY2soKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGZpeGVkIGh1ZmZtYW5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRml4ZWRIdWZmbWFuQmxvY2soKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGR5bmFtaWMgaHVmZm1hblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VEeW5hbWljSHVmZm1hbkJsb2NrKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyByZXNlcnZlZCBvciBvdGhlclxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gQlRZUEU6ICcgKyBoZHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICByZWFkQml0cyhsZW5ndGgpIHtcbiAgICAgICAgbGV0IGJpdHNidWYgPSB0aGlzLmJpdHNidWY7XG4gICAgICAgIGxldCBiaXRzYnVmbGVuID0gdGhpcy5iaXRzYnVmbGVuO1xuICAgICAgICBsZXQgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgICAgICBsZXQgaXAgPSB0aGlzLmlwO1xuICAgICAgICBsZXQgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIGxldCBvY3RldDtcbiAgICAgICAgaWYgKGlwICsgKChsZW5ndGggLSBiaXRzYnVmbGVuICsgNykgPj4gMykgPj0gaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgYnVmZmVyIGlzIGJyb2tlbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdCBlbm91Z2ggYnVmZmVyXG4gICAgICAgIHdoaWxlIChiaXRzYnVmbGVuIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBiaXRzYnVmIHw9IGlucHV0W2lwKytdIDw8IGJpdHNidWZsZW47XG4gICAgICAgICAgICBiaXRzYnVmbGVuICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3V0cHV0IGJ5dGVcbiAgICAgICAgb2N0ZXQgPSBiaXRzYnVmICYgLyogTUFTSyAqLyAoKDEgPDwgbGVuZ3RoKSAtIDEpO1xuICAgICAgICBiaXRzYnVmID4+Pj0gbGVuZ3RoO1xuICAgICAgICBiaXRzYnVmbGVuIC09IGxlbmd0aDtcbiAgICAgICAgdGhpcy5iaXRzYnVmID0gYml0c2J1ZjtcbiAgICAgICAgdGhpcy5iaXRzYnVmbGVuID0gYml0c2J1ZmxlbjtcbiAgICAgICAgdGhpcy5pcCA9IGlwO1xuICAgICAgICByZXR1cm4gb2N0ZXQ7XG4gICAgfVxuICAgIDtcbiAgICByZWFkQ29kZUJ5VGFibGUodGFibGUpIHtcbiAgICAgICAgbGV0IGJpdHNidWYgPSB0aGlzLmJpdHNidWY7XG4gICAgICAgIGxldCBiaXRzYnVmbGVuID0gdGhpcy5iaXRzYnVmbGVuO1xuICAgICAgICBsZXQgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgICAgICBsZXQgaXAgPSB0aGlzLmlwO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgbGV0IGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IGh1ZmZtYW4gY29kZSB0YWJsZSAqL1xuICAgICAgICBsZXQgY29kZVRhYmxlID0gdGFibGVbMF07XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBsZXQgbWF4Q29kZUxlbmd0aCA9IHRhYmxlWzFdO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gY29kZSBsZW5ndGggJiBjb2RlICgxNmJpdCwgMTZiaXQpICovXG4gICAgICAgIGxldCBjb2RlV2l0aExlbmd0aDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IGNvZGUgYml0cyBsZW5ndGggKi9cbiAgICAgICAgbGV0IGNvZGVMZW5ndGg7XG4gICAgICAgIC8vIG5vdCBlbm91Z2ggYnVmZmVyXG4gICAgICAgIHdoaWxlIChiaXRzYnVmbGVuIDwgbWF4Q29kZUxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGlwID49IGlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRzYnVmIHw9IGlucHV0W2lwKytdIDw8IGJpdHNidWZsZW47XG4gICAgICAgICAgICBiaXRzYnVmbGVuICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZCBtYXggbGVuZ3RoXG4gICAgICAgIGNvZGVXaXRoTGVuZ3RoID0gY29kZVRhYmxlW2JpdHNidWYgJiAoKDEgPDwgbWF4Q29kZUxlbmd0aCkgLSAxKV07XG4gICAgICAgIGNvZGVMZW5ndGggPSBjb2RlV2l0aExlbmd0aCA+Pj4gMTY7XG4gICAgICAgIGlmIChjb2RlTGVuZ3RoID4gYml0c2J1Zmxlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvZGUgbGVuZ3RoOiAnICsgY29kZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaXRzYnVmID0gYml0c2J1ZiA+PiBjb2RlTGVuZ3RoO1xuICAgICAgICB0aGlzLmJpdHNidWZsZW4gPSBiaXRzYnVmbGVuIC0gY29kZUxlbmd0aDtcbiAgICAgICAgdGhpcy5pcCA9IGlwO1xuICAgICAgICByZXR1cm4gY29kZVdpdGhMZW5ndGggJiAweGZmZmY7XG4gICAgfVxuICAgIDtcbiAgICBwYXJzZVVuY29tcHJlc3NlZEJsb2NrKCkge1xuICAgICAgICBsZXQgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgICAgICBsZXQgaXAgPSB0aGlzLmlwO1xuICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy5vdXRwdXQ7XG4gICAgICAgIGxldCBvcCA9IHRoaXMub3A7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBsZXQgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBibG9jayBsZW5ndGggKi9cbiAgICAgICAgbGV0IGxlbjtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IG51bWJlciBmb3IgY2hlY2sgYmxvY2sgbGVuZ3RoICovXG4gICAgICAgIGxldCBubGVuO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gb3V0cHV0IGJ1ZmZlciBsZW5ndGggKi9cbiAgICAgICAgbGV0IG9sZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gY29weSBjb3VudGVyICovXG4gICAgICAgIGxldCBwcmVDb3B5O1xuICAgICAgICAvLyBza2lwIGJ1ZmZlcmVkIGhlYWRlciBiaXRzXG4gICAgICAgIHRoaXMuYml0c2J1ZiA9IDA7XG4gICAgICAgIHRoaXMuYml0c2J1ZmxlbiA9IDA7XG4gICAgICAgIC8vIGxlblxuICAgICAgICBpZiAoaXAgKyAxID49IGlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdW5jb21wcmVzc2VkIGJsb2NrIGhlYWRlcjogTEVOJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG4gICAgICAgIC8vIG5sZW5cbiAgICAgICAgaWYgKGlwICsgMSA+PSBpbnB1dExlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IE5MRU4nKTtcbiAgICAgICAgfVxuICAgICAgICBubGVuID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG4gICAgICAgIC8vIGNoZWNrIGxlbiAmIG5sZW5cbiAgICAgICAgaWYgKGxlbiA9PT0gfm5sZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB1bmNvbXByZXNzZWQgYmxvY2sgaGVhZGVyOiBsZW5ndGggdmVyaWZ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgc2l6ZVxuICAgICAgICBpZiAoaXAgKyBsZW4gPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgYnVmZmVyIGlzIGJyb2tlbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cGFuZCBidWZmZXJcbiAgICAgICAgc3dpdGNoICh0aGlzLmJ1ZmZlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQnVmZmVyVHlwZS5CTE9DSzpcbiAgICAgICAgICAgICAgICAvLyBwcmUgY29weVxuICAgICAgICAgICAgICAgIHdoaWxlIChvcCArIGxlbiA+IG91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlQ29weSA9IG9sZW5ndGggLSBvcDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IHByZUNvcHk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXQoaW5wdXQuc3ViYXJyYXkoaXAsIGlwICsgcHJlQ29weSksIG9wKTtcbiAgICAgICAgICAgICAgICAgICAgb3AgKz0gcHJlQ29weTtcbiAgICAgICAgICAgICAgICAgICAgaXAgKz0gcHJlQ29weTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmV4cGFuZEJ1ZmZlckJsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIG9wID0gdGhpcy5vcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1ZmZlclR5cGUuQURBUFRJVkU6XG4gICAgICAgICAgICAgICAgd2hpbGUgKG9wICsgbGVuID4gb3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmV4cGFuZEJ1ZmZlckFkYXB0aXZlKHsgZml4UmF0aW86IDIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5mbGF0ZSBtb2RlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weVxuICAgICAgICBvdXRwdXQuc2V0KGlucHV0LnN1YmFycmF5KGlwLCBpcCArIGxlbiksIG9wKTtcbiAgICAgICAgb3AgKz0gbGVuO1xuICAgICAgICBpcCArPSBsZW47XG4gICAgICAgIHRoaXMuaXAgPSBpcDtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICB9XG4gICAgO1xuICAgIHBhcnNlRml4ZWRIdWZmbWFuQmxvY2soKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5idWZmZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEJ1ZmZlclR5cGUuQURBUFRJVkU6XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVIdWZmbWFuQWRhcHRpdmUoRml4ZWRMaXRlcmFsTGVuZ3RoVGFibGUsIEZpeGVkRGlzdGFuY2VUYWJsZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1ZmZlclR5cGUuQkxPQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVIdWZmbWFuQmxvY2soRml4ZWRMaXRlcmFsTGVuZ3RoVGFibGUsIEZpeGVkRGlzdGFuY2VUYWJsZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmZsYXRlIG1vZGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZUR5bmFtaWNIdWZmbWFuQmxvY2soKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBudW1iZXIgb2YgbGl0ZXJhbCBhbmQgbGVuZ3RoIGNvZGVzLiAqL1xuICAgICAgICBsZXQgaGxpdCA9IHRoaXMucmVhZEJpdHMoNSkgKyAyNTc7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMuICovXG4gICAgICAgIGxldCBoZGlzdCA9IHRoaXMucmVhZEJpdHMoNSkgKyAxO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gbnVtYmVyIG9mIGNvZGUgbGVuZ3Rocy4gKi9cbiAgICAgICAgbGV0IGhjbGVuID0gdGhpcy5yZWFkQml0cyg0KSArIDQ7XG4gICAgICAgIC8qKiBAdHlwZSB7IShVaW50OEFycmF5fEFycmF5LjxudW1iZXI+KX0gY29kZSBsZW5ndGhzLiAqL1xuICAgICAgICBsZXQgY29kZUxlbmd0aHMgPSBuZXcgVWludDhBcnJheShPcmRlci5sZW5ndGgpO1xuICAgICAgICAvKiogQHR5cGUgeyFBcnJheX0gY29kZSBsZW5ndGhzIHRhYmxlLiAqL1xuICAgICAgICBsZXQgY29kZUxlbmd0aHNUYWJsZTtcbiAgICAgICAgLyoqIEB0eXBlIHshKFVpbnQ4QXJyYXl8QXJyYXkuPG51bWJlcj4pfSBsaXRlcmFsIGFuZCBsZW5ndGggY29kZSB0YWJsZS4gKi9cbiAgICAgICAgbGV0IGxpdGxlblRhYmxlO1xuICAgICAgICAvKiogQHR5cGUgeyEoVWludDhBcnJheXxBcnJheS48bnVtYmVyPil9IGRpc3RhbmNlIGNvZGUgdGFibGUuICovXG4gICAgICAgIGxldCBkaXN0VGFibGU7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGxldCBwcmV2O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgbGV0IHJlcGVhdDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IGxvb3AgY291bnRlci4gKi9cbiAgICAgICAgbGV0IGk7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBsb29wIGxpbWl0LiAqL1xuICAgICAgICBsZXQgaWw7XG4gICAgICAgIC8vIGRlY29kZSBjb2RlIGxlbmd0aHNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGhjbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvZGVMZW5ndGhzW09yZGVyW2ldXSA9IHRoaXMucmVhZEJpdHMoMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVjb2RlIGxlbmd0aCB0YWJsZVxuICAgICAgICBjb2RlTGVuZ3Roc1RhYmxlID0gYnVpbGRIdWZmbWFuVGFibGUoY29kZUxlbmd0aHMpO1xuICAgICAgICBsZXQgbGVuZ3RoVGFibGUgPSBuZXcgVWludDhBcnJheShobGl0ICsgaGRpc3QpO1xuICAgICAgICBmb3IgKGkgPSAwLCBpbCA9IGhsaXQgKyBoZGlzdDsgaSA8IGlsOykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMucmVhZENvZGVCeVRhYmxlKGNvZGVMZW5ndGhzVGFibGUpO1xuICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gMyArIHRoaXMucmVhZEJpdHMoMik7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZXBlYXQtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoVGFibGVbaSsrXSA9IHByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gMyArIHRoaXMucmVhZEJpdHMoMyk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZXBlYXQtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoVGFibGVbaSsrXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IDExICsgdGhpcy5yZWFkQml0cyg3KTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlcGVhdC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhUYWJsZVtpKytdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoVGFibGVbaSsrXSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgIHByZXYgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaXRsZW5UYWJsZSA9IGJ1aWxkSHVmZm1hblRhYmxlKGxlbmd0aFRhYmxlLnN1YmFycmF5KDAsIGhsaXQpKTtcbiAgICAgICAgZGlzdFRhYmxlID0gYnVpbGRIdWZmbWFuVGFibGUobGVuZ3RoVGFibGUuc3ViYXJyYXkoaGxpdCkpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuYnVmZmVyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBCdWZmZXJUeXBlLkFEQVBUSVZFOlxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlSHVmZm1hbkFkYXB0aXZlKGxpdGxlblRhYmxlLCBkaXN0VGFibGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWZmZXJUeXBlLkJMT0NLOlxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlSHVmZm1hbkJsb2NrKGxpdGxlblRhYmxlLCBkaXN0VGFibGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5mbGF0ZSBtb2RlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVjb2RlSHVmZm1hbkJsb2NrKGxpdGxlbiwgZGlzdCkge1xuICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy5vdXRwdXQ7XG4gICAgICAgIGxldCBvcCA9IHRoaXMub3A7XG4gICAgICAgIHRoaXMuY3VycmVudExpdGxlblRhYmxlID0gbGl0bGVuO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gb3V0cHV0IHBvc2l0aW9uIGxpbWl0LiAqL1xuICAgICAgICBsZXQgb2xlbmd0aCA9IG91dHB1dC5sZW5ndGggLSBNYXhDb3B5TGVuZ3RoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gaHVmZm1hbiBjb2RlLiAqL1xuICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IHRhYmxlIGluZGV4LiAqL1xuICAgICAgICBsZXQgdGk7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBodWZmbWFuIGNvZGUgZGlzdGluYXRpb24uICovXG4gICAgICAgIGxldCBjb2RlRGlzdDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IGh1ZmZtYW4gY29kZSBsZW5ndGguICovXG4gICAgICAgIGxldCBjb2RlTGVuZ3RoO1xuICAgICAgICBsZXQgbGVuZ3RoQ29kZVRhYmxlID0gTGVuZ3RoQ29kZVRhYmxlO1xuICAgICAgICBsZXQgbGVuZ3RoRXh0cmFUYWJsZSA9IExlbmd0aEV4dHJhVGFibGU7XG4gICAgICAgIGxldCBkaXN0Q29kZVRhYmxlID0gRGlzdENvZGVUYWJsZTtcbiAgICAgICAgbGV0IGRpc3RFeHRyYVRhYmxlID0gRGlzdEV4dHJhVGFibGU7XG4gICAgICAgIHdoaWxlICgoY29kZSA9IHRoaXMucmVhZENvZGVCeVRhYmxlKGxpdGxlbikpICE9PSAyNTYpIHtcbiAgICAgICAgICAgIC8vIGxpdGVyYWxcbiAgICAgICAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wID49IG9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmV4cGFuZEJ1ZmZlckJsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIG9wID0gdGhpcy5vcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0W29wKytdID0gY29kZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxlbmd0aCBjb2RlXG4gICAgICAgICAgICB0aSA9IGNvZGUgLSAyNTc7XG4gICAgICAgICAgICBjb2RlTGVuZ3RoID0gbGVuZ3RoQ29kZVRhYmxlW3RpXTtcbiAgICAgICAgICAgIGlmIChsZW5ndGhFeHRyYVRhYmxlW3RpXSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb2RlTGVuZ3RoICs9IHRoaXMucmVhZEJpdHMobGVuZ3RoRXh0cmFUYWJsZVt0aV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGlzdCBjb2RlXG4gICAgICAgICAgICBjb2RlID0gdGhpcy5yZWFkQ29kZUJ5VGFibGUoZGlzdCk7XG4gICAgICAgICAgICBjb2RlRGlzdCA9IGRpc3RDb2RlVGFibGVbY29kZV07XG4gICAgICAgICAgICBpZiAoZGlzdEV4dHJhVGFibGVbY29kZV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgY29kZURpc3QgKz0gdGhpcy5yZWFkQml0cyhkaXN0RXh0cmFUYWJsZVtjb2RlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsejc3IGRlY29kZVxuICAgICAgICAgICAgaWYgKG9wID49IG9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5leHBhbmRCdWZmZXJCbG9jaygpO1xuICAgICAgICAgICAgICAgIG9wID0gdGhpcy5vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb2RlTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbb3BdID0gb3V0cHV0WyhvcCsrKSAtIGNvZGVEaXN0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5iaXRzYnVmbGVuID49IDgpIHtcbiAgICAgICAgICAgIHRoaXMuYml0c2J1ZmxlbiAtPSA4O1xuICAgICAgICAgICAgdGhpcy5pcC0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICB9XG4gICAgO1xuICAgIGRlY29kZUh1ZmZtYW5BZGFwdGl2ZShsaXRsZW4sIGRpc3QpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IHRoaXMub3V0cHV0O1xuICAgICAgICBsZXQgb3AgPSB0aGlzLm9wO1xuICAgICAgICB0aGlzLmN1cnJlbnRMaXRsZW5UYWJsZSA9IGxpdGxlbjtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IG91dHB1dCBwb3NpdGlvbiBsaW1pdC4gKi9cbiAgICAgICAgbGV0IG9sZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gaHVmZm1hbiBjb2RlLiAqL1xuICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IHRhYmxlIGluZGV4LiAqL1xuICAgICAgICBsZXQgdGk7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBodWZmbWFuIGNvZGUgZGlzdGluYXRpb24uICovXG4gICAgICAgIGxldCBjb2RlRGlzdDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IGh1ZmZtYW4gY29kZSBsZW5ndGguICovXG4gICAgICAgIGxldCBjb2RlTGVuZ3RoO1xuICAgICAgICBsZXQgbGVuZ3RoQ29kZVRhYmxlID0gTGVuZ3RoQ29kZVRhYmxlO1xuICAgICAgICBsZXQgbGVuZ3RoRXh0cmFUYWJsZSA9IExlbmd0aEV4dHJhVGFibGU7XG4gICAgICAgIGxldCBkaXN0Q29kZVRhYmxlID0gRGlzdENvZGVUYWJsZTtcbiAgICAgICAgbGV0IGRpc3RFeHRyYVRhYmxlID0gRGlzdEV4dHJhVGFibGU7XG4gICAgICAgIHdoaWxlICgoY29kZSA9IHRoaXMucmVhZENvZGVCeVRhYmxlKGxpdGxlbikpICE9PSAyNTYpIHtcbiAgICAgICAgICAgIC8vIGxpdGVyYWxcbiAgICAgICAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wID49IG9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5leHBhbmRCdWZmZXJBZGFwdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0W29wKytdID0gY29kZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxlbmd0aCBjb2RlXG4gICAgICAgICAgICB0aSA9IGNvZGUgLSAyNTc7XG4gICAgICAgICAgICBjb2RlTGVuZ3RoID0gbGVuZ3RoQ29kZVRhYmxlW3RpXTtcbiAgICAgICAgICAgIGlmIChsZW5ndGhFeHRyYVRhYmxlW3RpXSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb2RlTGVuZ3RoICs9IHRoaXMucmVhZEJpdHMobGVuZ3RoRXh0cmFUYWJsZVt0aV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGlzdCBjb2RlXG4gICAgICAgICAgICBjb2RlID0gdGhpcy5yZWFkQ29kZUJ5VGFibGUoZGlzdCk7XG4gICAgICAgICAgICBjb2RlRGlzdCA9IGRpc3RDb2RlVGFibGVbY29kZV07XG4gICAgICAgICAgICBpZiAoZGlzdEV4dHJhVGFibGVbY29kZV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgY29kZURpc3QgKz0gdGhpcy5yZWFkQml0cyhkaXN0RXh0cmFUYWJsZVtjb2RlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsejc3IGRlY29kZVxuICAgICAgICAgICAgaWYgKG9wICsgY29kZUxlbmd0aCA+IG9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmV4cGFuZEJ1ZmZlckFkYXB0aXZlKCk7XG4gICAgICAgICAgICAgICAgb2xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29kZUxlbmd0aC0tKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W29wXSA9IG91dHB1dFsob3ArKykgLSBjb2RlRGlzdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuYml0c2J1ZmxlbiA+PSA4KSB7XG4gICAgICAgICAgICB0aGlzLmJpdHNidWZsZW4gLT0gODtcbiAgICAgICAgICAgIHRoaXMuaXAtLTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgfVxuICAgIGV4cGFuZEJ1ZmZlckJsb2NrKCkge1xuICAgICAgICBsZXQgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vcCAtIE1heEJhY2t3YXJkTGVuZ3RoKTtcbiAgICAgICAgbGV0IGJhY2t3YXJkID0gdGhpcy5vcCAtIE1heEJhY2t3YXJkTGVuZ3RoO1xuICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy5vdXRwdXQ7XG4gICAgICAgIC8vIGNvcHkgdG8gb3V0cHV0IGJ1ZmZlclxuICAgICAgICBidWZmZXIuc2V0KG91dHB1dC5zdWJhcnJheShNYXhCYWNrd2FyZExlbmd0aCwgYnVmZmVyLmxlbmd0aCkpO1xuICAgICAgICB0aGlzLmJsb2Nrcy5wdXNoKGJ1ZmZlcik7XG4gICAgICAgIHRoaXMudG90YWxwb3MgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgLy8gY29weSB0byBiYWNrd2FyZCBidWZmZXJcbiAgICAgICAgb3V0cHV0LnNldChvdXRwdXQuc3ViYXJyYXkoYmFja3dhcmQsIGJhY2t3YXJkICsgTWF4QmFja3dhcmRMZW5ndGgpKTtcbiAgICAgICAgdGhpcy5vcCA9IE1heEJhY2t3YXJkTGVuZ3RoO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBleHBhbmRCdWZmZXJBZGFwdGl2ZShvcHRfcGFyYW0pIHtcbiAgICAgICAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBzdG9yZSBidWZmZXIuICovXG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBleHBhbnRpb24gcmF0aW8uICovXG4gICAgICAgIGxldCByYXRpbyA9ICh0aGlzLmlucHV0Lmxlbmd0aCAvIHRoaXMuaXAgKyAxKSB8IDA7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBtYXhpbXVtIG51bWJlciBvZiBodWZmbWFuIGNvZGUuICovXG4gICAgICAgIGxldCBtYXhIdWZmQ29kZTtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IG5ldyBvdXRwdXQgYnVmZmVyIHNpemUuICovXG4gICAgICAgIGxldCBuZXdTaXplO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gbWF4IGluZmxhdGUgc2l6ZS4gKi9cbiAgICAgICAgbGV0IG1heEluZmxhdGVTaXplO1xuICAgICAgICBsZXQgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy5vdXRwdXQ7XG4gICAgICAgIGlmIChvcHRfcGFyYW0pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0X3BhcmFtLmZpeFJhdGlvID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJhdGlvID0gb3B0X3BhcmFtLmZpeFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRfcGFyYW0uYWRkUmF0aW8gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmF0aW8gKz0gb3B0X3BhcmFtLmFkZFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBuZXcgYnVmZmVyIHNpemVcbiAgICAgICAgaWYgKHJhdGlvIDwgMikge1xuICAgICAgICAgICAgbWF4SHVmZkNvZGUgPVxuICAgICAgICAgICAgICAgIChpbnB1dC5sZW5ndGggLSB0aGlzLmlwKSAvIHRoaXMuY3VycmVudExpdGxlblRhYmxlWzJdO1xuICAgICAgICAgICAgbWF4SW5mbGF0ZVNpemUgPSAobWF4SHVmZkNvZGUgLyAyICogMjU4KSB8IDA7XG4gICAgICAgICAgICBuZXdTaXplID0gbWF4SW5mbGF0ZVNpemUgPCBvdXRwdXQubGVuZ3RoID9cbiAgICAgICAgICAgICAgICBvdXRwdXQubGVuZ3RoICsgbWF4SW5mbGF0ZVNpemUgOlxuICAgICAgICAgICAgICAgIG91dHB1dC5sZW5ndGggPDwgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1NpemUgPSBvdXRwdXQubGVuZ3RoICogcmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3U2l6ZSk7XG4gICAgICAgIGJ1ZmZlci5zZXQob3V0cHV0KTtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBidWZmZXI7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dDtcbiAgICB9XG4gICAgO1xuICAgIGNvbmNhdEJ1ZmZlckJsb2NrKCkge1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gYnVmZmVyIHBvaW50ZXIuICovXG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gYnVmZmVyIHBvaW50ZXIuICovXG4gICAgICAgIGxldCBsaW1pdCA9IHRoaXMudG90YWxwb3MgKyAodGhpcy5vcCAtIE1heEJhY2t3YXJkTGVuZ3RoKTtcbiAgICAgICAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBvdXRwdXQgYmxvY2sgYXJyYXkuICovXG4gICAgICAgIGxldCBvdXRwdXQgPSB0aGlzLm91dHB1dDtcbiAgICAgICAgLyoqIEB0eXBlIHshQXJyYXl9IGJsb2NrcyBhcnJheS4gKi9cbiAgICAgICAgbGV0IGJsb2NrcyA9IHRoaXMuYmxvY2tzO1xuICAgICAgICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IG91dHB1dCBibG9jayBhcnJheS4gKi9cbiAgICAgICAgbGV0IGJsb2NrO1xuICAgICAgICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IG91dHB1dCBidWZmZXIuICovXG4gICAgICAgIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheShsaW1pdCk7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBsb29wIGNvdW50ZXIuICovXG4gICAgICAgIGxldCBpO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gbG9vcCBsaW1pdGVyLiAqL1xuICAgICAgICBsZXQgaWw7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBsb29wIGNvdW50ZXIuICovXG4gICAgICAgIGxldCBqO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gbG9vcCBsaW1pdGVyLiAqL1xuICAgICAgICBsZXQgamw7XG4gICAgICAgIC8vIHNpbmdsZSBidWZmZXJcbiAgICAgICAgaWYgKGJsb2Nrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dHB1dC5zdWJhcnJheShNYXhCYWNrd2FyZExlbmd0aCwgdGhpcy5vcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSB0byBidWZmZXJcbiAgICAgICAgZm9yIChpID0gMCwgaWwgPSBibG9ja3MubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBqbCA9IGJsb2NrLmxlbmd0aDsgaiA8IGpsOyArK2opIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbcG9zKytdID0gYmxvY2tbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3VycmVudCBidWZmZXJcbiAgICAgICAgZm9yIChpID0gTWF4QmFja3dhcmRMZW5ndGgsIGlsID0gdGhpcy5vcDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgICAgIGJ1ZmZlcltwb3MrK10gPSBvdXRwdXRbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgICB9XG4gICAgO1xuICAgIGNvbmNhdEJ1ZmZlckR5bmFtaWMoKSB7XG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIGxldCBvcCA9IHRoaXMub3A7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZSkge1xuICAgICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkob3ApO1xuICAgICAgICAgICAgYnVmZmVyLnNldCh0aGlzLm91dHB1dC5zdWJhcnJheSgwLCBvcCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5vdXRwdXQuc3ViYXJyYXkoMCwgb3ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gICAgfVxufVxuXG5jbGFzcyBTdHJpbmdVdGlsIHtcbiAgICBzdGF0aWMgZW5jb2RlSFRNTChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIpXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKFwiJlwiLCBcIiZhbXA7XCIpLnJlcGxhY2UoXCI8XCIsIFwiJmx0O1wiKS5yZXBsYWNlKFwiPlwiLCBcIiZndDtcIikucmVwbGFjZShcIidcIiwgXCImYXBvcztcIik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRGaWxlTmFtZShzb3VyY2UpIHtcbiAgICAgICAgbGV0IGkgPSBzb3VyY2UubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgICBpZiAoaSAhPSAtMSlcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5zdWJzdHIoaSArIDEpO1xuICAgICAgICBpID0gc291cmNlLmxhc3RJbmRleE9mKFwiXFxcXFwiKTtcbiAgICAgICAgaWYgKGkgIT0gLTEpXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgaSA9IHNvdXJjZS5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgICAgIGlmIChpICE9IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuICAgIHN0YXRpYyBzdGFydHNXaXRoKHNvdXJjZSwgc3RyLCBpZ25vcmVDYXNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5sZW5ndGggPCBzdHIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIWlnbm9yZUNhc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSA9PSBzdHI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS50b0xvd2VyQ2FzZSgpID09IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBlbmRzV2l0aChzb3VyY2UsIHN0ciwgaWdub3JlQ2FzZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghc291cmNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbHNlIGlmIChzb3VyY2UubGVuZ3RoIDwgc3RyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc3Vic3RyaW5nKHNvdXJjZS5sZW5ndGggLSBzdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICghaWdub3JlQ2FzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlID09IHN0cjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLnRvTG93ZXJDYXNlKCkgPT0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHRyaW0odGFyZ2V0U3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmdVdGlsLnRyaW1MZWZ0KFN0cmluZ1V0aWwudHJpbVJpZ2h0KHRhcmdldFN0cmluZykpO1xuICAgIH1cbiAgICBzdGF0aWMgdHJpbUxlZnQodGFyZ2V0U3RyaW5nKSB7XG4gICAgICAgIGxldCB0ZW1wQ2hhciA9IFwiXCI7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wQ2hhciA9IHRhcmdldFN0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAodGVtcENoYXIgIT0gXCIgXCIgJiYgdGVtcENoYXIgIT0gXCJcXG5cIiAmJiB0ZW1wQ2hhciAhPSBcIlxcclwiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRTdHJpbmcuc3Vic3RyKGkpO1xuICAgIH1cbiAgICBzdGF0aWMgdHJpbVJpZ2h0KHRhcmdldFN0cmluZykge1xuICAgICAgICBsZXQgdGVtcENoYXIgPSBcIlwiO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gdGFyZ2V0U3RyaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0ZW1wQ2hhciA9IHRhcmdldFN0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAodGVtcENoYXIgIT0gXCIgXCIgJiYgdGVtcENoYXIgIT0gXCJcXG5cIiAmJiB0ZW1wQ2hhciAhPSBcIlxcclwiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRTdHJpbmcuc3Vic3RyaW5nKDAsIGkgKyAxKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbnZlcnRUb0h0bWxDb2xvcihhcmdiLCBoYXNBbHBoYSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBhbHBoYTtcbiAgICAgICAgaWYgKGhhc0FscGhhKVxuICAgICAgICAgICAgYWxwaGEgPSAoYXJnYiA+PiAyNCAmIDB4RkYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYWxwaGEgPSBcIlwiO1xuICAgICAgICBsZXQgcmVkID0gKGFyZ2IgPj4gMTYgJiAweEZGKS50b1N0cmluZygxNik7XG4gICAgICAgIGxldCBncmVlbiA9IChhcmdiID4+IDggJiAweEZGKS50b1N0cmluZygxNik7XG4gICAgICAgIGxldCBibHVlID0gKGFyZ2IgJiAweEZGKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChhbHBoYS5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIGFscGhhID0gYDAke2FscGhhfWA7XG4gICAgICAgIGlmIChyZWQubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZWQgPSBgMCR7cmVkfWA7XG4gICAgICAgIGlmIChncmVlbi5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIGdyZWVuID0gYDAke2dyZWVufWA7XG4gICAgICAgIGlmIChibHVlLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgYmx1ZSA9IGAwJHtibHVlfWA7XG4gICAgICAgIHJldHVybiBgIyR7YWxwaGF9JHtyZWR9JHtncmVlbn0ke2JsdWV9YDtcbiAgICB9XG4gICAgc3RhdGljIGNvbnZlcnRGcm9tSHRtbENvbG9yKHN0ciwgaGFzQWxwaGEgPSBmYWxzZSkge1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDEpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gXCIjXCIpXG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDEpO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PSA4KVxuICAgICAgICAgICAgcmV0dXJuIChwYXJzZUludChzdHIuc3Vic3RyKDAsIDIpLCAxNikgPDwgMjQpICsgcGFyc2VJbnQoc3RyLnN1YnN0cigyKSwgMTYpO1xuICAgICAgICBlbHNlIGlmIChoYXNBbHBoYSlcbiAgICAgICAgICAgIHJldHVybiAweEZGMDAwMDAwICsgcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzdHIsIDE2KTtcbiAgICB9XG4gICAgc3RhdGljIGNvbnZlcnRUb1JHQkEoc3RyKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KDApID09IFwiI1wiKVxuICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigxKTtcbiAgICAgICAgbGV0IGFscGhhID0gKyhwYXJzZUludCgnMHgnICsgc3RyLnNsaWNlKDAsIDIpKSAvIDI1NSkudG9GaXhlZCgyKTtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cigyKTtcbiAgICAgICAgbGV0IHIgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKDAsIDIpLCAxNik7XG4gICAgICAgIGxldCBnID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZygyLCA0KSwgMTYpO1xuICAgICAgICBsZXQgYiA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoNCksIDE2KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQihyLCBnLCBiLCBhbHBoYSk7XG4gICAgfVxuICAgIHN0YXRpYyBIRVgyUkdCKGhleCkge1xuICAgICAgICBpZiAoaGV4LmNoYXJBdCgwKSA9PSBcIiNcIilcbiAgICAgICAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICBoZXggKz0gaGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLkhFWDJERUMoaGV4LnN1YnN0cmluZygwLCAyKSl9LCR7dGhpcy5IRVgyREVDKGhleC5zdWJzdHJpbmcoMiwgNCkpfSwke3RoaXMuSEVYMkRFQyhoZXguc3Vic3RyaW5nKDQpKX1gO1xuICAgIH1cbiAgICBzdGF0aWMgSEVYMkRFQyhoZXgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGhleCwgMTYpLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuXG5jbGFzcyBVdGlscyB7XG4gICAgc3RhdGljIGRlZXBDb3B5UHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSwgcHJvcGVydHlPYmopIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wZXJ0eU9iaikge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXS5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmaWxsUGF0aChjdHgsIHBvaW50cywgcHgsIHB5KSB7XG4gICAgICAgIHZhciBjbnQgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXSArIHB4LCBwb2ludHNbMV0gKyBweSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgY250OyBpICs9IDIpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldICsgcHgsIHBvaW50c1tpICsgMV0gKyBweSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbMF0gKyBweCwgcG9pbnRzWzFdICsgcHkpO1xuICAgIH1cbn1cblV0aWxzLlRleHR1cmVDYWNoZSA9IHt9O1xuXG5jbGFzcyBYbWxOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGUpIHtcbiAgICAgICAgdGhpcy5ub2RlTmFtZSA9IGVsZS5ub2RlTmFtZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gZWxlO1xuICAgICAgICB0aGlzLnR5cGUgPSBlbGUubm9kZVR5cGU7XG4gICAgICAgIHRoaXMudGV4dCA9ICh0aGlzLnR5cGUgPT0gTm9kZS5DT01NRU5UX05PREUgfHwgdGhpcy50eXBlID09IE5vZGUuVEVYVF9OT0RFKSA/IHRoaXMuY29udGV4dC50ZXh0Q29udGVudCA6IG51bGw7XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRjaGlsZHJlbilcbiAgICAgICAgICAgIHRoaXMuJGNoaWxkcmVuID0gWG1sUGFyc2VyLmdldENoaWxkTm9kZXModGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLiRjaGlsZHJlbjtcbiAgICB9XG4gICAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy4kYXR0cmlidXRlcylcbiAgICAgICAgICAgIHRoaXMuJGF0dHJpYnV0ZXMgPSBYbWxQYXJzZXIuZ2V0Tm9kZUF0dHJpYnV0ZXModGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLiRhdHRyaWJ1dGVzO1xuICAgIH1cbn1cbmNsYXNzIFhtbFBhcnNlciB7XG4gICAgc3RhdGljIHRyeVBhcnNlKHhtbHN0cmluZywgbWltZVR5cGUgPSBcImFwcGxpY2F0aW9uL3htbFwiKSB7XG4gICAgICAgIGxldCBkb2MgPSBYbWxQYXJzZXIuJHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sc3RyaW5nLCBtaW1lVHlwZSk7XG4gICAgICAgIGlmIChkb2MgJiYgZG9jLmNoaWxkTm9kZXMgJiYgZG9jLmNoaWxkTm9kZXMubGVuZ3RoID49IDEpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFhtbE5vZGUoZG9jLmZpcnN0Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIGdldFhtbFJvb3QoeG1sKSB7XG4gICAgICAgIGlmICgheG1sIHx8ICF4bWwuY29udGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgeG1sIG5vZGVcIik7XG4gICAgICAgIGxldCBwID0geG1sLmNvbnRleHQ7XG4gICAgICAgIHdoaWxlIChwLnBhcmVudE5vZGUgIT0gbnVsbClcbiAgICAgICAgICAgIHAgPSBwLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiBwID09IHhtbC5jb250ZXh0ID8geG1sIDogbmV3IFhtbE5vZGUocCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDaGlsZE5vZGVzKHhtbCwgbWF0Y2hOYW1lID0gbnVsbCkge1xuICAgICAgICBsZXQgbm9kZXMgPSB4bWwuY29udGV4dC5jaGlsZE5vZGVzO1xuICAgICAgICBsZXQgcmV0ID0gW107XG4gICAgICAgIGlmICghbm9kZXMgfHwgbm9kZXMubGVuZ3RoIDw9IDApXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICBsZXQgbGVuID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbiA9IG5vZGVzLml0ZW0oaSk7XG4gICAgICAgICAgICBpZiAobi5ub2RlVHlwZSA9PSBOb2RlLlRFWFRfTk9ERSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hOYW1lIHx8IChtYXRjaE5hbWUgJiYgbWF0Y2hOYW1lLmxlbmd0aCA+IDAgJiYgbi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IG1hdGNoTmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgICAgICAgICByZXQucHVzaChuZXcgWG1sTm9kZShuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgc3RhdGljIGdldE5vZGVBdHRyaWJ1dGVzKHhtbCkge1xuICAgICAgICBsZXQgY29udGV4dCA9IHhtbC5jb250ZXh0O1xuICAgICAgICBsZXQgYXNMaXN0ID0gY29udGV4dC5hdHRyaWJ1dGVzO1xuICAgICAgICBsZXQgcmV0ID0ge307XG4gICAgICAgIGlmICghYXNMaXN0IHx8IGFzTGlzdC5sZW5ndGggPD0gMClcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIGxldCBsZW4gPSBhc0xpc3QubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYSA9IGFzTGlzdC5pdGVtKGkpO1xuICAgICAgICAgICAgcmV0W2Eubm9kZU5hbWVdID0gYS5ub2RlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5YbWxQYXJzZXIuJHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblxuY2xhc3MgRGlzcGxheUxpc3RJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihwYWNrYWdlSXRlbSwgdHlwZSkge1xuICAgICAgICB0aGlzLnBhY2thZ2VJdGVtID0gcGFja2FnZUl0ZW07XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxufVxuXG5jbGFzcyBQYWNrYWdlSXRlbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMudGlsZWRTbGljZXMgPSAwO1xuICAgICAgICAvL21vdmllY2xpcFxuICAgICAgICB0aGlzLmludGVydmFsID0gMDtcbiAgICAgICAgdGhpcy5yZXBlYXREZWxheSA9IDA7XG4gICAgfVxuICAgIGxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm93bmVyLmdldEl0ZW1Bc3NldCh0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxufVxuXG5jbGFzcyBBdGxhc0NvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoYXRsYXNOYW1lLCBmcmFtZSwgb3JpZywgdHJpbSwgcm90YXRlKSB7XG4gICAgICAgIHRoaXMuYXRsYXNOYW1lID0gYXRsYXNOYW1lO1xuICAgICAgICB0aGlzLmZyYW1lID0gZnJhbWU7XG4gICAgICAgIHRoaXMub3JpZyA9IG9yaWc7XG4gICAgICAgIHRoaXMudHJpbSA9IHRyaW07XG4gICAgICAgIHRoaXMucm90YXRlID0gcm90YXRlO1xuICAgIH1cbn1cbmNsYXNzIFVJUGFja2FnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuJGl0ZW1zID0gW107XG4gICAgICAgIHRoaXMuJGF0bGFzQ29uZmlncyA9IHt9O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QnlJZChpZCkge1xuICAgICAgICByZXR1cm4gVUlQYWNrYWdlLiRwYWNrYWdlSW5zdEJ5SWRbaWRdO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QnlOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFVJUGFja2FnZS4kcGFja2FnZUluc3RCeU5hbWVbbmFtZV07XG4gICAgfVxuICAgIHN0YXRpYyBhZGRQYWNrYWdlKHJlc0tleSkge1xuICAgICAgICBsZXQgcGtnID0gbmV3IFVJUGFja2FnZSgpO1xuICAgICAgICBwa2cuJHJlc0tleSA9IHJlc0tleTtcbiAgICAgICAgcGtnLmNyZWF0ZShyZXNLZXkpO1xuICAgICAgICBVSVBhY2thZ2UuJHBhY2thZ2VJbnN0QnlJZFtwa2cuaWRdID0gcGtnO1xuICAgICAgICBVSVBhY2thZ2UuJHBhY2thZ2VJbnN0QnlOYW1lW3BrZy5uYW1lXSA9IHBrZztcbiAgICAgICAgcGtnLmN1c3RvbUlkID0gcmVzS2V5O1xuICAgICAgICByZXR1cm4gcGtnO1xuICAgIH1cbiAgICBzdGF0aWMgcmVtb3ZlUGFja2FnZShwYWNrYWdlSWQpIHtcbiAgICAgICAgbGV0IHBrZyA9IFVJUGFja2FnZS4kcGFja2FnZUluc3RCeUlkW3BhY2thZ2VJZF07XG4gICAgICAgIHBrZy5kaXNwb3NlKCk7XG4gICAgICAgIGRlbGV0ZSBVSVBhY2thZ2UuJHBhY2thZ2VJbnN0QnlJZFtwa2cuaWRdO1xuICAgICAgICBpZiAocGtnLiRjdXN0b21JZCAhPSBudWxsKVxuICAgICAgICAgICAgZGVsZXRlIFVJUGFja2FnZS4kcGFja2FnZUluc3RCeUlkW3BrZy4kY3VzdG9tSWRdO1xuICAgICAgICBkZWxldGUgVUlQYWNrYWdlLiRwYWNrYWdlSW5zdEJ5TmFtZVtwa2cubmFtZV07XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVPYmplY3QocGtnTmFtZSwgcmVzTmFtZSwgdXNlckNsYXNzKSB7XG4gICAgICAgIGxldCBwa2cgPSBVSVBhY2thZ2UuZ2V0QnlOYW1lKHBrZ05hbWUpO1xuICAgICAgICBpZiAocGtnKVxuICAgICAgICAgICAgcmV0dXJuIHBrZy5jcmVhdGVPYmplY3QocmVzTmFtZSwgdXNlckNsYXNzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVPYmplY3RGcm9tVVJMKHVybCwgdXNlckNsYXNzKSB7XG4gICAgICAgIGxldCBwaSA9IFVJUGFja2FnZS5nZXRJdGVtQnlVUkwodXJsKTtcbiAgICAgICAgaWYgKHBpKVxuICAgICAgICAgICAgcmV0dXJuIHBpLm93bmVyLmludGVybmFsQ3JlYXRlT2JqZWN0KHBpLCB1c2VyQ2xhc3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIGdldEl0ZW1VUkwocGtnTmFtZSwgcmVzTmFtZSkge1xuICAgICAgICBsZXQgcGtnID0gVUlQYWNrYWdlLmdldEJ5TmFtZShwa2dOYW1lKTtcbiAgICAgICAgaWYgKCFwa2cpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHBpID0gcGtnLiRpdGVtc0J5TmFtZVtyZXNOYW1lXTtcbiAgICAgICAgaWYgKCFwaSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gYHVpOi8vJHtwa2cuaWR9JHtwaS5pZH1gO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SXRlbUJ5VVJMKHVybCkge1xuICAgICAgICBsZXQgcG9zMSA9IHVybC5pbmRleE9mKCcvLycpO1xuICAgICAgICBpZiAocG9zMSA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcG9zMiA9IHVybC5pbmRleE9mKCcvJywgcG9zMSArIDIpO1xuICAgICAgICBsZXQgcGtnO1xuICAgICAgICBpZiAocG9zMiA9PSAtMSkge1xuICAgICAgICAgICAgaWYgKHVybC5sZW5ndGggPiAxMykge1xuICAgICAgICAgICAgICAgIGxldCBwa2dJZCA9IHVybC5zdWJzdHIoNSwgOCk7XG4gICAgICAgICAgICAgICAgcGtnID0gVUlQYWNrYWdlLmdldEJ5SWQocGtnSWQpO1xuICAgICAgICAgICAgICAgIGlmIChwa2cgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3JjSWQgPSB1cmwuc3Vic3RyKDEzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBrZy5nZXRJdGVtQnlJZChzcmNJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBrZ05hbWUgPSB1cmwuc3Vic3RyKHBvczEgKyAyLCBwb3MyIC0gcG9zMSAtIDIpO1xuICAgICAgICAgICAgcGtnID0gVUlQYWNrYWdlLmdldEJ5TmFtZShwa2dOYW1lKTtcbiAgICAgICAgICAgIGlmIChwa2cgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBzcmNOYW1lID0gdXJsLnN1YnN0cihwb3MyICsgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBrZy5nZXRJdGVtQnlOYW1lKHNyY05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Qml0bWFwRm9udEJ5VVJMKHVybCkge1xuICAgICAgICByZXR1cm4gVUlQYWNrYWdlLiRiaXRtYXBGb250c1t1cmxdO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0U3RyaW5nc1NvdXJjZShzb3VyY2UpIHtcbiAgICAgICAgVUlQYWNrYWdlLiRzdHJpbmdzU291cmNlID0ge307XG4gICAgICAgIGxldCB4bWxyb290ID0gWG1sUGFyc2VyLnRyeVBhcnNlKHNvdXJjZSk7XG4gICAgICAgIHhtbHJvb3QuY2hpbGRyZW4uZm9yRWFjaChjeG1sID0+IHtcbiAgICAgICAgICAgIGlmIChjeG1sLm5vZGVOYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IGN4bWwuYXR0cmlidXRlcy5uYW1lO1xuICAgICAgICAgICAgICAgIGxldCBpID0ga2V5LmluZGV4T2YoJy0nKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gY3htbC5jaGlsZHJlbi5sZW5ndGggPiAwID8gY3htbC5jaGlsZHJlblswXS50ZXh0IDogJyc7XG4gICAgICAgICAgICAgICAgbGV0IGtleTIgPSBrZXkuc3Vic3RyKDAsIGkpO1xuICAgICAgICAgICAgICAgIGxldCBrZXkzID0ga2V5LnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgICAgICAgbGV0IGNvbCA9IFVJUGFja2FnZS4kc3RyaW5nc1NvdXJjZVtrZXkyXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbCkge1xuICAgICAgICAgICAgICAgICAgICBjb2wgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgVUlQYWNrYWdlLiRzdHJpbmdzU291cmNlW2tleTJdID0gY29sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xba2V5M10gPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZm9ybWF0IHRoZSBVUkwgZnJvbSBvbGQgdmVyc2lvbiB0byBuZXcgdmVyc2lvblxuICAgICAqIEBwYXJhbSB1cmwgdXJsIHdpdGggb2xkIHZlcnNpb24gZm9ybWF0XG4gICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZVVSTCh1cmwpIHtcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBwb3MxID0gdXJsLmluZGV4T2YoJy8vJyk7XG4gICAgICAgIGlmIChwb3MxID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBwb3MyID0gdXJsLmluZGV4T2YoJy8nLCBwb3MxICsgMik7XG4gICAgICAgIGlmIChwb3MyID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgbGV0IHBrZ05hbWUgPSB1cmwuc3Vic3RyKHBvczEgKyAyLCBwb3MyIC0gcG9zMSAtIDIpO1xuICAgICAgICBsZXQgc3JjTmFtZSA9IHVybC5zdWJzdHIocG9zMiArIDEpO1xuICAgICAgICByZXR1cm4gVUlQYWNrYWdlLmdldEl0ZW1VUkwocGtnTmFtZSwgc3JjTmFtZSk7XG4gICAgfVxuICAgIGNyZWF0ZShyZXNLZXkpIHtcbiAgICAgICAgdGhpcy4kcmVzS2V5ID0gcmVzS2V5O1xuICAgICAgICBsZXQgYnVmID0gQXNzZXRMb2FkZXIucmVzb3VyY2VzUG9vbFt0aGlzLiRyZXNLZXldO1xuICAgICAgICBpZiAoIWJ1Zikge1xuICAgICAgICAgICAgYnVmID0gQXNzZXRMb2FkZXIucmVzb3VyY2VzUG9vbFtgJHt0aGlzLiRyZXNLZXl9X2Z1aWBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYnVmKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc291cmNlICcke3RoaXMuJHJlc0tleX0nIG5vdCBmb3VuZCwgcGxlYXNlIG1ha2Ugc3VyZSB0aGF0IHlvdSB1c2UgXCJuZXcgZmd1aS51dGlscy5Bc3NldExvYWRlclwiIHRvIGxvYWQgcmVzb3VyY2VzXCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFidWYgfHwgIShidWYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb3VyY2UgJyR7dGhpcy4kcmVzS2V5fScgaXMgbm90IGEgcHJvcGVyIGJpbmFyeSByZXNvdXJjZSwgcGxlYXNlIGxvYWQgaXQgYXMgYmluYXJ5IGZvcm1hdCBpbiBtYW5pZmVzdCBmaWxlIGFkZFt7IGlkLCBzcmMsIHR5cGU6IFwiYmluYXJ5XCIgfV1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRQYWNrYWdlKGJ1Zik7XG4gICAgfVxuICAgIGxvYWRQYWNrYWdlKGRlc2NEYXRhKSB7XG4gICAgICAgIHRoaXMuZGVjb21wcmVzc1BhY2thZ2UoZGVzY0RhdGEpO1xuICAgICAgICBsZXQgc3RyID0gdGhpcy5nZXRSZXNEZXNjcmlwdG9yKCdzcHJpdGVzLmJ5dGVzJyk7XG4gICAgICAgIHN0ciAmJlxuICAgICAgICAgICAgc3RyLnNwbGl0KFVJUGFja2FnZS5zZXAxKS5mb3JFYWNoKChzdHIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDEgJiYgc3RyICYmIHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFyciA9IHN0ci5zcGxpdChVSVBhY2thZ2Uuc2VwMik7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXhJRDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW1JZCA9IGFyclswXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJpbkluZGV4ID0gcGFyc2VJbnQoYXJyWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbkluZGV4ID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXhJRCA9IGBhdGxhcyR7YmluSW5kZXh9YDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gaXRlbUlkLmluZGV4T2YoJ18nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4SUQgPSBgYXRsYXNfJHtpdGVtSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXhJRCA9IGBhdGxhc18ke2l0ZW1JZC5zdWJzdHIoMCwgcG9zKX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjZmcgPSBuZXcgQXRsYXNDb25maWcodGV4SUQpO1xuICAgICAgICAgICAgICAgICAgICBjZmcuZnJhbWUgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKHBhcnNlSW50KGFyclsyXSksIHBhcnNlSW50KGFyclszXSksIHBhcnNlSW50KGFycls0XSksIHBhcnNlSW50KGFycls1XSkpO1xuICAgICAgICAgICAgICAgICAgICBjZmcucm90YXRlID0gYXJyWzZdID09ICcxJyA/IDYgOiAwO1xuICAgICAgICAgICAgICAgICAgICBjZmcub3JpZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjZmcucm90YXRlICE9IDAgPyBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKDAsIDAsIGNmZy5mcmFtZS5oZWlnaHQsIGNmZy5mcmFtZS53aWR0aCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjZmcudHJpbSA9IHRyaW1lZDsgIC8vaWdub3JlZCBmb3Igbm93IC0gZWRpdG9yIG5vdCBzdXBwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGF0bGFzQ29uZmlnc1tpdGVtSWRdID0gY2ZnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBzdHIgPSB0aGlzLmdldFJlc0Rlc2NyaXB0b3IoJ3BhY2thZ2UueG1sJyk7XG4gICAgICAgIGxldCB4bWwgPSBYbWxQYXJzZXIudHJ5UGFyc2Uoc3RyKTtcbiAgICAgICAgdGhpcy4kaWQgPSB4bWwuYXR0cmlidXRlcy5pZDtcbiAgICAgICAgdGhpcy4kbmFtZSA9IHhtbC5hdHRyaWJ1dGVzLm5hbWU7XG4gICAgICAgIGxldCByZXNvdXJjZXMgPSB4bWwuY2hpbGRyZW5bMF0uY2hpbGRyZW47XG4gICAgICAgIHRoaXMuJGl0ZW1zQnlJZCA9IHt9O1xuICAgICAgICB0aGlzLiRpdGVtc0J5TmFtZSA9IHt9O1xuICAgICAgICByZXNvdXJjZXMuZm9yRWFjaChjeG1sID0+IHtcbiAgICAgICAgICAgIGxldCBwaSA9IG5ldyBQYWNrYWdlSXRlbSgpO1xuICAgICAgICAgICAgcGkudHlwZSA9IFBhcnNlUGFja2FnZUl0ZW1UeXBlKGN4bWwubm9kZU5hbWUpO1xuICAgICAgICAgICAgcGkuaWQgPSBjeG1sLmF0dHJpYnV0ZXMuaWQ7XG4gICAgICAgICAgICBwaS5uYW1lID0gY3htbC5hdHRyaWJ1dGVzLm5hbWU7XG4gICAgICAgICAgICBwaS5maWxlID0gY3htbC5hdHRyaWJ1dGVzLmZpbGU7XG4gICAgICAgICAgICBzdHIgPSBjeG1sLmF0dHJpYnV0ZXMuc2l6ZTtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXJyID0gc3RyLnNwbGl0KFVJUGFja2FnZS5zZXAwKTtcbiAgICAgICAgICAgICAgICBwaS53aWR0aCA9IHBhcnNlSW50KGFyclswXSk7XG4gICAgICAgICAgICAgICAgcGkuaGVpZ2h0ID0gcGFyc2VJbnQoYXJyWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAocGkudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBJbWFnZSAqLzoge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBjeG1sLmF0dHJpYnV0ZXMuc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gJzlncmlkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gY3htbC5hdHRyaWJ1dGVzLnNjYWxlOWdyaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyciA9IHN0ci5zcGxpdChVSVBhY2thZ2Uuc2VwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKHBhcnNlSW50KGFyclswXSksIHBhcnNlSW50KGFyclsxXSksIHBhcnNlSW50KGFyclsyXSksIHBhcnNlSW50KGFyclszXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpLnNjYWxlOUdyaWQgPSByZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IGN4bWwuYXR0cmlidXRlcy5ncmlkVGlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaS50aWxlZFNsaWNlcyA9IHBhcnNlSW50KHN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyID09ICd0aWxlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpLnNjYWxlQnlUaWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGkub3duZXIgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMucHVzaChwaSk7XG4gICAgICAgICAgICB0aGlzLiRpdGVtc0J5SWRbcGkuaWRdID0gcGk7XG4gICAgICAgICAgICBpZiAocGkubmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zQnlOYW1lW3BpLm5hbWVdID0gcGk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKHBpID0+IHtcbiAgICAgICAgICAgIGlmIChwaS50eXBlID09IDYgLyogRm9udCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZEZvbnQocGkpO1xuICAgICAgICAgICAgICAgIFVJUGFja2FnZS4kYml0bWFwRm9udHNbcGkuYml0bWFwRm9udC5pZF0gPSBwaS5iaXRtYXBGb250O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgZGVjb21wcmVzc1BhY2thZ2UoYnVmKSB7XG4gICAgICAgIHRoaXMuJHJlc0RhdGEgPSB7fTtcbiAgICAgICAgdmFyIG1hcmsgPSBuZXcgVWludDhBcnJheShidWYuc2xpY2UoMCwgMikpO1xuICAgICAgICBpZiAobWFya1swXSA9PSAweDUwICYmIG1hcmtbMV0gPT0gMHg0Yikge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVVbmNvbXByZXNzZWQoYnVmKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5mbGF0ZXIgPSBuZXcgUmF3SW5mbGF0ZShidWYpO1xuICAgICAgICBsZXQgZGF0YSA9IGluZmxhdGVyLmRlY29tcHJlc3MoKTtcbiAgICAgICAgbGV0IHNvdXJjZSA9IFJhd0J5dGUuZGVjb2RlVVRGOChkYXRhKTtcbiAgICAgICAgbGV0IGN1cnIgPSAwO1xuICAgICAgICBsZXQgZm47XG4gICAgICAgIGxldCBzaXplO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHNvdXJjZS5pbmRleE9mKCd8JywgY3Vycik7XG4gICAgICAgICAgICBpZiAocG9zID09IC0xKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZm4gPSBzb3VyY2Uuc3Vic3RyaW5nKGN1cnIsIHBvcyk7XG4gICAgICAgICAgICBjdXJyID0gcG9zICsgMTtcbiAgICAgICAgICAgIHBvcyA9IHNvdXJjZS5pbmRleE9mKCd8JywgY3Vycik7XG4gICAgICAgICAgICBzaXplID0gcGFyc2VJbnQoc291cmNlLnN1YnN0cmluZyhjdXJyLCBwb3MpKTtcbiAgICAgICAgICAgIGN1cnIgPSBwb3MgKyAxO1xuICAgICAgICAgICAgdGhpcy4kcmVzRGF0YVtmbl0gPSBzb3VyY2Uuc3Vic3RyKGN1cnIsIHNpemUpO1xuICAgICAgICAgICAgY3VyciArPSBzaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBidWZcbiAgICAgKi9cbiAgICBkZWNvZGVVbmNvbXByZXNzZWQoYnVmKSB7XG4gICAgICAgIHZhciBiYSA9IG5ldyBCeXRlQXJyYXkoYnVmKTtcbiAgICAgICAgYmEuZW5kaWFuID0gRW5kaWFuLkxJVFRMRV9FTkRJQU47XG4gICAgICAgIHZhciBwb3MgPSBiYS5sZW5ndGggLSAyMjtcbiAgICAgICAgYmEucG9zaXRpb24gPSBwb3MgKyAxMDtcbiAgICAgICAgdmFyIGVudHJ5Q291bnQgPSBiYS5yZWFkVW5zaWduZWRTaG9ydCgpO1xuICAgICAgICBiYS5wb3NpdGlvbiA9IHBvcyArIDE2O1xuICAgICAgICBwb3MgPSBiYS5yZWFkSW50KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cnlDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBiYS5wb3NpdGlvbiA9IHBvcyArIDI4O1xuICAgICAgICAgICAgdmFyIGxlbiA9IGJhLnJlYWRVbnNpZ25lZFNob3J0KCk7XG4gICAgICAgICAgICB2YXIgbGVuMiA9IGJhLnJlYWRVbnNpZ25lZFNob3J0KCkgKyBiYS5yZWFkVW5zaWduZWRTaG9ydCgpO1xuICAgICAgICAgICAgYmEucG9zaXRpb24gPSBwb3MgKyA0NjtcbiAgICAgICAgICAgIHZhciBlbnRyeU5hbWUgPSBiYS5yZWFkVVRGQnl0ZXMobGVuKTtcbiAgICAgICAgICAgIGlmIChlbnRyeU5hbWVbZW50cnlOYW1lLmxlbmd0aCAtIDFdICE9ICcvJyAmJiBlbnRyeU5hbWVbZW50cnlOYW1lLmxlbmd0aCAtIDFdICE9ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIC8vbm90IGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgIGJhLnBvc2l0aW9uID0gcG9zICsgMjA7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBiYS5yZWFkSW50KCk7XG4gICAgICAgICAgICAgICAgYmEucG9zaXRpb24gPSBwb3MgKyA0MjtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gYmEucmVhZEludCgpICsgMzAgKyBsZW47XG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhLnBvc2l0aW9uID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRyZXNEYXRhW2VudHJ5TmFtZV0gPSBiYS5yZWFkVVRGQnl0ZXMoc2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IDQ2ICsgbGVuICsgbGVuMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKHBpID0+IHtcbiAgICAgICAgICAgIGxldCBjZmcgPSB0aGlzLiRhdGxhc0NvbmZpZ3NbcGkuaWRdO1xuICAgICAgICAgICAgaWYgKGNmZylcbiAgICAgICAgICAgICAgICBBc3NldExvYWRlci5kZXN0cm95UmVzb3VyY2UoYCR7dGhpcy4kcmVzS2V5fUAke2NmZy5hdGxhc05hbWV9YCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRpZDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRuYW1lO1xuICAgIH1cbiAgICBnZXQgY3VzdG9tSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjdXN0b21JZDtcbiAgICB9XG4gICAgc2V0IGN1c3RvbUlkKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRjdXN0b21JZCAhPSBudWxsKVxuICAgICAgICAgICAgZGVsZXRlIFVJUGFja2FnZS4kcGFja2FnZUluc3RCeUlkW3RoaXMuJGN1c3RvbUlkXTtcbiAgICAgICAgdGhpcy4kY3VzdG9tSWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuJGN1c3RvbUlkICE9IG51bGwpXG4gICAgICAgICAgICBVSVBhY2thZ2UuJHBhY2thZ2VJbnN0QnlJZFt0aGlzLiRjdXN0b21JZF0gPSB0aGlzO1xuICAgIH1cbiAgICBjcmVhdGVPYmplY3QocmVzTmFtZSwgdXNlckNsYXNzKSB7XG4gICAgICAgIGxldCBwaSA9IHRoaXMuJGl0ZW1zQnlOYW1lW3Jlc05hbWVdO1xuICAgICAgICBpZiAocGkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENyZWF0ZU9iamVjdChwaSwgdXNlckNsYXNzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGludGVybmFsQ3JlYXRlT2JqZWN0KGl0ZW0sIHVzZXJDbGFzcyA9IG51bGwpIHtcbiAgICAgICAgbGV0IGcgPSBpdGVtLnR5cGUgPT0gNCAvKiBDb21wb25lbnQgKi8gJiYgdXNlckNsYXNzICE9IG51bGxcbiAgICAgICAgICAgID8gbmV3IHVzZXJDbGFzcygpXG4gICAgICAgICAgICA6IERlY2xzLlVJT2JqZWN0RmFjdG9yeS5uZXdPYmplY3QoaXRlbSk7XG4gICAgICAgIGlmIChnID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgVUlQYWNrYWdlLiRjb25zdHJ1Y3RpbmdPYmplY3RzKys7XG4gICAgICAgIGcucGFja2FnZUl0ZW0gPSBpdGVtO1xuICAgICAgICBnLmNvbnN0cnVjdEZyb21SZXNvdXJjZSgpO1xuICAgICAgICBVSVBhY2thZ2UuJGNvbnN0cnVjdGluZ09iamVjdHMtLTtcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgfVxuICAgIGdldEl0ZW1CeUlkKGl0ZW1JZCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXNCeUlkW2l0ZW1JZF07XG4gICAgfVxuICAgIGdldEl0ZW1CeU5hbWUocmVzTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXNCeU5hbWVbcmVzTmFtZV07XG4gICAgfVxuICAgIGdldEl0ZW1Bc3NldEJ5TmFtZShyZXNOYW1lKSB7XG4gICAgICAgIGxldCBwaSA9IHRoaXMuJGl0ZW1zQnlOYW1lW3Jlc05hbWVdO1xuICAgICAgICBpZiAocGkgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb3VyY2UgJyR7cmVzTmFtZX0nIG5vdCBmb3VuZGApO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtQXNzZXQocGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0b2RvXG4gICAgICovXG4gICAgY3JlYXRlU3ByaXRlVGV4dHVyZShjZmdOYW1lLCBjZmcpIHtcbiAgICAgICAgbGV0IGF0bGFzSXRlbSA9IHRoaXMuJGl0ZW1zQnlJZFtjZmcuYXRsYXNOYW1lXTtcbiAgICAgICAgaWYgKGF0bGFzSXRlbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgYXRsYXNUZXh0dXJlID0gdGhpcy5nZXRJdGVtQXNzZXQoYXRsYXNJdGVtKTtcbiAgICAgICAgICAgIGlmICghYXRsYXNUZXh0dXJlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKCFjZmcudGV4Q2FjaGVJRCkge1xuICAgICAgICAgICAgICAgIGNmZy50ZXhDYWNoZUlEID0gYCR7dGhpcy4kcmVzS2V5fUAke2NmZy5hdGxhc05hbWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0ZXggPSBVdGlscy5UZXh0dXJlQ2FjaGVbY2ZnLnRleENhY2hlSURdO1xuICAgICAgICAgICAgLy90b2RvIGFkZCB0byBjYWNoZVxuICAgICAgICAgICAgaWYgKCF0ZXgpIHtcbiAgICAgICAgICAgICAgICB0ZXggPSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiBhdGxhc1RleHR1cmUsXG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IGNmZy5mcmFtZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRJdGVtQXNzZXQoaXRlbSkge1xuICAgICAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIEltYWdlICovOlxuICAgICAgICAgICAgICAgIGlmICghaXRlbS5kZWNvZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGVjb2RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjZmcgPSB0aGlzLiRhdGxhc0NvbmZpZ3NbaXRlbS5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udGV4dHVyZSA9IHRoaXMuY3JlYXRlU3ByaXRlVGV4dHVyZShpdGVtLmlkLCBjZmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50ZXh0dXJlO1xuICAgICAgICAgICAgY2FzZSA3IC8qIEF0bGFzICovOlxuICAgICAgICAgICAgICAgIGlmICghaXRlbS5kZWNvZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGVjb2RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZSA9IGl0ZW0uZmlsZSAhPSBudWxsICYmIGl0ZW0uZmlsZS5sZW5ndGggPiAwID8gaXRlbS5maWxlIDogYCR7aXRlbS5pZH0ucG5nYDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc05hbWUgPSBgJHt0aGlzLiRyZXNLZXl9QCR7U3RyaW5nVXRpbC5nZXRGaWxlTmFtZShmaWxlTmFtZSl9YDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRleHR1cmUgPSBBc3NldExvYWRlci5yZXNvdXJjZXNQb29sW3Jlc05hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNOYW1lfSBub3QgZm91bmQgaW4gZmd1aS5Bc3NldExvYWRlci5yZXNvdXJjZXNQb29sLCBwbGVhc2UgbG9hZCBhc3NldHMgZmlyc3QhYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXRlbS50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUgPSBBc3NldExvYWRlci5yZXNvdXJjZXNQb29sW2Ake3RoaXMuJHJlc0tleX1AJHtmaWxlTmFtZS5yZXBsYWNlKCcuJywgJ18nKX1gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udGV4dHVyZSA9IHRleHR1cmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udGV4dHVyZTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTb3VuZCAqLzpcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uZGVjb2RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlY29kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRBdWRpbyhpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uc291bmQ7XG4gICAgICAgICAgICBjYXNlIDYgLyogRm9udCAqLzpcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uZGVjb2RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlY29kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRGb250KGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5iaXRtYXBGb250O1xuICAgICAgICAgICAgY2FzZSAyIC8qIE1vdmllQ2xpcCAqLzpcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uZGVjb2RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlY29kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRNb3ZpZUNsaXAoaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmZyYW1lcztcbiAgICAgICAgICAgIGNhc2UgNCAvKiBDb21wb25lbnQgKi86XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmRlY29kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kZWNvZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ciA9IHRoaXMuZ2V0UmVzRGVzY3JpcHRvcihgJHtpdGVtLmlkfS54bWxgKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHhtbCA9IFhtbFBhcnNlci50cnlQYXJzZShzdHIpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbXBvbmVudERhdGEgPSB4bWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZENvbXBvbmVudENoaWxkcmVuKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRDb21wb25lbnRUcmFuc2xhdGlvbihpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uY29tcG9uZW50RGF0YTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFzc2V0TG9hZGVyLnJlc291cmNlc1Bvb2xbYCR7dGhpcy4kcmVzS2V5fUAke2l0ZW0uaWR9YF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9hZENvbXBvbmVudENoaWxkcmVuKGl0ZW0pIHtcbiAgICAgICAgbGV0IGxpc3ROb2RlID0gWG1sUGFyc2VyLmdldENoaWxkTm9kZXMoaXRlbS5jb21wb25lbnREYXRhLCAnZGlzcGxheUxpc3QnKTtcbiAgICAgICAgaWYgKGxpc3ROb2RlICE9IG51bGwgJiYgbGlzdE5vZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaXRlbS5kaXNwbGF5TGlzdCA9IFtdO1xuICAgICAgICAgICAgbGlzdE5vZGVbMF0uY2hpbGRyZW4uZm9yRWFjaChjeG1sID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdGFnTmFtZSA9IGN4bWwubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgbGV0IGRpO1xuICAgICAgICAgICAgICAgIGxldCBzcmMgPSBjeG1sLmF0dHJpYnV0ZXMuc3JjO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBrZ0lkID0gY3htbC5hdHRyaWJ1dGVzLnBrZztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBrZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBrZ0lkICYmIHBrZ0lkICE9IGl0ZW0ub3duZXIuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBwa2cgPSBVSVBhY2thZ2UuZ2V0QnlJZChwa2dJZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHBrZyA9IGl0ZW0ub3duZXI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaSA9IHBrZyAhPSBudWxsID8gcGtnLmdldEl0ZW1CeUlkKHNyYykgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpID0gbmV3IERpc3BsYXlMaXN0SXRlbShwaSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpID0gbmV3IERpc3BsYXlMaXN0SXRlbShudWxsLCB0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09ICd0ZXh0JyAmJiBjeG1sLmF0dHJpYnV0ZXMuaW5wdXQgPT0gJ3RydWUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGkgPSBuZXcgRGlzcGxheUxpc3RJdGVtKG51bGwsICdpbnB1dHRleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGkgPSBuZXcgRGlzcGxheUxpc3RJdGVtKG51bGwsIHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaS5kZXNjID0gY3htbDtcbiAgICAgICAgICAgICAgICBpdGVtLmRpc3BsYXlMaXN0LnB1c2goZGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaXRlbS5kaXNwbGF5TGlzdCA9IFtdO1xuICAgIH1cbiAgICBnZXRSZXNEZXNjcmlwdG9yKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZXNEYXRhW2ZuXTtcbiAgICB9XG4gICAgbG9hZENvbXBvbmVudFRyYW5zbGF0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKFVJUGFja2FnZS4kc3RyaW5nc1NvdXJjZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgc3RyaW5ncyA9IFVJUGFja2FnZS4kc3RyaW5nc1NvdXJjZVt0aGlzLmlkICsgaXRlbS5pZF07XG4gICAgICAgIGlmIChzdHJpbmdzID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgbGV0IGN4bWwsIGR4bWw7XG4gICAgICAgIGxldCBlbmFtZTtcbiAgICAgICAgbGV0IGVsZW1lbnRJZDtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgaXRlbS5kaXNwbGF5TGlzdC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY3htbCA9IGl0ZW0uZGVzYztcbiAgICAgICAgICAgIGVuYW1lID0gY3htbC5ub2RlTmFtZTtcbiAgICAgICAgICAgIGVsZW1lbnRJZCA9IGN4bWwuYXR0cmlidXRlcy5pZDtcbiAgICAgICAgICAgIHN0ciA9IGN4bWwuYXR0cmlidXRlcy50b29sdGlwcztcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0cmluZ3NbYCR7ZWxlbWVudElkfS10aXBzYF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgY3htbC5hdHRyaWJ1dGVzLnRvb2x0aXBzID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3MgPSBYbWxQYXJzZXIuZ2V0Q2hpbGROb2RlcyhjeG1sLCAnZ2VhclRleHQnKTtcbiAgICAgICAgICAgIGR4bWwgPSBjcyAmJiBjc1swXTtcbiAgICAgICAgICAgIGlmIChkeG1sKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmdzW2Ake2VsZW1lbnRJZH0tdGV4dHNgXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBkeG1sLmF0dHJpYnV0ZXMudmFsdWVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmdzW2Ake2VsZW1lbnRJZH0tdGV4dHNfZGVmYF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgZHhtbC5hdHRyaWJ1dGVzLmRlZmF1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmFtZSA9PSAndGV4dCcgfHwgZW5hbWUgPT0gJ3JpY2h0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RyaW5nc1tlbGVtZW50SWRdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGN4bWwuYXR0cmlidXRlcy50ZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmdzW2Ake2VsZW1lbnRJZH0tcHJvbXB0YF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgY3htbC5hdHRyaWJ1dGVzLnByb21wdCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5hbWUgPT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgY3htbC5jaGlsZHJlbi5mb3JFYWNoKChleG1sLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhtbC5ub2RlTmFtZSAhPSAnaXRlbScpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3RyaW5nc1tgJHtlbGVtZW50SWR9LSR7aW5kZXh9YF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBleG1sLmF0dHJpYnV0ZXMudGl0bGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVuYW1lID09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgICAgICAgY3MgPSBYbWxQYXJzZXIuZ2V0Q2hpbGROb2RlcyhjeG1sLCAnQnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgZHhtbCA9IGNzICYmIGNzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChkeG1sKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3RyaW5nc1tlbGVtZW50SWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHhtbC5hdHRyaWJ1dGVzLnRpdGxlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3RyaW5nc1tgJHtlbGVtZW50SWR9LTBgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4bWwuYXR0cmlidXRlcy5zZWxlY3RlZFRpdGxlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3MgPSBYbWxQYXJzZXIuZ2V0Q2hpbGROb2RlcyhjeG1sLCAnTGFiZWwnKTtcbiAgICAgICAgICAgICAgICBkeG1sID0gY3MgJiYgY3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKGR4bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmdzW2VsZW1lbnRJZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBkeG1sLmF0dHJpYnV0ZXMudGl0bGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjcyA9IFhtbFBhcnNlci5nZXRDaGlsZE5vZGVzKGN4bWwsICdDb21ib0JveCcpO1xuICAgICAgICAgICAgICAgIGR4bWwgPSBjcyAmJiBjc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoZHhtbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0cmluZ3NbZWxlbWVudElkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4bWwuYXR0cmlidXRlcy50aXRsZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBkeG1sLmNoaWxkcmVuLmZvckVhY2goKGV4bWwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhtbC5ub2RlTmFtZSAhPSAnaXRlbScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmdzW2Ake2VsZW1lbnRJZH0tJHtpbmRleH1gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhtbC5hdHRyaWJ1dGVzLnRpdGxlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9hZE1vdmllQ2xpcChpdGVtKSB7XG4gICAgICAgIGxldCB4bWwgPSBYbWxQYXJzZXIudHJ5UGFyc2UodGhpcy5nZXRSZXNEZXNjcmlwdG9yKGAke2l0ZW0uaWR9LnhtbGApKTtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuaW50ZXJ2YWw7XG4gICAgICAgIGlmIChzdHIgIT0gbnVsbClcbiAgICAgICAgICAgIGl0ZW0uaW50ZXJ2YWwgPSBwYXJzZUludChzdHIpO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5zd2luZztcbiAgICAgICAgaWYgKHN0ciAhPSBudWxsKVxuICAgICAgICAgICAgaXRlbS5zd2luZyA9IHN0ciA9PSAndHJ1ZSc7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnJlcGVhdERlbGF5O1xuICAgICAgICBpZiAoc3RyICE9IG51bGwpXG4gICAgICAgICAgICBpdGVtLnJlcGVhdERlbGF5ID0gcGFyc2VJbnQoc3RyKTtcbiAgICAgICAgaXRlbS5mcmFtZXMgPSBbXTtcbiAgICAgICAgbGV0IGZyYW1lTm9kZXMgPSB4bWwuY2hpbGRyZW5bMF0uY2hpbGRyZW47XG4gICAgICAgIGZyYW1lTm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBmcmFtZSA9IG5ldyBGcmFtZSgpO1xuICAgICAgICAgICAgc3RyID0gbm9kZS5hdHRyaWJ1dGVzLnJlY3Q7XG4gICAgICAgICAgICBsZXQgYXJyID0gc3RyLnNwbGl0KFVJUGFja2FnZS5zZXAwKTtcbiAgICAgICAgICAgIGxldCB0cmltUmVjdCA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUocGFyc2VJbnQoYXJyWzBdKSwgcGFyc2VJbnQoYXJyWzFdKSwgcGFyc2VJbnQoYXJyWzJdKSwgcGFyc2VJbnQoYXJyWzNdKSk7XG4gICAgICAgICAgICBzdHIgPSBub2RlLmF0dHJpYnV0ZXMuYWRkRGVsYXk7XG4gICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgIGZyYW1lLmFkZERlbGF5ID0gcGFyc2VJbnQoc3RyKTtcbiAgICAgICAgICAgIGl0ZW0uZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgaWYgKHRyaW1SZWN0LndpZHRoIDw9IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc3RyID0gbm9kZS5hdHRyaWJ1dGVzLnNwcml0ZTtcbiAgICAgICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICAgICAgc3RyID0gYCR7aXRlbS5pZH1fJHtzdHJ9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdHIgPSBgJHtpdGVtLmlkfV8ke2luZGV4fWA7XG4gICAgICAgICAgICBsZXQgY2ZnID0gdGhpcy4kYXRsYXNDb25maWdzW3N0cl07XG4gICAgICAgICAgICBpZiAoY2ZnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmcmFtZS50ZXh0dXJlID0gdGhpcy5jcmVhdGVTcHJpdGVUZXh0dXJlKHN0ciwgY2ZnKTtcbiAgICAgICAgICAgICAgICBmcmFtZS50ZXh0dXJlLnRyaW0gPSB0cmltUmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWRGb250KGl0ZW0pIHtcbiAgICAgICAgbGV0IGZvbnQgPSBuZXcgQml0bWFwRm9udCgpO1xuICAgICAgICBmb250LmlkID0gYHVpOi8vJHt0aGlzLmlkfSR7aXRlbS5pZH1gO1xuICAgICAgICBsZXQgc3RyID0gdGhpcy5nZXRSZXNEZXNjcmlwdG9yKGAke2l0ZW0uaWR9LmZudGApO1xuICAgICAgICBsZXQgbGluZXMgPSBzdHIuc3BsaXQoVUlQYWNrYWdlLnNlcDEpO1xuICAgICAgICBsZXQga3YgPSB7fTtcbiAgICAgICAgbGV0IHR0ZiA9IGZhbHNlO1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGxldCB4YWR2YW5jZSA9IDA7XG4gICAgICAgIGxldCByZXNpemFibGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvbG9yYWJsZSA9IGZhbHNlO1xuICAgICAgICBsZXQgYXRsYXNPZmZzZXRYID0gMCwgYXRsYXNPZmZzZXRZID0gMDtcbiAgICAgICAgbGV0IGNoYXJJbWc7XG4gICAgICAgIGxldCBtYWluVGV4dHVyZTtcbiAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSAwO1xuICAgICAgICBsZXQgbWF4Q2hhckhlaWdodCA9IDA7XG4gICAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICBpZiAobGluZSAmJiBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN0ciA9IFN0cmluZ1V0aWwudHJpbShsaW5lKTtcbiAgICAgICAgICAgICAgICBsZXQgYXJyID0gc3RyLnNwbGl0KFVJUGFja2FnZS5zZXAyKTtcbiAgICAgICAgICAgICAgICBhcnIuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF0ID0gdi5zcGxpdChVSVBhY2thZ2Uuc2VwMyk7XG4gICAgICAgICAgICAgICAgICAgIGt2W2F0WzBdXSA9IGF0WzFdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0ciA9IGFyclswXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09ICdjaGFyJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmcgPSBuZXcgQk1HbHlwaCgpO1xuICAgICAgICAgICAgICAgICAgICBiZy54ID0gcGFyc2VJbnQoa3YueCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgYmcueSA9IHBhcnNlSW50KGt2LnkpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGJnLm9mZnNldFggPSBwYXJzZUludChrdi54b2Zmc2V0KSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBiZy5vZmZzZXRZID0gcGFyc2VJbnQoa3YueW9mZnNldCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgYmcud2lkdGggPSBwYXJzZUludChrdi53aWR0aCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgYmcuaGVpZ2h0ID0gcGFyc2VJbnQoa3YuaGVpZ2h0KSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBtYXhDaGFySGVpZ2h0ID0gTWF0aC5tYXgoYmcuaGVpZ2h0LCBtYXhDaGFySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYmcuYWR2YW5jZSA9IHBhcnNlSW50KGt2LnhhZHZhbmNlKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa3YuY2hubCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJnLmNoYW5uZWwgPSBwYXJzZUludChrdi5jaG5sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZy5jaGFubmVsID09IDE1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnLmNoYW5uZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYmcuY2hhbm5lbCA9PSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnLmNoYW5uZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYmcuY2hhbm5lbCA9PSAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnLmNoYW5uZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnLmNoYW5uZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHRmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa3YuaW1nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckltZyA9IHRoaXMuJGl0ZW1zQnlJZFtrdi5pbWddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFySW1nICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckltZy5sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnLndpZHRoID0gY2hhckltZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmcuaGVpZ2h0ID0gY2hhckltZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnLnRleHR1cmUgPSBjaGFySW1nLnRleHR1cmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1haW5UZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmcudGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnLnRleHR1cmUgPSB7IGltYWdlOiBtYWluVGV4dHVyZSwgcmVjdDoge30gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJnLnRleHR1cmUucmVjdCA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoYmcueCArIGF0bGFzT2Zmc2V0WCwgYmcueSArIGF0bGFzT2Zmc2V0WSwgYmcud2lkdGgsIGJnLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR0ZilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJnLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZy5hZHZhbmNlID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGFkdmFuY2UgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmcuYWR2YW5jZSA9IGJnLm9mZnNldFggKyBiZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnLmFkdmFuY2UgPSB4YWR2YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJnLmxpbmVIZWlnaHQgPSBiZy5vZmZzZXRZIDwgMCA/IGJnLmhlaWdodCA6IGJnLm9mZnNldFkgKyBiZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDAgJiYgYmcubGluZUhlaWdodCA8IHNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmcubGluZUhlaWdodCA9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9udC5nbHlwaHNbU3RyaW5nLmZyb21DaGFyQ29kZSgra3YuaWQgfCAwKV0gPSBiZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyID09ICdpbmZvJykge1xuICAgICAgICAgICAgICAgICAgICB0dGYgPSBrdi5mYWNlICE9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrdi5zaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IHBhcnNlSW50KGt2LnNpemUpO1xuICAgICAgICAgICAgICAgICAgICByZXNpemFibGUgPSBrdi5yZXNpemFibGUgPT0gJ3RydWUnO1xuICAgICAgICAgICAgICAgICAgICBjb2xvcmFibGUgPSBrdi5jb2xvcmVkID09ICd0cnVlJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR0Zikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNmZyA9IHRoaXMuJGF0bGFzQ29uZmlnc1tpdGVtLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0bGFzT2Zmc2V0WCA9IGNmZy5mcmFtZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0bGFzT2Zmc2V0WSA9IGNmZy5mcmFtZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhdGxhc0l0ZW0gPSB0aGlzLiRpdGVtc0J5SWRbY2ZnLmF0bGFzTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0bGFzSXRlbSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluVGV4dHVyZSA9IHRoaXMuZ2V0SXRlbUFzc2V0KGF0bGFzSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyID09ICdjb21tb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrdi5saW5lSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCA9IHBhcnNlSW50KGt2LmxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxpbmVIZWlnaHQgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa3YueGFkdmFuY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB4YWR2YW5jZSA9IHBhcnNlSW50KGt2LnhhZHZhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2l6ZSA9PSAwICYmIG1heENoYXJIZWlnaHQgPiAwKVxuICAgICAgICAgICAgc2l6ZSA9IG1heENoYXJIZWlnaHQ7XG4gICAgICAgIGZvbnQudHRmID0gdHRmO1xuICAgICAgICBmb250LnNpemUgPSBzaXplO1xuICAgICAgICBmb250LnJlc2l6YWJsZSA9IHJlc2l6YWJsZTtcbiAgICAgICAgZm9udC5jb2xvcmFibGUgPSBjb2xvcmFibGU7XG4gICAgICAgIGl0ZW0uYml0bWFwRm9udCA9IGZvbnQ7XG4gICAgfVxuICAgIGxvYWRBdWRpbyhpdGVtKSB7XG4gICAgICAgIGxldCBmaWxlTmFtZSA9IGl0ZW0uZmlsZSAhPSBudWxsICYmIGl0ZW0uZmlsZS5sZW5ndGggPiAwID8gaXRlbS5maWxlIDogYCR7aXRlbS5pZH0ubXAzYDtcbiAgICAgICAgbGV0IHJlc05hbWUgPSBgJHt0aGlzLiRyZXNLZXl9QCR7U3RyaW5nVXRpbC5nZXRGaWxlTmFtZShmaWxlTmFtZSl9YDtcbiAgICAgICAgbGV0IHNvdW5kID0gQXNzZXRMb2FkZXIucmVzb3VyY2VzUG9vbFtyZXNOYW1lXTtcbiAgICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgICAgICBpdGVtLnNvdW5kID0gY3JlYXRlanMuU291bmQucGxheShyZXNOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVzb3VyY2UgJ1wiICsgaXRlbS5maWxlICsgXCInIG5vdCBmb3VuZCwgcGxlYXNlIGxvYWRNYW5pZmVzdCBmaXJzdCFcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipAaW50ZXJuYWwgKi9cblVJUGFja2FnZS4kY29uc3RydWN0aW5nT2JqZWN0cyA9IDA7XG5VSVBhY2thZ2UuJHBhY2thZ2VJbnN0QnlJZCA9IHt9O1xuVUlQYWNrYWdlLiRwYWNrYWdlSW5zdEJ5TmFtZSA9IHt9O1xuVUlQYWNrYWdlLiRiaXRtYXBGb250cyA9IHt9O1xuVUlQYWNrYWdlLiRzdHJpbmdzU291cmNlID0gbnVsbDtcblVJUGFja2FnZS5zZXAwID0gJywnO1xuVUlQYWNrYWdlLnNlcDEgPSAnXFxuJztcblVJUGFja2FnZS5zZXAyID0gJyAnO1xuVUlQYWNrYWdlLnNlcDMgPSAnPSc7XG5sZXQgRGVjbHMgPSB7fTtcblxuY2xhc3MgR2Vhckxvb2sgZXh0ZW5kcyBHZWFyQmFzZSB7XG4gICAgY29uc3RydWN0b3Iob3duZXIpIHtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLiRkZWZhdWx0ID0gbmV3IEdlYXJMb29rVmFsdWUodGhpcy4kb3duZXIuYWxwaGEsIHRoaXMuJG93bmVyLnJvdGF0aW9uLCB0aGlzLiRvd25lci5ncmF5ZWQpO1xuICAgICAgICB0aGlzLiRzdG9yYWdlID0ge307XG4gICAgfVxuICAgIGFkZFN0YXR1cyhwYWdlSWQsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSAnLScpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBhcnIgPSB2YWx1ZS5zcGxpdCgnLCcpO1xuICAgICAgICBsZXQgZ3Y7XG4gICAgICAgIGlmIChwYWdlSWQgPT0gbnVsbClcbiAgICAgICAgICAgIGd2ID0gdGhpcy4kZGVmYXVsdDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBndiA9IG5ldyBHZWFyTG9va1ZhbHVlKCk7XG4gICAgICAgICAgICB0aGlzLiRzdG9yYWdlW3BhZ2VJZF0gPSBndjtcbiAgICAgICAgfVxuICAgICAgICBndi5hbHBoYSA9IHBhcnNlRmxvYXQoYXJyWzBdKTtcbiAgICAgICAgZ3Yucm90YXRpb24gPSBwYXJzZUludChhcnJbMV0pO1xuICAgICAgICBndi5ncmF5ZWQgPSBhcnJbMl0gPT0gJzEnID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBhcHBseSgpIHtcbiAgICAgICAgbGV0IGd2ID0gdGhpcy4kc3RvcmFnZVt0aGlzLiRjb250cm9sbGVyLnNlbGVjdGVkUGFnZUlkXTtcbiAgICAgICAgaWYgKCFndilcbiAgICAgICAgICAgIGd2ID0gdGhpcy4kZGVmYXVsdDtcbiAgICAgICAgaWYgKHRoaXMuJHR3ZWVuICYmICFVSVBhY2thZ2UuJGNvbnN0cnVjdGluZ09iamVjdHMgJiYgIUdlYXJCYXNlLmRpc2FibGVBbGxUd2VlbkVmZmVjdCkge1xuICAgICAgICAgICAgdGhpcy4kb3duZXIuJGdlYXJMb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kb3duZXIuZ3JheWVkID0gZ3YuZ3JheWVkO1xuICAgICAgICAgICAgdGhpcy4kb3duZXIuJGdlYXJMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0d2VlbmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHR3ZWVuVGFyZ2V0LmFscGhhID09PSBndi5hbHBoYSAmJiB0aGlzLiR0d2VlblRhcmdldC5yb3RhdGlvbiA9PT0gZ3Yucm90YXRpb24pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlbmVyLmdvdG9BbmRTdG9wKHRoaXMuJHR3ZWVuZXIuZHVyYXRpb24pOyAvL3NldCB0byBlbmRcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhID0gZ3YuYWxwaGEgIT0gdGhpcy4kb3duZXIuYWxwaGE7XG4gICAgICAgICAgICBsZXQgYiA9IGd2LnJvdGF0aW9uICE9IHRoaXMuJG93bmVyLnJvdGF0aW9uO1xuICAgICAgICAgICAgaWYgKGEgfHwgYikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRvd25lci5oYXNHZWFyQ29udHJvbGxlcigwLCB0aGlzLiRjb250cm9sbGVyKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9ja1Rva2VuID0gdGhpcy4kb3duZXIubG9ja0dlYXJEaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5UYXJnZXQgPSBndjtcbiAgICAgICAgICAgICAgICBsZXQgdmFycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLiRnZWFyTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLmFscGhhID0gdGhpcy4kdHdlZW5WYWx1ZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kb3duZXIucm90YXRpb24gPSB0aGlzLiR0d2VlblZhbHVlLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kdHdlZW5WYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiR0d2VlblZhbHVlID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5WYWx1ZS54ID0gdGhpcy4kb3duZXIuYWxwaGE7XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5WYWx1ZS55ID0gdGhpcy4kb3duZXIucm90YXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5lciA9IGNyZWF0ZWpzLlR3ZWVuLmdldCh0aGlzLiR0d2VlblZhbHVlLCB2YXJzKVxuICAgICAgICAgICAgICAgICAgICAud2FpdCh0aGlzLiR0d2VlbkRlbGF5ICogMTAwMClcbiAgICAgICAgICAgICAgICAgICAgLnRvKHsgeDogZ3YuYWxwaGEsIHk6IGd2LnJvdGF0aW9uIH0sIHRoaXMuJHR3ZWVuVGltZSAqIDEwMDAsIHRoaXMuJGVhc2VUeXBlKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh0aGlzLnR3ZWVuQ29tcGxldGUsIG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kb3duZXIuJGdlYXJMb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kb3duZXIuZ3JheWVkID0gZ3YuZ3JheWVkO1xuICAgICAgICAgICAgdGhpcy4kb3duZXIuYWxwaGEgPSBndi5hbHBoYTtcbiAgICAgICAgICAgIHRoaXMuJG93bmVyLnJvdGF0aW9uID0gZ3Yucm90YXRpb247XG4gICAgICAgICAgICB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHR3ZWVuQ29tcGxldGUoKSB7XG4gICAgICAgIGlmICh0aGlzLiRsb2NrVG9rZW4gIT0gMCkge1xuICAgICAgICAgICAgdGhpcy4kb3duZXIucmVsZWFzZUdlYXJEaXNwbGF5KHRoaXMuJGxvY2tUb2tlbik7XG4gICAgICAgICAgICB0aGlzLiRsb2NrVG9rZW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHR3ZWVuZXIgPSBudWxsO1xuICAgICAgICBsZXQgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX19nZWFyU3RvcFwiIC8qIEdFQVJfU1RPUCAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLiRvd25lci5kaXNwYXRjaEV2ZW50KGV2dCwgdGhpcyk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy4kY29udHJvbGxlciA9PSBudWxsIHx8IHRoaXMuJG93bmVyLiRnZWFyTG9ja2VkIHx8IHRoaXMuJG93bmVyLiRpblByb2dyZXNzQnVpbGRpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBndiA9IHRoaXMuJHN0b3JhZ2VbdGhpcy4kY29udHJvbGxlci5zZWxlY3RlZFBhZ2VJZF07XG4gICAgICAgIGlmICghZ3YpIHtcbiAgICAgICAgICAgIGd2ID0gbmV3IEdlYXJMb29rVmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMuJHN0b3JhZ2VbdGhpcy4kY29udHJvbGxlci5zZWxlY3RlZFBhZ2VJZF0gPSBndjtcbiAgICAgICAgfVxuICAgICAgICBndi5hbHBoYSA9IHRoaXMuJG93bmVyLmFscGhhO1xuICAgICAgICBndi5yb3RhdGlvbiA9IHRoaXMuJG93bmVyLnJvdGF0aW9uO1xuICAgICAgICBndi5ncmF5ZWQgPSB0aGlzLiRvd25lci5ncmF5ZWQ7XG4gICAgfVxufVxuY2xhc3MgR2Vhckxvb2tWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IoYWxwaGEgPSAwLCByb3RhdGlvbiA9IDAsIGdyYXllZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYWxwaGEgPSBhbHBoYTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgICB0aGlzLmdyYXllZCA9IGdyYXllZDtcbiAgICB9XG59XG5cbmNsYXNzIEdlYXJTaXplIGV4dGVuZHMgR2VhckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyKSB7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy4kZGVmYXVsdCA9IG5ldyBHZWFyU2l6ZVZhbHVlKHRoaXMuJG93bmVyLndpZHRoLCB0aGlzLiRvd25lci5oZWlnaHQsIHRoaXMuJG93bmVyLnNjYWxlWCwgdGhpcy4kb3duZXIuc2NhbGVZKTtcbiAgICAgICAgdGhpcy4kc3RvcmFnZSA9IHt9O1xuICAgIH1cbiAgICBhZGRTdGF0dXMocGFnZUlkLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gJy0nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgYXJyID0gdmFsdWUuc3BsaXQoJywnKTtcbiAgICAgICAgbGV0IGd2O1xuICAgICAgICBpZiAocGFnZUlkID09IG51bGwpXG4gICAgICAgICAgICBndiA9IHRoaXMuJGRlZmF1bHQ7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3YgPSBuZXcgR2VhclNpemVWYWx1ZSgpO1xuICAgICAgICAgICAgdGhpcy4kc3RvcmFnZVtwYWdlSWRdID0gZ3Y7XG4gICAgICAgIH1cbiAgICAgICAgZ3Yud2lkdGggPSBwYXJzZUludChhcnJbMF0pO1xuICAgICAgICBndi5oZWlnaHQgPSBwYXJzZUludChhcnJbMV0pO1xuICAgICAgICBpZiAoYXJyLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGd2LnNjYWxlWCA9IHBhcnNlRmxvYXQoYXJyWzJdKTtcbiAgICAgICAgICAgIGd2LnNjYWxlWSA9IHBhcnNlRmxvYXQoYXJyWzNdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseSgpIHtcbiAgICAgICAgbGV0IGd2ID0gdGhpcy4kc3RvcmFnZVt0aGlzLiRjb250cm9sbGVyLnNlbGVjdGVkUGFnZUlkXTtcbiAgICAgICAgaWYgKCFndilcbiAgICAgICAgICAgIGd2ID0gdGhpcy4kZGVmYXVsdDtcbiAgICAgICAgaWYgKHRoaXMuJHR3ZWVuICYmICFVSVBhY2thZ2UuJGNvbnN0cnVjdGluZ09iamVjdHMgJiYgIUdlYXJCYXNlLmRpc2FibGVBbGxUd2VlbkVmZmVjdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHR3ZWVuZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kdHdlZW5UYXJnZXQud2lkdGggIT0gZ3Yud2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5UYXJnZXQuaGVpZ2h0ICE9IGd2LmhlaWdodCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiR0d2VlblRhcmdldC5zY2FsZVggIT0gZ3Yuc2NhbGVYIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuVGFyZ2V0LnNjYWxlWSAhPSBndi5zY2FsZVkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5lci5nb3RvQW5kU3RvcCh0aGlzLiR0d2VlbmVyLmR1cmF0aW9uKTsgLy9zZXQgdG8gZW5kXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhID0gZ3Yud2lkdGggIT0gdGhpcy4kb3duZXIud2lkdGggfHwgZ3YuaGVpZ2h0ICE9IHRoaXMuJG93bmVyLmhlaWdodDtcbiAgICAgICAgICAgIGxldCBiID0gZ3Yuc2NhbGVYICE9IHRoaXMuJG93bmVyLnNjYWxlWCB8fCBndi5zY2FsZVkgIT0gdGhpcy4kb3duZXIuc2NhbGVZO1xuICAgICAgICAgICAgaWYgKGEgfHwgYikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRvd25lci5oYXNHZWFyQ29udHJvbGxlcigwLCB0aGlzLiRjb250cm9sbGVyKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9ja1Rva2VuID0gdGhpcy4kb3duZXIubG9ja0dlYXJEaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5UYXJnZXQgPSBndjtcbiAgICAgICAgICAgICAgICBsZXQgdmFycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLiRnZWFyTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLnNldFNpemUodGhpcy4kdHdlZW5WYWx1ZS53aWR0aCwgdGhpcy4kdHdlZW5WYWx1ZS5oZWlnaHQsIHRoaXMuJG93bmVyLmdlYXJYWS5jb250cm9sbGVyID09IHRoaXMuJGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kb3duZXIuc2V0U2NhbGUodGhpcy4kdHdlZW5WYWx1ZS5zY2FsZVgsIHRoaXMuJHR3ZWVuVmFsdWUuc2NhbGVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLiRnZWFyTG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiR0d2VlblZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuVmFsdWUgPSBuZXcgR2VhclNpemVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuVmFsdWUud2lkdGggPSB0aGlzLiRvd25lci53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlblZhbHVlLmhlaWdodCA9IHRoaXMuJG93bmVyLmhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlblZhbHVlLnNjYWxlWCA9IHRoaXMuJG93bmVyLnNjYWxlWDtcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlblZhbHVlLnNjYWxlWSA9IHRoaXMuJG93bmVyLnNjYWxlWTtcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlbmVyID0gY3JlYXRlanMuVHdlZW4uZ2V0KHRoaXMuJHR3ZWVuVmFsdWUsIHZhcnMpXG4gICAgICAgICAgICAgICAgICAgIC53YWl0KHRoaXMuJHR3ZWVuRGVsYXkgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAudG8oeyB3aWR0aDogZ3Yud2lkdGgsIGhlaWdodDogZ3YuaGVpZ2h0LCBzY2FsZVg6IGd2LnNjYWxlWCwgc2NhbGVZOiBndi5zY2FsZVkgfSwgdGhpcy4kdHdlZW5UaW1lICogMTAwMCwgdGhpcy4kZWFzZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHRoaXMudHdlZW5Db21wbGV0ZSwgbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiRvd25lci5zZXRTaXplKGd2LndpZHRoLCBndi5oZWlnaHQsIHRoaXMuJG93bmVyLmdlYXJYWS5jb250cm9sbGVyID09IHRoaXMuJGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgdGhpcy4kb3duZXIuc2V0U2NhbGUoZ3Yuc2NhbGVYLCBndi5zY2FsZVkpO1xuICAgICAgICAgICAgdGhpcy4kb3duZXIuJGdlYXJMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0d2VlbkNvbXBsZXRlKCkge1xuICAgICAgICBpZiAodGhpcy4kbG9ja1Rva2VuICE9IDApIHtcbiAgICAgICAgICAgIHRoaXMuJG93bmVyLnJlbGVhc2VHZWFyRGlzcGxheSh0aGlzLiRsb2NrVG9rZW4pO1xuICAgICAgICAgICAgdGhpcy4kbG9ja1Rva2VuID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR0d2VlbmVyID0gbnVsbDtcbiAgICAgICAgbGV0IGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcIl9fZ2VhclN0b3BcIiAvKiBHRUFSX1NUT1AgKi8sIHRydWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy4kb3duZXIuZGlzcGF0Y2hFdmVudChldnQsIHRoaXMpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGNvbnRyb2xsZXIgPT0gbnVsbCB8fCB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCB8fCB0aGlzLiRvd25lci4kaW5Qcm9ncmVzc0J1aWxkaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZ3YgPSB0aGlzLiRzdG9yYWdlW3RoaXMuJGNvbnRyb2xsZXIuc2VsZWN0ZWRQYWdlSWRdO1xuICAgICAgICBpZiAoIWd2KSB7XG4gICAgICAgICAgICBndiA9IG5ldyBHZWFyU2l6ZVZhbHVlKCk7XG4gICAgICAgICAgICB0aGlzLiRzdG9yYWdlW3RoaXMuJGNvbnRyb2xsZXIuc2VsZWN0ZWRQYWdlSWRdID0gZ3Y7XG4gICAgICAgIH1cbiAgICAgICAgZ3Yud2lkdGggPSB0aGlzLiRvd25lci53aWR0aDtcbiAgICAgICAgZ3YuaGVpZ2h0ID0gdGhpcy4kb3duZXIuaGVpZ2h0O1xuICAgICAgICBndi5zY2FsZVggPSB0aGlzLiRvd25lci5zY2FsZVg7XG4gICAgICAgIGd2LnNjYWxlWSA9IHRoaXMuJG93bmVyLnNjYWxlWTtcbiAgICB9XG4gICAgdXBkYXRlRnJvbVJlbGF0aW9ucyhkeCwgZHkpIHtcbiAgICAgICAgaWYgKHRoaXMuJGNvbnRyb2xsZXIgPT0gbnVsbCB8fCB0aGlzLiRzdG9yYWdlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLiRzdG9yYWdlKSB7XG4gICAgICAgICAgICBsZXQgZ3YgPSB0aGlzLiRzdG9yYWdlW2tleV07XG4gICAgICAgICAgICBndi53aWR0aCArPSBkeDtcbiAgICAgICAgICAgIGd2LmhlaWdodCArPSBkeTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRkZWZhdWx0LndpZHRoICs9IGR4O1xuICAgICAgICB0aGlzLiRkZWZhdWx0LmhlaWdodCArPSBkeTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgIH1cbn1cbmNsYXNzIEdlYXJTaXplVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoID0gMCwgaGVpZ2h0ID0gMCwgc2NhbGVYID0gMCwgc2NhbGVZID0gMCkge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVk7XG4gICAgfVxufVxuXG5jbGFzcyBHZWFyWFkgZXh0ZW5kcyBHZWFyQmFzZSB7XG4gICAgY29uc3RydWN0b3Iob3duZXIpIHtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLiRkZWZhdWx0ID0gbmV3IGNyZWF0ZWpzLlBvaW50KHRoaXMuJG93bmVyLngsIHRoaXMuJG93bmVyLnkpO1xuICAgICAgICB0aGlzLiRzdG9yYWdlID0ge307XG4gICAgfVxuICAgIGFkZFN0YXR1cyhwYWdlSWQsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSAnLScpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBhcnIgPSB2YWx1ZS5zcGxpdCgnLCcpO1xuICAgICAgICBsZXQgcHQ7XG4gICAgICAgIGlmIChwYWdlSWQgPT0gbnVsbClcbiAgICAgICAgICAgIHB0ID0gdGhpcy4kZGVmYXVsdDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwdCA9IG5ldyBjcmVhdGVqcy5Qb2ludCgpO1xuICAgICAgICAgICAgdGhpcy4kc3RvcmFnZVtwYWdlSWRdID0gcHQ7XG4gICAgICAgIH1cbiAgICAgICAgcHQueCA9IHBhcnNlSW50KGFyclswXSk7XG4gICAgICAgIHB0LnkgPSBwYXJzZUludChhcnJbMV0pO1xuICAgIH1cbiAgICBhcHBseSgpIHtcbiAgICAgICAgbGV0IHB0ID0gdGhpcy4kc3RvcmFnZVt0aGlzLiRjb250cm9sbGVyLnNlbGVjdGVkUGFnZUlkXTtcbiAgICAgICAgaWYgKCFwdClcbiAgICAgICAgICAgIHB0ID0gdGhpcy4kZGVmYXVsdDtcbiAgICAgICAgaWYgKHRoaXMuJHR3ZWVuICYmICFVSVBhY2thZ2UuJGNvbnN0cnVjdGluZ09iamVjdHMgJiYgIUdlYXJCYXNlLmRpc2FibGVBbGxUd2VlbkVmZmVjdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHR3ZWVuZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kdHdlZW5UYXJnZXQueCA9PT0gcHQueCAmJiB0aGlzLiR0d2VlblRhcmdldC55ID09PSBwdC55KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5lci5nb3RvQW5kU3RvcCh0aGlzLiR0d2VlbmVyLmR1cmF0aW9uKTsgLy9zZXQgdG8gZW5kXG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kb3duZXIueCAhPSBwdC54IHx8IHRoaXMuJG93bmVyLnkgIT0gcHQueSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLmhhc0dlYXJDb250cm9sbGVyKDAsIHRoaXMuJGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGxvY2tUb2tlbiA9IHRoaXMuJG93bmVyLmxvY2tHZWFyRGlzcGxheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuVGFyZ2V0ID0gcHQ7XG4gICAgICAgICAgICAgICAgbGV0IHZhcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRvd25lci5zZXRYWSh0aGlzLiR0d2VlblZhbHVlLngsIHRoaXMuJHR3ZWVuVmFsdWUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kdHdlZW5WYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiR0d2VlblZhbHVlID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5WYWx1ZS54ID0gdGhpcy4kb3duZXIueDtcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlblZhbHVlLnkgPSB0aGlzLiRvd25lci55O1xuICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuZXIgPSBjcmVhdGVqcy5Ud2Vlbi5nZXQodGhpcy4kdHdlZW5WYWx1ZSwgdmFycylcbiAgICAgICAgICAgICAgICAgICAgLndhaXQodGhpcy4kdHdlZW5EZWxheSAqIDEwMDApXG4gICAgICAgICAgICAgICAgICAgIC50byh7IHg6IHB0LngsIHk6IHB0LnkgfSwgdGhpcy4kdHdlZW5UaW1lICogMTAwMCwgdGhpcy4kZWFzZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHRoaXMudHdlZW5Db21wbGV0ZSwgbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiRvd25lci5zZXRYWShwdC54LCBwdC55KTtcbiAgICAgICAgICAgIHRoaXMuJG93bmVyLiRnZWFyTG9ja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHdlZW5Db21wbGV0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGxvY2tUb2tlbiAhPSAwKSB7XG4gICAgICAgICAgICB0aGlzLiRvd25lci5yZWxlYXNlR2VhckRpc3BsYXkodGhpcy4kbG9ja1Rva2VuKTtcbiAgICAgICAgICAgIHRoaXMuJGxvY2tUb2tlbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kdHdlZW5lciA9IG51bGw7XG4gICAgICAgIGxldCBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJfX2dlYXJTdG9wXCIgLyogR0VBUl9TVE9QICovLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuJG93bmVyLmRpc3BhdGNoRXZlbnQoZXZ0LCB0aGlzKTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLiRjb250cm9sbGVyID09IG51bGwgfHwgdGhpcy4kb3duZXIuJGdlYXJMb2NrZWQgfHwgdGhpcy4kb3duZXIuJGluUHJvZ3Jlc3NCdWlsZGluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHB0ID0gdGhpcy4kc3RvcmFnZVt0aGlzLiRjb250cm9sbGVyLnNlbGVjdGVkUGFnZUlkXTtcbiAgICAgICAgaWYgKCFwdCkge1xuICAgICAgICAgICAgcHQgPSBuZXcgY3JlYXRlanMuUG9pbnQoKTtcbiAgICAgICAgICAgIHRoaXMuJHN0b3JhZ2VbdGhpcy4kY29udHJvbGxlci5zZWxlY3RlZFBhZ2VJZF0gPSBwdDtcbiAgICAgICAgfVxuICAgICAgICBwdC54ID0gdGhpcy4kb3duZXIueDtcbiAgICAgICAgcHQueSA9IHRoaXMuJG93bmVyLnk7XG4gICAgfVxuICAgIHVwZGF0ZUZyb21SZWxhdGlvbnMoZHgsIGR5KSB7XG4gICAgICAgIGlmICh0aGlzLiRjb250cm9sbGVyID09IG51bGwgfHwgdGhpcy4kc3RvcmFnZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy4kc3RvcmFnZSkge1xuICAgICAgICAgICAgbGV0IHB0ID0gdGhpcy4kc3RvcmFnZVtrZXldO1xuICAgICAgICAgICAgcHQueCArPSBkeDtcbiAgICAgICAgICAgIHB0LnkgKz0gZHk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZGVmYXVsdC54ICs9IGR4O1xuICAgICAgICB0aGlzLiRkZWZhdWx0LnkgKz0gZHk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgICB9XG59XG5cbmxldCBpc1VJT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgJ1VJT3duZXInIGluIG9iaiAmJiBvYmouVUlPd25lciAhPSBudWxsO1xufTtcblxuY2xhc3MgUmVsYXRpb25EZWYge1xuICAgIGNvcHlGcm9tKHNvdXJjZSkge1xuICAgICAgICB0aGlzLnBlcmNlbnQgPSBzb3VyY2UucGVyY2VudDtcbiAgICAgICAgdGhpcy50eXBlID0gc291cmNlLnR5cGU7XG4gICAgfVxufVxuY2xhc3MgUmVsYXRpb25JdGVtIHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcikge1xuICAgICAgICB0aGlzLiRvd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLiRkZWZzID0gW107XG4gICAgfVxuICAgIGdldCBvd25lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG93bmVyO1xuICAgIH1cbiAgICBzZXQgdGFyZ2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiR0YXJnZXQgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0YXJnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlUmVmVGFyZ2V0KHRoaXMuJHRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLiR0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0YXJnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRSZWZUYXJnZXQodGhpcy4kdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdGFyZ2V0O1xuICAgIH1cbiAgICBhZGQocmVsYXRpb25UeXBlLCB1c2VQZXJjZW50KSB7XG4gICAgICAgIGlmIChyZWxhdGlvblR5cGUgPT0gMjQgLyogU2l6ZSAqLykge1xuICAgICAgICAgICAgdGhpcy5hZGQoMTQgLyogV2lkdGggKi8sIHVzZVBlcmNlbnQpO1xuICAgICAgICAgICAgdGhpcy5hZGQoMTUgLyogSGVpZ2h0ICovLCB1c2VQZXJjZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy4kZGVmcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSB0aGlzLiRkZWZzW2ldO1xuICAgICAgICAgICAgaWYgKGRlZi50eXBlID09IHJlbGF0aW9uVHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcm5hbEFkZChyZWxhdGlvblR5cGUsIHVzZVBlcmNlbnQpO1xuICAgIH1cbiAgICBpbnRlcm5hbEFkZChyZWxhdGlvblR5cGUsIHVzZVBlcmNlbnQpIHtcbiAgICAgICAgaWYgKHJlbGF0aW9uVHlwZSA9PSAyNCAvKiBTaXplICovKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsQWRkKDE0IC8qIFdpZHRoICovLCB1c2VQZXJjZW50KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxBZGQoMTUgLyogSGVpZ2h0ICovLCB1c2VQZXJjZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5mbyA9IG5ldyBSZWxhdGlvbkRlZigpO1xuICAgICAgICBpbmZvLnBlcmNlbnQgPSB1c2VQZXJjZW50O1xuICAgICAgICBpbmZvLnR5cGUgPSByZWxhdGlvblR5cGU7XG4gICAgICAgIHRoaXMuJGRlZnMucHVzaChpbmZvKTtcbiAgICAgICAgLy9DRU5URVIgcmVsYXRpb24gd2lsbCBjYXVzZSBmbG9hdCBwaXhlbCwgc28gZW5hYmxlIHRoZSBhdXRvLXBpeGVsLXNuYXBwaW5nIGhlcmVcbiAgICAgICAgaWYgKHVzZVBlcmNlbnQgfHxcbiAgICAgICAgICAgIHJlbGF0aW9uVHlwZSA9PSAxIC8qIExlZnRfQ2VudGVyICovIHx8XG4gICAgICAgICAgICByZWxhdGlvblR5cGUgPT0gMyAvKiBDZW50ZXJfQ2VudGVyICovIHx8XG4gICAgICAgICAgICByZWxhdGlvblR5cGUgPT0gNSAvKiBSaWdodF9DZW50ZXIgKi8gfHxcbiAgICAgICAgICAgIHJlbGF0aW9uVHlwZSA9PSA4IC8qIFRvcF9NaWRkbGUgKi8gfHxcbiAgICAgICAgICAgIHJlbGF0aW9uVHlwZSA9PSAxMCAvKiBNaWRkbGVfTWlkZGxlICovIHx8XG4gICAgICAgICAgICByZWxhdGlvblR5cGUgPT0gMTIgLyogQm90dG9tX01pZGRsZSAqLykge1xuICAgICAgICAgICAgdGhpcy4kb3duZXIucGl4ZWxTbmFwcGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKHJlbGF0aW9uVHlwZSA9IDApIHtcbiAgICAgICAgaWYgKHJlbGF0aW9uVHlwZSA9PSAyNCAvKiBTaXplICovKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgxNCAvKiBXaWR0aCAqLyk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgxNSAvKiBIZWlnaHQgKi8pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYyA9IHRoaXMuJGRlZnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBrID0gZGMgLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGRlZnNba10udHlwZSA9PSByZWxhdGlvblR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkZWZzLnNwbGljZShrLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3B5RnJvbShzb3VyY2UpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0O1xuICAgICAgICB0aGlzLiRkZWZzLmxlbmd0aCA9IDA7XG4gICAgICAgIHNvdXJjZS4kZGVmcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICAgICAgbGV0IGluZm8yID0gbmV3IFJlbGF0aW9uRGVmKCk7XG4gICAgICAgICAgICBpbmZvMi5jb3B5RnJvbShpbmZvKTtcbiAgICAgICAgICAgIHRoaXMuJGRlZnMucHVzaChpbmZvMik7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy4kdGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZVJlZlRhcmdldCh0aGlzLiR0YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy4kdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGRlZnMubGVuZ3RoID09IDA7XG4gICAgfVxuICAgIGFwcGx5T25TZWxmUmVzaXplZChkV2lkdGgsIGRIZWlnaHQpIHtcbiAgICAgICAgbGV0IG94ID0gdGhpcy4kb3duZXIueDtcbiAgICAgICAgbGV0IG95ID0gdGhpcy4kb3duZXIueTtcbiAgICAgICAgdGhpcy4kZGVmcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChpbmZvLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogQ2VudGVyX0NlbnRlciAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDUgLyogUmlnaHRfQ2VudGVyICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRvd25lci54IC09IGRXaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBSaWdodF9MZWZ0ICovOlxuICAgICAgICAgICAgICAgIGNhc2UgNiAvKiBSaWdodF9SaWdodCAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kb3duZXIueCAtPSBkV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTAgLyogTWlkZGxlX01pZGRsZSAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDEyIC8qIEJvdHRvbV9NaWRkbGUgKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLnkgLT0gZEhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTEgLyogQm90dG9tX1RvcCAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDEzIC8qIEJvdHRvbV9Cb3R0b20gKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLnkgLT0gZEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBpZiAob3ggIT0gdGhpcy4kb3duZXIueCB8fCBveSAhPSB0aGlzLiRvd25lci55KSB7XG4gICAgICAgICAgICBveCA9IHRoaXMuJG93bmVyLnggLSBveDtcbiAgICAgICAgICAgIG95ID0gdGhpcy4kb3duZXIueSAtIG95O1xuICAgICAgICAgICAgdGhpcy4kb3duZXIudXBkYXRlR2VhckZyb21SZWxhdGlvbnMoMSAvKiBYWSAqLywgb3gsIG95KTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRvd25lci5wYXJlbnQgIT0gbnVsbCAmJiB0aGlzLiRvd25lci5wYXJlbnQuJHRyYW5zaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci5wYXJlbnQuJHRyYW5zaXRpb25zLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHQudXBkYXRlRnJvbVJlbGF0aW9ucyh0aGlzLiRvd25lci5pZCwgb3gsIG95KTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseU9uWFlDaGFuZ2VkKGluZm8sIGR4LCBkeSkge1xuICAgICAgICBsZXQgdG1wO1xuICAgICAgICBzd2l0Y2ggKGluZm8udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIExlZnRfTGVmdCAqLzpcbiAgICAgICAgICAgIGNhc2UgMSAvKiBMZWZ0X0NlbnRlciAqLzpcbiAgICAgICAgICAgIGNhc2UgMiAvKiBMZWZ0X1JpZ2h0ICovOlxuICAgICAgICAgICAgY2FzZSAzIC8qIENlbnRlcl9DZW50ZXIgKi86XG4gICAgICAgICAgICBjYXNlIDQgLyogUmlnaHRfTGVmdCAqLzpcbiAgICAgICAgICAgIGNhc2UgNSAvKiBSaWdodF9DZW50ZXIgKi86XG4gICAgICAgICAgICBjYXNlIDYgLyogUmlnaHRfUmlnaHQgKi86XG4gICAgICAgICAgICAgICAgdGhpcy4kb3duZXIueCArPSBkeDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNyAvKiBUb3BfVG9wICovOlxuICAgICAgICAgICAgY2FzZSA4IC8qIFRvcF9NaWRkbGUgKi86XG4gICAgICAgICAgICBjYXNlIDkgLyogVG9wX0JvdHRvbSAqLzpcbiAgICAgICAgICAgIGNhc2UgMTAgLyogTWlkZGxlX01pZGRsZSAqLzpcbiAgICAgICAgICAgIGNhc2UgMTEgLyogQm90dG9tX1RvcCAqLzpcbiAgICAgICAgICAgIGNhc2UgMTIgLyogQm90dG9tX01pZGRsZSAqLzpcbiAgICAgICAgICAgIGNhc2UgMTMgLyogQm90dG9tX0JvdHRvbSAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci55ICs9IGR5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNCAvKiBXaWR0aCAqLzpcbiAgICAgICAgICAgIGNhc2UgMTUgLyogSGVpZ2h0ICovOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNiAvKiBMZWZ0RXh0X0xlZnQgKi86XG4gICAgICAgICAgICBjYXNlIDE3IC8qIExlZnRFeHRfUmlnaHQgKi86XG4gICAgICAgICAgICAgICAgdG1wID0gdGhpcy4kb3duZXIueDtcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci54ICs9IGR4O1xuICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLndpZHRoID0gdGhpcy4kb3duZXIuJHJhd1dpZHRoIC0gKHRoaXMuJG93bmVyLnggLSB0bXApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOCAvKiBSaWdodEV4dF9MZWZ0ICovOlxuICAgICAgICAgICAgY2FzZSAxOSAvKiBSaWdodEV4dF9SaWdodCAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci53aWR0aCA9IHRoaXMuJG93bmVyLiRyYXdXaWR0aCArIGR4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMCAvKiBUb3BFeHRfVG9wICovOlxuICAgICAgICAgICAgY2FzZSAyMSAvKiBUb3BFeHRfQm90dG9tICovOlxuICAgICAgICAgICAgICAgIHRtcCA9IHRoaXMuJG93bmVyLnk7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3duZXIueSArPSBkeTtcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci5oZWlnaHQgPSB0aGlzLiRvd25lci4kcmF3SGVpZ2h0IC0gKHRoaXMuJG93bmVyLnkgLSB0bXApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMiAvKiBCb3R0b21FeHRfVG9wICovOlxuICAgICAgICAgICAgY2FzZSAyMyAvKiBCb3R0b21FeHRfQm90dG9tICovOlxuICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLmhlaWdodCA9IHRoaXMuJG93bmVyLiRyYXdIZWlnaHQgKyBkeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseU9uU2l6ZUNoYW5nZWQoaW5mbykge1xuICAgICAgICBsZXQgdGFyZ2V0WCwgdGFyZ2V0WTtcbiAgICAgICAgaWYgKHRoaXMuJHRhcmdldCAhPSB0aGlzLiRvd25lci5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRhcmdldFggPSB0aGlzLiR0YXJnZXQueDtcbiAgICAgICAgICAgIHRhcmdldFkgPSB0aGlzLiR0YXJnZXQueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFggPSAwO1xuICAgICAgICAgICAgdGFyZ2V0WSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHYsIHRtcDtcbiAgICAgICAgc3dpdGNoIChpbmZvLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBMZWZ0X0xlZnQgKi86XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEgLyogTGVmdF9DZW50ZXIgKi86XG4gICAgICAgICAgICAgICAgdiA9IHRoaXMuJG93bmVyLnggLSAodGFyZ2V0WCArIHRoaXMuJHRhcmdldFdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8ucGVyY2VudClcbiAgICAgICAgICAgICAgICAgICAgdiA9ICh2IC8gdGhpcy4kdGFyZ2V0V2lkdGgpICogdGhpcy4kdGFyZ2V0LiRyYXdXaWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci54ID0gdGFyZ2V0WCArIHRoaXMuJHRhcmdldC4kcmF3V2lkdGggLyAyICsgdjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBMZWZ0X1JpZ2h0ICovOlxuICAgICAgICAgICAgICAgIHYgPSB0aGlzLiRvd25lci54IC0gKHRhcmdldFggKyB0aGlzLiR0YXJnZXRXaWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8ucGVyY2VudClcbiAgICAgICAgICAgICAgICAgICAgdiA9ICh2IC8gdGhpcy4kdGFyZ2V0V2lkdGgpICogdGhpcy4kdGFyZ2V0LiRyYXdXaWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci54ID0gdGFyZ2V0WCArIHRoaXMuJHRhcmdldC4kcmF3V2lkdGggKyB2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIENlbnRlcl9DZW50ZXIgKi86XG4gICAgICAgICAgICAgICAgdiA9IHRoaXMuJG93bmVyLnggKyB0aGlzLiRvd25lci4kcmF3V2lkdGggLyAyIC0gKHRhcmdldFggKyB0aGlzLiR0YXJnZXRXaWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnBlcmNlbnQpXG4gICAgICAgICAgICAgICAgICAgIHYgPSAodiAvIHRoaXMuJHRhcmdldFdpZHRoKSAqIHRoaXMuJHRhcmdldC4kcmF3V2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3duZXIueCA9IHRhcmdldFggKyB0aGlzLiR0YXJnZXQuJHJhd1dpZHRoIC8gMiArIHYgLSB0aGlzLiRvd25lci4kcmF3V2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0IC8qIFJpZ2h0X0xlZnQgKi86XG4gICAgICAgICAgICAgICAgdiA9IHRoaXMuJG93bmVyLnggKyB0aGlzLiRvd25lci4kcmF3V2lkdGggLSB0YXJnZXRYO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnBlcmNlbnQpXG4gICAgICAgICAgICAgICAgICAgIHYgPSAodiAvIHRoaXMuJHRhcmdldFdpZHRoKSAqIHRoaXMuJHRhcmdldC4kcmF3V2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3duZXIueCA9IHRhcmdldFggKyB2IC0gdGhpcy4kb3duZXIuJHJhd1dpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1IC8qIFJpZ2h0X0NlbnRlciAqLzpcbiAgICAgICAgICAgICAgICB2ID0gdGhpcy4kb3duZXIueCArIHRoaXMuJG93bmVyLiRyYXdXaWR0aCAtICh0YXJnZXRYICsgdGhpcy4kdGFyZ2V0V2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5wZXJjZW50KVxuICAgICAgICAgICAgICAgICAgICB2ID0gKHYgLyB0aGlzLiR0YXJnZXRXaWR0aCkgKiB0aGlzLiR0YXJnZXQuJHJhd1dpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLnggPSB0YXJnZXRYICsgdGhpcy4kdGFyZ2V0LiRyYXdXaWR0aCAvIDIgKyB2IC0gdGhpcy4kb3duZXIuJHJhd1dpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2IC8qIFJpZ2h0X1JpZ2h0ICovOlxuICAgICAgICAgICAgICAgIHYgPSB0aGlzLiRvd25lci54ICsgdGhpcy4kb3duZXIuJHJhd1dpZHRoIC0gKHRhcmdldFggKyB0aGlzLiR0YXJnZXRXaWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8ucGVyY2VudClcbiAgICAgICAgICAgICAgICAgICAgdiA9ICh2IC8gdGhpcy4kdGFyZ2V0V2lkdGgpICogdGhpcy4kdGFyZ2V0LiRyYXdXaWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci54ID0gdGFyZ2V0WCArIHRoaXMuJHRhcmdldC4kcmF3V2lkdGggKyB2IC0gdGhpcy4kb3duZXIuJHJhd1dpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3IC8qIFRvcF9Ub3AgKi86XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDggLyogVG9wX01pZGRsZSAqLzpcbiAgICAgICAgICAgICAgICB2ID0gdGhpcy4kb3duZXIueSAtICh0YXJnZXRZICsgdGhpcy4kdGFyZ2V0SGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8ucGVyY2VudClcbiAgICAgICAgICAgICAgICAgICAgdiA9ICh2IC8gdGhpcy4kdGFyZ2V0SGVpZ2h0KSAqIHRoaXMuJHRhcmdldC4kcmF3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLnkgPSB0YXJnZXRZICsgdGhpcy4kdGFyZ2V0LiRyYXdIZWlnaHQgLyAyICsgdjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOSAvKiBUb3BfQm90dG9tICovOlxuICAgICAgICAgICAgICAgIHYgPSB0aGlzLiRvd25lci55IC0gKHRhcmdldFkgKyB0aGlzLiR0YXJnZXRIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnBlcmNlbnQpXG4gICAgICAgICAgICAgICAgICAgIHYgPSAodiAvIHRoaXMuJHRhcmdldEhlaWdodCkgKiB0aGlzLiR0YXJnZXQuJHJhd0hlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci55ID0gdGFyZ2V0WSArIHRoaXMuJHRhcmdldC4kcmF3SGVpZ2h0ICsgdjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTAgLyogTWlkZGxlX01pZGRsZSAqLzpcbiAgICAgICAgICAgICAgICB2ID0gdGhpcy4kb3duZXIueSArIHRoaXMuJG93bmVyLiRyYXdIZWlnaHQgLyAyIC0gKHRhcmdldFkgKyB0aGlzLiR0YXJnZXRIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5wZXJjZW50KVxuICAgICAgICAgICAgICAgICAgICB2ID0gKHYgLyB0aGlzLiR0YXJnZXRIZWlnaHQpICogdGhpcy4kdGFyZ2V0LiRyYXdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3duZXIueSA9IHRhcmdldFkgKyB0aGlzLiR0YXJnZXQuJHJhd0hlaWdodCAvIDIgKyB2IC0gdGhpcy4kb3duZXIuJHJhd0hlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDExIC8qIEJvdHRvbV9Ub3AgKi86XG4gICAgICAgICAgICAgICAgdiA9IHRoaXMuJG93bmVyLnkgKyB0aGlzLiRvd25lci4kcmF3SGVpZ2h0IC0gdGFyZ2V0WTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5wZXJjZW50KVxuICAgICAgICAgICAgICAgICAgICB2ID0gKHYgLyB0aGlzLiR0YXJnZXRIZWlnaHQpICogdGhpcy4kdGFyZ2V0LiRyYXdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3duZXIueSA9IHRhcmdldFkgKyB2IC0gdGhpcy4kb3duZXIuJHJhd0hlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTIgLyogQm90dG9tX01pZGRsZSAqLzpcbiAgICAgICAgICAgICAgICB2ID0gdGhpcy4kb3duZXIueSArIHRoaXMuJG93bmVyLiRyYXdIZWlnaHQgLSAodGFyZ2V0WSArIHRoaXMuJHRhcmdldEhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnBlcmNlbnQpXG4gICAgICAgICAgICAgICAgICAgIHYgPSAodiAvIHRoaXMuJHRhcmdldEhlaWdodCkgKiB0aGlzLiR0YXJnZXQuJHJhd0hlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci55ID0gdGFyZ2V0WSArIHRoaXMuJHRhcmdldC4kcmF3SGVpZ2h0IC8gMiArIHYgLSB0aGlzLiRvd25lci4kcmF3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMyAvKiBCb3R0b21fQm90dG9tICovOlxuICAgICAgICAgICAgICAgIHYgPSB0aGlzLiRvd25lci55ICsgdGhpcy4kb3duZXIuJHJhd0hlaWdodCAtICh0YXJnZXRZICsgdGhpcy4kdGFyZ2V0SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5wZXJjZW50KVxuICAgICAgICAgICAgICAgICAgICB2ID0gKHYgLyB0aGlzLiR0YXJnZXRIZWlnaHQpICogdGhpcy4kdGFyZ2V0LiRyYXdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3duZXIueSA9IHRhcmdldFkgKyB0aGlzLiR0YXJnZXQuJHJhd0hlaWdodCArIHYgLSB0aGlzLiRvd25lci4kcmF3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNCAvKiBXaWR0aCAqLzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kb3duZXIuJGluUHJvZ3Jlc3NCdWlsZGluZyAmJiB0aGlzLiRvd25lciA9PSB0aGlzLiR0YXJnZXQucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy4kb3duZXIuc291cmNlV2lkdGggLSB0aGlzLiR0YXJnZXQuJGluaXRXaWR0aDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLiRvd25lci4kcmF3V2lkdGggLSB0aGlzLiR0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5wZXJjZW50KVxuICAgICAgICAgICAgICAgICAgICB2ID0gKHYgLyB0aGlzLiR0YXJnZXRXaWR0aCkgKiB0aGlzLiR0YXJnZXQuJHJhd1dpZHRoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiR0YXJnZXQgPT0gdGhpcy4kb3duZXIucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRvd25lci5zZXRTaXplKHRoaXMuJHRhcmdldC4kcmF3V2lkdGggKyB2LCB0aGlzLiRvd25lci4kcmF3SGVpZ2h0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLndpZHRoID0gdGhpcy4kdGFyZ2V0LiRyYXdXaWR0aCArIHY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE1IC8qIEhlaWdodCAqLzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kb3duZXIuJGluUHJvZ3Jlc3NCdWlsZGluZyAmJiB0aGlzLiRvd25lciA9PSB0aGlzLiR0YXJnZXQucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy4kb3duZXIuc291cmNlSGVpZ2h0IC0gdGhpcy4kdGFyZ2V0LiRpbml0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuJG93bmVyLiRyYXdIZWlnaHQgLSB0aGlzLiR0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8ucGVyY2VudClcbiAgICAgICAgICAgICAgICAgICAgdiA9ICh2IC8gdGhpcy4kdGFyZ2V0SGVpZ2h0KSAqIHRoaXMuJHRhcmdldC4kcmF3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiR0YXJnZXQgPT0gdGhpcy4kb3duZXIucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRvd25lci5zZXRTaXplKHRoaXMuJG93bmVyLiRyYXdXaWR0aCwgdGhpcy4kdGFyZ2V0LiRyYXdIZWlnaHQgKyB2LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLmhlaWdodCA9IHRoaXMuJHRhcmdldC4kcmF3SGVpZ2h0ICsgdjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTYgLyogTGVmdEV4dF9MZWZ0ICovOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNyAvKiBMZWZ0RXh0X1JpZ2h0ICovOlxuICAgICAgICAgICAgICAgIHYgPSB0aGlzLiRvd25lci54IC0gKHRhcmdldFggKyB0aGlzLiR0YXJnZXRXaWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8ucGVyY2VudClcbiAgICAgICAgICAgICAgICAgICAgdiA9ICh2IC8gdGhpcy4kdGFyZ2V0V2lkdGgpICogdGhpcy4kdGFyZ2V0LiRyYXdXaWR0aDtcbiAgICAgICAgICAgICAgICB0bXAgPSB0aGlzLiRvd25lci54O1xuICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLnggPSB0YXJnZXRYICsgdGhpcy4kdGFyZ2V0LiRyYXdXaWR0aCArIHY7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3duZXIud2lkdGggPSB0aGlzLiRvd25lci4kcmF3V2lkdGggLSAodGhpcy4kb3duZXIueCAtIHRtcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE4IC8qIFJpZ2h0RXh0X0xlZnQgKi86XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE5IC8qIFJpZ2h0RXh0X1JpZ2h0ICovOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRvd25lci4kaW5Qcm9ncmVzc0J1aWxkaW5nICYmIHRoaXMuJG93bmVyID09IHRoaXMuJHRhcmdldC5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLiRvd25lci5zb3VyY2VXaWR0aCAtICh0YXJnZXRYICsgdGhpcy4kdGFyZ2V0LiRpbml0V2lkdGgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuJG93bmVyLndpZHRoIC0gKHRhcmdldFggKyB0aGlzLiR0YXJnZXRXaWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJG93bmVyICE9IHRoaXMuJHRhcmdldC5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHYgKz0gdGhpcy4kb3duZXIueDtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5wZXJjZW50KVxuICAgICAgICAgICAgICAgICAgICB2ID0gKHYgLyB0aGlzLiR0YXJnZXRXaWR0aCkgKiB0aGlzLiR0YXJnZXQuJHJhd1dpZHRoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRvd25lciAhPSB0aGlzLiR0YXJnZXQucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRvd25lci53aWR0aCA9IHRhcmdldFggKyB0aGlzLiR0YXJnZXQuJHJhd1dpZHRoICsgdiAtIHRoaXMuJG93bmVyLng7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRvd25lci53aWR0aCA9IHRhcmdldFggKyB0aGlzLiR0YXJnZXQuJHJhd1dpZHRoICsgdjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjAgLyogVG9wRXh0X1RvcCAqLzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjEgLyogVG9wRXh0X0JvdHRvbSAqLzpcbiAgICAgICAgICAgICAgICB2ID0gdGhpcy4kb3duZXIueSAtICh0YXJnZXRZICsgdGhpcy4kdGFyZ2V0SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5wZXJjZW50KVxuICAgICAgICAgICAgICAgICAgICB2ID0gKHYgLyB0aGlzLiR0YXJnZXRIZWlnaHQpICogdGhpcy4kdGFyZ2V0LiRyYXdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdG1wID0gdGhpcy4kb3duZXIueTtcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci55ID0gdGFyZ2V0WSArIHRoaXMuJHRhcmdldC4kcmF3SGVpZ2h0ICsgdjtcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci5oZWlnaHQgPSB0aGlzLiRvd25lci4kcmF3SGVpZ2h0IC0gKHRoaXMuJG93bmVyLnkgLSB0bXApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMiAvKiBCb3R0b21FeHRfVG9wICovOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMyAvKiBCb3R0b21FeHRfQm90dG9tICovOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRvd25lci4kaW5Qcm9ncmVzc0J1aWxkaW5nICYmIHRoaXMuJG93bmVyID09IHRoaXMuJHRhcmdldC5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLiRvd25lci5zb3VyY2VIZWlnaHQgLSAodGFyZ2V0WSArIHRoaXMuJHRhcmdldC4kaW5pdEhlaWdodCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy4kb3duZXIuJHJhd0hlaWdodCAtICh0YXJnZXRZICsgdGhpcy4kdGFyZ2V0SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kb3duZXIgIT0gdGhpcy4kdGFyZ2V0LnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgdiArPSB0aGlzLiRvd25lci55O1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnBlcmNlbnQpXG4gICAgICAgICAgICAgICAgICAgIHYgPSAodiAvIHRoaXMuJHRhcmdldEhlaWdodCkgKiB0aGlzLiR0YXJnZXQuJHJhd0hlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kb3duZXIgIT0gdGhpcy4kdGFyZ2V0LnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kb3duZXIuaGVpZ2h0ID0gdGFyZ2V0WSArIHRoaXMuJHRhcmdldC4kcmF3SGVpZ2h0ICsgdiAtIHRoaXMuJG93bmVyLnk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRvd25lci5oZWlnaHQgPSB0YXJnZXRZICsgdGhpcy4kdGFyZ2V0LiRyYXdIZWlnaHQgKyB2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFJlZlRhcmdldCh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCAhPSB0aGlzLiRvd25lci5wYXJlbnQpXG4gICAgICAgICAgICB0YXJnZXQub24oXCJfX3h5Q2hhbmdlZFwiIC8qIFhZX0NIQU5HRUQgKi8sIHRoaXMuJHRhcmdldFhZQ2hhbmdlZCwgdGhpcyk7XG4gICAgICAgIHRhcmdldC5vbihcIl9fc2l6ZUNoYW5nZWRcIiAvKiBTSVpFX0NIQU5HRUQgKi8sIHRoaXMuJHRhcmdldFNpemVDaGFuZ2VkLCB0aGlzKTtcbiAgICAgICAgdGFyZ2V0Lm9uKFwiX19zaXplRGVsYXlDaGFuZ2VcIiAvKiBTSVpFX0RFTEFZX0NIQU5HRSAqLywgdGhpcy4kdGFyZ2V0U2l6ZVdpbGxDaGFuZ2UsIHRoaXMpO1xuICAgICAgICB0aGlzLiR0YXJnZXRYID0gdGhpcy4kdGFyZ2V0Lng7XG4gICAgICAgIHRoaXMuJHRhcmdldFkgPSB0aGlzLiR0YXJnZXQueTtcbiAgICAgICAgdGhpcy4kdGFyZ2V0V2lkdGggPSB0aGlzLiR0YXJnZXQuJHJhd1dpZHRoO1xuICAgICAgICB0aGlzLiR0YXJnZXRIZWlnaHQgPSB0aGlzLiR0YXJnZXQuJHJhd0hlaWdodDtcbiAgICB9XG4gICAgcmVsZWFzZVJlZlRhcmdldCh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0Lm9mZihcIl9feHlDaGFuZ2VkXCIgLyogWFlfQ0hBTkdFRCAqLywgdGhpcy4kdGFyZ2V0WFlDaGFuZ2VkKTtcbiAgICAgICAgdGFyZ2V0Lm9mZihcIl9fc2l6ZUNoYW5nZWRcIiAvKiBTSVpFX0NIQU5HRUQgKi8sIHRoaXMuJHRhcmdldFNpemVDaGFuZ2VkKTtcbiAgICAgICAgdGFyZ2V0Lm9mZihcIl9fc2l6ZURlbGF5Q2hhbmdlXCIgLyogU0laRV9ERUxBWV9DSEFOR0UgKi8sIHRoaXMuJHRhcmdldFNpemVXaWxsQ2hhbmdlKTtcbiAgICB9XG4gICAgJHRhcmdldFhZQ2hhbmdlZChldnQpIHtcbiAgICAgICAgaWYgKHRoaXMuJG93bmVyLnJlbGF0aW9ucy4kZGVhbGluZyAhPSBudWxsIHx8XG4gICAgICAgICAgICAodGhpcy4kb3duZXIuZ3JvdXAgIT0gbnVsbCAmJiB0aGlzLiRvd25lci5ncm91cC4kdXBkYXRpbmcpKSB7XG4gICAgICAgICAgICB0aGlzLiR0YXJnZXRYID0gdGhpcy4kdGFyZ2V0Lng7XG4gICAgICAgICAgICB0aGlzLiR0YXJnZXRZID0gdGhpcy4kdGFyZ2V0Lnk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kb3duZXIucmVsYXRpb25zLiRkZWFsaW5nID0gdGhpcy4kdGFyZ2V0O1xuICAgICAgICBsZXQgb3ggPSB0aGlzLiRvd25lci54O1xuICAgICAgICBsZXQgb3kgPSB0aGlzLiRvd25lci55O1xuICAgICAgICBsZXQgZHggPSB0aGlzLiR0YXJnZXQueCAtIHRoaXMuJHRhcmdldFg7XG4gICAgICAgIGxldCBkeSA9IHRoaXMuJHRhcmdldC55IC0gdGhpcy4kdGFyZ2V0WTtcbiAgICAgICAgdGhpcy4kZGVmcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICAgICAgdGhpcy5hcHBseU9uWFlDaGFuZ2VkKGluZm8sIGR4LCBkeSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLiR0YXJnZXRYID0gdGhpcy4kdGFyZ2V0Lng7XG4gICAgICAgIHRoaXMuJHRhcmdldFkgPSB0aGlzLiR0YXJnZXQueTtcbiAgICAgICAgaWYgKG94ICE9IHRoaXMuJG93bmVyLnggfHwgb3kgIT0gdGhpcy4kb3duZXIueSkge1xuICAgICAgICAgICAgb3ggPSB0aGlzLiRvd25lci54IC0gb3g7XG4gICAgICAgICAgICBveSA9IHRoaXMuJG93bmVyLnkgLSBveTtcbiAgICAgICAgICAgIHRoaXMuJG93bmVyLnVwZGF0ZUdlYXJGcm9tUmVsYXRpb25zKDEgLyogWFkgKi8sIG94LCBveSk7XG4gICAgICAgICAgICBpZiAodGhpcy4kb3duZXIucGFyZW50ICE9IG51bGwgJiYgdGhpcy4kb3duZXIucGFyZW50LiR0cmFuc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3duZXIucGFyZW50LiR0cmFuc2l0aW9ucy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0LnVwZGF0ZUZyb21SZWxhdGlvbnModGhpcy4kb3duZXIuaWQsIG94LCBveSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kb3duZXIucmVsYXRpb25zLiRkZWFsaW5nID0gbnVsbDtcbiAgICB9XG4gICAgJHRhcmdldFNpemVDaGFuZ2VkKGV2dCkge1xuICAgICAgICBpZiAodGhpcy4kb3duZXIucmVsYXRpb25zLiRkZWFsaW5nICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJG93bmVyLnJlbGF0aW9ucy4kZGVhbGluZyA9IHRoaXMuJHRhcmdldDtcbiAgICAgICAgbGV0IG94ID0gdGhpcy4kb3duZXIueDtcbiAgICAgICAgbGV0IG95ID0gdGhpcy4kb3duZXIueTtcbiAgICAgICAgbGV0IG93ID0gdGhpcy4kb3duZXIuJHJhd1dpZHRoO1xuICAgICAgICBsZXQgb2ggPSB0aGlzLiRvd25lci4kcmF3SGVpZ2h0O1xuICAgICAgICB0aGlzLiRkZWZzLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5T25TaXplQ2hhbmdlZChpbmZvKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuJHRhcmdldFdpZHRoID0gdGhpcy4kdGFyZ2V0LiRyYXdXaWR0aDtcbiAgICAgICAgdGhpcy4kdGFyZ2V0SGVpZ2h0ID0gdGhpcy4kdGFyZ2V0LiRyYXdIZWlnaHQ7XG4gICAgICAgIGlmIChveCAhPSB0aGlzLiRvd25lci54IHx8IG95ICE9IHRoaXMuJG93bmVyLnkpIHtcbiAgICAgICAgICAgIG94ID0gdGhpcy4kb3duZXIueCAtIG94O1xuICAgICAgICAgICAgb3kgPSB0aGlzLiRvd25lci55IC0gb3k7XG4gICAgICAgICAgICB0aGlzLiRvd25lci51cGRhdGVHZWFyRnJvbVJlbGF0aW9ucygxIC8qIFhZICovLCBveCwgb3kpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJG93bmVyLnBhcmVudCAhPSBudWxsICYmIHRoaXMuJG93bmVyLnBhcmVudC4kdHJhbnNpdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJG93bmVyLnBhcmVudC4kdHJhbnNpdGlvbnMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdC51cGRhdGVGcm9tUmVsYXRpb25zKHRoaXMuJG93bmVyLmlkLCBveCwgb3kpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdyAhPSB0aGlzLiRvd25lci4kcmF3V2lkdGggfHwgb2ggIT0gdGhpcy4kb3duZXIuJHJhd0hlaWdodCkge1xuICAgICAgICAgICAgb3cgPSB0aGlzLiRvd25lci4kcmF3V2lkdGggLSBvdztcbiAgICAgICAgICAgIG9oID0gdGhpcy4kb3duZXIuJHJhd0hlaWdodCAtIG9oO1xuICAgICAgICAgICAgdGhpcy4kb3duZXIudXBkYXRlR2VhckZyb21SZWxhdGlvbnMoMiAvKiBTaXplICovLCBvdywgb2gpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJG93bmVyLnJlbGF0aW9ucy4kZGVhbGluZyA9IG51bGw7XG4gICAgfVxuICAgICR0YXJnZXRTaXplV2lsbENoYW5nZShldnQpIHtcbiAgICAgICAgdGhpcy4kb3duZXIucmVsYXRpb25zLnNpemVEaXJ0eSA9IHRydWU7XG4gICAgfVxufVxuXG5jbGFzcyBSZWxhdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyKSB7XG4gICAgICAgIHRoaXMuc2l6ZURpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJG93bmVyID0gb3duZXI7XG4gICAgICAgIHRoaXMuJGl0ZW1zID0gW107XG4gICAgfVxuICAgIGFkZCh0YXJnZXQsIHJlbGF0aW9uVHlwZSwgdXNlUGVyY2VudCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLiRpdGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy4kaXRlbXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbS50YXJnZXQgPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hZGQocmVsYXRpb25UeXBlLCB1c2VQZXJjZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0l0ZW0gPSBuZXcgUmVsYXRpb25JdGVtKHRoaXMuJG93bmVyKTtcbiAgICAgICAgbmV3SXRlbS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIG5ld0l0ZW0uYWRkKHJlbGF0aW9uVHlwZSwgdXNlUGVyY2VudCk7XG4gICAgICAgIHRoaXMuJGl0ZW1zLnB1c2gobmV3SXRlbSk7XG4gICAgfVxuICAgIGFkZEl0ZW1zKHRhcmdldCwgc2lkZVBhaXJzKSB7XG4gICAgICAgIGxldCBhcnIgPSBzaWRlUGFpcnMuc3BsaXQoJywnKTtcbiAgICAgICAgbGV0IHM7XG4gICAgICAgIGxldCB1c2VQZXJjZW50O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgcyA9IGFycltpXTtcbiAgICAgICAgICAgIGlmICghcylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChzLmNoYXJBdChzLmxlbmd0aCAtIDEpID09ICclJykge1xuICAgICAgICAgICAgICAgIHMgPSBzLnN1YnN0cigwLCBzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHVzZVBlcmNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHVzZVBlcmNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzLmluZGV4T2YoJy0nKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBzID0gYCR7c30tJHtzfWA7XG4gICAgICAgICAgICBsZXQgdCA9IFJlbGF0aW9ucy5SRUxBVElPTl9OQU1FUy5pbmRleE9mKHMpO1xuICAgICAgICAgICAgaWYgKHQgPT0gLTEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlbGF0aW9uIHR5cGUnKTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHRhcmdldCwgdCwgdXNlUGVyY2VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKHRhcmdldCwgcmVsYXRpb25UeXBlID0gMCkge1xuICAgICAgICBsZXQgY250ID0gdGhpcy4kaXRlbXMubGVuZ3RoO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgY250KSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuJGl0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0udGFyZ2V0ID09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlKHJlbGF0aW9uVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBjbnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnRhaW5zKHRhcmdldCkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy4kaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kaXRlbXNbaV0udGFyZ2V0ID09IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNsZWFyRm9yKHRhcmdldCkge1xuICAgICAgICBsZXQgY250ID0gdGhpcy4kaXRlbXMubGVuZ3RoO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgY250KSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuJGl0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0udGFyZ2V0ID09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBjbnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJBbGwoKSB7XG4gICAgICAgIHRoaXMuJGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLmRpc3Bvc2UoKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuJGl0ZW1zLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGNvcHlGcm9tKHNvdXJjZSkge1xuICAgICAgICB0aGlzLmNsZWFyQWxsKCk7XG4gICAgICAgIHNvdXJjZS4kaXRlbXMuZm9yRWFjaChyaSA9PiB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IG5ldyBSZWxhdGlvbkl0ZW0odGhpcy4kb3duZXIpO1xuICAgICAgICAgICAgaXRlbS5jb3B5RnJvbShyaSk7XG4gICAgICAgICAgICB0aGlzLiRpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbGVhckFsbCgpO1xuICAgIH1cbiAgICBvbk93bmVyU2l6ZUNoYW5nZWQoZFdpZHRoLCBkSGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLiRpdGVtcy5sZW5ndGggPD0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uYXBwbHlPblNlbGZSZXNpemVkKGRXaWR0aCwgZEhlaWdodCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBlbnN1cmVSZWxhdGlvbnNTaXplQ29ycmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGl0ZW1zLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNpemVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS50YXJnZXQuZW5zdXJlU2l6ZUNvcnJlY3QoKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmxlbmd0aCA9PSAwO1xuICAgIH1cbiAgICBzZXR1cCh4bWwpIHtcbiAgICAgICAgeG1sLmNoaWxkcmVuLmZvckVhY2goY3htbCA9PiB7XG4gICAgICAgICAgICBpZiAoY3htbC5ub2RlTmFtZSAhPSAncmVsYXRpb24nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB0YXJnZXRJZDtcbiAgICAgICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgICAgICB0YXJnZXRJZCA9IGN4bWwuYXR0cmlidXRlcy50YXJnZXQ7XG4gICAgICAgICAgICBpZiAodGhpcy4kb3duZXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldElkKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzLiRvd25lci5wYXJlbnQuZ2V0Q2hpbGRCeUlkKHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuJG93bmVyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY2FsbCBmcm9tIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuJG93bmVyLmdldENoaWxkQnlJZCh0YXJnZXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbXModGFyZ2V0LCBjeG1sLmF0dHJpYnV0ZXMuc2lkZVBhaXIpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59XG5SZWxhdGlvbnMuUkVMQVRJT05fTkFNRVMgPSBbXG4gICAgJ2xlZnQtbGVmdCcsXG4gICAgJ2xlZnQtY2VudGVyJyxcbiAgICAnbGVmdC1yaWdodCcsXG4gICAgJ2NlbnRlci1jZW50ZXInLFxuICAgICdyaWdodC1sZWZ0JyxcbiAgICAncmlnaHQtY2VudGVyJyxcbiAgICAncmlnaHQtcmlnaHQnLFxuICAgICd0b3AtdG9wJyxcbiAgICAndG9wLW1pZGRsZScsXG4gICAgJ3RvcC1ib3R0b20nLFxuICAgICdtaWRkbGUtbWlkZGxlJyxcbiAgICAnYm90dG9tLXRvcCcsXG4gICAgJ2JvdHRvbS1taWRkbGUnLFxuICAgICdib3R0b20tYm90dG9tJyxcbiAgICAnd2lkdGgtd2lkdGgnLFxuICAgICdoZWlnaHQtaGVpZ2h0JyxcbiAgICAnbGVmdGV4dC1sZWZ0JyxcbiAgICAnbGVmdGV4dC1yaWdodCcsXG4gICAgJ3JpZ2h0ZXh0LWxlZnQnLFxuICAgICdyaWdodGV4dC1yaWdodCcsXG4gICAgJ3RvcGV4dC10b3AnLFxuICAgICd0b3BleHQtYm90dG9tJyxcbiAgICAnYm90dG9tZXh0LXRvcCcsXG4gICAgJ2JvdHRvbWV4dC1ib3R0b20nIC8vMjNcbl07XG5cbmxldCBpc0NvbG9yR2VhciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiY29sb3JcIiBpbiBvYmo7XG59O1xuXG5jbGFzcyBHZWFyQ29sb3IgZXh0ZW5kcyBHZWFyQmFzZSB7XG4gICAgY29uc3RydWN0b3Iob3duZXIpIHtcbiAgICAgICAgc3VwZXIob3duZXIpO1xuICAgICAgICB0aGlzLiRkZWZhdWx0ID0gJyNmZmZmZmYnO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLiRkZWZhdWx0ID0gdGhpcy4kb3duZXJbJ2NvbG9yJ107XG4gICAgICAgIHRoaXMuJHN0b3JhZ2UgPSB7fTtcbiAgICB9XG4gICAgYWRkU3RhdHVzKHBhZ2VJZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09ICctJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGNvbCA9IHZhbHVlO1xuICAgICAgICBpZiAocGFnZUlkID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLiRkZWZhdWx0ID0gY29sO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRzdG9yYWdlW3BhZ2VJZF0gPSBjb2w7XG4gICAgfVxuICAgIGFwcGx5KCkge1xuICAgICAgICB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCA9IHRydWU7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy4kc3RvcmFnZVt0aGlzLiRjb250cm9sbGVyLnNlbGVjdGVkUGFnZUlkXTtcbiAgICAgICAgaWYgKGRhdGEgIT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy4kb3duZXJbJ2NvbG9yJ10gPSBTdHJpbmdVdGlsLkhFWDJSR0IoZGF0YSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuJG93bmVyWydjb2xvciddID0gU3RyaW5nVXRpbC5IRVgyUkdCKHRoaXMuJGRlZmF1bHQpO1xuICAgICAgICB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGNvbnRyb2xsZXIgPT0gbnVsbCB8fCB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCB8fCB0aGlzLiRvd25lci4kaW5Qcm9ncmVzc0J1aWxkaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRzdG9yYWdlW3RoaXMuJGNvbnRyb2xsZXIuc2VsZWN0ZWRQYWdlSWRdID0gdGhpcy4kb3duZXJbJ2NvbG9yJ107XG4gICAgfVxufVxuXG5sZXQgaXNBbmltYXRpb25HZWFyID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgXCJwbGF5aW5nXCIgaW4gb2JqICYmIFwiZnJhbWVcIiBpbiBvYmo7XG59O1xuXG5jbGFzcyBHZWFyQW5pbWF0aW9uIGV4dGVuZHMgR2VhckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyKSB7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy4kZGVmYXVsdCA9IG5ldyBHZWFyQW5pbWF0aW9uVmFsdWUodGhpcy4kb3duZXJbJ3BsYXlpbmcnXSwgdGhpcy4kb3duZXJbJ2ZyYW1lJ10pO1xuICAgICAgICB0aGlzLiRzdG9yYWdlID0ge307XG4gICAgfVxuICAgIGFkZFN0YXR1cyhwYWdlSWQsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSAnLScpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBndjtcbiAgICAgICAgaWYgKHBhZ2VJZCA9PSBudWxsKVxuICAgICAgICAgICAgZ3YgPSB0aGlzLiRkZWZhdWx0O1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGd2ID0gbmV3IEdlYXJBbmltYXRpb25WYWx1ZSgpO1xuICAgICAgICAgICAgdGhpcy4kc3RvcmFnZVtwYWdlSWRdID0gZ3Y7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFyciA9IHZhbHVlLnNwbGl0KCcsJyk7XG4gICAgICAgIGd2LmZyYW1lID0gcGFyc2VJbnQoYXJyWzBdKTtcbiAgICAgICAgZ3YucGxheWluZyA9IGFyclsxXSA9PSAncCc7XG4gICAgfVxuICAgIGFwcGx5KCkge1xuICAgICAgICB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCA9IHRydWU7XG4gICAgICAgIGxldCBndiA9IHRoaXMuJHN0b3JhZ2VbdGhpcy4kY29udHJvbGxlci5zZWxlY3RlZFBhZ2VJZF07XG4gICAgICAgIGlmICghZ3YpXG4gICAgICAgICAgICBndiA9IHRoaXMuJGRlZmF1bHQ7XG4gICAgICAgIHRoaXMuJG93bmVyWydmcmFtZSddID0gZ3YuZnJhbWU7XG4gICAgICAgIHRoaXMuJG93bmVyWydwbGF5aW5nJ10gPSBndi5wbGF5aW5nO1xuICAgICAgICB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGNvbnRyb2xsZXIgPT0gbnVsbCB8fCB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCB8fCB0aGlzLiRvd25lci4kaW5Qcm9ncmVzc0J1aWxkaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZ3YgPSB0aGlzLiRzdG9yYWdlW3RoaXMuJGNvbnRyb2xsZXIuc2VsZWN0ZWRQYWdlSWRdO1xuICAgICAgICBpZiAoIWd2KSB7XG4gICAgICAgICAgICBndiA9IG5ldyBHZWFyQW5pbWF0aW9uVmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMuJHN0b3JhZ2VbdGhpcy4kY29udHJvbGxlci5zZWxlY3RlZFBhZ2VJZF0gPSBndjtcbiAgICAgICAgfVxuICAgICAgICBndi5mcmFtZSA9IHRoaXMuJG93bmVyWydmcmFtZSddO1xuICAgICAgICBndi5wbGF5aW5nID0gdGhpcy4kb3duZXJbJ3BsYXlpbmcnXTtcbiAgICB9XG59XG5jbGFzcyBHZWFyQW5pbWF0aW9uVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHBsYXlpbmcgPSB0cnVlLCBmcmFtZSA9IDApIHtcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gcGxheWluZztcbiAgICAgICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xuICAgIH1cbn1cblxuY2xhc3MgU3ByaXRlIGV4dGVuZHMgY3JlYXRlanMuRGlzcGxheU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuJHRpbnQgPSAnI2ZmZic7XG4gICAgICAgIHRoaXMuJGlzVHJpbSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgdGludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHRpbnQ7XG4gICAgfVxuICAgIHNldCB0aW50KHYpIHtcbiAgICAgICAgdGhpcy4kdGludCA9IHY7XG4gICAgICAgIGxldCByZ2IgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IFtcbiAgICAgICAgICAgIG5ldyBjcmVhdGVqcy5Db2xvckZpbHRlcigrcmdiWzBdIC8gMjU1LCArcmdiWzFdIC8gMjU1LCArcmdiWzJdIC8gMjU1LCAxLCAwLCAwLCAwLCAxKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBzZXQgc291cmNlUmVjdChyZWN0KSB7XG4gICAgICAgIHRoaXMuJHNvdXJjZVJlY3QgPSByZWN0O1xuICAgIH1cbiAgICBnZXQgc291cmNlUmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNvdXJjZVJlY3Q7XG4gICAgfVxuICAgIHNldCB0ZXh0dXJlUmVjdChyZWN0KSB7XG4gICAgICAgIHRoaXMuJHRleHR1cmVSZWN0ID0gcmVjdDtcbiAgICB9XG4gICAgZ2V0IHRleHR1cmVSZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdGV4dHVyZVJlY3Q7XG4gICAgfVxuICAgIGlzVmlzaWJsZSgpIHtcbiAgICAgICAgdmFyIGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8XG4gICAgICAgICAgICAodGhpcy50ZXh0dXJlICYmXG4gICAgICAgICAgICAgICAgKHRoaXMudGV4dHVyZVsnbmF0dXJhbFdpZHRoJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlWydnZXRDb250ZXh0J10gfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlWydyZWFkeVN0YXRlJ10gPj0gMikpO1xuICAgICAgICByZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcbiAgICB9XG4gICAgZ2V0Qm91bmRzKCkge1xuICAgICAgICB2YXIgcmVjdCA9IHN1cGVyLmdldEJvdW5kcygpO1xuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLnRleHR1cmUsIG8gPSB0aGlzLnNvdXJjZVJlY3QgfHwgdGV4dHVyZTtcbiAgICAgICAgdmFyIGhhc0NvbnRlbnQgPSB0ZXh0dXJlICYmICh0ZXh0dXJlWyduYXR1cmFsV2lkdGgnXSB8fCB0ZXh0dXJlWydnZXRDb250ZXh0J10gfHwgdGV4dHVyZVsncmVhZHlTdGF0ZSddID49IDIpO1xuICAgICAgICByZXR1cm4gaGFzQ29udGVudCA/IHRoaXMuc291cmNlUmVjdC5zZXRWYWx1ZXMoMCwgMCwgby53aWR0aCwgby5oZWlnaHQpIDogbnVsbDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy90b2RvXG4gICAgfVxufVxuU3ByaXRlLiRjYWNoZWRUZXh0dXJlUG9vbCA9IHt9O1xuXG5jbGFzcyBHZWFySWNvbiBleHRlbmRzIEdlYXJCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcikge1xuICAgICAgICBzdXBlcihvd25lcik7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuJGRlZmF1bHQgPSB0aGlzLiRvd25lci5pY29uO1xuICAgICAgICB0aGlzLiRzdG9yYWdlID0ge307XG4gICAgfVxuICAgIGFkZFN0YXR1cyhwYWdlSWQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwYWdlSWQgPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuJGRlZmF1bHQgPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kc3RvcmFnZVtwYWdlSWRdID0gdmFsdWU7XG4gICAgfVxuICAgIGFwcGx5KCkge1xuICAgICAgICB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCA9IHRydWU7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy4kc3RvcmFnZVt0aGlzLiRjb250cm9sbGVyLnNlbGVjdGVkUGFnZUlkXTtcbiAgICAgICAgaWYgKGRhdGEgIT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy4kb3duZXIuaWNvbiA9IGRhdGE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuJG93bmVyLmljb24gPSB0aGlzLiRkZWZhdWx0O1xuICAgICAgICB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGNvbnRyb2xsZXIgPT0gbnVsbCB8fCB0aGlzLiRvd25lci4kZ2VhckxvY2tlZCB8fCB0aGlzLiRvd25lci4kaW5Qcm9ncmVzc0J1aWxkaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRzdG9yYWdlW3RoaXMuJGNvbnRyb2xsZXIuc2VsZWN0ZWRQYWdlSWRdID0gdGhpcy4kb3duZXIuaWNvbjtcbiAgICB9XG59XG5cbmNsYXNzIEdlYXJUZXh0IGV4dGVuZHMgR2VhckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyKSB7XG4gICAgICAgIHN1cGVyKG93bmVyKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy4kZGVmYXVsdCA9IHRoaXMuJG93bmVyLnRleHQ7XG4gICAgICAgIHRoaXMuJHN0b3JhZ2UgPSB7fTtcbiAgICB9XG4gICAgYWRkU3RhdHVzKHBhZ2VJZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHBhZ2VJZCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy4kZGVmYXVsdCA9IHZhbHVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRzdG9yYWdlW3BhZ2VJZF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgYXBwbHkoKSB7XG4gICAgICAgIHRoaXMuJG93bmVyLiRnZWFyTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLiRzdG9yYWdlW3RoaXMuJGNvbnRyb2xsZXIuc2VsZWN0ZWRQYWdlSWRdO1xuICAgICAgICBpZiAoZGF0YSAhPSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLiRvd25lci50ZXh0ID0gZGF0YTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kb3duZXIudGV4dCA9IHRoaXMuJGRlZmF1bHQ7XG4gICAgICAgIHRoaXMuJG93bmVyLiRnZWFyTG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy4kY29udHJvbGxlciA9PSBudWxsIHx8IHRoaXMuJG93bmVyLiRnZWFyTG9ja2VkIHx8IHRoaXMuJG93bmVyLiRpblByb2dyZXNzQnVpbGRpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJHN0b3JhZ2VbdGhpcy4kY29udHJvbGxlci5zZWxlY3RlZFBhZ2VJZF0gPSB0aGlzLiRvd25lci50ZXh0O1xuICAgIH1cbn1cblxuY2xhc3MgR09iamVjdCBleHRlbmRzIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuJHggPSAwO1xuICAgICAgICB0aGlzLiR5ID0gMDtcbiAgICAgICAgdGhpcy4kd2lkdGggPSAwO1xuICAgICAgICB0aGlzLiRoZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLiRhbHBoYSA9IDE7XG4gICAgICAgIHRoaXMuJHJvdGF0aW9uID0gMDtcbiAgICAgICAgdGhpcy4kdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuJHRvdWNoYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuJGdyYXllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRkcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kc2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy4kc2NhbGVZID0gMTtcbiAgICAgICAgdGhpcy4kc2tld1ggPSAwO1xuICAgICAgICB0aGlzLiRza2V3WSA9IDA7XG4gICAgICAgIHRoaXMuJHBpdm90ID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG4gICAgICAgIHRoaXMuJHBpdm90QXNBbmNob3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kcGl2b3RPZmZzZXQgPSBuZXcgY3JlYXRlanMuUG9pbnQoKTtcbiAgICAgICAgdGhpcy4kc29ydGluZ09yZGVyID0gMDtcbiAgICAgICAgdGhpcy4kaW50ZXJuYWxWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kZm9jdXNhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJHBpeGVsU25hcHBpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kaGFuZGxpbmdDb250cm9sbGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGxhc3RDb2xvckNvbXBvbmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLiRkaXNwbGF5RXZlbnRNYXAgPSB7fTtcbiAgICAgICAgLyoqQGludGVybmFsICovXG4gICAgICAgIHRoaXMuJHJhd1dpZHRoID0gMDtcbiAgICAgICAgLyoqQGludGVybmFsICovXG4gICAgICAgIHRoaXMuJHJhd0hlaWdodCA9IDA7XG4gICAgICAgIC8qKkBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLiRpbml0V2lkdGggPSAwO1xuICAgICAgICAvKipAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy4kaW5pdEhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuJHNvdXJjZVdpZHRoID0gMDtcbiAgICAgICAgdGhpcy4kc291cmNlSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy4kaWQgPSBgJHtHT2JqZWN0LmdJbnN0YW5jZUNvdW50ZXIrK31gO1xuICAgICAgICB0aGlzLiRuYW1lID0gJyc7XG4gICAgICAgIHRoaXMuY3JlYXRlRGlzcGxheU9iamVjdCgpO1xuICAgICAgICB0aGlzLiRyZWxhdGlvbnMgPSBuZXcgUmVsYXRpb25zKHRoaXMpO1xuICAgICAgICB0aGlzLiRnZWFycyA9IFtdO1xuICAgICAgICB0aGlzLiR0b3VjaGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRpZDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRuYW1lO1xuICAgIH1cbiAgICBzZXQgbmFtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiRuYW1lID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4keDtcbiAgICB9XG4gICAgc2V0IHgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRYWSh2YWx1ZSwgdGhpcy4keSk7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4keTtcbiAgICB9XG4gICAgc2V0IHkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRYWSh0aGlzLiR4LCB2YWx1ZSk7XG4gICAgfVxuICAgIHNldFhZKHh2LCB5dikge1xuICAgICAgICBpZiAodGhpcy4keCAhPSB4diB8fCB0aGlzLiR5ICE9IHl2KSB7XG4gICAgICAgICAgICB0aGlzLiR4ID0geHY7XG4gICAgICAgICAgICB0aGlzLiR5ID0geXY7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVhZQ2hhbmdlZCgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVHZWFyKDEgLyogWFkgKi8pO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHBhcmVudC5zZXRCb3VuZHNDaGFuZ2VkRmxhZygpO1xuICAgICAgICAgICAgICAgIGxldCBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJfX3h5Q2hhbmdlZFwiIC8qIFhZX0NIQU5HRUQgKi8sIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQoZXZ0LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChHT2JqZWN0LmRyYWdnaW5nT2JqZWN0ID09IHRoaXMgJiYgIUdPYmplY3Quc1VwZGF0aW5nV2hpbGVEcmFnZ2luZylcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsVG9HbG9iYWxSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBHT2JqZWN0LnNHbG9iYWxSZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcGl4ZWxTbmFwcGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHBpeGVsU25hcHBpbmc7XG4gICAgfVxuICAgIHNldCBwaXhlbFNuYXBwaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRwaXhlbFNuYXBwaW5nICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRwaXhlbFNuYXBwaW5nID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVhZQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNlbnRlcihyZXN0cmFpbnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcjtcbiAgICAgICAgaWYgKHRoaXMuJHBhcmVudCAhPSBudWxsKVxuICAgICAgICAgICAgciA9IHRoaXMucGFyZW50O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByID0gRGVjbHMkMS5HUm9vdC5pbnN0O1xuICAgICAgICB0aGlzLnNldFhZKChyLndpZHRoIC0gdGhpcy53aWR0aCkgLyAyLCAoci5oZWlnaHQgLSB0aGlzLmhlaWdodCkgLyAyKTtcbiAgICAgICAgaWYgKHJlc3RyYWludCkge1xuICAgICAgICAgICAgdGhpcy5hZGRSZWxhdGlvbihyLCAzIC8qIENlbnRlcl9DZW50ZXIgKi8pO1xuICAgICAgICAgICAgdGhpcy5hZGRSZWxhdGlvbihyLCAxMCAvKiBNaWRkbGVfTWlkZGxlICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlU2l6ZUNvcnJlY3QoKTtcbiAgICAgICAgaWYgKHRoaXMuJHJlbGF0aW9ucy5zaXplRGlydHkpXG4gICAgICAgICAgICB0aGlzLiRyZWxhdGlvbnMuZW5zdXJlUmVsYXRpb25zU2l6ZUNvcnJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHdpZHRoO1xuICAgIH1cbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRTaXplKHZhbHVlLCB0aGlzLiRyYXdIZWlnaHQpO1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICB0aGlzLmVuc3VyZVNpemVDb3JyZWN0KCk7XG4gICAgICAgIGlmICh0aGlzLiRyZWxhdGlvbnMuc2l6ZURpcnR5KVxuICAgICAgICAgICAgdGhpcy4kcmVsYXRpb25zLmVuc3VyZVJlbGF0aW9uc1NpemVDb3JyZWN0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRoZWlnaHQ7XG4gICAgfVxuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRTaXplKHRoaXMuJHJhd1dpZHRoLCB2YWx1ZSk7XG4gICAgfVxuICAgIHNldFNpemUod3YsIGh2LCBpZ25vcmVQaXZvdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLiRyYXdXaWR0aCAhPSB3diB8fCB0aGlzLiRyYXdIZWlnaHQgIT0gaHYpIHtcbiAgICAgICAgICAgIHRoaXMuJHJhd1dpZHRoID0gd3Y7XG4gICAgICAgICAgICB0aGlzLiRyYXdIZWlnaHQgPSBodjtcbiAgICAgICAgICAgIHd2ID0gTWF0aC5tYXgoMCwgd3YpO1xuICAgICAgICAgICAgaHYgPSBNYXRoLm1heCgwLCBodik7XG4gICAgICAgICAgICBsZXQgZGlmZncgPSB3diAtIHRoaXMubWFwUGl2b3RXaWR0aCgxKTtcbiAgICAgICAgICAgIGxldCBkaWZmaCA9IGh2IC0gdGhpcy5tYXBQaXZvdEhlaWdodCgxKTtcbiAgICAgICAgICAgIHRoaXMuJHdpZHRoID0gd3Y7XG4gICAgICAgICAgICB0aGlzLiRoZWlnaHQgPSBodjtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2l6ZUNoYW5nZWQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRwaXZvdC54ICE9IDAgfHwgdGhpcy4kcGl2b3QueSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiRwaXZvdEFzQW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaWdub3JlUGl2b3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFhZKHRoaXMueCAtIHRoaXMuJHBpdm90LnggKiBkaWZmdywgdGhpcy55IC0gdGhpcy4kcGl2b3QueSAqIGRpZmZoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQaXZvdE9mZnNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseVBpdm90KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVHZWFyKDIgLyogU2l6ZSAqLyk7XG4gICAgICAgICAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVsYXRpb25zLm9uT3duZXJTaXplQ2hhbmdlZChkaWZmdywgZGlmZmgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHBhcmVudC5zZXRCb3VuZHNDaGFuZ2VkRmxhZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcIl9fc2l6ZUNoYW5nZWRcIiAvKiBTSVpFX0NIQU5HRUQgKi8sIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChldnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVuc3VyZVNpemVDb3JyZWN0KCkgeyB9XG4gICAgZ2V0IHNvdXJjZUhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNvdXJjZUhlaWdodDtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZVdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc291cmNlV2lkdGg7XG4gICAgfVxuICAgIGdldCBpbml0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaW5pdEhlaWdodDtcbiAgICB9XG4gICAgZ2V0IGluaXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGluaXRXaWR0aDtcbiAgICB9XG4gICAgZ2V0IGFjdHVhbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIE1hdGguYWJzKHRoaXMuJHNjYWxlWCk7XG4gICAgfVxuICAgIGdldCBhY3R1YWxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodCAqIE1hdGguYWJzKHRoaXMuJHNjYWxlWSk7XG4gICAgfVxuICAgIGdldCBzY2FsZVgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzY2FsZVg7XG4gICAgfVxuICAgIHNldCBzY2FsZVgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRTY2FsZSh2YWx1ZSwgdGhpcy4kc2NhbGVZKTtcbiAgICB9XG4gICAgZ2V0IHNjYWxlWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNjYWxlWTtcbiAgICB9XG4gICAgc2V0IHNjYWxlWSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldFNjYWxlKHRoaXMuJHNjYWxlWCwgdmFsdWUpO1xuICAgIH1cbiAgICBzZXRTY2FsZShzeCwgc3kpIHtcbiAgICAgICAgaWYgKHRoaXMuJHNjYWxlWCAhPSBzeCB8fCB0aGlzLiRzY2FsZVkgIT0gc3kpIHtcbiAgICAgICAgICAgIHRoaXMuJHNjYWxlWCA9IHN4O1xuICAgICAgICAgICAgdGhpcy4kc2NhbGVZID0gc3k7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjYWxlQ2hhbmdlZCgpO1xuICAgICAgICAgICAgdGhpcy5hcHBseVBpdm90KCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUdlYXIoMiAvKiBTaXplICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2tld1goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRza2V3WDtcbiAgICB9XG4gICAgc2V0IHNrZXdYKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0U2tldyh2YWx1ZSwgdGhpcy4kc2tld1kpO1xuICAgIH1cbiAgICBnZXQgc2tld1koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRza2V3WTtcbiAgICB9XG4gICAgc2V0IHNrZXdZKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0U2tldyh0aGlzLiRza2V3WCwgdmFsdWUpO1xuICAgIH1cbiAgICBzZXRTa2V3KHh2LCB5dikge1xuICAgICAgICBpZiAodGhpcy4kc2tld1ggIT0geHYgfHwgdGhpcy4kc2tld1kgIT0geXYpIHtcbiAgICAgICAgICAgIHRoaXMuJHNrZXdYID0geHY7XG4gICAgICAgICAgICB0aGlzLiRza2V3WSA9IHl2O1xuICAgICAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5za2V3WCA9IHh2O1xuICAgICAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5za2V3WSA9IHl2O1xuICAgICAgICAgICAgdGhpcy5hcHBseVBpdm90KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFwUGl2b3RXaWR0aChzY2FsZSkge1xuICAgICAgICByZXR1cm4gc2NhbGUgKiB0aGlzLiR3aWR0aDtcbiAgICB9XG4gICAgbWFwUGl2b3RIZWlnaHQoc2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlICogdGhpcy4kaGVpZ2h0O1xuICAgIH1cbiAgICBnZXQgcGl2b3RYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcGl2b3QueDtcbiAgICB9XG4gICAgZ2V0IHBpdm90WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHBpdm90Lnk7XG4gICAgfVxuICAgIHNldCBwaXZvdFgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRQaXZvdCh2YWx1ZSwgdGhpcy5waXZvdFkpO1xuICAgIH1cbiAgICBzZXQgcGl2b3RZKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0UGl2b3QodGhpcy5waXZvdFgsIHZhbHVlKTtcbiAgICB9XG4gICAgc2V0UGl2b3QoeHYsIHl2LCBhc0FuY2hvciA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLiRwaXZvdC54ICE9IHh2IHx8IHRoaXMuJHBpdm90LnkgIT0geXYgfHwgdGhpcy4kcGl2b3RBc0FuY2hvciAhPSBhc0FuY2hvcikge1xuICAgICAgICAgICAgdGhpcy4kcGl2b3Quc2V0VmFsdWVzKHh2LCB5dik7XG4gICAgICAgICAgICB0aGlzLiRwaXZvdEFzQW5jaG9yID0gYXNBbmNob3I7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBpdm90T2Zmc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVhZQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludGVybmFsU2V0UGl2b3QoeHYsIHl2LCBhc0FuY2hvcikge1xuICAgICAgICB0aGlzLiRwaXZvdC5zZXRWYWx1ZXMoeHYsIHl2KTtcbiAgICAgICAgdGhpcy4kcGl2b3RBc0FuY2hvciA9IGFzQW5jaG9yO1xuICAgICAgICBpZiAoYXNBbmNob3IpXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVhZQ2hhbmdlZCgpO1xuICAgIH1cbiAgICB1cGRhdGVQaXZvdE9mZnNldCgpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHRoaXMuJGRpc3BsYXlPYmplY3QuZ2V0TWF0cml4KCk7XG4gICAgICAgIGlmICh0aGlzLiRwaXZvdC54ICE9IDAgfHwgKHRoaXMuJHBpdm90LnkgIT0gMCAmJiB0cmFuc2Zvcm0pKSB7XG4gICAgICAgICAgICBsZXQgdnggPSB0aGlzLm1hcFBpdm90V2lkdGgodGhpcy4kcGl2b3QueCksIHZ5ID0gdGhpcy5tYXBQaXZvdEhlaWdodCh0aGlzLiRwaXZvdC55KTtcbiAgICAgICAgICAgIEdPYmplY3Quc0hlbHBlclBvaW50LnNldFZhbHVlcyh2eCwgdnkpO1xuICAgICAgICAgICAgbGV0IHAgPSB0cmFuc2Zvcm0udHJhbnNmb3JtUG9pbnQoR09iamVjdC5zSGVscGVyUG9pbnQueCwgR09iamVjdC5zSGVscGVyUG9pbnQueSk7XG4gICAgICAgICAgICAocC54IC09IHRyYW5zZm9ybS50eCksIChwLnkgLT0gdHJhbnNmb3JtLnR5KTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRYID0gdGhpcy4kcGl2b3QueCAqIHRoaXMuJHdpZHRoIC0gcC54O1xuICAgICAgICAgICAgbGV0IG9mZnNldFkgPSB0aGlzLiRwaXZvdC55ICogdGhpcy4kaGVpZ2h0IC0gcC55O1xuICAgICAgICAgICAgdGhpcy4kcGl2b3RPZmZzZXQuc2V0VmFsdWVzKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuJHBpdm90T2Zmc2V0LnNldFZhbHVlcygwLCAwKTtcbiAgICB9XG4gICAgYXBwbHlQaXZvdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHBpdm90LnggIT0gMCB8fCB0aGlzLiRwaXZvdC55ICE9IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGl2b3RPZmZzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlWFlDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRvdWNoYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHRvdWNoYWJsZTtcbiAgICB9XG4gICAgc2V0IHRvdWNoYWJsZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiR0b3VjaGFibGUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuJHRvdWNoYWJsZSkge1xuICAgICAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5tb3VzZUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5tb3VzZUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZ3JheWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZ3JheWVkO1xuICAgIH1cbiAgICBzZXQgZ3JheWVkKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRncmF5ZWQgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGdyYXllZCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVHcmF5ZWRDaGFuZ2VkKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUdlYXIoMyAvKiBMb29rICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLiRncmF5ZWQgJiYgdGhpcy4kdG91Y2hhYmxlO1xuICAgIH1cbiAgICBzZXQgZW5hYmxlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdyYXllZCA9ICF2YWx1ZTtcbiAgICAgICAgdGhpcy50b3VjaGFibGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHJvdGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcm90YXRpb247XG4gICAgfVxuICAgIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kcm90YXRpb24gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJHJvdGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy4kZGlzcGxheU9iamVjdClcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwbGF5T2JqZWN0LnJvdGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFwcGx5UGl2b3QoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlR2VhcigzIC8qIExvb2sgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBub3JtYWxpemVSb3RhdGlvbigpIHtcbiAgICAgICAgbGV0IHJvdCA9IHRoaXMuJHJvdGF0aW9uICUgMzYwO1xuICAgICAgICBpZiAocm90ID4gMTgwKVxuICAgICAgICAgICAgcm90IC09IDM2MDtcbiAgICAgICAgZWxzZSBpZiAocm90IDwgLTE4MClcbiAgICAgICAgICAgIHJvdCArPSAzNjA7XG4gICAgICAgIHJldHVybiByb3Q7XG4gICAgfVxuICAgIGdldCBhbHBoYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGFscGhhO1xuICAgIH1cbiAgICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGFscGhhICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRhbHBoYSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBbHBoYSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUFscGhhKCkge1xuICAgICAgICBpZiAodGhpcy4kZGlzcGxheU9iamVjdClcbiAgICAgICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3QuYWxwaGEgPSB0aGlzLiRhbHBoYTtcbiAgICAgICAgdGhpcy51cGRhdGVHZWFyKDMgLyogTG9vayAqLyk7XG4gICAgfVxuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdmlzaWJsZTtcbiAgICB9XG4gICAgc2V0IHZpc2libGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJHZpc2libGUgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJHZpc2libGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRkaXNwbGF5T2JqZWN0KVxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3QudmlzaWJsZSA9IHRoaXMuJHZpc2libGU7XG4gICAgICAgICAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kcGFyZW50LmNoaWxkU3RhdGVDaGFuZ2VkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHBhcmVudC5zZXRCb3VuZHNDaGFuZ2VkRmxhZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX192aXNpYmxlQ2hhbmdlZFwiIC8qIFZJU0lCTEVfQ0hBTkdFRCAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZXZlbnQuZGF0YSA9IHsgdmlzaWJsZTogdGhpcy4kdmlzaWJsZSB9O1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipAaW50ZXJuYWwgKi9cbiAgICBzZXQgaW50ZXJuYWxWaXNpYmxlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSB0aGlzLiRpbnRlcm5hbFZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuJGludGVybmFsVmlzaWJsZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHBhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLiRwYXJlbnQuY2hpbGRTdGF0ZUNoYW5nZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqQGludGVybmFsICovXG4gICAgZ2V0IGludGVybmFsVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGludGVybmFsVmlzaWJsZTtcbiAgICB9XG4gICAgZ2V0IGZpbmFsVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHZpc2libGUgJiYgdGhpcy4kaW50ZXJuYWxWaXNpYmxlICYmICghdGhpcy4kZ3JvdXAgfHwgdGhpcy4kZ3JvdXAuZmluYWxWaXNpYmxlKTtcbiAgICB9XG4gICAgZ2V0IHNvcnRpbmdPcmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNvcnRpbmdPcmRlcjtcbiAgICB9XG4gICAgc2V0IHNvcnRpbmdPcmRlcih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwKVxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICBpZiAodGhpcy4kc29ydGluZ09yZGVyICE9IHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgb2xkID0gdGhpcy4kc29ydGluZ09yZGVyO1xuICAgICAgICAgICAgdGhpcy4kc29ydGluZ09yZGVyID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy4kcGFyZW50ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy4kcGFyZW50LmNoaWxkU29ydGluZ09yZGVyQ2hhbmdlZCh0aGlzLCBvbGQsIHRoaXMuJHNvcnRpbmdPcmRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZvY3VzYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGZvY3VzYWJsZTtcbiAgICB9XG4gICAgc2V0IGZvY3VzYWJsZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiRmb2N1c2FibGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGZvY3VzZWQoKSB7XG4gICAgICAgIHJldHVybiBEZWNscyQxLkdSb290Lmluc3QuZm9jdXMgPT0gdGhpcztcbiAgICB9XG4gICAgcmVxdWVzdEZvY3VzKCkge1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwICYmICFwLiRmb2N1c2FibGUpXG4gICAgICAgICAgICBwID0gcC5wYXJlbnQ7XG4gICAgICAgIGlmIChwICE9IG51bGwpXG4gICAgICAgICAgICBEZWNscyQxLkdSb290Lmluc3QuZm9jdXMgPSBwO1xuICAgIH1cbiAgICBnZXQgdG9vbHRpcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0b29sdGlwcztcbiAgICB9XG4gICAgc2V0IHRvb2x0aXBzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJHRvb2x0aXBzID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBibGVuZE1vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLiRkaXNwbGF5T2JqZWN0ICYmIHRoaXMuJGRpc3BsYXlPYmplY3QgaW5zdGFuY2VvZiBTcHJpdGUpXG4gICAgICAgICAgICByZXR1cm4gQmxlbmRNb2RlTWFwW3RoaXMuJGRpc3BsYXlPYmplY3QuY29tcG9zaXRlT3BlcmF0aW9uXSB8fCAnTm9uZSc7XG4gICAgICAgIHJldHVybiBCbGVuZE1vZGVNYXBbMF07IC8vTm9ybWFsXG4gICAgfVxuICAgIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUubGVuZ3RoIHx8ICF0aGlzLiRkaXNwbGF5T2JqZWN0IHx8ICEodGhpcy4kZGlzcGxheU9iamVjdCBpbnN0YW5jZW9mIFNwcml0ZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQmxlbmRNb2RlTWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQmxlbmRNb2RlTWFwW2ldLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwbGF5T2JqZWN0LmNvbXBvc2l0ZU9wZXJhdGlvbiA9IEJsZW5kTW9kZU1hcFtpXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRkaXNwbGF5T2JqZWN0LmZpbHRlcnM7XG4gICAgfVxuICAgIHNldCBmaWx0ZXJzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3QuZmlsdGVycyA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaW5Db250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRkaXNwbGF5T2JqZWN0LnBhcmVudCAhPSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgaXNEaXNwbGF5T2JqZWN0T25TdGFnZShkaXNwbGF5KSB7XG4gICAgICAgIGlmICghZGlzcGxheSB8fCAhZGlzcGxheS5wYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBwID0gZGlzcGxheTtcbiAgICAgICAgd2hpbGUgKHAgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHAgPT0gRGVjbHMkMS5HUm9vdC5pbnN0Lm5hdGl2ZVN0YWdlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcCA9IHAucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG9uU3RhZ2UoKSB7XG4gICAgICAgIHJldHVybiBHT2JqZWN0LmlzRGlzcGxheU9iamVjdE9uU3RhZ2UodGhpcy4kZGlzcGxheU9iamVjdCk7XG4gICAgfVxuICAgIGdldCByZXNvdXJjZVVSTCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFja2FnZUl0ZW0gIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBgdWk6Ly8ke3RoaXMucGFja2FnZUl0ZW0ub3duZXIuaWR9JHt0aGlzLnBhY2thZ2VJdGVtLmlkfWA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXQgZ3JvdXAodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kZ3JvdXAgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGdyb3VwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZ3JvdXA7XG4gICAgfVxuICAgIGdldEdlYXIoaW5kZXgpIHtcbiAgICAgICAgbGV0IGdlYXIgPSB0aGlzLiRnZWFyc1tpbmRleF07XG4gICAgICAgIGlmIChnZWFyID09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogRGlzcGxheSAqLzpcbiAgICAgICAgICAgICAgICAgICAgZ2VhciA9IG5ldyBHZWFyRGlzcGxheSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIFhZICovOlxuICAgICAgICAgICAgICAgICAgICBnZWFyID0gbmV3IEdlYXJYWSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIFNpemUgKi86XG4gICAgICAgICAgICAgICAgICAgIGdlYXIgPSBuZXcgR2VhclNpemUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBMb29rICovOlxuICAgICAgICAgICAgICAgICAgICBnZWFyID0gbmV3IEdlYXJMb29rKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogQ29sb3IgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbG9yR2Vhcih0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlYXIgPSBuZXcgR2VhckNvbG9yKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29tcG9uZW50IHR5cGUgdG8gYWRkIEdlYXJDb2xvciBmZWF0dXJlLCBwbGVhc2UgY2hlY2sgdGhlIGNvbXBvbmVudCBuYW1lZCAke3RoaXMuJG5hbWV9IGluIHRoZSBFZGl0b3IuYCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNSAvKiBBbmltYXRpb24gKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FuaW1hdGlvbkdlYXIodGhpcykpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZWFyID0gbmV3IEdlYXJBbmltYXRpb24odGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb21wb25lbnQgdHlwZSB0byBhZGQgR2VhckFuaW1hdGlvbiBmZWF0dXJlLCBwbGVhc2UgY2hlY2sgdGhlIGNvbXBvbmVudCBuYW1lZCAke3RoaXMuJG5hbWV9IGluIHRoZSBFZGl0b3IuYCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNiAvKiBUZXh0ICovOlxuICAgICAgICAgICAgICAgICAgICBnZWFyID0gbmV3IEdlYXJUZXh0KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDcgLyogSWNvbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgZ2VhciA9IG5ldyBHZWFySWNvbih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGR1VJOiBpbnZhbGlkIGdlYXIgdHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kZ2VhcnNbaW5kZXhdID0gZ2VhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2VhcjtcbiAgICB9XG4gICAgdXBkYXRlR2VhcihpbmRleCkge1xuICAgICAgICBpZiAodGhpcy4kZ2VhcnNbaW5kZXhdICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLiRnZWFyc1tpbmRleF0udXBkYXRlU3RhdGUoKTtcbiAgICB9XG4gICAgdXBkYXRlR2VhckZyb21SZWxhdGlvbnMoaW5kZXgsIGR4LCBkeSkge1xuICAgICAgICBpZiAodGhpcy4kZ2VhcnNbaW5kZXhdICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLiRnZWFyc1tpbmRleF0udXBkYXRlRnJvbVJlbGF0aW9ucyhkeCwgZHkpO1xuICAgIH1cbiAgICBoYXNHZWFyQ29udHJvbGxlcihpbmRleCwgYykge1xuICAgICAgICByZXR1cm4gdGhpcy4kZ2VhcnNbaW5kZXhdICYmIHRoaXMuJGdlYXJzW2luZGV4XS5jb250cm9sbGVyID09IGM7XG4gICAgfVxuICAgIC8qKkBpbnRlcm5hbCAqL1xuICAgIGxvY2tHZWFyRGlzcGxheSgpIHtcbiAgICAgICAgbGV0IGcgPSB0aGlzLiRnZWFyc1swXTtcbiAgICAgICAgaWYgKGcgJiYgZy5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICBsZXQgcmV0ID0gZy5sb2NrKCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrR2VhclZpc2libGUoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKkBpbnRlcm5hbCAqL1xuICAgIHJlbGVhc2VHZWFyRGlzcGxheSh0b2tlbikge1xuICAgICAgICBsZXQgZyA9IHRoaXMuJGdlYXJzWzBdO1xuICAgICAgICBpZiAoZyAmJiBnLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGcucmVsZWFzZSh0b2tlbik7XG4gICAgICAgICAgICB0aGlzLmNoZWNrR2VhclZpc2libGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0dlYXJWaXNpYmxlKCkge1xuICAgICAgICBpZiAodGhpcy4kaGFuZGxpbmdDb250cm9sbGVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZyA9IHRoaXMuJGdlYXJzWzBdO1xuICAgICAgICBsZXQgdiA9ICFnIHx8IGcuY29ubmVjdGVkO1xuICAgICAgICBpZiAodiAhPSB0aGlzLiRpbnRlcm5hbFZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuJGludGVybmFsVmlzaWJsZSA9IHY7XG4gICAgICAgICAgICBpZiAodGhpcy4kcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuJHBhcmVudC5jaGlsZFN0YXRlQ2hhbmdlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZ2VhclhZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHZWFyKDEgLyogWFkgKi8pO1xuICAgIH1cbiAgICBnZXQgZ2VhclNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdlYXIoMiAvKiBTaXplICovKTtcbiAgICB9XG4gICAgZ2V0IGdlYXJMb29rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHZWFyKDMgLyogTG9vayAqLyk7XG4gICAgfVxuICAgIGdldCByZWxhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWxhdGlvbnM7XG4gICAgfVxuICAgIGFkZFJlbGF0aW9uKHRhcmdldCwgcmVsYXRpb25UeXBlLCB1c2VQZXJjZW50ID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy4kcmVsYXRpb25zLmFkZCh0YXJnZXQsIHJlbGF0aW9uVHlwZSwgdXNlUGVyY2VudCk7XG4gICAgfVxuICAgIHJlbW92ZVJlbGF0aW9uKHRhcmdldCwgcmVsYXRpb25UeXBlID0gMCkge1xuICAgICAgICB0aGlzLiRyZWxhdGlvbnMucmVtb3ZlKHRhcmdldCwgcmVsYXRpb25UeXBlKTtcbiAgICB9XG4gICAgZ2V0IGRpc3BsYXlPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRkaXNwbGF5T2JqZWN0O1xuICAgIH1cbiAgICBjcmVhdGVEaXNwbGF5T2JqZWN0KCkgeyB9XG4gICAgc2V0RGlzcGxheU9iamVjdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiRkaXNwbGF5T2JqZWN0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRwYXJlbnQ7XG4gICAgfVxuICAgIHNldCBwYXJlbnQodmFsKSB7XG4gICAgICAgIHRoaXMuJHBhcmVudCA9IHZhbDtcbiAgICB9XG4gICAgcmVtb3ZlRnJvbVBhcmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHBhcmVudClcbiAgICAgICAgICAgIHRoaXMuJHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqIEB2aXJ0dWFsICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKiogQHZpcnR1YWwgKi9cbiAgICBzZXQgdGV4dCh2YWx1ZSkgeyB9XG4gICAgLyoqIEB2aXJ0dWFsICovXG4gICAgZ2V0IGljb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKiogQHZpcnR1YWwgKi9cbiAgICBzZXQgaWNvbih2YWx1ZSkgeyB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGcm9tUGFyZW50KCk7XG4gICAgICAgIHRoaXMuJHJlbGF0aW9ucy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuJG1vdXNlTW92ZUV2ZW50ID0gRGVjbHMkMS5HUm9vdC5pbnN0Lm5hdGl2ZVN0YWdlLm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5Nb3ZlLCB0aGlzLiRtb3ZpbmcpO1xuICAgICAgICB0aGlzLiRtb3VzZVVwRXZlbnQgPSBEZWNscyQxLkdSb290Lmluc3QubmF0aXZlU3RhZ2Uub2ZmKEludGVyYWN0aXZlRXZlbnRzLlVwLCB0aGlzLiRlbmQpO1xuICAgICAgICB0aGlzLiRtb3VzZU1vdmUyRXZlbnQgPSBEZWNscyQxLkdSb290Lmluc3QubmF0aXZlU3RhZ2Uub2ZmKEludGVyYWN0aXZlRXZlbnRzLk1vdmUsIHRoaXMuJG1vdmluZzIpO1xuICAgICAgICB0aGlzLiRtb3VzZVVwMkV2ZW50ID0gRGVjbHMkMS5HUm9vdC5pbnN0Lm5hdGl2ZVN0YWdlLm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5VcCwgdGhpcy4kZW5kMik7XG4gICAgICAgIC8vIHRoaXMuJGRpc3BsYXlPYmplY3QuZGVzdHJveSgpOyAgLy9janMgbm90IHRoZSBkZXN0cm95IEFQSVxuICAgIH1cbiAgICBjbGljayhsaXN0ZW5lciwgdGhpc09iaikge1xuICAgICAgICB0aGlzLm9uKEludGVyYWN0aXZlRXZlbnRzLkNsaWNrLCBsaXN0ZW5lciwgdGhpc09iaik7XG4gICAgfVxuICAgIHJlbW92ZUNsaWNrKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMub2ZmKEludGVyYWN0aXZlRXZlbnRzLkNsaWNrLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIGhhc0NsaWNrKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0xpc3RlbmVyKEludGVyYWN0aXZlRXZlbnRzLkNsaWNrKTtcbiAgICB9XG4gICAgb24odHlwZSwgbGlzdGVuZXIsIHRoaXNPYmplY3QsIG9uY2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodHlwZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBmbiA9IHRoaXMuJGRpc3BsYXlPYmplY3Qub24odHlwZSwgbGlzdGVuZXIsIHRoaXNPYmplY3QsIG9uY2UpO1xuICAgICAgICB0aGlzLiRkaXNwbGF5RXZlbnRNYXBbdHlwZV0gPSBmbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9mZih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy4kZGlzcGxheU9iamVjdC5oYXNFdmVudExpc3RlbmVyKHR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLiRkaXNwbGF5T2JqZWN0Lm9mZih0eXBlLCB0aGlzLiRkaXNwbGF5RXZlbnRNYXBbdHlwZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uY2UodHlwZSwgbGlzdGVuZXIsIHRoaXNPYmplY3QpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB0aGlzLm9uKHR5cGUsIGxpc3RlbmVyLCB0aGlzT2JqZWN0LCB0cnVlKTtcbiAgICB9XG4gICAgaGFzTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgLy9kbyB3ZSBuZWVkIHRvIGFsc28gY2hlY2sgdGhlIGNvbnRleHQ/XG4gICAgICAgIC8vIHN1cGVyLmhhc0V2ZW50TGlzdGVuZXIoZXZlbnQpXG4gICAgICAgIHJldHVybiB0aGlzLiRkaXNwbGF5T2JqZWN0Lmhhc0V2ZW50TGlzdGVuZXIoZXZlbnQpO1xuICAgIH1cbiAgICBkaXNwYXRjaEV2ZW50KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIHN1cGVyLmRpc3BhdGNoRXZlbnQoZXZlbnQsIGFyZ3MpXG4gICAgICAgIGlmICghYXJncyB8fCBhcmdzLmxlbmd0aCA8PSAwKVxuICAgICAgICAgICAgYXJncyA9IFtldmVudF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdChldmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQoZXZlbnQsIHRoaXMuJGRpc3BsYXlPYmplY3QpO1xuICAgIH1cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKHR5cGUpO1xuICAgIH1cbiAgICBnZXQgZHJhZ2dhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZHJhZ2dhYmxlO1xuICAgIH1cbiAgICBzZXQgZHJhZ2dhYmxlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRkcmFnZ2FibGUgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGRyYWdnYWJsZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5pbml0RHJhZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkcmFnQm91bmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZHJhZ0JvdW5kcztcbiAgICB9XG4gICAgc2V0IGRyYWdCb3VuZHModmFsdWUpIHtcbiAgICAgICAgdGhpcy4kZHJhZ0JvdW5kcyA9IHZhbHVlO1xuICAgIH1cbiAgICBzdGFydERyYWcodG91Y2hQb2ludElEID0gLTEpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uU3RhZ2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZHJhZ0JlZ2luKCk7XG4gICAgfVxuICAgIHN0b3BEcmFnKCkge1xuICAgICAgICB0aGlzLmRyYWdFbmQoKTtcbiAgICB9XG4gICAgZ2V0IGRyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gR09iamVjdC5kcmFnZ2luZ09iamVjdCA9PSB0aGlzO1xuICAgIH1cbiAgICBsb2NhbFRvR2xvYmFsKGF4ID0gMCwgYXkgPSAwLCByZXN1bHRQb2ludCkge1xuICAgICAgICBpZiAodGhpcy4kcGl2b3RBc0FuY2hvcikge1xuICAgICAgICAgICAgYXggKz0gdGhpcy4kcGl2b3QueCAqIHRoaXMuJHdpZHRoO1xuICAgICAgICAgICAgYXkgKz0gdGhpcy4kcGl2b3QueSAqIHRoaXMuJGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdFBvaW50KVxuICAgICAgICAgICAgcmVzdWx0UG9pbnQgPSBHT2JqZWN0LnNIZWxwZXJQb2ludDtcbiAgICAgICAgcmVzdWx0UG9pbnQueCA9IGF4O1xuICAgICAgICByZXN1bHRQb2ludC55ID0gYXk7XG4gICAgICAgIHJldHVybiB0aGlzLiRkaXNwbGF5T2JqZWN0LmxvY2FsVG9HbG9iYWwocmVzdWx0UG9pbnQueCwgcmVzdWx0UG9pbnQueSk7XG4gICAgfVxuICAgIGdsb2JhbFRvTG9jYWwoYXggPSAwLCBheSA9IDAsIHJlc3VsdFBvaW50KSB7XG4gICAgICAgIGlmICghcmVzdWx0UG9pbnQpXG4gICAgICAgICAgICByZXN1bHRQb2ludCA9IEdPYmplY3Quc0hlbHBlclBvaW50O1xuICAgICAgICByZXN1bHRQb2ludC5zZXRWYWx1ZXMoYXgsIGF5KTtcbiAgICAgICAgcmVzdWx0UG9pbnQgPSB0aGlzLiRkaXNwbGF5T2JqZWN0Lmdsb2JhbFRvTG9jYWwocmVzdWx0UG9pbnQueCwgcmVzdWx0UG9pbnQueSk7XG4gICAgICAgIGlmICh0aGlzLiRwaXZvdEFzQW5jaG9yKSB7XG4gICAgICAgICAgICByZXN1bHRQb2ludC54IC09IHRoaXMuJHBpdm90LnggKiB0aGlzLiR3aWR0aDtcbiAgICAgICAgICAgIHJlc3VsdFBvaW50LnkgLT0gdGhpcy4kcGl2b3QueSAqIHRoaXMuJGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0UG9pbnQ7XG4gICAgfVxuICAgIGxvY2FsVG9Sb290KGF4ID0gMCwgYXkgPSAwLCByZXN1bHRQb2ludCkge1xuICAgICAgICBsZXQgcHQgPSB0aGlzLmxvY2FsVG9HbG9iYWwoYXgsIGF5LCByZXN1bHRQb2ludCk7XG4gICAgICAgIHB0LnggLz0gRGVjbHMkMS5HUm9vdC5pbnN0LmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICAgICAgcHQueSAvPSBEZWNscyQxLkdSb290Lmluc3QuY29udGVudFNjYWxlRmFjdG9yO1xuICAgICAgICByZXR1cm4gcHQ7XG4gICAgfVxuICAgIHJvb3RUb0xvY2FsKGF4ID0gMCwgYXkgPSAwLCByZXN1bHRQb2ludCkge1xuICAgICAgICBheCAqPSBEZWNscyQxLkdSb290Lmluc3QuY29udGVudFNjYWxlRmFjdG9yO1xuICAgICAgICBheSAqPSBEZWNscyQxLkdSb290Lmluc3QuY29udGVudFNjYWxlRmFjdG9yO1xuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxUb0xvY2FsKGF4LCBheSwgcmVzdWx0UG9pbnQpO1xuICAgIH1cbiAgICBsb2NhbFRvR2xvYmFsUmVjdChheCA9IDAsIGF5ID0gMCwgYVdpZHRoID0gMCwgYUhlaWdodCA9IDAsIHJlc3VsdFJlY3QpIHtcbiAgICAgICAgaWYgKHJlc3VsdFJlY3QgPT0gbnVsbClcbiAgICAgICAgICAgIHJlc3VsdFJlY3QgPSBHT2JqZWN0LnNEcmFnSGVscGVyUmVjdDtcbiAgICAgICAgbGV0IHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKGF4LCBheSk7XG4gICAgICAgIHJlc3VsdFJlY3QueCA9IHB0Lng7XG4gICAgICAgIHJlc3VsdFJlY3QueSA9IHB0Lnk7XG4gICAgICAgIHJlc3VsdFJlY3Qud2lkdGggPSBhV2lkdGg7XG4gICAgICAgIHJlc3VsdFJlY3QuaGVpZ2h0ID0gYUhlaWdodDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFJlY3Q7XG4gICAgfVxuICAgIGdsb2JhbFRvTG9jYWxSZWN0KGF4ID0gMCwgYXkgPSAwLCBhV2lkdGggPSAwLCBhSGVpZ2h0ID0gMCwgcmVzdWx0UmVjdCkge1xuICAgICAgICBpZiAocmVzdWx0UmVjdCA9PSBudWxsKVxuICAgICAgICAgICAgcmVzdWx0UmVjdCA9IEdPYmplY3Quc0RyYWdIZWxwZXJSZWN0O1xuICAgICAgICBsZXQgcHQgPSB0aGlzLmdsb2JhbFRvTG9jYWwoYXgsIGF5KTtcbiAgICAgICAgcmVzdWx0UmVjdC54ID0gcHQueDtcbiAgICAgICAgcmVzdWx0UmVjdC55ID0gcHQueTtcbiAgICAgICAgcmVzdWx0UmVjdC53aWR0aCA9IGFXaWR0aDtcbiAgICAgICAgcmVzdWx0UmVjdC5oZWlnaHQgPSBhSGVpZ2h0O1xuICAgICAgICByZXR1cm4gcmVzdWx0UmVjdDtcbiAgICB9XG4gICAgaGFuZGxlQ29udHJvbGxlckNoYW5nZWQoYykge1xuICAgICAgICB0aGlzLiRoYW5kbGluZ0NvbnRyb2xsZXIgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDggLyogQ291bnQgKi87IGkrKykge1xuICAgICAgICAgICAgbGV0IGdlYXIgPSB0aGlzLiRnZWFyc1tpXTtcbiAgICAgICAgICAgIGlmIChnZWFyICE9IG51bGwgJiYgZ2Vhci5jb250cm9sbGVyID09IGMpXG4gICAgICAgICAgICAgICAgZ2Vhci5hcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGhhbmRsaW5nQ29udHJvbGxlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoZWNrR2VhclZpc2libGUoKTtcbiAgICB9XG4gICAgc3dpdGNoRGlzcGxheU9iamVjdChuZXdPYmopIHtcbiAgICAgICAgaWYgKG5ld09iaiA9PSB0aGlzLiRkaXNwbGF5T2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgb2xkID0gdGhpcy4kZGlzcGxheU9iamVjdDtcbiAgICAgICAgaWYgKHRoaXMuaW5Db250YWluZXIpIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy4kZGlzcGxheU9iamVjdC5wYXJlbnQuZ2V0Q2hpbGRJbmRleCh0aGlzLiRkaXNwbGF5T2JqZWN0KTtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3QucGFyZW50LmFkZENoaWxkQXQobmV3T2JqLCBpKTtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3QucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuJGRpc3BsYXlPYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3QgPSBuZXdPYmo7XG4gICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3QueCA9IG9sZC54O1xuICAgICAgICB0aGlzLiRkaXNwbGF5T2JqZWN0LnkgPSBvbGQueTtcbiAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5yb3RhdGlvbiA9IG9sZC5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5hbHBoYSA9IG9sZC5hbHBoYTtcbiAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC52aXNpYmxlID0gb2xkLnZpc2libGU7XG4gICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3Quc2NhbGVYID0gb2xkLnNjYWxlWDtcbiAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5zY2FsZVkgPSBvbGQuc2NhbGVZO1xuICAgICAgICB0aGlzLiRkaXNwbGF5T2JqZWN0Lm1vdXNlRW5hYmxlZCA9IG9sZC5tb3VzZUVuYWJsZWQ7XG4gICAgfVxuICAgIGhhbmRsZVhZQ2hhbmdlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGRpc3BsYXlPYmplY3QpIHtcbiAgICAgICAgICAgIGxldCB4diA9IHRoaXMuJHg7XG4gICAgICAgICAgICBsZXQgeXYgPSB0aGlzLiR5O1xuICAgICAgICAgICAgaWYgKHRoaXMuJHBpdm90QXNBbmNob3IpIHtcbiAgICAgICAgICAgICAgICB4diAtPSB0aGlzLiRwaXZvdC54ICogdGhpcy4kd2lkdGg7XG4gICAgICAgICAgICAgICAgeXYgLT0gdGhpcy4kcGl2b3QueSAqIHRoaXMuJGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRwaXhlbFNuYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgeHYgPSBNYXRoLnJvdW5kKHh2KTtcbiAgICAgICAgICAgICAgICB5diA9IE1hdGgucm91bmQoeXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC54ID0geHYgKyB0aGlzLiRwaXZvdE9mZnNldC54O1xuICAgICAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC55ID0geXYgKyB0aGlzLiRwaXZvdE9mZnNldC55O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVNpemVDaGFuZ2VkKCkgeyB9XG4gICAgaGFuZGxlU2NhbGVDaGFuZ2VkKCkge1xuICAgICAgICBpZiAodGhpcy4kZGlzcGxheU9iamVjdClcbiAgICAgICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3Quc2NhbGVYID0gdGhpcy4kc2NhbGVYO1xuICAgICAgICB0aGlzLiRkaXNwbGF5T2JqZWN0LnNjYWxlWSA9IHRoaXMuJHNjYWxlWTtcbiAgICB9XG4gICAgZ2V0IGNvbG9yRmlsdGVyKCkge1xuICAgICAgICBpZiAodGhpcy4kY29sb3JGaWx0ZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY29sb3JGaWx0ZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0b2RvXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IGNyZWF0ZWpzLkNvbG9yTWF0cml4KCk7XG4gICAgICAgIHRoaXMuJGNvbG9yRmlsdGVyID0gbmV3IGNyZWF0ZWpzLkNvbG9yTWF0cml4RmlsdGVyKG1hdHJpeCk7XG4gICAgICAgIGlmICh0aGlzLiRkaXNwbGF5T2JqZWN0KSB7XG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMuJGRpc3BsYXlPYmplY3QuZmlsdGVycyB8fCBbXTtcbiAgICAgICAgICAgIGEucHVzaCh0aGlzLiRjb2xvckZpbHRlcik7XG4gICAgICAgICAgICB0aGlzLiRkaXNwbGF5T2JqZWN0LmZpbHRlcnMgPSBhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiRjb2xvckZpbHRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdXBkYXRlIGNvbG9yIGFwcGVhcmFuY2VcbiAgICAgKiBAcGFyYW0gYnJpZ2h0bmVzcyB2YWx1ZSBvZiB0aGUgYnJpZ3RobmVzcyAoLTEgLSAxLCB3aGVyZSAtMSBpcyBibGFjaylcbiAgICAgKiBAcGFyYW0gY29udHJhc3QgdmFsdWUgb2YgdGhlIGNvbnRyYXN0ICgtMSAtIDEpXG4gICAgICogQHBhcmFtIHNhdHVyYXRlIFRoZSBzYXR1cmF0aW9uIGFtb3VudCAoLTEgLSAxKVxuICAgICAqIEBwYXJhbSBodWUgVGhlIGh1ZSBwcm9wZXJ0eSBvZiB0aGUgY29sb3IgaW4gZGVncmVzcyAoLTEgLSAxLCB3aGVyZSAxIGlzIDM2MGRlZylcbiAgICAgKi9cbiAgICB1cGRhdGVDb2xvckNvbXBvbmVudHMoYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRlLCBodWUpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBjcmVhdGVqcy5Db2xvck1hdHJpeCgpXG4gICAgICAgICAgICAuYWRqdXN0QnJpZ2h0bmVzcyhicmlnaHRuZXNzKVxuICAgICAgICAgICAgLmFkanVzdENvbnRyYXN0KGNvbnRyYXN0ICogMTAwKVxuICAgICAgICAgICAgLmFkanVzdEh1ZShodWUgKiAxODApXG4gICAgICAgICAgICAuYWRqdXN0U2F0dXJhdGlvbihzYXR1cmF0ZSAqIDEwMCk7XG4gICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3QuZmlsdGVycyA9IFtuZXcgY3JlYXRlanMuQ29sb3JNYXRyaXhGaWx0ZXIobWF0cml4KV07XG4gICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3QuY2FjaGUoMCwgMCwgdGhpcy4kd2lkdGgsIHRoaXMuJGhlaWdodCk7XG4gICAgICAgIGlmICghdGhpcy4kbGFzdENvbG9yQ29tcG9uZW50cylcbiAgICAgICAgICAgIHRoaXMuJGxhc3RDb2xvckNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy4kbGFzdENvbG9yQ29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLiRsYXN0Q29sb3JDb21wb25lbnRzLnB1c2goYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRlLCBodWUpO1xuICAgIH1cbiAgICBoYW5kbGVHcmF5ZWRDaGFuZ2VkKCkge1xuICAgICAgICBpZiAodGhpcy4kZGlzcGxheU9iamVjdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGdyYXllZCkge1xuICAgICAgICAgICAgICAgIHZhciBHcmF5c2NhbGUgPSBuZXcgY3JlYXRlanMuQ29sb3JNYXRyaXhGaWx0ZXIoW1xuICAgICAgICAgICAgICAgICAgICAwLjMsIDAuMywgMC4zLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLjMsIDAuMywgMC4zLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLjMsIDAuMywgMC4zLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLCAwLCAwLCAxLCAwIC8vIGFscGhhXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5maWx0ZXJzID0gW0dyYXlzY2FsZV07XG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5jYWNoZSgwLCAwLCB0aGlzLiR3aWR0aCwgdGhpcy4kaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRsYXN0Q29sb3JDb21wb25lbnRzICYmIHRoaXMuJGxhc3RDb2xvckNvbXBvbmVudHMubGVuZ3RoID49IDQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sb3JDb21wb25lbnRzKHRoaXMuJGxhc3RDb2xvckNvbXBvbmVudHNbMF0sIHRoaXMuJGxhc3RDb2xvckNvbXBvbmVudHNbMV0sIHRoaXMuJGxhc3RDb2xvckNvbXBvbmVudHNbMl0sIHRoaXMuJGxhc3RDb2xvckNvbXBvbmVudHNbM10pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5maWx0ZXJzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqQGludGVybmFsICovXG4gICAgY29uc3RydWN0RnJvbVJlc291cmNlKCkge1xuICAgIH1cbiAgICBzZXR1cEJlZm9yZUFkZCh4bWwpIHtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgbGV0IGFycjtcbiAgICAgICAgdGhpcy4kaWQgPSB4bWwuYXR0cmlidXRlcy5pZDtcbiAgICAgICAgdGhpcy4kbmFtZSA9IHhtbC5hdHRyaWJ1dGVzLm5hbWU7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnh5O1xuICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJywnKTtcbiAgICAgICAgdGhpcy5zZXRYWShwYXJzZUludChhcnJbMF0pLCBwYXJzZUludChhcnJbMV0pKTtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuc2l6ZTtcbiAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB0aGlzLiRpbml0V2lkdGggPSBwYXJzZUludChhcnJbMF0pO1xuICAgICAgICAgICAgdGhpcy4kaW5pdEhlaWdodCA9IHBhcnNlSW50KGFyclsxXSk7XG4gICAgICAgICAgICB0aGlzLnNldFNpemUodGhpcy4kaW5pdFdpZHRoLCB0aGlzLiRpbml0SGVpZ2h0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5zY2FsZTtcbiAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB0aGlzLnNldFNjYWxlKHBhcnNlRmxvYXQoYXJyWzBdKSwgcGFyc2VGbG9hdChhcnJbMV0pKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5yb3RhdGlvbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSBwYXJzZUludChzdHIpO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5za2V3O1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2tldyhwYXJzZUZsb2F0KGFyclswXSksIHBhcnNlRmxvYXQoYXJyWzFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMucGl2b3Q7XG4gICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgbGV0IG4xID0gcGFyc2VGbG9hdChhcnJbMF0pLCBuMiA9IHBhcnNlRmxvYXQoYXJyWzFdKTtcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmFuY2hvcjtcbiAgICAgICAgICAgIHRoaXMuc2V0UGl2b3QobjEsIG4yLCBzdHIgPT0gJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5hbHBoYTtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuYWxwaGEgPSBwYXJzZUZsb2F0KHN0cik7XG4gICAgICAgIGlmICh4bWwuYXR0cmlidXRlcy50b3VjaGFibGUgPT0gJ2ZhbHNlJylcbiAgICAgICAgICAgIHRoaXMudG91Y2hhYmxlID0gZmFsc2U7XG4gICAgICAgIGlmICh4bWwuYXR0cmlidXRlcy52aXNpYmxlID09ICdmYWxzZScpXG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHhtbC5hdHRyaWJ1dGVzLmdyYXllZCA9PSAndHJ1ZScpXG4gICAgICAgICAgICB0aGlzLmdyYXllZCA9IHRydWU7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB4bWwuYXR0cmlidXRlcy50b29sdGlwcztcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuYmxlbmQ7XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IHN0cjtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuZmlsdGVyO1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0cikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgICAgICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuZmlsdGVyRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sb3JDb21wb25lbnRzKHBhcnNlRmxvYXQoYXJyWzBdKSwgcGFyc2VGbG9hdChhcnJbMV0pLCBwYXJzZUZsb2F0KGFyclsyXSksIHBhcnNlRmxvYXQoYXJyWzNdKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldHVwQWZ0ZXJBZGQoeG1sKSB7XG4gICAgICAgIGxldCBzdHIgPSB4bWwuYXR0cmlidXRlcy5ncm91cDtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuJGdyb3VwID0gdGhpcy4kcGFyZW50LmdldENoaWxkQnlJZChzdHIpO1xuICAgICAgICBsZXQgY29sID0geG1sLmNoaWxkcmVuO1xuICAgICAgICBjb2wuZm9yRWFjaChjeG1sID0+IHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IEdlYXJYTUxOb2RlTmFtZU1hcFtjeG1sLm5vZGVOYW1lXTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSB2b2lkIDApXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRHZWFyKGluZGV4KS5zZXR1cChjeG1sKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBjYXN0RnJvbU5hdGl2ZU9iamVjdChkaXNwKSB7XG4gICAgICAgIGlmIChpc1VJT2JqZWN0KGRpc3ApKVxuICAgICAgICAgICAgcmV0dXJuIGRpc3AuVUlPd25lcjtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGluaXREcmFnKCkge1xuICAgICAgICBpZiAodGhpcy4kZHJhZ2dhYmxlKVxuICAgICAgICAgICAgdGhpcy5vbihJbnRlcmFjdGl2ZUV2ZW50cy5Eb3duLCB0aGlzLiR0b3VjaEJlZ2luLCB0aGlzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5vZmYoSW50ZXJhY3RpdmVFdmVudHMuRG93biwgdGhpcy4kdG91Y2hCZWdpbik7XG4gICAgfVxuICAgIGRyYWdCZWdpbigpIHtcbiAgICAgICAgaWYgKEdPYmplY3QuZHJhZ2dpbmdPYmplY3QgIT0gbnVsbClcbiAgICAgICAgICAgIEdPYmplY3QuZHJhZ2dpbmdPYmplY3Quc3RvcERyYWcoKTtcbiAgICAgICAgR09iamVjdC5zR2xvYmFsRHJhZ1N0YXJ0LnggPSBEZWNscyQxLkdSb290Lmdsb2JhbE1vdXNlU3RhdHVzLm1vdXNlWDtcbiAgICAgICAgR09iamVjdC5zR2xvYmFsRHJhZ1N0YXJ0LnkgPSBEZWNscyQxLkdSb290Lmdsb2JhbE1vdXNlU3RhdHVzLm1vdXNlWTtcbiAgICAgICAgdGhpcy5sb2NhbFRvR2xvYmFsUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgR09iamVjdC5zR2xvYmFsUmVjdCk7XG4gICAgICAgIEdPYmplY3QuZHJhZ2dpbmdPYmplY3QgPSB0aGlzO1xuICAgICAgICB0aGlzLiRtb3VzZU1vdmUyRXZlbnQgPSBEZWNscyQxLkdSb290Lmluc3QubmF0aXZlU3RhZ2Uub24oSW50ZXJhY3RpdmVFdmVudHMuTW92ZSwgdGhpcy4kbW92aW5nMiwgdGhpcyk7XG4gICAgICAgIHRoaXMuJG1vdXNlVXAyRXZlbnQgPSBEZWNscyQxLkdSb290Lmluc3QubmF0aXZlU3RhZ2Uub24oSW50ZXJhY3RpdmVFdmVudHMuVXAsIHRoaXMuJGVuZDIsIHRoaXMpO1xuICAgIH1cbiAgICBkcmFnRW5kKCkge1xuICAgICAgICBpZiAoR09iamVjdC5kcmFnZ2luZ09iamVjdCA9PSB0aGlzKSB7XG4gICAgICAgICAgICBEZWNscyQxLkdSb290Lmluc3QubmF0aXZlU3RhZ2Uub2ZmKEludGVyYWN0aXZlRXZlbnRzLk1vdmUsIHRoaXMuJG1vdXNlTW92ZTJFdmVudCk7XG4gICAgICAgICAgICBEZWNscyQxLkdSb290Lmluc3QubmF0aXZlU3RhZ2Uub2ZmKEludGVyYWN0aXZlRXZlbnRzLlVwLCB0aGlzLiRtb3VzZVVwMkV2ZW50KTtcbiAgICAgICAgICAgIEdPYmplY3QuZHJhZ2dpbmdPYmplY3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIEdPYmplY3QuJGRyYWdCZWdpbkNhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBEZWNscyQxLkdSb290Lmluc3QubmF0aXZlU3RhZ2Uub2ZmKEludGVyYWN0aXZlRXZlbnRzLk1vdmUsIHRoaXMuJG1vdXNlTW92ZUV2ZW50KTtcbiAgICAgICAgRGVjbHMkMS5HUm9vdC5pbnN0Lm5hdGl2ZVN0YWdlLm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5VcCwgdGhpcy4kbW91c2VVcEV2ZW50KTtcbiAgICB9XG4gICAgJHRvdWNoQmVnaW4oZXZ0KSB7XG4gICAgICAgIGlmICh0aGlzLiR0b3VjaERvd25Qb2ludCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy4kdG91Y2hEb3duUG9pbnQgPSBuZXcgY3JlYXRlanMuUG9pbnQoKTtcbiAgICAgICAgdGhpcy4kdG91Y2hEb3duUG9pbnQueCA9IGV2dC5zdGFnZVg7XG4gICAgICAgIHRoaXMuJHRvdWNoRG93blBvaW50LnkgPSBldnQuc3RhZ2VZO1xuICAgICAgICB0aGlzLiRtb3VzZU1vdmVFdmVudCA9IERlY2xzJDEuR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vbihJbnRlcmFjdGl2ZUV2ZW50cy5Nb3ZlLCB0aGlzLiRtb3ZpbmcsIHRoaXMpO1xuICAgICAgICB0aGlzLiRtb3VzZVVwRXZlbnQgPSBEZWNscyQxLkdSb290Lmluc3QubmF0aXZlU3RhZ2Uub24oSW50ZXJhY3RpdmVFdmVudHMuVXAsIHRoaXMuJGVuZCwgdGhpcyk7XG4gICAgfVxuICAgICRlbmQoZXZ0KSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgJG1vdmluZyhldnQpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJtb3ZpbmdcIik7XG4gICAgICAgIGxldCBzZW5zaXRpdml0eSA9IFVJQ29uZmlnLnRvdWNoRHJhZ1NlbnNpdGl2aXR5O1xuICAgICAgICBpZiAodGhpcy4kdG91Y2hEb3duUG9pbnQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy4kdG91Y2hEb3duUG9pbnQueCAtIGV2dC5zdGFnZVgpIDwgc2Vuc2l0aXZpdHkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuJHRvdWNoRG93blBvaW50LnkgLSBldnQuc3RhZ2VZKSA8IHNlbnNpdGl2aXR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIEdPYmplY3QuJGRyYWdCZWdpbkNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJfX2RyYWdTdGFydFwiIC8qIFNUQVJUICovLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGV2ZW50LmRhdGEgPSB7IGN1cnJlbnRUYXJnZXQ6IHRoaXMuJGRpc3BsYXlPYmplY3QgfTtcbiAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0aGlzKTtcbiAgICAgICAgaWYgKCFHT2JqZWN0LiRkcmFnQmVnaW5DYW5jZWxsZWQpXG4gICAgICAgICAgICAvL3VzZXIgbWF5IGNhbGwgb2JqLnN0b3BEcmFnIGluIHRoZSBEcmFnU3RhcnQgZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5kcmFnQmVnaW4oKTtcbiAgICB9XG4gICAgJG1vdmluZzIoZXZ0KSB7XG4gICAgICAgIGxldCB4eCA9IGV2dC5zdGFnZVggLSBHT2JqZWN0LnNHbG9iYWxEcmFnU3RhcnQueCArIEdPYmplY3Quc0dsb2JhbFJlY3QueDtcbiAgICAgICAgbGV0IHl5ID0gZXZ0LnN0YWdlWSAtIEdPYmplY3Quc0dsb2JhbERyYWdTdGFydC55ICsgR09iamVjdC5zR2xvYmFsUmVjdC55O1xuICAgICAgICBpZiAodGhpcy4kZHJhZ0JvdW5kcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IERlY2xzJDEuR1Jvb3QuaW5zdC5sb2NhbFRvR2xvYmFsUmVjdCh0aGlzLiRkcmFnQm91bmRzLngsIHRoaXMuJGRyYWdCb3VuZHMueSwgdGhpcy4kZHJhZ0JvdW5kcy53aWR0aCwgdGhpcy4kZHJhZ0JvdW5kcy5oZWlnaHQsIEdPYmplY3Quc0RyYWdIZWxwZXJSZWN0KTtcbiAgICAgICAgICAgIGlmICh4eCA8IHJlY3QueClcbiAgICAgICAgICAgICAgICB4eCA9IHJlY3QueDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHh4ICsgR09iamVjdC5zR2xvYmFsUmVjdC53aWR0aCA+IHJlY3QueCArIHJlY3Qud2lkdGgpIHtcbiAgICAgICAgICAgICAgICB4eCA9IHJlY3QueCArIHJlY3Qud2lkdGggLSBHT2JqZWN0LnNHbG9iYWxSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGlmICh4eCA8IHJlY3QueClcbiAgICAgICAgICAgICAgICAgICAgeHggPSByZWN0Lng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeXkgPCByZWN0LnkpXG4gICAgICAgICAgICAgICAgeXkgPSByZWN0Lnk7XG4gICAgICAgICAgICBlbHNlIGlmICh5eSArIEdPYmplY3Quc0dsb2JhbFJlY3QuaGVpZ2h0ID4gcmVjdC55ICsgcmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB5eSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC0gR09iamVjdC5zR2xvYmFsUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHl5IDwgcmVjdC55KVxuICAgICAgICAgICAgICAgICAgICB5eSA9IHJlY3QueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBHT2JqZWN0LnNVcGRhdGluZ1doaWxlRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICBHT2JqZWN0LnNIZWxwZXJQb2ludC54ID0geHg7XG4gICAgICAgIEdPYmplY3Quc0hlbHBlclBvaW50LnkgPSB5eTtcbiAgICAgICAgbGV0IHB0ID0gdGhpcy5wYXJlbnQuZ2xvYmFsVG9Mb2NhbCh4eCwgeXksIEdPYmplY3Quc0hlbHBlclBvaW50KTtcbiAgICAgICAgdGhpcy5zZXRYWShNYXRoLnJvdW5kKHB0LngpLCBNYXRoLnJvdW5kKHB0LnkpKTtcbiAgICAgICAgR09iamVjdC5zVXBkYXRpbmdXaGlsZURyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gdGhpcy4kZGlzcGxheU9iamVjdDtcbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX19kcmFnTW92aW5nXCIgLyogTU9WSU5HICovLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGV2ZW50LmRhdGEgPSB7IGN1cnJlbnRUYXJnZXQgfTtcbiAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0aGlzKTtcbiAgICB9XG4gICAgJGVuZDIoZXZ0KSB7XG4gICAgICAgIGlmIChHT2JqZWN0LmRyYWdnaW5nT2JqZWN0ID09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcERyYWcoKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gdGhpcy4kZGlzcGxheU9iamVjdDtcbiAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcIl9fZHJhZ0VuZFwiIC8qIEVORCAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZXZlbnQuZGF0YSA9IHsgY3VycmVudFRhcmdldCB9O1xuICAgICAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkdPYmplY3QuZ0luc3RhbmNlQ291bnRlciA9IDA7XG4vL2RyYWdnaW5nXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbkdPYmplY3Quc0dsb2JhbERyYWdTdGFydCA9IG5ldyBjcmVhdGVqcy5Qb2ludCgpO1xuR09iamVjdC5zR2xvYmFsUmVjdCA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKTtcbkdPYmplY3Quc0hlbHBlclBvaW50ID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG5HT2JqZWN0LnNEcmFnSGVscGVyUmVjdCA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKTtcbmxldCBEZWNscyQxID0ge307XG5cbmNsYXNzIEdHcm91cCBleHRlbmRzIEdPYmplY3Qge1xuICAgIGNyZWF0ZURpc3BsYXlPYmplY3QoKSB7XG4gICAgICAgIGxldCBjID0gbmV3IFVJQ29udGFpbmVyKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogdG9kb1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gYy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBjLm1vdXNlRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldERpc3BsYXlPYmplY3QoYyk7XG4gICAgfVxuICAgIHVwZGF0ZUJvdW5kcygpIHtcbiAgICAgICAgaWYgKHRoaXMuJHVwZGF0aW5nIHx8ICF0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGNudCA9IHRoaXMuJHBhcmVudC5udW1DaGlsZHJlbjtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgYXggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIGF5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICBsZXQgYXIgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIGFiID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICB0aGlzLiRlbXB0eSA9IHRydWU7XG4gICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgbGV0IHRtcCA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSB0aGlzLiRwYXJlbnQuZ2V0Q2hpbGRBdChpKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5ncm91cCA9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gY2hpbGQueDtcbiAgICAgICAgICAgICAgICBpZiAodG1wIDwgYXgpXG4gICAgICAgICAgICAgICAgICAgIGF4ID0gdG1wO1xuICAgICAgICAgICAgICAgIHRtcCA9IGNoaWxkLnk7XG4gICAgICAgICAgICAgICAgaWYgKHRtcCA8IGF5KVxuICAgICAgICAgICAgICAgICAgICBheSA9IHRtcDtcbiAgICAgICAgICAgICAgICB0bXAgPSBjaGlsZC54ICsgY2hpbGQud2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKHRtcCA+IGFyKVxuICAgICAgICAgICAgICAgICAgICBhciA9IHRtcDtcbiAgICAgICAgICAgICAgICB0bXAgPSBjaGlsZC55ICsgY2hpbGQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh0bXAgPiBhYilcbiAgICAgICAgICAgICAgICAgICAgYWIgPSB0bXA7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR1cGRhdGluZyA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy4kZW1wdHkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0WFkoYXgsIGF5KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2l6ZShhciAtIGF4LCBhYiAtIGF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNldFNpemUoMCwgMCk7XG4gICAgICAgIHRoaXMuJHVwZGF0aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHNldFhZKHh2LCB5dikge1xuICAgICAgICBpZiAodGhpcy4keCAhPSB4diB8fCB0aGlzLiR5ICE9IHl2KSB7XG4gICAgICAgICAgICBsZXQgZHggPSB4diAtIHRoaXMuJHg7XG4gICAgICAgICAgICBsZXQgZHkgPSB5diAtIHRoaXMuJHk7XG4gICAgICAgICAgICBzdXBlci5zZXRYWSh4diwgeXYpO1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ2hpbGRyZW4oZHgsIGR5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlQ2hpbGRyZW4oZHgsIGR5KSB7XG4gICAgICAgIGlmICh0aGlzLiR1cGRhdGluZyB8fCAhdGhpcy4kcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiR1cGRhdGluZyA9IHRydWU7XG4gICAgICAgIGxldCBjbnQgPSB0aGlzLiRwYXJlbnQubnVtQ2hpbGRyZW47XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGNoaWxkO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gdGhpcy4kcGFyZW50LmdldENoaWxkQXQoaSk7XG4gICAgICAgICAgICBpZiAoY2hpbGQuZ3JvdXAgPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIGNoaWxkLnNldFhZKGNoaWxkLnggKyBkeCwgY2hpbGQueSArIGR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR1cGRhdGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGVBbHBoYSgpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlQWxwaGEoKTtcbiAgICAgICAgaWYgKHRoaXMuJGluUHJvZ3Jlc3NCdWlsZGluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGNudCA9IHRoaXMuJHBhcmVudC5udW1DaGlsZHJlbjtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHRoaXMuJHBhcmVudC5nZXRDaGlsZEF0KGkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmdyb3VwID09IHRoaXMpXG4gICAgICAgICAgICAgICAgY2hpbGQuYWxwaGEgPSB0aGlzLmFscGhhO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBVSVNwcml0ZSBleHRlbmRzIGNyZWF0ZWpzLlNoYXBlIHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLlVJT3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy5tb3VzZUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gdGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvLyB0aGlzLmludGVyYWN0aXZlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICB9XG59XG5cbmNsYXNzIEdHcmFwaCBleHRlbmRzIEdPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLiR0eXBlID0gMDtcbiAgICAgICAgdGhpcy4kbGluZVNpemUgPSAxO1xuICAgICAgICB0aGlzLiRzaWRlcyA9IDA7XG4gICAgICAgIHRoaXMuJHN0YXJ0QW5nbGUgPSAwO1xuICAgICAgICB0aGlzLiRwb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy4kbGluZVNpemUgPSAxO1xuICAgICAgICB0aGlzLiRsaW5lQ29sb3IgPSAnIzAwMDAwMCc7XG4gICAgICAgIHRoaXMuJGZpbGxDb2xvciA9ICcjRkZGRkZGJztcbiAgICB9XG4gICAgZHJhd1JlY3QobGluZVNpemUsIGxpbmVDb2xvciwgZmlsbENvbG9yKSB7XG4gICAgICAgIHRoaXMuJHR5cGUgPSAxO1xuICAgICAgICB0aGlzLiRsaW5lU2l6ZSA9IGxpbmVTaXplO1xuICAgICAgICB0aGlzLiRsaW5lQ29sb3IgPSBsaW5lQ29sb3I7XG4gICAgICAgIHRoaXMuJGZpbGxDb2xvciA9IGZpbGxDb2xvcjtcbiAgICAgICAgdGhpcy5kcmF3R3JhcGgoKTtcbiAgICB9XG4gICAgZHJhd0VsbGlwc2UobGluZVNpemUsIGxpbmVDb2xvciwgZmlsbENvbG9yKSB7XG4gICAgICAgIHRoaXMuJHR5cGUgPSAyO1xuICAgICAgICB0aGlzLiRsaW5lU2l6ZSA9IGxpbmVTaXplO1xuICAgICAgICB0aGlzLiRsaW5lQ29sb3IgPSBsaW5lQ29sb3I7XG4gICAgICAgIHRoaXMuJGZpbGxDb2xvciA9IGZpbGxDb2xvcjtcbiAgICAgICAgdGhpcy5kcmF3R3JhcGgoKTtcbiAgICB9XG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZmlsbENvbG9yO1xuICAgIH1cbiAgICBzZXQgY29sb3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kZmlsbENvbG9yID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLiR0eXBlICE9IDApXG4gICAgICAgICAgICB0aGlzLmRyYXdHcmFwaCgpO1xuICAgIH1cbiAgICBkcmF3R3JhcGgoKSB7XG4gICAgICAgIGxldCBzaGFwZSA9IHRoaXMuJGRpc3BsYXlPYmplY3Q7XG4gICAgICAgIGxldCBnID0gc2hhcGUuZ3JhcGhpY3M7XG4gICAgICAgIGcuY2xlYXIoKTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLndpZHRoO1xuICAgICAgICBsZXQgaCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBpZiAodyA9PSAwIHx8IGggPT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZy5iZWdpblN0cm9rZSh0aGlzLiRsaW5lQ29sb3IpO1xuICAgICAgICBpZiAodGhpcy4kbGluZVNpemUgPT0gMCkge1xuICAgICAgICAgICAgZy5zZXRTdHJva2VTdHlsZSgwLjEpOyAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0NyZWF0ZUpTL0Vhc2VsSlMvaXNzdWVzLzczNFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZy5zZXRTdHJva2VTdHlsZSh0aGlzLiRsaW5lU2l6ZSk7XG4gICAgICAgICAgICB3IC09IHRoaXMuJGxpbmVTaXplO1xuICAgICAgICAgICAgaCAtPSB0aGlzLiRsaW5lU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBnLmJlZ2luRmlsbCh0aGlzLiRmaWxsQ29sb3IpO1xuICAgICAgICBpZiAodGhpcy4kdHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kY29ybmVyICYmIHRoaXMuJGNvcm5lci5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRjb3JuZXIubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZy5kcmF3Um91bmRSZWN0KHRoaXMuJGxpbmVTaXplIC8gMiwgdGhpcy4kbGluZVNpemUgLyAyLCB3LCBoLCB0aGlzLiRjb3JuZXJbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZy5kcmF3Um91bmRSZWN0Q29tcGxleCh0aGlzLiRsaW5lU2l6ZSAvIDIsIHRoaXMuJGxpbmVTaXplIC8gMiwgdywgaCwgdGhpcy4kY29ybmVyWzBdLCB0aGlzLiRjb3JuZXJbMV0sIHRoaXMuJGNvcm5lclszXSwgdGhpcy4kY29ybmVyWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnLmRyYXdSZWN0KHRoaXMuJGxpbmVTaXplIC8gMiwgdGhpcy4kbGluZVNpemUgLyAyLCB3LCBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiR0eXBlID09IDIpIHtcbiAgICAgICAgICAgIGxldCBoYWxmVyA9IHcgKiAwLjU7XG4gICAgICAgICAgICBpZiAodyA9PSBoKVxuICAgICAgICAgICAgICAgIGcuZHJhd0NpcmNsZShoYWxmVyArIHRoaXMuJGxpbmVTaXplIC8gMiwgaGFsZlcgKyB0aGlzLiRsaW5lU2l6ZSAvIDIsIGhhbGZXKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHcgPSB3IC0gdGhpcy4kbGluZVNpemU7XG4gICAgICAgICAgICAgICAgaCA9IGggLSB0aGlzLiRsaW5lU2l6ZTtcbiAgICAgICAgICAgICAgICBnLmRyYXdFbGxpcHNlKHRoaXMuJGxpbmVTaXplIC8gMiwgdGhpcy4kbGluZVNpemUgLyAyLCB3LCBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiR0eXBlID09IDMpIHtcbiAgICAgICAgICAgIGxldCByYWRpdXMgPSB3ID4gaCA/IHcgLyAyIDogaCAvIDI7XG4gICAgICAgICAgICBnLmRyYXdQb2x5U3RhcigwICsgcmFkaXVzLCAwICsgcmFkaXVzLCByYWRpdXMsIHRoaXMuJHNpZGVzLCAwLCB0aGlzLiRzdGFydEFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiR0eXBlID09IDQpIHtcbiAgICAgICAgICAgIFV0aWxzLmZpbGxQYXRoKGcsIHRoaXMuJHBvaW50cywgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZy5lbmRGaWxsKCk7XG4gICAgICAgIHNoYXBlLmNhY2hlKDAsIDAsIHRoaXMuJHdpZHRoLCB0aGlzLiRoZWlnaHQpO1xuICAgIH1cbiAgICByZXBsYWNlTWUodGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGhpcy4kcGFyZW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJlbnQgbm90IHNldCcpO1xuICAgICAgICB0YXJnZXQubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgdGFyZ2V0LmFscGhhID0gdGhpcy5hbHBoYTtcbiAgICAgICAgdGFyZ2V0LnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgdGFyZ2V0LnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgICAgIHRhcmdldC50b3VjaGFibGUgPSB0aGlzLnRvdWNoYWJsZTtcbiAgICAgICAgdGFyZ2V0LmdyYXllZCA9IHRoaXMuZ3JheWVkO1xuICAgICAgICB0YXJnZXQuc2V0WFkodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICB0YXJnZXQuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuJHBhcmVudC5nZXRDaGlsZEluZGV4KHRoaXMpO1xuICAgICAgICB0aGlzLiRwYXJlbnQuYWRkQ2hpbGRBdCh0YXJnZXQsIGluZGV4KTtcbiAgICAgICAgdGFyZ2V0LnJlbGF0aW9ucy5jb3B5RnJvbSh0aGlzLnJlbGF0aW9ucyk7XG4gICAgICAgIHRoaXMuJHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLCB0cnVlKTtcbiAgICB9XG4gICAgYWRkQmVmb3JlTWUodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLiRwYXJlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyZW50IG5vdCBzZXQnKTtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy4kcGFyZW50LmdldENoaWxkSW5kZXgodGhpcyk7XG4gICAgICAgIHRoaXMuJHBhcmVudC5hZGRDaGlsZEF0KHRhcmdldCwgaW5kZXgpO1xuICAgIH1cbiAgICBhZGRBZnRlck1lKHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy4kcGFyZW50ID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcmVudCBub3Qgc2V0Jyk7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuJHBhcmVudC5nZXRDaGlsZEluZGV4KHRoaXMpO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICB0aGlzLiRwYXJlbnQuYWRkQ2hpbGRBdCh0YXJnZXQsIGluZGV4KTtcbiAgICB9XG4gICAgY3JlYXRlRGlzcGxheU9iamVjdCgpIHtcbiAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdCA9IG5ldyBVSVNwcml0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5tb3VzZUVuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBoYW5kbGVTaXplQ2hhbmdlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHR5cGUgIT0gMClcbiAgICAgICAgICAgIHRoaXMuZHJhd0dyYXBoKCk7XG4gICAgfVxuICAgIHNldHVwQmVmb3JlQWRkKHhtbCkge1xuICAgICAgICBzdXBlci5zZXR1cEJlZm9yZUFkZCh4bWwpO1xuICAgICAgICBsZXQgdHlwZSA9IHhtbC5hdHRyaWJ1dGVzLnR5cGU7XG4gICAgICAgIGlmICh0eXBlICYmIHR5cGUgIT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmxpbmVTaXplO1xuICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICB0aGlzLiRsaW5lU2l6ZSA9IHBhcnNlSW50KHN0cik7XG4gICAgICAgICAgICBsZXQgYztcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmxpbmVDb2xvcjtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBjID0gU3RyaW5nVXRpbC5jb252ZXJ0VG9SR0JBKHN0cik7XG4gICAgICAgICAgICAgICAgdGhpcy4kbGluZUNvbG9yID0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmZpbGxDb2xvcjtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBjID0gU3RyaW5nVXRpbC5jb252ZXJ0VG9SR0JBKHN0cik7XG4gICAgICAgICAgICAgICAgdGhpcy4kZmlsbENvbG9yID0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhcnI7XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5jb3JuZXI7XG4gICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb3JuZXIgPSBbcGFyc2VJbnQoYXJyWzBdKSwgcGFyc2VJbnQoYXJyWzFdKSwgcGFyc2VJbnQoYXJyWzJdKSwgcGFyc2VJbnQoYXJyWzNdKV07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb3JuZXIgPSBbcGFyc2VJbnQoYXJyWzBdKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PSAncmVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR0eXBlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gJ2VjbGlwc2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdHlwZSA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09ICdyZWd1bGFyX3BvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdHlwZSA9IDM7XG4gICAgICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuc2lkZXM7XG4gICAgICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRzaWRlcyA9IHBhcnNlSW50KHN0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRzdGFydEFuZ2xlID0gcGFyc2VJbnQoc3RyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09ICdwb2x5Z29uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuJHR5cGUgPSA0O1xuICAgICAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnBvaW50cztcbiAgICAgICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRwb2ludHMgPSBhcnIubWFwKHBvaW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhd0dyYXBoKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEJpdG1hcCBleHRlbmRzIFNwcml0ZSB7XG4gICAgY29uc3RydWN0b3IoaXRlbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgbGV0IHsgd2lkdGgsIGhlaWdodCwgdGV4dHVyZSwgaWQgfSA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLiRmcmFtZUlkID0gaWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRleHR1cmUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuc3JjID0gdGV4dHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmUuaW1hZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVJlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlUmVjdCA9IHRleHR1cmUucmVjdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3KGN0eCwgaWdub3JlQ2FjaGUpIHtcbiAgICAgICAgbGV0IGZsYWcgPSBzdXBlci5kcmF3KGN0eCwgaWdub3JlQ2FjaGUpO1xuICAgICAgICBpZiAoZmxhZykge1xuICAgICAgICAgICAgcmV0dXJuIGZsYWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc291cmNlUmVjdCAmJiB0aGlzLnRleHR1cmVSZWN0KSB7XG4gICAgICAgICAgICBsZXQgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnNvdXJjZVJlY3Q7XG4gICAgICAgICAgICB4ID0gdGhpcy4kaXNUcmltID8geCA6IDA7XG4gICAgICAgICAgICB5ID0gdGhpcy4kaXNUcmltID8geSA6IDA7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMudGV4dHVyZSwgdGhpcy50ZXh0dXJlUmVjdC54LCB0aGlzLnRleHR1cmVSZWN0LnksIHRoaXMudGV4dHVyZVJlY3Qud2lkdGgsIHRoaXMudGV4dHVyZVJlY3QuaGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTsgLy9HT2JqZWN05p2l5o6n5Yi25L2N572u5Z2Q5qCHXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMudGV4dHVyZSwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldEJvdW5kcygpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBzdXBlci5nZXRCb3VuZHMoKTtcbiAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlLCBvID0gdGhpcy5zb3VyY2VSZWN0IHx8IHRleHR1cmU7XG4gICAgICAgIHZhciBoYXNDb250ZW50ID0gdGV4dHVyZSAmJiAodGV4dHVyZVsnbmF0dXJhbFdpZHRoJ10gfHwgdGV4dHVyZVsnZ2V0Q29udGV4dCddIHx8IHRleHR1cmVbJ3JlYWR5U3RhdGUnXSA+PSAyKTtcbiAgICAgICAgcmV0dXJuIGhhc0NvbnRlbnQgPyB0aGlzLnNvdXJjZVJlY3Quc2V0VmFsdWVzKDAsIDAsIG8ud2lkdGgsIG8uaGVpZ2h0KSA6IG51bGw7XG4gICAgfVxufVxuXG5jbGFzcyBTY2FsZUJpdG1hcCBleHRlbmRzIFNwcml0ZSB7XG4gICAgY29uc3RydWN0b3IoaXRlbSwgc2NhbGU5R3JpZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgbGV0IHsgd2lkdGgsIGhlaWdodCwgdGV4dHVyZSwgaWQgfSA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLiRmcmFtZUlkID0gaWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRleHR1cmUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuc3JjID0gdGV4dHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmUuaW1hZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVJlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlUmVjdCA9IHRleHR1cmUucmVjdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYWxlOUdyaWQgPSBzY2FsZTlHcmlkO1xuICAgICAgICB0aGlzLnNuYXBUb1BpeGVsID0gdHJ1ZTtcbiAgICB9XG4gICAgZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSB7XG4gICAgICAgIGxldCBmbGFnID0gc3VwZXIuZHJhdyhjdHgsIGlnbm9yZUNhY2hlKTtcbiAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjZW50ZXJYID0gdGhpcy5zY2FsZTlHcmlkLndpZHRoO1xuICAgICAgICB2YXIgY2VudGVyWSA9IHRoaXMuc2NhbGU5R3JpZC5oZWlnaHQ7XG4gICAgICAgIHZhciBzY2FsZWRDZW50ZXJYO1xuICAgICAgICB2YXIgc2NhbGVkQ2VudGVyWTtcbiAgICAgICAgdmFyIGltYWdlSGVpZ2h0ID0gdGhpcy5zb3VyY2VSZWN0LmhlaWdodDtcbiAgICAgICAgdmFyIGltYWdlV2lkdGggPSB0aGlzLnNvdXJjZVJlY3Qud2lkdGg7XG4gICAgICAgIGlmIChjZW50ZXJYID09IDApIHtcbiAgICAgICAgICAgIC8vdmVydGljYWxcbiAgICAgICAgICAgIGlmIChjZW50ZXJZID09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnT25lIG9mIHNjYWxlOUdyaWQgd2lkdGggb3IgaGVpZ2h0IG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzY2FsZTNSZWdpb24yID0gdGhpcy50ZXh0dXJlUmVjdC55ICsgdGhpcy5zY2FsZTlHcmlkLnk7XG4gICAgICAgICAgICB2YXIgc2NhbGUzUmVnaW9uMyA9IHRoaXMudGV4dHVyZVJlY3QueSArIHRoaXMuc2NhbGU5R3JpZC55ICsgdGhpcy5zY2FsZTlHcmlkLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBzY2FsZWRGaXJzdFJlZ2lvbiA9IHRoaXMuc2NhbGU5R3JpZC55O1xuICAgICAgICAgICAgdmFyIHNjYWxlZFNlY29uZFJlZ2lvbiA9IHRoaXMuc2NhbGU5R3JpZC5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgc2NhbGVkVGhpcmRSZWdpb24gPSB0aGlzLnRleHR1cmVSZWN0LmhlaWdodCAtIHNjYWxlZEZpcnN0UmVnaW9uIC0gc2NhbGVkU2Vjb25kUmVnaW9uO1xuICAgICAgICAgICAgc2NhbGVkQ2VudGVyWSA9IGltYWdlSGVpZ2h0IC0gc2NhbGVkRmlyc3RSZWdpb24gLSBzY2FsZWRUaGlyZFJlZ2lvbjtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLCB0aGlzLnRleHR1cmVSZWN0LngsIHRoaXMudGV4dHVyZVJlY3QueSwgdGhpcy50ZXh0dXJlUmVjdC53aWR0aCwgc2NhbGVkRmlyc3RSZWdpb24sIDAsIDAsIGltYWdlV2lkdGgsIHNjYWxlZEZpcnN0UmVnaW9uKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLCB0aGlzLnRleHR1cmVSZWN0LngsIHNjYWxlM1JlZ2lvbjIsIHRoaXMudGV4dHVyZVJlY3Qud2lkdGgsIHNjYWxlZFNlY29uZFJlZ2lvbiwgMCwgc2NhbGVkRmlyc3RSZWdpb24sIGltYWdlV2lkdGgsIHNjYWxlZENlbnRlclkpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnRleHR1cmUsIHRoaXMudGV4dHVyZVJlY3QueCwgc2NhbGUzUmVnaW9uMywgdGhpcy50ZXh0dXJlUmVjdC53aWR0aCwgc2NhbGVkVGhpcmRSZWdpb24sIDAsIHNjYWxlZENlbnRlclkgKyBzY2FsZWRGaXJzdFJlZ2lvbiwgaW1hZ2VXaWR0aCwgc2NhbGVkVGhpcmRSZWdpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNlbnRlclkgPT0gMCkge1xuICAgICAgICAgICAgLy9ob3Jpem9udGFsXG4gICAgICAgICAgICB2YXIgc2NhbGUzUmVnaW9uMiA9IHRoaXMudGV4dHVyZVJlY3QueCArIHRoaXMuc2NhbGU5R3JpZC54O1xuICAgICAgICAgICAgdmFyIHNjYWxlM1JlZ2lvbjMgPSB0aGlzLnRleHR1cmVSZWN0LnggKyB0aGlzLnNjYWxlOUdyaWQueCArIHRoaXMuc2NhbGU5R3JpZC53aWR0aDtcbiAgICAgICAgICAgIHZhciBzY2FsZWRGaXJzdFJlZ2lvbiA9IHRoaXMuc2NhbGU5R3JpZC54O1xuICAgICAgICAgICAgdmFyIHNjYWxlZFNlY29uZFJlZ2lvbiA9IHRoaXMuc2NhbGU5R3JpZC53aWR0aDtcbiAgICAgICAgICAgIHZhciBzY2FsZWRUaGlyZFJlZ2lvbiA9IHRoaXMudGV4dHVyZVJlY3Qud2lkdGggLSBzY2FsZWRGaXJzdFJlZ2lvbiAtIHNjYWxlZFNlY29uZFJlZ2lvbjtcbiAgICAgICAgICAgIHNjYWxlZENlbnRlclggPSBpbWFnZVdpZHRoIC0gc2NhbGVkRmlyc3RSZWdpb24gLSBzY2FsZWRUaGlyZFJlZ2lvbjtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLCB0aGlzLnRleHR1cmVSZWN0LngsIHRoaXMudGV4dHVyZVJlY3QueSwgc2NhbGVkRmlyc3RSZWdpb24sIHRoaXMudGV4dHVyZVJlY3QuaGVpZ2h0LCAwLCAwLCBzY2FsZWRGaXJzdFJlZ2lvbiwgaW1hZ2VIZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnRleHR1cmUsIHNjYWxlM1JlZ2lvbjIsIHRoaXMudGV4dHVyZVJlY3QueSwgc2NhbGVkU2Vjb25kUmVnaW9uLCB0aGlzLnRleHR1cmVSZWN0LmhlaWdodCwgc2NhbGVkRmlyc3RSZWdpb24sIDAsIHNjYWxlZENlbnRlclgsIGltYWdlSGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLCBzY2FsZTNSZWdpb24zLCB0aGlzLnRleHR1cmVSZWN0LnksIHNjYWxlZFRoaXJkUmVnaW9uLCB0aGlzLnRleHR1cmVSZWN0LmhlaWdodCwgc2NhbGVkRmlyc3RSZWdpb24gKyBzY2FsZWRDZW50ZXJYLCAwLCBzY2FsZWRUaGlyZFJlZ2lvbiwgaW1hZ2VIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnNjYWxlOUdyaWQueDtcbiAgICAgICAgICAgIHZhciB0b3AgPSB0aGlzLnNjYWxlOUdyaWQueTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMudGV4dHVyZVJlY3Qud2lkdGggLSBjZW50ZXJYIC0gbGVmdDtcbiAgICAgICAgICAgIHZhciBib3R0b20gPSB0aGlzLnRleHR1cmVSZWN0LmhlaWdodCAtIGNlbnRlclkgLSB0b3A7XG4gICAgICAgICAgICBzY2FsZWRDZW50ZXJYID0gaW1hZ2VXaWR0aCAtIGxlZnQgLSByaWdodDtcbiAgICAgICAgICAgIHNjYWxlZENlbnRlclkgPSBpbWFnZUhlaWdodCAtIHRvcCAtIGJvdHRvbTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLCB0aGlzLnRleHR1cmVSZWN0LngsIHRoaXMudGV4dHVyZVJlY3QueSwgbGVmdCwgdG9wLCAwLCAwLCBsZWZ0LCB0b3ApO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnRleHR1cmUsIHRoaXMudGV4dHVyZVJlY3QueCArIGxlZnQsIHRoaXMudGV4dHVyZVJlY3QueSwgY2VudGVyWCwgdG9wLCBsZWZ0LCAwLCBzY2FsZWRDZW50ZXJYLCB0b3ApO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnRleHR1cmUsIHRoaXMudGV4dHVyZVJlY3QueCArIGxlZnQgKyBjZW50ZXJYLCB0aGlzLnRleHR1cmVSZWN0LnksIHJpZ2h0LCB0b3AsIGxlZnQgKyBzY2FsZWRDZW50ZXJYLCAwLCByaWdodCwgdG9wKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLCB0aGlzLnRleHR1cmVSZWN0LngsIHRoaXMudGV4dHVyZVJlY3QueSArIHRvcCwgbGVmdCwgY2VudGVyWSwgMCwgdG9wLCBsZWZ0LCBzY2FsZWRDZW50ZXJZKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLCB0aGlzLnRleHR1cmVSZWN0LnggKyBsZWZ0LCB0aGlzLnRleHR1cmVSZWN0LnkgKyB0b3AsIGNlbnRlclgsIGNlbnRlclksIGxlZnQsIHRvcCwgc2NhbGVkQ2VudGVyWCwgc2NhbGVkQ2VudGVyWSk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMudGV4dHVyZSwgdGhpcy50ZXh0dXJlUmVjdC54ICsgbGVmdCArIGNlbnRlclgsIHRoaXMudGV4dHVyZVJlY3QueSArIHRvcCwgcmlnaHQsIGNlbnRlclksIGxlZnQgKyBzY2FsZWRDZW50ZXJYLCB0b3AsIHJpZ2h0LCBzY2FsZWRDZW50ZXJZKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLCB0aGlzLnRleHR1cmVSZWN0LngsIHRoaXMudGV4dHVyZVJlY3QueSArIHRvcCArIGNlbnRlclksIGxlZnQsIGJvdHRvbSwgMCwgdG9wICsgc2NhbGVkQ2VudGVyWSwgbGVmdCwgYm90dG9tKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLCB0aGlzLnRleHR1cmVSZWN0LnggKyBsZWZ0LCB0aGlzLnRleHR1cmVSZWN0LnkgKyB0b3AgKyBjZW50ZXJZLCBjZW50ZXJYLCBib3R0b20sIGxlZnQsIHRvcCArIHNjYWxlZENlbnRlclksIHNjYWxlZENlbnRlclgsIGJvdHRvbSk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMudGV4dHVyZSwgdGhpcy50ZXh0dXJlUmVjdC54ICsgbGVmdCArIGNlbnRlclgsIHRoaXMudGV4dHVyZVJlY3QueSArIHRvcCArIGNlbnRlclksIHJpZ2h0LCBib3R0b20sIGxlZnQgKyBzY2FsZWRDZW50ZXJYLCB0b3AgKyBzY2FsZWRDZW50ZXJZLCByaWdodCwgYm90dG9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmNsYXNzIFRpbGluZ0JpdG1hcCBleHRlbmRzIFNwcml0ZSB7XG4gICAgY29uc3RydWN0b3IoaXRlbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgbGV0IHsgd2lkdGgsIGhlaWdodCwgdGV4dHVyZSwgaWQgfSA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLiRmcmFtZUlkID0gaWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRleHR1cmUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuc3JjID0gdGV4dHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmUuaW1hZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVJlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlUmVjdCA9IHRleHR1cmUucmVjdDtcbiAgICAgICAgICAgIGxldCBvZmZzZXRDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRDYW52YXNDb250ZXh0ID0gb2Zmc2V0Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBvZmZzZXRDYW52YXMud2lkdGggPSB0aGlzLnRleHR1cmVSZWN0LndpZHRoO1xuICAgICAgICAgICAgb2Zmc2V0Q2FudmFzLmhlaWdodCA9IHRoaXMudGV4dHVyZVJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgb2Zmc2V0Q2FudmFzQ29udGV4dC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLCB0aGlzLnRleHR1cmVSZWN0LngsIHRoaXMudGV4dHVyZVJlY3QueSwgdGhpcy50ZXh0dXJlUmVjdC53aWR0aCwgdGhpcy50ZXh0dXJlUmVjdC5oZWlnaHQsIDAsIDAsIHRoaXMudGV4dHVyZVJlY3Qud2lkdGgsIHRoaXMudGV4dHVyZVJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4gPSBvZmZzZXRDYW52YXNDb250ZXh0LmNyZWF0ZVBhdHRlcm4ob2Zmc2V0Q2FudmFzLCAncmVwZWF0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSB7XG4gICAgICAgIGxldCBmbGFnID0gc3VwZXIuZHJhdyhjdHgsIGlnbm9yZUNhY2hlKTtcbiAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgIHJldHVybiBmbGFnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGN0eC5zYXZlKCk7XG4gICAgICAgIGxldCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuc291cmNlUmVjdDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX3BhdHRlcm47XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgLy8gY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5jbGFzcyBVSUltYWdlIGV4dGVuZHMgY3JlYXRlanMuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLlVJT3duZXIgPSBvd25lcjtcbiAgICAgICAgLy8gdGhpcy5tb3VzZUVuYWJsZWQgPSB0aGlzLm1vdXNlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgc2V0IHNvdXJjZVJlY3QocmVjdCkge1xuICAgICAgICB0aGlzLiRkaXNwLnNvdXJjZVJlY3QgPSByZWN0O1xuICAgIH1cbiAgICBzZXRDYWNoZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuJGRpc3AuY2FjaGUoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIC8qKkBpbnRlcm5hbCAqL1xuICAgICRpbml0RGlzcChpdGVtKSB7XG4gICAgICAgIGlmICh0aGlzLiRkaXNwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS5sb2FkKCk7XG4gICAgICAgICAgICBpZiAoaXRlbS5zY2FsZUJ5VGlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3AgPSBuZXcgVGlsaW5nQml0bWFwKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5zY2FsZTlHcmlkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKGl0ZW0uc2NhbGU5R3JpZC54LCBpdGVtLnNjYWxlOUdyaWQueSwgTWF0aC5tYXgoMCwgaXRlbS5zY2FsZTlHcmlkLndpZHRoKSwgTWF0aC5tYXgoMCwgaXRlbS5zY2FsZTlHcmlkLmhlaWdodCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3AgPSBuZXcgU2NhbGVCaXRtYXAoaXRlbSwgcmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwID0gbmV3IEJpdG1hcChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3AgPSBuZXcgQml0bWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLiRkaXNwKTtcbiAgICB9XG4gICAgZ2V0IHRpbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRkaXNwLnRpbnQ7XG4gICAgfVxuICAgIHNldCB0aW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJGRpc3AudGludCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZGlzcC5zb3VyY2VSZWN0LmhlaWdodDtcbiAgICB9XG4gICAgc2V0IGhlaWdodCh2KSB7XG4gICAgICAgIHRoaXMuJGRpc3Auc291cmNlUmVjdC5oZWlnaHQgPSB2O1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRkaXNwLnNvdXJjZVJlY3Qud2lkdGg7XG4gICAgfVxuICAgIHNldCB3aWR0aCh2KSB7XG4gICAgICAgIHRoaXMuJGRpc3Auc291cmNlUmVjdC53aWR0aCA9IHY7XG4gICAgfVxuICAgIGdldCB0ZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZGlzcC50ZXh0dXJlO1xuICAgIH1cbiAgICBzZXQgdGV4dHVyZSh2KSB7XG4gICAgICAgIHRoaXMuJGRpc3AudGV4dHVyZSA9IHY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlY3QgPSB4LHksdyxoID0gbCx0LHIsYlxuICAgICAqL1xuICAgIGdldCBzY2FsZTlHcmlkKCkge1xuICAgICAgICBpZiAodGhpcy4kZGlzcCBpbnN0YW5jZW9mIFNjYWxlQml0bWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZGlzcC5zY2FsZTlHcmlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZWN0ID0geCx5LHcsaCA9IGwsdCxyLGJcbiAgICAgKi9cbiAgICBzZXQgc2NhbGU5R3JpZChyZWN0KSB7XG4gICAgICAgIGlmICh0aGlzLiRkaXNwIGluc3RhbmNlb2YgU2NhbGVCaXRtYXApIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3Auc2NhbGU5R3JpZCA9IHJlY3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdG9kb1xuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vICAgICBpZih0aGlzLiRkaXNwKSB7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy4kZGlzcC5kZXN0cm95KG9wdGlvbnMpO1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuJGRpc3AgPSBudWxsO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICB9XG59XG5cbmNsYXNzIEdJbWFnZSBleHRlbmRzIEdPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICBnZXQgdG91Y2hhYmxlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNldCB0b3VjaGFibGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kdG91Y2hhYmxlID0gZmFsc2U7IC8vR0ltYWdlIGhhcyBubyBpbnRlcmFjdGlvblxuICAgIH1cbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjb250ZW50LnRpbnQ7XG4gICAgfVxuICAgIHNldCBjb2xvcih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jb2xvciAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVHZWFyKDQgLyogQ29sb3IgKi8pO1xuICAgICAgICAgICAgdGhpcy4kY29udGVudC50aW50ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLiRjb250ZW50LnNldENhY2hlKDAsIDAsIHRoaXMuJHdpZHRoLCB0aGlzLiRoZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmbGlwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZmxpcDtcbiAgICB9XG4gICAgc2V0IGZsaXAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGZsaXAgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGZsaXAgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRlbnQuc2NhbGVYID0gdGhpcy4kY29udGVudC5zY2FsZVkgPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGZsaXAgPT0gMSAvKiBIb3Jpem9udGFsICovIHx8IHRoaXMuJGZsaXAgPT0gMyAvKiBCb3RoICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGVudC5zY2FsZVggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRmbGlwID09IDIgLyogVmVydGljYWwgKi8gfHwgdGhpcy4kZmxpcCA9PSAzIC8qIEJvdGggKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50LnNjYWxlWSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVYWUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRlbnQudGV4dHVyZTtcbiAgICB9XG4gICAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuJHNvdXJjZVdpZHRoID0gdmFsdWUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLiRzb3VyY2VIZWlnaHQgPSB2YWx1ZS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kc291cmNlV2lkdGggPSB0aGlzLiRzb3VyY2VIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLiRpbml0V2lkdGggPSB0aGlzLiRzb3VyY2VXaWR0aDtcbiAgICAgICAgdGhpcy4kaW5pdEhlaWdodCA9IHRoaXMuJHNvdXJjZUhlaWdodDtcbiAgICAgICAgdGhpcy4kY29udGVudC50ZXh0dXJlID0gdmFsdWU7XG4gICAgfVxuICAgIGNyZWF0ZURpc3BsYXlPYmplY3QoKSB7XG4gICAgICAgIHRoaXMuJGNvbnRlbnQgPSBuZXcgVUlJbWFnZSh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXREaXNwbGF5T2JqZWN0KHRoaXMuJGNvbnRlbnQpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLiRjb250ZW50LmRlc3Ryb3koKTtcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RGcm9tUmVzb3VyY2UoKSB7XG4gICAgICAgIHRoaXMuJHNvdXJjZVdpZHRoID0gdGhpcy5wYWNrYWdlSXRlbS53aWR0aDtcbiAgICAgICAgdGhpcy4kc291cmNlSGVpZ2h0ID0gdGhpcy5wYWNrYWdlSXRlbS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuJGluaXRXaWR0aCA9IHRoaXMuJHNvdXJjZVdpZHRoO1xuICAgICAgICB0aGlzLiRpbml0SGVpZ2h0ID0gdGhpcy4kc291cmNlSGVpZ2h0O1xuICAgICAgICB0aGlzLiRjb250ZW50LiRpbml0RGlzcCh0aGlzLnBhY2thZ2VJdGVtKTtcbiAgICAgICAgdGhpcy5zZXRTaXplKHRoaXMuJHNvdXJjZVdpZHRoLCB0aGlzLiRzb3VyY2VIZWlnaHQpO1xuICAgIH1cbiAgICBoYW5kbGVYWUNoYW5nZWQoKSB7XG4gICAgICAgIHN1cGVyLmhhbmRsZVhZQ2hhbmdlZCgpO1xuICAgICAgICBpZiAodGhpcy4kZmxpcCAhPSAwIC8qIE5vbmUgKi8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRjb250ZW50LnNjYWxlWCA9PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50LnggKz0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLiRjb250ZW50LnNjYWxlWSA9PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50LnkgKz0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlU2l6ZUNoYW5nZWQoKSB7XG4gICAgICAgIHRoaXMuJGNvbnRlbnQud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLiRjb250ZW50LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy4kY29udGVudC5zb3VyY2VSZWN0ID0gcmVjdDtcbiAgICB9XG4gICAgc2V0dXBCZWZvcmVBZGQoeG1sKSB7XG4gICAgICAgIHN1cGVyLnNldHVwQmVmb3JlQWRkKHhtbCk7XG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmNvbG9yO1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gU3RyaW5nVXRpbC5IRVgyUkdCKHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuZmxpcDtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuZmxpcCA9IFBhcnNlRmxpcFR5cGUoc3RyKTtcbiAgICB9XG59XG5cbmNsYXNzIEdUaW1lciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuJGVudW1JZHggPSAwO1xuICAgICAgICB0aGlzLiRlbnVtQ291bnQgPSAwO1xuICAgICAgICB0aGlzLiRjdXJUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy4kaXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy4kaXRlbVBvb2wgPSBbXTtcbiAgICAgICAgLy8gdGhpcy4kbGFzdFRpbWUgPSBjcmVhdGVqcy5UaWNrZXIuZ2V0VGltZSgpO1xuICAgICAgICAvLyBHVGltZXIudGltZSA9IHRoaXMuJGxhc3RUaW1lO1xuICAgICAgICBjcmVhdGVqcy5UaWNrZXIub24oJ3RpY2snLCB0aGlzLmFkdmFuY2UsIHRoaXMpO1xuICAgIH1cbiAgICBnZXRJdGVtKCkge1xuICAgICAgICBpZiAodGhpcy4kaXRlbVBvb2wubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1Qb29sLnBvcCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRpbWVySXRlbSgpO1xuICAgIH1cbiAgICBmaW5kSXRlbShjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBsZXQgbGVuID0gdGhpcy4kaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuJGl0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0uY2FsbGJhY2sgPT0gY2FsbGJhY2sgJiYgaXRlbS50aGlzT2JqID09IHRoaXNPYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vcmVwZWF0IDw9IDAgbWVhbnMgbG9vcFxuICAgIGFkZChkZWxheUluTXMsIHJlcGVhdCwgY2FsbGJhY2ssIHRoaXNPYmosIGNhbGxiYWNrUGFyYW0pIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmZpbmRJdGVtKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5nZXRJdGVtKCk7XG4gICAgICAgICAgICBpdGVtLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBpdGVtLnRoaXNPYmogPSB0aGlzT2JqO1xuICAgICAgICAgICAgdGhpcy4kaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLmRlbGF5ID0gZGVsYXlJbk1zO1xuICAgICAgICBpdGVtLmNvdW50ZXIgPSAwO1xuICAgICAgICBpdGVtLnJlcGVhdCA9IHJlcGVhdDtcbiAgICAgICAgaXRlbS5wYXJhbSA9IGNhbGxiYWNrUGFyYW07XG4gICAgICAgIGl0ZW0uZW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGFkZExvb3AoZGVsYXlJbk1zLCBjYWxsYmFjaywgdGhpc09iaiwgY2FsbGJhY2tQYXJhbSkge1xuICAgICAgICB0aGlzLmFkZChkZWxheUluTXMsIDAsIGNhbGxiYWNrLCB0aGlzT2JqLCBjYWxsYmFja1BhcmFtKTtcbiAgICB9XG4gICAgY2FsbExhdGVyKGNhbGxiYWNrLCB0aGlzT2JqLCBjYWxsYmFja1BhcmFtKSB7XG4gICAgICAgIHRoaXMuYWRkKDEsIDEsIGNhbGxiYWNrLCB0aGlzT2JqLCBjYWxsYmFja1BhcmFtKTtcbiAgICB9XG4gICAgY2FsbERlbGF5KGRlbGF5SW5NcywgY2FsbGJhY2ssIHRoaXNPYmosIGNhbGxiYWNrUGFyYW0pIHtcbiAgICAgICAgdGhpcy5hZGQoZGVsYXlJbk1zLCAxLCBjYWxsYmFjaywgdGhpc09iaiwgY2FsbGJhY2tQYXJhbSk7XG4gICAgfVxuICAgIGV4aXN0cyhjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuZmluZEl0ZW0oY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICByZXR1cm4gaXRlbSAhPSBudWxsO1xuICAgIH1cbiAgICByZW1vdmUoY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmZpbmRJdGVtKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy4kaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuJGl0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGlmIChpIDwgdGhpcy4kZW51bUlkeClcbiAgICAgICAgICAgICAgICB0aGlzLiRlbnVtSWR4LS07XG4gICAgICAgICAgICB0aGlzLiRlbnVtQ291bnQtLTtcbiAgICAgICAgICAgIGl0ZW0uY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgaXRlbS5wYXJhbSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLiRpdGVtUG9vbC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0aWNrZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0aWNrZXI7XG4gICAgfVxuICAgIGdldCBjdXJUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY3VyVGltZTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgdGhpcy4kZW51bUlkeCA9IDA7XG4gICAgICAgIHRoaXMuJGVudW1Db3VudCA9IHRoaXMuJGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHRoaXMuJGVudW1JZHggPCB0aGlzLiRlbnVtQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy4kaXRlbXNbdGhpcy4kZW51bUlkeF07XG4gICAgICAgICAgICB0aGlzLiRlbnVtSWR4Kys7XG4gICAgICAgICAgICBsZXQgbXMgPSBjcmVhdGVqcy5UaWNrZXIuaW50ZXJ2YWw7XG4gICAgICAgICAgICB0aGlzLiRjdXJUaW1lICs9IG1zO1xuICAgICAgICAgICAgaWYgKGl0ZW0uYWR2YW5jZShtcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW51bUlkeC0tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbnVtQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuc3BsaWNlKHRoaXMuJGVudW1JZHgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRpdGVtUG9vbC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXJncyA9IFttc107XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnBhcmFtICYmIGl0ZW0ucGFyYW0gaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBpdGVtLnBhcmFtLmNvbmNhdChhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5wYXJhbSAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KGl0ZW0ucGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNhbGxiYWNrLmFwcGx5KGl0ZW0udGhpc09iaiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmVuZClcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jYWxsYmFjayA9IGl0ZW0udGhpc09iaiA9IGl0ZW0ucGFyYW0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuR1RpbWVyLmluc3QgPSBuZXcgR1RpbWVyKCk7XG5jbGFzcyBUaW1lckl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRlbGF5ID0gMDtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5yZXBlYXQgPSAwO1xuICAgIH1cbiAgICBhZHZhbmNlKGRlbHRhID0gMCkge1xuICAgICAgICB0aGlzLmNvdW50ZXIgKz0gZGVsdGE7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ZXIgPj0gdGhpcy5kZWxheSkge1xuICAgICAgICAgICAgdGhpcy5jb3VudGVyIC09IHRoaXMuZGVsYXk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudGVyID4gdGhpcy5kZWxheSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ZXIgPSB0aGlzLmRlbGF5O1xuICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0LS07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ID09IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmNsYXNzIE1hdGhVdGlsIHtcbiAgICBzdGF0aWMgY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IG1pbilcbiAgICAgICAgICAgIHZhbHVlID0gbWluO1xuICAgICAgICBlbHNlIGlmICh2YWx1ZSA+IG1heClcbiAgICAgICAgICAgIHZhbHVlID0gbWF4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHN0YXRpYyBjbGFtcDAxKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+IDEpXG4gICAgICAgICAgICB2YWx1ZSA9IDE7XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgMClcbiAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgaXNOdW1iZXIobikge1xuICAgICAgICBpZiAodHlwZW9mIChuKSAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoaXNOYU4obikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzdGF0aWMgc2lnbih4KSB7XG4gICAgICAgIHggPSBOdW1iZXIoeCk7XG4gICAgICAgIGlmICh4ID09PSAwIHx8IGlzTmFOKHgpKVxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIHJldHVybiB4ID4gMCA/IDEgOiAtMTtcbiAgICB9XG4gICAgc3RhdGljIGFuZ2xlVG9SYWRpYW4obikge1xuICAgICAgICByZXR1cm4gbiAqIE1hdGhVdGlsLlJBRElBTjtcbiAgICB9XG4gICAgc3RhdGljIGxlcnAocywgZSwgcCkge1xuICAgICAgICByZXR1cm4gcyArIHAgKiAoZSAtIHMpO1xuICAgIH1cbn1cbk1hdGhVdGlsLlJBRElBTiA9IE1hdGguUEkgLyAxODA7XG5cbmNsYXNzIE1vdmllQ2xpcERhdGEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlcGVhdGVkQ291bnQgPSAwO1xuICAgICAgICB0aGlzLiRjdXJGcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuJGxhc3RUaW1lID0gMDtcbiAgICAgICAgdGhpcy4kY3VyRnJhbWVEZWxheSA9IDA7XG4gICAgICAgIHRoaXMuJGxhc3RUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgdXBkYXRlKG1jKSB7XG4gICAgICAgIGxldCB0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IGVsYXBzZWQgPSB0IC0gdGhpcy4kbGFzdFRpbWU7XG4gICAgICAgIHRoaXMuJGxhc3RUaW1lID0gdDtcbiAgICAgICAgbGV0IGN1ciA9IHRoaXMuJGN1ckZyYW1lO1xuICAgICAgICBpZiAoY3VyID49IG1jLmZyYW1lQ291bnQpXG4gICAgICAgICAgICBjdXIgPSBtYy5mcmFtZUNvdW50IC0gMTtcbiAgICAgICAgdGhpcy5yZWFjaGVzRW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGN1ckZyYW1lRGVsYXkgKz0gZWxhcHNlZDtcbiAgICAgICAgbGV0IGludGVydmFsID0gbWMuaW50ZXJ2YWwgKyBtYy5mcmFtZXNbY3VyXS5hZGREZWxheVxuICAgICAgICAgICAgKyAoKGN1ciA9PSAwICYmIHRoaXMucmVwZWF0ZWRDb3VudCA+IDApID8gbWMucmVwZWF0RGVsYXkgOiAwKTtcbiAgICAgICAgaWYgKHRoaXMuJGN1ckZyYW1lRGVsYXkgPCBpbnRlcnZhbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kY3VyRnJhbWVEZWxheSAtPSBpbnRlcnZhbDtcbiAgICAgICAgaWYgKHRoaXMuJGN1ckZyYW1lRGVsYXkgPiBtYy5pbnRlcnZhbClcbiAgICAgICAgICAgIHRoaXMuJGN1ckZyYW1lRGVsYXkgPSBtYy5pbnRlcnZhbDtcbiAgICAgICAgaWYgKG1jLnN3aW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXZlcnNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGN1ckZyYW1lLS07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGN1ckZyYW1lIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjdXJGcmFtZSA9IE1hdGgubWluKDEsIG1jLmZyYW1lQ291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZWQgPSAhdGhpcy5yZXZlcnNlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjdXJGcmFtZSsrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRjdXJGcmFtZSA+IG1jLmZyYW1lQ291bnQgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGN1ckZyYW1lID0gTWF0aC5tYXgoMCwgbWMuZnJhbWVDb3VudCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFjaGVzRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXZlcnNlZCA9ICF0aGlzLnJldmVyc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGN1ckZyYW1lKys7XG4gICAgICAgICAgICBpZiAodGhpcy4kY3VyRnJhbWUgPiBtYy5mcmFtZUNvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGN1ckZyYW1lID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWNoZXNFbmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjdXJyZW50RnJhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjdXJGcmFtZTtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRGcmFtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiRjdXJGcmFtZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLiRjdXJGcmFtZURlbGF5ID0gMDtcbiAgICB9XG4gICAgcmV3aW5kKCkge1xuICAgICAgICB0aGlzLiRjdXJGcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuJGN1ckZyYW1lRGVsYXkgPSAwO1xuICAgICAgICB0aGlzLnJldmVyc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVhY2hlc0VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy4kY3VyRnJhbWUgPSAwO1xuICAgICAgICB0aGlzLiRjdXJGcmFtZURlbGF5ID0gMDtcbiAgICAgICAgdGhpcy5yZXBlYXRlZENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5yZWFjaGVzRW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmV2ZXJzZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY29weShzcmMpIHtcbiAgICAgICAgdGhpcy4kY3VyRnJhbWUgPSBzcmMuJGN1ckZyYW1lO1xuICAgICAgICB0aGlzLiRjdXJGcmFtZURlbGF5ID0gc3JjLiRjdXJGcmFtZURlbGF5O1xuICAgICAgICB0aGlzLnJlcGVhdGVkQ291bnQgPSBzcmMucmVwZWF0ZWRDb3VudDtcbiAgICAgICAgdGhpcy5yZWFjaGVzRW5kID0gc3JjLnJlYWNoZXNFbmQ7XG4gICAgICAgIHRoaXMucmV2ZXJzZWQgPSBzcmMucmV2ZXJzZWQ7XG4gICAgfVxufVxuXG5jbGFzcyBEZWZhdWx0TW92aWVDbGlwU2V0dGluZ3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKip0aGUgZmlyc3QgZnJhbWUgbnVtYmVyIHRvIHN0YXJ0IHRvIHBsYXkgKi9cbiAgICAgICAgdGhpcy5zdGFydEZyYW1lID0gMDtcbiAgICAgICAgLyoqdGhlIGVuZCBmcmFtZSB0aGUgcGxheWluZyB3aWxsIGVuZCBhdCwgLTEgbWVhbnMgdG8gdGhlIHRhaWwgKi9cbiAgICAgICAgdGhpcy5lbmRGcmFtZSA9IC0xO1xuICAgICAgICAvKipwbGF5IGNvdW50LCAwIG1lYW5zIGVuZGVsZXNzICovXG4gICAgICAgIHRoaXMucmVwZWF0Q291bnQgPSAwO1xuICAgICAgICAvKipvbmNlIHRoZSByZXBlYXRlZCBwbGF5aW5nIGNvbXBsZXRlcywgdGhlIHBsYXlpbmcgd2lsbCBlbmQgYXQsIC0xIG1lYW5zIHRvIHRoZSB0YWlsICovXG4gICAgICAgIHRoaXMubG9vcEVuZEF0ID0gLTE7XG4gICAgICAgIC8qKmNvbXBsZXRlIGNhbGxiYWNrIGhhbmRsZXIgKi9cbiAgICAgICAgdGhpcy5lbmRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIC8qKmNvbnRleHQgb2JqZWN0IGZvciB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gKi9cbiAgICAgICAgdGhpcy5lbmRDYWxsYmFja0NvbnRleHQgPSBudWxsO1xuICAgIH1cbiAgICAvKiptb2RpZnkgdGhlIGN1cnJlbnQgc2V0dGluZ3Mgd2l0aG91dCB3aG9sZSBwYXJhbWV0ZXJzIHByb3ZpZGVkICovXG4gICAgbWl4KG90aGVyKSB7XG4gICAgICAgIGxldCByZXQgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb3RoZXIpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT0gXCJtaXhcIilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHJldFtrZXldID0gb3RoZXJba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNsYXNzIE1vdmllQ2xpcCBleHRlbmRzIEJpdG1hcCB7XG4gICAgY29uc3RydWN0b3Iob3duZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IDA7XG4gICAgICAgIHRoaXMucmVwZWF0RGVsYXkgPSAwO1xuICAgICAgICB0aGlzLiRmcmFtZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy4kY3VycmVudEZyYW1lID0gMDtcbiAgICAgICAgdGhpcy4kc3RhdHVzID0gMCAvKiBOT1JNQUwgKi87XG4gICAgICAgIHRoaXMuVUlPd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTW92aWVDbGlwRGF0YSgpO1xuICAgICAgICB0aGlzLiRwbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tb3VzZUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kc2V0dGluZ3MgPSBuZXcgRGVmYXVsdE1vdmllQ2xpcFNldHRpbmdzKCk7XG4gICAgICAgIHRoaXMuJGlzVHJpbSA9IHRydWU7XG4gICAgICAgIHRoaXMub24oJ2FkZGVkJywgdGhpcy5hZGRlZCwgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ3JlbW92ZWQnLCB0aGlzLnJlbW92ZWQsIHRoaXMpO1xuICAgIH1cbiAgICAvLyBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBpZ25vcmVDYWNoZTogYm9vbGVhbik6IGJvb2xlYW4ge1xuICAgIC8vICAgICAvLyBsZXQgZmxhZyA9IHN1cGVyLmRyYXcoY3R4LCBpZ25vcmVDYWNoZSk7XG4gICAgLy8gICAgIC8vIGlmIChmbGFnKSB7XG4gICAgLy8gICAgIC8vICAgICByZXR1cm4gZmxhZztcbiAgICAvLyAgICAgLy8gfVxuICAgIC8vICAgICBpZiAodGhpcy5zb3VyY2VSZWN0ICYmIHRoaXMudGV4dHVyZVJlY3QpIHtcbiAgICAvLyAgICAgICAgIGxldCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMudGV4dHVyZVJlY3Q7XG4gICAgLy8gICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMudGV4dHVyZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgdGhpcy5zb3VyY2VSZWN0LngsIHRoaXMuc291cmNlUmVjdC55LCB0aGlzLnNvdXJjZVJlY3Qud2lkdGgsIHRoaXMuc291cmNlUmVjdC5oZWlnaHQpOy8vR09iamVjdOadpeaOp+WItuS9jee9ruWdkOagh1xuICAgIC8vICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnRleHR1cmUsIDAsIDApO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgIC8vIH1cbiAgICBnZXQgZnJhbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZnJhbWVzO1xuICAgIH1cbiAgICBzZXQgZnJhbWVzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJGZyYW1lcyA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy4kZnJhbWVzICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLiRmcmFtZUNvdW50ID0gdGhpcy4kZnJhbWVzLmxlbmd0aDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kZnJhbWVDb3VudCA9IDA7XG4gICAgICAgIGlmICh0aGlzLiRzZXR0aW5ncy5lbmRGcmFtZSA9PSAtMSB8fCB0aGlzLiRzZXR0aW5ncy5lbmRGcmFtZSA+IHRoaXMuJGZyYW1lQ291bnQgLSAxKVxuICAgICAgICAgICAgdGhpcy4kc2V0dGluZ3MuZW5kRnJhbWUgPSB0aGlzLiRmcmFtZUNvdW50IC0gMTtcbiAgICAgICAgaWYgKHRoaXMuJHNldHRpbmdzLmxvb3BFbmRBdCA9PSAtMSB8fCB0aGlzLiRzZXR0aW5ncy5sb29wRW5kQXQgPiB0aGlzLiRmcmFtZUNvdW50IC0gMSlcbiAgICAgICAgICAgIHRoaXMuJHNldHRpbmdzLmxvb3BFbmRBdCA9IHRoaXMuJGZyYW1lQ291bnQgLSAxO1xuICAgICAgICBpZiAodGhpcy4kY3VycmVudEZyYW1lIDwgMCB8fCB0aGlzLiRjdXJyZW50RnJhbWUgPiB0aGlzLiRmcmFtZUNvdW50IC0gMSlcbiAgICAgICAgICAgIHRoaXMuJGN1cnJlbnRGcmFtZSA9IHRoaXMuJGZyYW1lQ291bnQgLSAxO1xuICAgICAgICBpZiAodGhpcy4kZnJhbWVDb3VudCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RnJhbWUodGhpcy4kZnJhbWVzW3RoaXMuJGN1cnJlbnRGcmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRGcmFtZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGEucmV3aW5kKCk7XG4gICAgfVxuICAgIGdldCBmcmFtZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZnJhbWVDb3VudDtcbiAgICB9XG4gICAgLy8gcHVibGljIGdldCBib3VuZHNSZWN0KCk6IGNyZWF0ZWpzLlJlY3RhbmdsZSB7XG4gICAgLy8gICAgIHJldHVybiB0aGlzLmdldEJvdW5kcygpO1xuICAgIC8vICAgICAvLyByZXR1cm4gdGhpcy5fYm91bmRzUmVjdDtcbiAgICAvLyB9XG4gICAgc2V0IGJvdW5kc1JlY3QodmFsdWUpIHtcbiAgICAgICAgLy8gdGhpcy5fYm91bmRzUmVjdCA9IHZhbHVlO1xuICAgICAgICAvLyB0aGlzLnNvdXJjZVJlY3QgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRGcmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGN1cnJlbnRGcmFtZTtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRGcmFtZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kY3VycmVudEZyYW1lICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRjdXJyZW50RnJhbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5jdXJyZW50RnJhbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0RnJhbWUodGhpcy4kY3VycmVudEZyYW1lIDwgdGhpcy4kZnJhbWVDb3VudCA/IHRoaXMuJGZyYW1lc1t0aGlzLiRjdXJyZW50RnJhbWVdIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHBsYXlpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRwbGF5aW5nO1xuICAgIH1cbiAgICBzZXQgcGxheWluZyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiRwbGF5aW5nID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJiBHT2JqZWN0LmlzRGlzcGxheU9iamVjdE9uU3RhZ2UodGhpcykpXG4gICAgICAgICAgICBHVGltZXIuaW5zdC5hZGQoMCwgMCwgdGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBHVGltZXIuaW5zdC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICAqIE1vZGlmeSB0aGUgcGxheWluZyBzZXR0aW5ncyBmb3IgdGhlIGN1cnJlbnQgTW92aWVDbGlwIG9iamVjdCwgdGhlcmUgYXJlIHR3byB3YXlzIHRvIGNhbGwgdGhpcyBtZXRob2Q6XG4gICAgICAgKiAxKSBwYXNzIHdob2xlIHBhcmFtZXRlcnM6XG4gICAgICAgICAgICAgIHN0YXJ0RnJhbWU6IG51bWJlcjtcbiAgICAgICAgICAgICAgZW5kRnJhbWU6IG51bWJlcjtcbiAgICAgICAgICAgICAgcmVwZWF0Q291bnQ6IG51bWJlcjtcbiAgICAgICAgICAgICAgbG9vcEVuZEF0OiBudW1iZXI7XG4gICAgICAgICAgICAgIGVuZENhbGxiYWNrOiAodGFyZ2V0PzogTW92aWVDbGlwKSA9PiB2b2lkO1xuICAgICAgICAgICAgICBlbmRDYWxsYmFja0NvbnRleHQ6IGFueTtcbiAgICAgICAqIDIpIGp1c3QgcGFzcyAxIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIE1vdmllQ2xpcFNldHRpbmdzIChyZWNvbW1lbmRlZClcbiAgICAgICAqL1xuICAgIHNldFBsYXlTZXR0aW5ncyguLi5hcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAxICYmIHR5cGVvZiBhcmdzWzBdID09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhpcy4kc2V0dGluZ3MubWl4KGFyZ3NbMF0pO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzID0gYXJnc1swXSwgZSA9IGFyZ3NbMV0sIHIgPSBhcmdzWzJdLCBsID0gYXJnc1szXSwgZWMgPSBhcmdzWzRdLCBlY2MgPSBhcmdzWzVdO1xuICAgICAgICAgICAgbGV0IG8gPSB7fTtcbiAgICAgICAgICAgIGlmIChNYXRoVXRpbC5pc051bWJlcihzKSlcbiAgICAgICAgICAgICAgICBvLnN0YXJ0RnJhbWUgPSBzO1xuICAgICAgICAgICAgaWYgKE1hdGhVdGlsLmlzTnVtYmVyKGUpKVxuICAgICAgICAgICAgICAgIG8uZW5kRnJhbWUgPSBlO1xuICAgICAgICAgICAgaWYgKE1hdGhVdGlsLmlzTnVtYmVyKHIpKVxuICAgICAgICAgICAgICAgIG8ucmVwZWF0Q291bnQgPSByO1xuICAgICAgICAgICAgaWYgKE1hdGhVdGlsLmlzTnVtYmVyKGwpKVxuICAgICAgICAgICAgICAgIG8ubG9vcEVuZEF0ID0gbDtcbiAgICAgICAgICAgIGlmIChlYyAmJiB0eXBlb2YgZWMgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBvLmVuZENhbGxiYWNrID0gZWM7XG4gICAgICAgICAgICBpZiAoZWNjKVxuICAgICAgICAgICAgICAgIG8uZW5kQ2FsbGJhY2tDb250ZXh0ID0gZWNjO1xuICAgICAgICAgICAgdGhpcy4kc2V0dGluZ3MubWl4KG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRzZXR0aW5ncy5lbmRGcmFtZSA9PSAtMSB8fCB0aGlzLiRzZXR0aW5ncy5lbmRGcmFtZSA+IHRoaXMuJGZyYW1lQ291bnQgLSAxKVxuICAgICAgICAgICAgdGhpcy4kc2V0dGluZ3MuZW5kRnJhbWUgPSB0aGlzLiRmcmFtZUNvdW50IC0gMTtcbiAgICAgICAgaWYgKHRoaXMuJHNldHRpbmdzLmxvb3BFbmRBdCA9PSAtMSlcbiAgICAgICAgICAgIHRoaXMuJHNldHRpbmdzLmxvb3BFbmRBdCA9IHRoaXMuJHNldHRpbmdzLmVuZEZyYW1lO1xuICAgICAgICB0aGlzLiRzdGF0dXMgPSAwIC8qIE5PUk1BTCAqLztcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSB0aGlzLiRzZXR0aW5ncy5zdGFydEZyYW1lO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLlVJT3duZXIuJGluUHJvZ3Jlc3NCdWlsZGluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuJHBsYXlpbmcgJiYgdGhpcy4kZnJhbWVDb3VudCAhPSAwICYmIHRoaXMuJHN0YXR1cyAhPSAzIC8qIEVOREVEICovKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEudXBkYXRlKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGN1cnJlbnRGcmFtZSAhPSB0aGlzLmRhdGEuY3VycmVudEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHN0YXR1cyA9PSAxIC8qIExPT1BJTkcgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY3VycmVudEZyYW1lID0gdGhpcy4kc2V0dGluZ3Muc3RhcnRGcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmN1cnJlbnRGcmFtZSA9IHRoaXMuJGN1cnJlbnRGcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kc3RhdHVzID0gMCAvKiBOT1JNQUwgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJHN0YXR1cyA9PSAyIC8qIFNUT1BQSU5HICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGN1cnJlbnRGcmFtZSA9IHRoaXMuJHNldHRpbmdzLmxvb3BFbmRBdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmN1cnJlbnRGcmFtZSA9IHRoaXMuJGN1cnJlbnRGcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kc3RhdHVzID0gMyAvKiBFTkRFRCAqLztcbiAgICAgICAgICAgICAgICAgICAgLy9wbGF5IGVuZFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kc2V0dGluZ3MuZW5kQ2FsbGJhY2sgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIEdUaW1lci5pbnN0LmNhbGxMYXRlcih0aGlzLiRwbGF5RW5kLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGN1cnJlbnRGcmFtZSA9IHRoaXMuZGF0YS5jdXJyZW50RnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRjdXJyZW50RnJhbWUgPT0gdGhpcy4kc2V0dGluZ3MuZW5kRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRzZXR0aW5ncy5yZXBlYXRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXR0aW5ncy5yZXBlYXRDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRzZXR0aW5ncy5yZXBlYXRDb3VudCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzdGF0dXMgPSAyIC8qIFNUT1BQSU5HICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc3RhdHVzID0gMSAvKiBMT09QSU5HICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RnJhbWUodGhpcy4kZnJhbWVzW3RoaXMuJGN1cnJlbnRGcmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICRwbGF5RW5kKCkge1xuICAgICAgICBpZiAodGhpcy4kc2V0dGluZ3MuZW5kQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGYgPSB0aGlzLiRzZXR0aW5ncy5lbmRDYWxsYmFjaztcbiAgICAgICAgICAgIGxldCBmT2JqID0gdGhpcy4kc2V0dGluZ3MuZW5kQ2FsbGJhY2tDb250ZXh0O1xuICAgICAgICAgICAgdGhpcy4kc2V0dGluZ3MuZW5kQ2FsbGJhY2sgPSB0aGlzLiRzZXR0aW5ncy5lbmRDYWxsYmFja0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kc2V0dGluZ3MuZW5kQ2FsbGJhY2tDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICAgIGYuY2FsbChmT2JqLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRGcmFtZShmcmFtZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBmcmFtZSA9PSBudWxsID8gbnVsbCA6IGZyYW1lLnRleHR1cmUuaW1hZ2U7XG4gICAgICAgIHRoaXMudGV4dHVyZVJlY3QgPSBmcmFtZS50ZXh0dXJlLnJlY3Q7XG4gICAgICAgIHRoaXMuc291cmNlUmVjdCA9IGZyYW1lLnRleHR1cmUudHJpbTtcbiAgICAgICAgbGV0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5zb3VyY2VSZWN0O1xuICAgICAgICB0aGlzLmNhY2hlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvLyB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICB9XG4gICAgYWRkZWQoZGlzcCkge1xuICAgICAgICBpZiAodGhpcy4kcGxheWluZylcbiAgICAgICAgICAgIEdUaW1lci5pbnN0LmFkZCgwLCAwLCB0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgfVxuICAgIHJlbW92ZWQoZGlzcCkge1xuICAgICAgICBpZiAodGhpcy4kcGxheWluZylcbiAgICAgICAgICAgIEdUaW1lci5pbnN0LnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIEdUaW1lci5pbnN0LnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMub2ZmKCdhZGRlZCcsIHRoaXMuYWRkZWQpO1xuICAgICAgICB0aGlzLm9mZigncmVtb3ZlZCcsIHRoaXMucmVtb3ZlZCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbmNsYXNzIEdNb3ZpZUNsaXAgZXh0ZW5kcyBHT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgbWFwUGl2b3RXaWR0aChzY2FsZSkge1xuICAgICAgICByZXR1cm4gc2NhbGUgKiB0aGlzLiRzb3VyY2VXaWR0aDtcbiAgICB9XG4gICAgbWFwUGl2b3RIZWlnaHQoc2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlICogdGhpcy4kc291cmNlSGVpZ2h0O1xuICAgIH1cbiAgICBoYW5kbGVTaXplQ2hhbmdlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGRpc3BsYXlPYmplY3QgIT0gbnVsbCAmJiB0aGlzLiRzb3VyY2VXaWR0aCAhPSAwICYmIHRoaXMuJHNvdXJjZUhlaWdodCAhPSAwKVxuICAgICAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5zZXQoe1xuICAgICAgICAgICAgICAgIHNjYWxlWDogKHRoaXMuJHdpZHRoIC8gdGhpcy4kc291cmNlV2lkdGgpICogdGhpcy4kc2NhbGVYLFxuICAgICAgICAgICAgICAgIHNjYWxlWTogKHRoaXMuJGhlaWdodCAvIHRoaXMuJHNvdXJjZUhlaWdodCkgKiB0aGlzLiRzY2FsZVlcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTY2FsZUNoYW5nZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRkaXNwbGF5T2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3Quc2V0KHtcbiAgICAgICAgICAgICAgICBzY2FsZVg6ICh0aGlzLiR3aWR0aCAvIHRoaXMuJHNvdXJjZVdpZHRoKSAqIHRoaXMuJHNjYWxlWCxcbiAgICAgICAgICAgICAgICBzY2FsZVk6ICh0aGlzLiRoZWlnaHQgLyB0aGlzLiRzb3VyY2VIZWlnaHQpICogdGhpcy4kc2NhbGVZXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdG91Y2hhYmxlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNldCB0b3VjaGFibGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kdG91Y2hhYmxlID0gZmFsc2U7IC8vR01vdmllQ2xpcCBoYXMgbm8gaW50ZXJhY3Rpb25cbiAgICB9XG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kbW92aWVDbGlwLnRpbnQ7XG4gICAgfVxuICAgIHNldCBjb2xvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLiRtb3ZpZUNsaXAudGludCA9IHZhbHVlO1xuICAgIH1cbiAgICBjcmVhdGVEaXNwbGF5T2JqZWN0KCkge1xuICAgICAgICB0aGlzLiRtb3ZpZUNsaXAgPSBuZXcgTW92aWVDbGlwKHRoaXMpO1xuICAgICAgICB0aGlzLnNldERpc3BsYXlPYmplY3QodGhpcy4kbW92aWVDbGlwKTtcbiAgICB9XG4gICAgZ2V0IHBsYXlpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRtb3ZpZUNsaXAucGxheWluZztcbiAgICB9XG4gICAgc2V0IHBsYXlpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJG1vdmllQ2xpcC5wbGF5aW5nICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRtb3ZpZUNsaXAucGxheWluZyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVHZWFyKDUgLyogQW5pbWF0aW9uICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZnJhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRtb3ZpZUNsaXAuY3VycmVudEZyYW1lO1xuICAgIH1cbiAgICBzZXQgZnJhbWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJG1vdmllQ2xpcC5jdXJyZW50RnJhbWUgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJG1vdmllQ2xpcC5jdXJyZW50RnJhbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlR2Vhcig1IC8qIEFuaW1hdGlvbiAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICAgKiBNb2RpZnkgdGhlIHBsYXlpbmcgc2V0dGluZ3MgZm9yIHRoZSBjdXJyZW50IE1vdmllQ2xpcCBvYmplY3QsIHRoZXJlIGFyZSB0d28gd2F5cyB0byBjYWxsIHRoaXMgbWV0aG9kOlxuICAgICAgICogMSkgcGFzcyB3aG9sZSBwYXJhbWV0ZXJzOlxuICAgICAgICAgICAgICBzdGFydEZyYW1lOiBudW1iZXI7XG4gICAgICAgICAgICAgIGVuZEZyYW1lOiBudW1iZXI7XG4gICAgICAgICAgICAgIHJlcGVhdENvdW50OiBudW1iZXI7XG4gICAgICAgICAgICAgIGxvb3BFbmRBdDogbnVtYmVyO1xuICAgICAgICAgICAgICBlbmRDYWxsYmFjazogKHRhcmdldD86IE1vdmllQ2xpcCkgPT4gdm9pZDtcbiAgICAgICAgICAgICAgZW5kQ2FsbGJhY2tDb250ZXh0OiBhbnk7XG4gICAgICAgKiAyKSBqdXN0IHBhc3MgMSBvYmplY3Qgd2hpY2ggaW1wbGVtZW50cyBNb3ZpZUNsaXBTZXR0aW5ncyAocmVjb21tZW5kZWQpXG4gICAgICAgKi9cbiAgICBzZXRQbGF5U2V0dGluZ3MoLi4uYXJncykge1xuICAgICAgICB0aGlzLiRtb3ZpZUNsaXAuc2V0UGxheVNldHRpbmdzLmFwcGx5KHRoaXMuJG1vdmllQ2xpcCwgYXJncyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdEZyb21SZXNvdXJjZSgpIHtcbiAgICAgICAgdGhpcy4kc291cmNlV2lkdGggPSB0aGlzLnBhY2thZ2VJdGVtLndpZHRoO1xuICAgICAgICB0aGlzLiRzb3VyY2VIZWlnaHQgPSB0aGlzLnBhY2thZ2VJdGVtLmhlaWdodDtcbiAgICAgICAgdGhpcy4kaW5pdFdpZHRoID0gdGhpcy4kc291cmNlV2lkdGg7XG4gICAgICAgIHRoaXMuJGluaXRIZWlnaHQgPSB0aGlzLiRzb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuc2V0U2l6ZSh0aGlzLiRzb3VyY2VXaWR0aCwgdGhpcy4kc291cmNlSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5wYWNrYWdlSXRlbS5sb2FkKCk7XG4gICAgICAgIHRoaXMuJG1vdmllQ2xpcC5pbnRlcnZhbCA9IHRoaXMucGFja2FnZUl0ZW0uaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuJG1vdmllQ2xpcC5zd2luZyA9IHRoaXMucGFja2FnZUl0ZW0uc3dpbmc7XG4gICAgICAgIHRoaXMuJG1vdmllQ2xpcC5yZXBlYXREZWxheSA9IHRoaXMucGFja2FnZUl0ZW0ucmVwZWF0RGVsYXk7XG4gICAgICAgIHRoaXMuJG1vdmllQ2xpcC5mcmFtZXMgPSB0aGlzLnBhY2thZ2VJdGVtLmZyYW1lcztcbiAgICAgICAgdGhpcy4kbW92aWVDbGlwLmJvdW5kc1JlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKDAsIDAsIHRoaXMuJHNvdXJjZVdpZHRoLCB0aGlzLiRzb3VyY2VIZWlnaHQpO1xuICAgIH1cbiAgICBzZXR1cEJlZm9yZUFkZCh4bWwpIHtcbiAgICAgICAgc3VwZXIuc2V0dXBCZWZvcmVBZGQoeG1sKTtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuZnJhbWU7XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLiRtb3ZpZUNsaXAuY3VycmVudEZyYW1lID0gcGFyc2VJbnQoc3RyKTtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMucGxheWluZztcbiAgICAgICAgdGhpcy4kbW92aWVDbGlwLnBsYXlpbmcgPSBzdHIgIT0gJ2ZhbHNlJztcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuY29sb3I7XG4gICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBTdHJpbmdVdGlsLkhFWDJSR0Ioc3RyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgRE9NRXZlbnRNYW5hZ2VyIGV4dGVuZHMgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZXRFdmVudCA9IHt9O1xuICAgICAgICB0aGlzLm51bGxMb3dlc3REZWx0YVRpbWVvdXQgPSBOYU47XG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqa2V5cyoqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIHRoaXMuJHByZXNzZWRLZXlzID0ge307XG4gICAgICAgIHRoaXMuJHJlbGVhc2VkS2V5cyA9IHt9O1xuICAgICAgICB0aGlzLiRkb3duS2V5cyA9IFtdO1xuICAgICAgICAvL3Jlc2l6ZVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZSA9PiB0aGlzLm5vdGlmeVJlc2l6ZUV2ZW50cyhlKSwgZmFsc2UpO1xuICAgICAgICAvL21vZGlmZXIga2V5c1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGUgPT4gdGhpcy5vbldpbmRvd0tleURvd24oZSksIGZhbHNlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZSA9PiB0aGlzLm9uV2luZG93S2V5VXAoZSksIGZhbHNlKTtcbiAgICAgICAgLy9tb3VzZSB3aGVlbFxuICAgICAgICBjb25zdCB0b0JpbmQgPSAnb253aGVlbCcgaW4gZG9jdW1lbnQgfHwgZG9jdW1lbnRbJ2RvY3VtZW50TW9kZSddID49IDlcbiAgICAgICAgICAgID8gWyd3aGVlbCddXG4gICAgICAgICAgICA6IFsnbW91c2V3aGVlbCcsICdEb21Nb3VzZVNjcm9sbCcsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJ107XG4gICAgICAgIGZvciAobGV0IGkgPSB0b0JpbmQubGVuZ3RoOyBpOykge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIodG9CaW5kWy0taV0sIGUgPT4gdGhpcy5vbk1vdXNlV2hlZWwoZSksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL3Jlc2l6ZVxuICAgIG5vdGlmeVJlc2l6ZUV2ZW50cyhlKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgncmVzaXplJyk7XG4gICAgfVxuICAgIG9uTW91c2VXaGVlbChldmVudCkge1xuICAgICAgICBsZXQgb3JnRXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQsIGRlbHRhID0gMCwgZGVsdGFYID0gMCwgZGVsdGFZID0gMCwgYWJzRGVsdGEgPSAwO1xuICAgICAgICBpZiAoJ2RldGFpbCcgaW4gb3JnRXZlbnQpIHtcbiAgICAgICAgICAgIGRlbHRhWSA9IG9yZ0V2ZW50LmRldGFpbCAqIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnd2hlZWxEZWx0YScgaW4gb3JnRXZlbnQpIHtcbiAgICAgICAgICAgIGRlbHRhWSA9IG9yZ0V2ZW50LndoZWVsRGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCd3aGVlbERlbHRhWScgaW4gb3JnRXZlbnQpIHtcbiAgICAgICAgICAgIGRlbHRhWSA9IG9yZ0V2ZW50LndoZWVsRGVsdGFZO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnd2hlZWxEZWx0YVgnIGluIG9yZ0V2ZW50KSB7XG4gICAgICAgICAgICBkZWx0YVggPSBvcmdFdmVudC53aGVlbERlbHRhWCAqIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vRkYgRE9NTW91c2VTY3JvbGxcbiAgICAgICAgaWYgKCdheGlzJyBpbiBvcmdFdmVudCAmJiBvcmdFdmVudC5heGlzID09PSBvcmdFdmVudC5IT1JJWk9OVEFMX0FYSVMpIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IGRlbHRhWSAqIC0xO1xuICAgICAgICAgICAgZGVsdGFZID0gMDtcbiAgICAgICAgfVxuICAgICAgICBkZWx0YSA9IGRlbHRhWSA9PT0gMCA/IGRlbHRhWCA6IGRlbHRhWTtcbiAgICAgICAgaWYgKCdkZWx0YVknIGluIG9yZ0V2ZW50KSB7XG4gICAgICAgICAgICBkZWx0YVkgPSBvcmdFdmVudC5kZWx0YVkgKiAtMTtcbiAgICAgICAgICAgIGRlbHRhID0gZGVsdGFZO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZGVsdGFYJyBpbiBvcmdFdmVudCkge1xuICAgICAgICAgICAgZGVsdGFYID0gb3JnRXZlbnQuZGVsdGFYO1xuICAgICAgICAgICAgaWYgKGRlbHRhWSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbHRhID0gZGVsdGFYICogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbHRhWSA9PT0gMCAmJiBkZWx0YVggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWx0YSBtb2RlczpcbiAgICAgICAgLy8gICAqIGRlbHRhTW9kZSAwIGlzIGJ5IHBpeGVscywgbm90aGluZyB0byBkb1xuICAgICAgICAvLyAgICogZGVsdGFNb2RlIDEgaXMgYnkgbGluZXNcbiAgICAgICAgLy8gICAqIGRlbHRhTW9kZSAyIGlzIGJ5IHBhZ2VzXG4gICAgICAgIGlmIChvcmdFdmVudC5kZWx0YU1vZGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSAxNjsgLy9mb250U2l6ZSAtIGxpbmUtaGVpZ2h0O1xuICAgICAgICAgICAgZGVsdGEgKj0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIGRlbHRhWSAqPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgZGVsdGFYICo9IGxpbmVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3JnRXZlbnQuZGVsdGFNb2RlID09PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBwYWdlSGVpZ2h0ID0gMTY7IC8vZG9tLmNsaWVudEhlaWdodCA9IHBhZ2UtaGVpZ2h0XG4gICAgICAgICAgICBkZWx0YSAqPSBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgZGVsdGFZICo9IHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBkZWx0YVggKj0gcGFnZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBhYnNEZWx0YSA9IE1hdGgubWF4KE1hdGguYWJzKGRlbHRhWSksIE1hdGguYWJzKGRlbHRhWCkpO1xuICAgICAgICBpZiAoIXRoaXMubG93ZXN0RGVsdGEgfHwgYWJzRGVsdGEgPCB0aGlzLmxvd2VzdERlbHRhKSB7XG4gICAgICAgICAgICB0aGlzLmxvd2VzdERlbHRhID0gYWJzRGVsdGE7XG4gICAgICAgICAgICBpZiAob3JnRXZlbnQudHlwZSA9PT0gJ21vdXNld2hlZWwnICYmIGFic0RlbHRhICUgMTIwID09PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMubG93ZXN0RGVsdGEgLz0gNDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZ0V2ZW50LnR5cGUgPT09ICdtb3VzZXdoZWVsJyAmJiBhYnNEZWx0YSAlIDEyMCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsdGEgLz0gNDA7XG4gICAgICAgICAgICBkZWx0YVggLz0gNDA7XG4gICAgICAgICAgICBkZWx0YVkgLz0gNDA7XG4gICAgICAgIH1cbiAgICAgICAgZGVsdGEgPSBNYXRoW2RlbHRhID49IDEgPyAnZmxvb3InIDogJ2NlaWwnXShkZWx0YSAvIHRoaXMubG93ZXN0RGVsdGEpO1xuICAgICAgICBkZWx0YVggPSBNYXRoW2RlbHRhWCA+PSAxID8gJ2Zsb29yJyA6ICdjZWlsJ10oZGVsdGFYIC8gdGhpcy5sb3dlc3REZWx0YSk7XG4gICAgICAgIGRlbHRhWSA9IE1hdGhbZGVsdGFZID49IDEgPyAnZmxvb3InIDogJ2NlaWwnXShkZWx0YVkgLyB0aGlzLmxvd2VzdERlbHRhKTtcbiAgICAgICAgdGhpcy5yZXRFdmVudC5kZWx0YSA9IGRlbHRhO1xuICAgICAgICB0aGlzLnJldEV2ZW50LmRlbHRhWCA9IGRlbHRhWDtcbiAgICAgICAgdGhpcy5yZXRFdmVudC5kZWx0YVkgPSBkZWx0YVk7XG4gICAgICAgIHRoaXMucmV0RXZlbnQuZGVsdGFGYWN0b3IgPSB0aGlzLmxvd2VzdERlbHRhO1xuICAgICAgICB0aGlzLnJldEV2ZW50LmRlbHRhTW9kZSA9IDA7XG4gICAgICAgIGlmICh0aGlzLm51bGxMb3dlc3REZWx0YVRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm51bGxMb3dlc3REZWx0YVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubnVsbExvd2VzdERlbHRhVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMubnVsbExvd2VzdERlbHRhKCksIDIwMCk7XG4gICAgICAgIGxldCBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJfX21vdXNlV2hlZWxcIiAvKiBNT1VTRV9XSEVFTCAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBldnQuZGF0YSA9IHsgZXZlbnQ6IHRoaXMucmV0RXZlbnQgfTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2dCwgdGhpcyk7XG4gICAgfVxuICAgIG51bGxMb3dlc3REZWx0YSgpIHtcbiAgICAgICAgdGhpcy5sb3dlc3REZWx0YSA9IG51bGw7XG4gICAgfVxuICAgIGlzS2V5RG93bihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGRvd25LZXlzLmluZGV4T2Yoa2V5KSA+PSAwO1xuICAgIH1cbiAgICBpc0tleVByZXNzZWQoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuJHByZXNzZWRLZXlzW2tleV07XG4gICAgfVxuICAgIGlzS2V5UmVsZWFzZWQoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuJHJlbGVhc2VkS2V5c1trZXldO1xuICAgIH1cbiAgICBvbldpbmRvd0tleURvd24oZXZ0KSB7XG4gICAgICAgIGxldCBrZXkgPSBldnQud2hpY2ggfHwgZXZ0LmtleUNvZGU7XG4gICAgICAgIGlmICghdGhpcy5pc0tleURvd24oa2V5KSkge1xuICAgICAgICAgICAgdGhpcy4kZG93bktleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdGhpcy4kcHJlc3NlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2tleVByZXNzZWQnLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uV2luZG93S2V5VXAoZXZ0KSB7XG4gICAgICAgIGxldCBrZXkgPSBldnQud2hpY2ggfHwgZXZ0LmtleUNvZGU7XG4gICAgICAgIGlmICh0aGlzLmlzS2V5RG93bihrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLiRwcmVzc2VkS2V5c1trZXldID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRyZWxlYXNlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLiRkb3duS2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICB0aGlzLiRkb3duS2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdrZXlSZWxlYXNlZCcsIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5ET01FdmVudE1hbmFnZXIuaW5zdCA9IG5ldyBET01FdmVudE1hbmFnZXIoKTtcblxuY2xhc3MgSFRNTElucHV0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqQGludGVybmFsICovXG4gICAgICAgIHRoaXMuJHJlcXVlc3RUb1Nob3cgPSBmYWxzZTtcbiAgICAgICAgLyoqQGludGVybmFsICovXG4gICAgICAgIHRoaXMuJHNjYWxlWCA9IDE7XG4gICAgICAgIC8qKkBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLiRzY2FsZVkgPSAxO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGluc3QoKSB7XG4gICAgICAgIGlmICghSFRNTElucHV0LiRpbnN0YW5jZSlcbiAgICAgICAgICAgIEhUTUxJbnB1dC4kaW5zdGFuY2UgPSBuZXcgSFRNTElucHV0KCk7XG4gICAgICAgIHJldHVybiBIVE1MSW5wdXQuJGluc3RhbmNlO1xuICAgIH1cbiAgICBpbml0aWFsaXplKGNvbnRhaW5lciwgdmlldykge1xuICAgICAgICB0aGlzLiRjYW52YXMgPSB2aWV3O1xuICAgICAgICBsZXQgZGl2O1xuICAgICAgICBpZiAoIXRoaXMuJGRlbGVnYXRlRGl2KSB7XG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuJGRlbGVnYXRlRGl2ID0gZGl2O1xuICAgICAgICAgICAgZGl2LmlkID0gJ19fZGVsZWdhdGVEaXYnO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgICB0aGlzLmluaXREb21Qb3MoZGl2KTtcbiAgICAgICAgICAgIHRoaXMuJHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvbVBvcyh0aGlzLiR3cmFwcGVyKTtcbiAgICAgICAgICAgIHRoaXMuJHdyYXBwZXIuc3R5bGUud2lkdGggPSAnMHB4JztcbiAgICAgICAgICAgIHRoaXMuJHdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG4gICAgICAgICAgICB0aGlzLiR3cmFwcGVyLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgICAgIHRoaXMuJHdyYXBwZXIuc3R5bGUudG9wID0gJy0xMDBweCc7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSh0aGlzLiR3cmFwcGVyLCAnMCUgMCUgMHB4Jyk7XG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy4kd3JhcHBlcik7XG4gICAgICAgICAgICBEZWNscyQxLkdSb290Lmluc3Qub24oSW50ZXJhY3RpdmVFdmVudHMuQ2xpY2ssIHRoaXMuY2FudmFzQ2xpY2tIYW5kbGVyLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdElucHV0RWxlbWVudCh0cnVlKTsgLy9pbnB1dFxuICAgICAgICAgICAgdGhpcy5pbml0SW5wdXRFbGVtZW50KGZhbHNlKTsgLy90ZXh0YXJlYVxuICAgICAgICB9XG4gICAgfVxuICAgIGlzSW5wdXRPbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0ICE9IG51bGw7XG4gICAgfVxuICAgIGNhbnZhc0NsaWNrSGFuZGxlcihlKSB7XG4gICAgICAgIGlmICh0aGlzLiRyZXF1ZXN0VG9TaG93KSB7XG4gICAgICAgICAgICB0aGlzLiRyZXF1ZXN0VG9TaG93ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vbkNsaWNrSGFuZGxlcihlKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGN1ckVsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJJbnB1dEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjdXJFbGUuYmx1cigpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGN1ckVsZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNJbnB1dFNob3duKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQgIT0gbnVsbDtcbiAgICB9XG4gICAgaXNDdXJyZW50SW5wdXQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0ID09IGlucHV0O1xuICAgIH1cbiAgICBpbml0RG9tUG9zKGRvbSkge1xuICAgICAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBkb20uc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICBkb20uc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIGRvbS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgICAgIGRvbS5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgIH1cbiAgICBzZXRUcmFuc2Zvcm0oZWwsIG9yaWdpbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgIGxldCBzdHlsZSA9IGVsLnN0eWxlO1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5tc1RyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLm1velRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLm9UcmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS5tc1RyYW5zZm9ybSA9IHN0eWxlLm1velRyYW5zZm9ybSA9IHN0eWxlLm9UcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxuICAgIC8qKkBpbnRlcm5hbCAqL1xuICAgIHVwZGF0ZVNpemUoc3gsIHN5KSB7XG4gICAgICAgIGlmICghdGhpcy4kY2FudmFzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRzY2FsZVggPSBzeDtcbiAgICAgICAgdGhpcy4kc2NhbGVZID0gc3k7XG4gICAgICAgIHRoaXMuJGRlbGVnYXRlRGl2LnN0eWxlLmxlZnQgPSB0aGlzLiRjYW52YXMuc3R5bGUubGVmdDtcbiAgICAgICAgdGhpcy4kZGVsZWdhdGVEaXYuc3R5bGUudG9wID0gdGhpcy4kY2FudmFzLnN0eWxlLnRvcDtcbiAgICAgICAgbGV0IGN2c1N0eWxlID0gdGhpcy4kY2FudmFzLnN0eWxlO1xuICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSh0aGlzLiRkZWxlZ2F0ZURpdiwgJzAlIDAlIDBweCcsIGN2c1N0eWxlLnRyYW5zZm9ybSB8fFxuICAgICAgICAgICAgY3ZzU3R5bGUud2Via2l0VHJhbnNmb3JtIHx8XG4gICAgICAgICAgICBjdnNTdHlsZS5tc1RyYW5zZm9ybSB8fFxuICAgICAgICAgICAgY3ZzU3R5bGUubW96VHJhbnNmb3JtIHx8XG4gICAgICAgICAgICBjdnNTdHlsZS5vVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaW5pdElucHV0RWxlbWVudChtdWx0aWxpbmUpIHtcbiAgICAgICAgbGV0IGlucHV0RWxlbWVudDtcbiAgICAgICAgaWYgKG11bHRpbGluZSkge1xuICAgICAgICAgICAgaW5wdXRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgICAgIGlucHV0RWxlbWVudC5zdHlsZS5yZXNpemUgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLiRtdWx0aUxpbmUgPSBpbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBpbnB1dEVsZW1lbnQuaWQgPSAnc3RhZ2VUZXh0QXJlYUVsZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnB1dEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgdGhpcy4kc2luZ2xlTGluZSA9IGlucHV0RWxlbWVudDtcbiAgICAgICAgICAgIGlucHV0RWxlbWVudC50eXBlID0gJ3RleHQnO1xuICAgICAgICAgICAgaW5wdXRFbGVtZW50LmlkID0gJ3N0YWdlSW5wdXRFbGUnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHdyYXBwZXIuYXBwZW5kQ2hpbGQoaW5wdXRFbGVtZW50KTtcbiAgICAgICAgaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgaW5wdXRFbGVtZW50LnN0eWxlLndpZHRoID0gJzFweCc7XG4gICAgICAgIGlucHV0RWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMTJweCc7XG4gICAgICAgIHRoaXMuaW5pdERvbVBvcyhpbnB1dEVsZW1lbnQpO1xuICAgICAgICBsZXQgc3R5bGUgPSBpbnB1dEVsZW1lbnQuc3R5bGU7XG4gICAgICAgIHN0eWxlLm91dGxpbmUgPSAndGhpbic7XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmQgPSAnbm9uZSc7XG4gICAgICAgIHN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHN0eWxlLndvcmRCcmVhayA9ICdicmVhay1hbGwnO1xuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgaW5wdXRFbGVtZW50Lm9uaW5wdXQgPSBlID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRpbnB1dClcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5vbklucHV0SGFuZGxlcigpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgICBHVGltZXIuaW5zdC5jYWxsTGF0ZXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4kY3VyRWxlLnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KGVsZSkge1xuICAgICAgICBpZiAodGhpcy4kaW5wdXQgPT0gbnVsbCB8fCB0aGlzLiRpbnB1dCA9PSBlbGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJJbnB1dEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRjdXJFbGUpXG4gICAgICAgICAgICAgICAgdGhpcy4kY3VyRWxlLmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhckF0dHJpYnV0ZXMob2JqKSB7XG4gICAgICAgIGlmICh0aGlzLiRjdXJFbGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjdXJFbGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJJbnB1dEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRjdXJFbGUpIHtcbiAgICAgICAgICAgIHRoaXMuJGN1ckVsZS52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgdGhpcy4kY3VyRWxlLm9uYmx1ciA9IG51bGw7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLiRjdXJFbGUuc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS53aWR0aCA9ICcxcHgnO1xuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gJzEycHgnO1xuICAgICAgICAgICAgc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgICAgICBzdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAgICAgbGV0IGVsMjtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzaW5nbGVMaW5lID09IHRoaXMuJGN1ckVsZSlcbiAgICAgICAgICAgICAgICBlbDIgPSB0aGlzLiRtdWx0aUxpbmU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZWwyID0gdGhpcy4kc2luZ2xlTGluZTtcbiAgICAgICAgICAgIGVsMi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRoaXMuJHdyYXBwZXIuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgdGhpcy4kd3JhcHBlci5zdHlsZS50b3AgPSAnLTEwMHB4JztcbiAgICAgICAgICAgIHRoaXMuJHdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG4gICAgICAgICAgICB0aGlzLiR3cmFwcGVyLnN0eWxlLndpZHRoID0gJzBweCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0ID0gbnVsbDtcbiAgICAgICAgICAgIEhUTUxJbnB1dC5pc1R5cGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RJbnB1dChlbGUpIHtcbiAgICAgICAgdGhpcy5jbGVhcklucHV0RWxlbWVudCgpO1xuICAgICAgICB0aGlzLiRpbnB1dCA9IGVsZTtcbiAgICAgICAgSFRNTElucHV0LmlzVHlwaW5nID0gdHJ1ZTtcbiAgICAgICAgbGV0IGVsMjtcbiAgICAgICAgaWYgKHRoaXMuJGlucHV0LnRleHRGaWVsZC5tdWx0aXBsZUxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuJGN1ckVsZSA9IHRoaXMuJG11bHRpTGluZTtcbiAgICAgICAgICAgIGVsMiA9IHRoaXMuJHNpbmdsZUxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRjdXJFbGUgPSB0aGlzLiRzaW5nbGVMaW5lO1xuICAgICAgICAgICAgZWwyID0gdGhpcy4kbXVsdGlMaW5lO1xuICAgICAgICB9XG4gICAgICAgIGVsMi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICByZXR1cm4gdGhpcy4kY3VyRWxlO1xuICAgIH1cbn1cbkhUTUxJbnB1dC5pc1R5cGluZyA9IGZhbHNlO1xuXG5jbGFzcyBEZWZhdWx0VUlTdGFnZU9wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNjYWxlTW9kZSA9IFwic2hvd0FsbFwiIC8qIFNIT1dfQUxMICovO1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gXCJhdXRvXCIgLyogQVVUTyAqLztcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gMTtcbiAgICAgICAgdGhpcy5kZXNpZ25XaWR0aCA9IDgwMDtcbiAgICAgICAgdGhpcy5kZXNpZ25IZWlnaHQgPSA2MDA7XG4gICAgICAgIHRoaXMuYWxpZ25WID0gNCAvKiBNSURETEUgKi87XG4gICAgICAgIHRoaXMuYWxpZ25IID0gMSAvKiBDRU5URVIgKi87XG4gICAgICAgIHRoaXMuZmFsbGJhY2tXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuZmFsbGJhY2tIZWlnaHQgPSAwO1xuICAgIH1cbn1cbmNsYXNzIERlZmF1bHRCb3VkaW5nUmVjdENhbGN1bGF0b3Ige1xuICAgIGdldFJlY3QodmlldywgZmFsbGJhY2tXaWR0aCwgZmFsbGJhY2tIZWlnaHQpIHtcbiAgICAgICAgbGV0IHAgPSB2aWV3LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmICghcClcbiAgICAgICAgICAgIC8vdGhpcyBzaG91bGQgYmUgaW1wb3NzaWJsZSBzaXR1YXRpb24gdW5sZXNzIHRoZSB1c2VyIGZvcmdldCB0byBhcHBlbmQgdGhlIHZpZXcgaW50byB0aGUgRE9NLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciB2aWV3IG9mIFBJWEkgYXJlIHN0aWxsIGluIG1lbW9yeSBidXQgbm90IGFwcGVuZGVkIHRvIERPTSB5ZXQ/IGl0J3MgbmVjZXNzYXJ5IHRoYXQgdGhlcmUgaXMgYSBwYXJlbnQgZWxlbWVudCB0byB3cmFwIHlvdXIgdmlldyB1cC5cIik7XG4gICAgICAgIGxldCByZWN0ID0gcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHJldCA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFyZWN0IHx8IHJlY3Qud2lkdGggPD0gMCB8fCByZWN0LmhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0l0IHNlZW1zIHRoYXQgeW91IGRpZCBub3Qgc2V0IGEgZXhwbGljaXQgc2l6ZSBmb3IgdGhlIHBhcmVudCBlbGVtZW50IG9mIHlvdXIgdmlldywgbm93IGZhbGwgYmFjayB0byB3aW5kb3cgc2l6ZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgcmV0LndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICByZXQuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgcmV0LnggPSAwO1xuICAgICAgICAgICAgcmV0LnkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0LnggPSByZWN0LmxlZnQ7XG4gICAgICAgICAgICByZXQueSA9IHJlY3QudG9wO1xuICAgICAgICAgICAgcmV0LndpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgIHJldC5oZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNpZGVyIHRoZSB3b3JzdCBzaXR1YXRpb246IHdpbmRvdyBkb2VzIG5vdCBoYXZlIHNpemUhIVxuICAgICAgICBpZiAocmV0LndpZHRoIDw9IDAgfHwgcmV0LmhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2ZldGNoIGNvbnRhaW5lciBzaXplIHRvIGluaXRpYWxpemUgUElYSSBpbiBhbGwgd2F5cyBoYXZlIGZhaWxlZCwgbm93IHVzZSBkZWZhdWx0IHNpemUgKGZhbGxiYWNrV2lkdGggLyBmYWxsYmFja0hlaWdodCkgc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zIGluc3RlYWQuJyk7XG4gICAgICAgICAgICByZXQud2lkdGggPSBmYWxsYmFja1dpZHRoO1xuICAgICAgICAgICAgcmV0LmhlaWdodCA9IGZhbGxiYWNrSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuY2xhc3MgVUlTdGFnZSBleHRlbmRzIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoYXBwLCBzdGFnZU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4kd2lkdGggPSAwO1xuICAgICAgICB0aGlzLiRoZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLiRzY2FsZVggPSAxO1xuICAgICAgICB0aGlzLiRzY2FsZVkgPSAxO1xuICAgICAgICB0aGlzLiRjYW52YXNNYXRyaXggPSBuZXcgY3JlYXRlanMuTWF0cml4MkQoKTtcbiAgICAgICAgdGhpcy5vZmZzZXRYID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXRZID0gMDtcbiAgICAgICAgdGhpcy4kc2l6ZUNhbGNlciA9IG5ldyBEZWZhdWx0Qm91ZGluZ1JlY3RDYWxjdWxhdG9yKCk7XG4gICAgICAgIFVJU3RhZ2VJbnN0LnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuJGFwcENvbnRleHQgPSBhcHA7XG4gICAgICAgIGxldCBvcHQ7XG4gICAgICAgIGlmIChzdGFnZU9wdGlvbnMgaW5zdGFuY2VvZiBEZWZhdWx0VUlTdGFnZU9wdGlvbnMpXG4gICAgICAgICAgICBvcHQgPSBzdGFnZU9wdGlvbnM7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0ID0gbmV3IERlZmF1bHRVSVN0YWdlT3B0aW9ucygpO1xuICAgICAgICAgICAgaWYgKHN0YWdlT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBzdGFnZU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0W2ldID0gc3RhZ2VPcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdC5kZXNpZ25XaWR0aCB8fCAhb3B0LmRlc2lnbkhlaWdodClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGVzaWduV2lkdGggLyBkZXNpZ25IZWlnaHQgaW4gdGhlIHBhcmFtZXRlciAnc3RhZ2VPcHRpb25zJy5cIik7XG4gICAgICAgIHRoaXMuJG9wdGlvbnMgPSBvcHQ7XG4gICAgICAgIHRoaXMuJGFwcENvbnRleHQuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMuJGFwcENvbnRleHQuY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGxldCBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcbiAgICAgICAgLy9pZiBwYXJlbnQgaXMgbm90IGEgRElWIGJveCwgbWFrZSBvbmVcbiAgICAgICAgaWYgKGNvbnRhaW5lci50YWdOYW1lICE9ICdESVYnKSB7XG4gICAgICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBzdHlsZS50b3AgPSAnMHB4JztcbiAgICAgICAgICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gJzEwMCUnOyAvL2FuZCBzZXQgZGVmYXVsdCBmdWxsLXNjcmVlblxuICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIC8vIHRoaXMuJGFwcENvbnRleHQudmlldy5wYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7IC8vdG9kb1xuICAgICAgICAgICAgLy8gY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuJGFwcENvbnRleHQudmlldyk7IC8vdG9kb1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250YWluZXJQb3NpdGlvbjtcbiAgICAgICAgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpXG4gICAgICAgICAgICBjb250YWluZXJQb3NpdGlvbiA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5wb3NpdGlvbjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGFpbmVyUG9zaXRpb24gPSBzdHlsZS5wb3NpdGlvbjtcbiAgICAgICAgaWYgKGNvbnRhaW5lclBvc2l0aW9uID09ICcnIHx8IGNvbnRhaW5lclBvc2l0aW9uID09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICBjb250YWluZXJQb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBjb250YWluZXJQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBIVE1MSW5wdXQuaW5zdC5pbml0aWFsaXplKGNvbnRhaW5lciwgdGhpcy4kYXBwQ29udGV4dC5jYW52YXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNjcmVlblNpemUoKTtcbiAgICB9XG4gICAgZ2V0IG9yaWVudGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kb3B0aW9ucy5vcmllbnRhdGlvbjtcbiAgICB9XG4gICAgZ2V0IHN0YWdlV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR3aWR0aDtcbiAgICB9XG4gICAgZ2V0IHN0YWdlSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaGVpZ2h0O1xuICAgIH1cbiAgICBnZXQgYXBwbGljYXRpb25Db250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kYXBwQ29udGV4dDtcbiAgICB9XG4gICAgZ2V0IG5hdGl2ZVN0YWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kYXBwQ29udGV4dDtcbiAgICB9XG4gICAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRvcHRpb25zLnJlc29sdXRpb247XG4gICAgfVxuICAgIHNldCByZXNvbHV0aW9uKHYpIHtcbiAgICAgICAgdGhpcy4kb3B0aW9ucy5yZXNvbHV0aW9uID0gdjtcbiAgICAgICAgdGhpcy51cGRhdGVTY3JlZW5TaXplKCk7XG4gICAgfVxuICAgIGdldCBzY2FsZVgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzY2FsZVg7XG4gICAgfVxuICAgIGdldCBzY2FsZVkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzY2FsZVk7XG4gICAgfVxuICAgIGdldCBkZXNpZ25XaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG9wdGlvbnMuZGVzaWduV2lkdGg7XG4gICAgfVxuICAgIGdldCBkZXNpZ25IZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRvcHRpb25zLmRlc2lnbkhlaWdodDtcbiAgICB9XG4gICAgc2V0RGVzaWduU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBvcHRpb24gPSB0aGlzLiRvcHRpb25zO1xuICAgICAgICBvcHRpb24uZGVzaWduV2lkdGggPSB3aWR0aDtcbiAgICAgICAgb3B0aW9uLmRlc2lnbkhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy51cGRhdGVTY3JlZW5TaXplKCk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZVN0YWdlU2l6ZShzY2FsZU1vZGUsIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQsIGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodCkge1xuICAgICAgICBsZXQgZGlzcGxheVdpZHRoID0gc2NyZWVuV2lkdGg7XG4gICAgICAgIGxldCBkaXNwbGF5SGVpZ2h0ID0gc2NyZWVuSGVpZ2h0O1xuICAgICAgICBsZXQgc3RhZ2VXaWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgICAgICAgbGV0IHN0YWdlSGVpZ2h0ID0gY29udGVudEhlaWdodDtcbiAgICAgICAgbGV0IHNjYWxlWCA9IHNjcmVlbldpZHRoIC8gc3RhZ2VXaWR0aCB8fCAwO1xuICAgICAgICBsZXQgc2NhbGVZID0gc2NyZWVuSGVpZ2h0IC8gc3RhZ2VIZWlnaHQgfHwgMDtcbiAgICAgICAgc3dpdGNoIChzY2FsZU1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJleGFjdEZpdFwiIC8qIEVYQUNUX0ZJVCAqLzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZEhlaWdodFwiIC8qIEZJWEVEX0hFSUdIVCAqLzpcbiAgICAgICAgICAgICAgICBzdGFnZVdpZHRoID0gTWF0aC5yb3VuZChzY3JlZW5XaWR0aCAvIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWRXaWR0aFwiIC8qIEZJWEVEX1dJRFRIICovOlxuICAgICAgICAgICAgICAgIHN0YWdlSGVpZ2h0ID0gTWF0aC5yb3VuZChzY3JlZW5IZWlnaHQgLyBzY2FsZVgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm5vQm9yZGVyXCIgLyogTk9fQk9SREVSICovOlxuICAgICAgICAgICAgICAgIGlmIChzY2FsZVggPiBzY2FsZVkpXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlIZWlnaHQgPSBNYXRoLnJvdW5kKHN0YWdlSGVpZ2h0ICogc2NhbGVYKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlXaWR0aCA9IE1hdGgucm91bmQoc3RhZ2VXaWR0aCAqIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2hvd0FsbFwiIC8qIFNIT1dfQUxMICovOlxuICAgICAgICAgICAgICAgIGlmIChzY2FsZVggPiBzY2FsZVkpXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlXaWR0aCA9IE1hdGgucm91bmQoc3RhZ2VXaWR0aCAqIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5SGVpZ2h0ID0gTWF0aC5yb3VuZChzdGFnZUhlaWdodCAqIHNjYWxlWCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWRBdXRvXCIgLyogRklYRURfQVVUTyAqLzpcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGxheVdpZHRoIC8gZGlzcGxheUhlaWdodCA8IHN0YWdlV2lkdGggLyBzdGFnZUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVkgPSBzY2FsZVg7XG4gICAgICAgICAgICAgICAgICAgIHN0YWdlSGVpZ2h0ID0gTWF0aC5yb3VuZChzY3JlZW5IZWlnaHQgLyBzY2FsZVgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVYID0gc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICBzdGFnZVdpZHRoID0gTWF0aC5yb3VuZChzY3JlZW5XaWR0aCAvIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzdGFnZVdpZHRoID0gc2NyZWVuV2lkdGg7XG4gICAgICAgICAgICAgICAgc3RhZ2VIZWlnaHQgPSBzY3JlZW5IZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YWdlV2lkdGg6IHN0YWdlV2lkdGgsXG4gICAgICAgICAgICBzdGFnZUhlaWdodDogc3RhZ2VIZWlnaHQsXG4gICAgICAgICAgICBkaXNwbGF5V2lkdGg6IGRpc3BsYXlXaWR0aCxcbiAgICAgICAgICAgIGRpc3BsYXlIZWlnaHQ6IGRpc3BsYXlIZWlnaHRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqQGludGVybmFsICovXG4gICAgdXBkYXRlU2NyZWVuU2l6ZSgpIHtcbiAgICAgICAgaWYgKEhUTUxJbnB1dC5pc1R5cGluZylcbiAgICAgICAgICAgIHJldHVybjsgLy90b2RvXG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLiRhcHBDb250ZXh0LmNhbnZhcztcbiAgICAgICAgbGV0IGNhbnZhc1N0eWxlID0gY2FudmFzLnN0eWxlO1xuICAgICAgICAvLyB0b2RvXG4gICAgICAgIGxldCByZWN0ID0gdGhpcy4kc2l6ZUNhbGNlci5nZXRSZWN0KGNhbnZhcywgdGhpcy4kb3B0aW9ucy5mYWxsYmFja1dpZHRoLCB0aGlzLiRvcHRpb25zLmZhbGxiYWNrSGVpZ2h0KTtcbiAgICAgICAgbGV0IHNob3VsZFJvdGF0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgb3JpZW50YXRpb24gPSB0aGlzLiRvcHRpb25zLm9yaWVudGF0aW9uO1xuICAgICAgICBpZiAob3JpZW50YXRpb24gIT0gXCJhdXRvXCIgLyogQVVUTyAqLykge1xuICAgICAgICAgICAgc2hvdWxkUm90YXRlID1cbiAgICAgICAgICAgICAgICAob3JpZW50YXRpb24gIT0gXCJwb3J0cmFpdFwiIC8qIFBPUlRSQUlUICovICYmIHJlY3QuaGVpZ2h0ID4gcmVjdC53aWR0aCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG9yaWVudGF0aW9uID09IFwicG9ydHJhaXRcIiAvKiBQT1JUUkFJVCAqLyAmJiByZWN0LndpZHRoID4gcmVjdC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY3JlZW5XaWR0aCA9IHNob3VsZFJvdGF0ZSA/IHJlY3QuaGVpZ2h0IDogcmVjdC53aWR0aDtcbiAgICAgICAgbGV0IHNjcmVlbkhlaWdodCA9IHNob3VsZFJvdGF0ZSA/IHJlY3Qud2lkdGggOiByZWN0LmhlaWdodDtcbiAgICAgICAgbGV0IHN0YWdlU2l6ZSA9IHRoaXMuY2FsY3VsYXRlU3RhZ2VTaXplKHRoaXMuJG9wdGlvbnMuc2NhbGVNb2RlLCBzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0LCB0aGlzLiRvcHRpb25zLmRlc2lnbldpZHRoLCB0aGlzLiRvcHRpb25zLmRlc2lnbkhlaWdodCk7XG4gICAgICAgIGxldCBzdGFnZVdpZHRoID0gc3RhZ2VTaXplLnN0YWdlV2lkdGg7XG4gICAgICAgIGxldCBzdGFnZUhlaWdodCA9IHN0YWdlU2l6ZS5zdGFnZUhlaWdodDtcbiAgICAgICAgbGV0IGRpc3BsYXlXaWR0aCA9IHN0YWdlU2l6ZS5kaXNwbGF5V2lkdGg7XG4gICAgICAgIGxldCBkaXNwbGF5SGVpZ2h0ID0gc3RhZ2VTaXplLmRpc3BsYXlIZWlnaHQ7XG4gICAgICAgIGlmIChjYW52YXMud2lkdGggIT09IHN0YWdlV2lkdGgpXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBzdGFnZVdpZHRoO1xuICAgICAgICBpZiAoY2FudmFzLmhlaWdodCAhPT0gc3RhZ2VIZWlnaHQpXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gc3RhZ2VIZWlnaHQ7XG4gICAgICAgIGNhbnZhc1N0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGNhbnZhc1N0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IGNhbnZhc1N0eWxlLm1zVHJhbnNmb3JtT3JpZ2luID0gY2FudmFzU3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gY2FudmFzU3R5bGUub1RyYW5zZm9ybU9yaWdpbiA9XG4gICAgICAgICAgICAnMHB4IDBweCAwcHgnO1xuICAgICAgICBjYW52YXNTdHlsZS53aWR0aCA9IGRpc3BsYXlXaWR0aCArICdweCc7XG4gICAgICAgIGNhbnZhc1N0eWxlLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQgKyAncHgnO1xuICAgICAgICBsZXQgbWF0ID0gdGhpcy4kY2FudmFzTWF0cml4LmlkZW50aXR5KCk7XG4gICAgICAgIGxldCBkaXNwV2lkdGggPSBzaG91bGRSb3RhdGUgPyBkaXNwbGF5SGVpZ2h0IDogZGlzcGxheVdpZHRoO1xuICAgICAgICBsZXQgZGlzcEhlaWdodCA9IHNob3VsZFJvdGF0ZSA/IGRpc3BsYXlXaWR0aCA6IGRpc3BsYXlIZWlnaHQ7XG4gICAgICAgIGxldCBvZmZ4LCBvZmZ5O1xuICAgICAgICBpZiAodGhpcy4kb3B0aW9ucy5hbGlnbkggPT0gMCAvKiBMRUZUICovKVxuICAgICAgICAgICAgb2ZmeCA9IDA7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJG9wdGlvbnMuYWxpZ25IID09IDIgLyogUklHSFQgKi8pXG4gICAgICAgICAgICBvZmZ4ID0gcmVjdC53aWR0aCAtIGRpc3BXaWR0aDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2ZmeCA9IChyZWN0LndpZHRoIC0gZGlzcFdpZHRoKSAqIDAuNTtcbiAgICAgICAgaWYgKHRoaXMuJG9wdGlvbnMuYWxpZ25WID09IDMgLyogVE9QICovKVxuICAgICAgICAgICAgb2ZmeSA9IDA7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJG9wdGlvbnMuYWxpZ25WID09IDUgLyogQk9UVE9NICovKVxuICAgICAgICAgICAgb2ZmeSA9IHJlY3QuaGVpZ2h0IC0gZGlzcEhlaWdodDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2ZmeSA9IChyZWN0LmhlaWdodCAtIGRpc3BIZWlnaHQpICogMC41O1xuICAgICAgICBpZiAoc2hvdWxkUm90YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kb3B0aW9ucy5vcmllbnRhdGlvbiA9PSBcImxhbmRzY2FwZVwiIC8qIExBTkRTQ0FQRSAqLykge1xuICAgICAgICAgICAgICAgIG1hdC5yb3RhdGUoTWF0aC5QSSAvIDIpO1xuICAgICAgICAgICAgICAgIG1hdC50cmFuc2xhdGUoc2NyZWVuSGVpZ2h0IC0gb2ZmeCwgb2ZmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXQucm90YXRlKC1NYXRoLlBJIC8gMik7XG4gICAgICAgICAgICAgICAgbWF0LnRyYW5zbGF0ZShvZmZ4LCBzY3JlZW5XaWR0aCAtIG9mZnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hdC50cmFuc2xhdGUob2ZmeCwgb2ZmeSk7XG4gICAgICAgIGlmIChzaG91bGRSb3RhdGUpIHtcbiAgICAgICAgICAgIG1hdC50eCArPSB0aGlzLm9mZnNldFk7XG4gICAgICAgICAgICBtYXQudHkgKz0gdGhpcy5vZmZzZXRYO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF0LnR4ICs9IHRoaXMub2Zmc2V0WDtcbiAgICAgICAgICAgIG1hdC50eSArPSB0aGlzLm9mZnNldFk7XG4gICAgICAgIH1cbiAgICAgICAgKG1hdC5hID0gdGhpcy5mb3JtYXREYXRhKG1hdC5hKSksXG4gICAgICAgICAgICAobWF0LmQgPSB0aGlzLmZvcm1hdERhdGEobWF0LmQpKSxcbiAgICAgICAgICAgIChtYXQudHggPSB0aGlzLmZvcm1hdERhdGEobWF0LnR4KSksXG4gICAgICAgICAgICAobWF0LnR5ID0gdGhpcy5mb3JtYXREYXRhKG1hdC50eSkpO1xuICAgICAgICBjYW52YXNTdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBjYW52YXNTdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSBjYW52YXNTdHlsZS5tc1RyYW5zZm9ybU9yaWdpbiA9IGNhbnZhc1N0eWxlLm1velRyYW5zZm9ybU9yaWdpbiA9IGNhbnZhc1N0eWxlLm9UcmFuc2Zvcm1PcmlnaW4gPVxuICAgICAgICAgICAgJzBweCAwcHggMHB4JztcbiAgICAgICAgY2FudmFzU3R5bGUudHJhbnNmb3JtID0gY2FudmFzU3R5bGUud2Via2l0VHJhbnNmb3JtID0gY2FudmFzU3R5bGUubXNUcmFuc2Zvcm0gPSBjYW52YXNTdHlsZS5tb3pUcmFuc2Zvcm0gPSBjYW52YXNTdHlsZS5vVHJhbnNmb3JtID0gYG1hdHJpeCgke21hdC5hfSwke21hdC5ifSwke21hdC5jfSwke21hdC5kfSwke21hdC50eH0sJHttYXQudHl9KWA7XG4gICAgICAgIHRoaXMuJHdpZHRoID0gc3RhZ2VXaWR0aDtcbiAgICAgICAgdGhpcy4kaGVpZ2h0ID0gc3RhZ2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuJHNjYWxlWCA9IHN0YWdlV2lkdGggLyBkaXNwbGF5V2lkdGg7XG4gICAgICAgIHRoaXMuJHNjYWxlWSA9IHN0YWdlSGVpZ2h0IC8gZGlzcGxheUhlaWdodDtcbiAgICAgICAgdGhpcy4kYXBwQ29udGV4dC5zZXQoeyB3aWR0aDogc3RhZ2VXaWR0aCwgaGVpZ2h0OiBzdGFnZUhlaWdodCB9KTtcbiAgICAgICAgSFRNTElucHV0Lmluc3QudXBkYXRlU2l6ZShkaXNwbGF5V2lkdGggLyBzdGFnZVdpZHRoLCBkaXNwbGF5SGVpZ2h0IC8gc3RhZ2VIZWlnaHQpO1xuICAgICAgICBsZXQgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX19zaXplQ2hhbmdlZFwiIC8qIFNJWkVfQ0hBTkdFRCAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0LCB0aGlzKTtcbiAgICB9XG4gICAgZm9ybWF0RGF0YSh2YWx1ZSkge1xuICAgICAgICBpZiAoTWF0aC5hYnModmFsdWUpIDwgMC4wMDAwMDEpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgaWYgKE1hdGguYWJzKDEgLSB2YWx1ZSkgPCAwLjAwMSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IDAgPyAxIDogLTE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgbGV0IGkgPSBVSVN0YWdlSW5zdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0gPj0gMCkge1xuICAgICAgICAgICAgaWYgKFVJU3RhZ2VJbnN0W2ldID09PSB0aGlzKVxuICAgICAgICAgICAgICAgIFVJU3RhZ2VJbnN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBVSVN0YWdlSW5zdCA9IFtdO1xubGV0IHJlc2l6ZUNoZWNrVGltZXIgPSBOYU47XG5mdW5jdGlvbiByZXNpemVIYW5kbGVyKCkge1xuICAgIFVJU3RhZ2VJbnN0LmZvckVhY2goc3RhZ2UgPT4ge1xuICAgICAgICBzdGFnZS51cGRhdGVTY3JlZW5TaXplKCk7XG4gICAgfSk7XG59XG5ET01FdmVudE1hbmFnZXIuaW5zdC5vbigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dChyZXNpemVDaGVja1RpbWVyKTtcbiAgICByZXNpemVDaGVja1RpbWVyID0gd2luZG93LnNldFRpbWVvdXQocmVzaXplSGFuZGxlciwgMzAwKTtcbn0pO1xuXG5jbGFzcyBBY3Rpb24ge1xuICAgIGV4ZWN1dGUoY29udHJvbGxlciwgcHJldlBhZ2UsIGN1clBhZ2UpIHtcbiAgICAgICAgaWYgKCghdGhpcy5mcm9tUGFnZSB8fCB0aGlzLmZyb21QYWdlLmxlbmd0aCA9PSAwIHx8IHRoaXMuZnJvbVBhZ2UuaW5kZXhPZihwcmV2UGFnZSkgIT0gLTEpXG4gICAgICAgICAgICAmJiAoIXRoaXMudG9QYWdlIHx8IHRoaXMudG9QYWdlLmxlbmd0aCA9PSAwIHx8IHRoaXMudG9QYWdlLmluZGV4T2YoY3VyUGFnZSkgIT0gLTEpKVxuICAgICAgICAgICAgdGhpcy5lbnRlcihjb250cm9sbGVyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5sZWF2ZShjb250cm9sbGVyKTtcbiAgICB9XG4gICAgZW50ZXIoY29udHJvbGxlcikge1xuICAgIH1cbiAgICBsZWF2ZShjb250cm9sbGVyKSB7XG4gICAgfVxuICAgIHNldHVwKHhtbCkge1xuICAgICAgICBsZXQgc3RyO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5mcm9tUGFnZTtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuZnJvbVBhZ2UgPSBzdHIuc3BsaXQoXCIsXCIpO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy50b1BhZ2U7XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLnRvUGFnZSA9IHN0ci5zcGxpdChcIixcIik7XG4gICAgfVxufVxuXG5jbGFzcyBDaGFuZ2VQYWdlQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcbiAgICBlbnRlcihjb250cm9sbGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250cm9sbGVyTmFtZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGdjb207XG4gICAgICAgIGlmICh0aGlzLm9iamVjdElkKVxuICAgICAgICAgICAgZ2NvbSA9IGNvbnRyb2xsZXIucGFyZW50LmdldENoaWxkQnlJZCh0aGlzLm9iamVjdElkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZ2NvbSA9IGNvbnRyb2xsZXIucGFyZW50O1xuICAgICAgICBpZiAoZ2NvbSkge1xuICAgICAgICAgICAgbGV0IGNjID0gZ2NvbS5nZXRDb250cm9sbGVyKHRoaXMuY29udHJvbGxlck5hbWUpO1xuICAgICAgICAgICAgaWYgKGNjICYmIGNjICE9IGNvbnRyb2xsZXIgJiYgIWNjLiR1cGRhdGluZylcbiAgICAgICAgICAgICAgICBjYy5zZWxlY3RlZFBhZ2VJZCA9IHRoaXMudGFyZ2V0UGFnZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXR1cCh4bWwpIHtcbiAgICAgICAgc3VwZXIuc2V0dXAoeG1sKTtcbiAgICAgICAgdGhpcy5vYmplY3RJZCA9IHhtbC5hdHRyaWJ1dGVzLm9iamVjdElkO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXJOYW1lID0geG1sLmF0dHJpYnV0ZXMuY29udHJvbGxlcjtcbiAgICAgICAgdGhpcy50YXJnZXRQYWdlID0geG1sLmF0dHJpYnV0ZXMudGFyZ2V0UGFnZTtcbiAgICB9XG59XG5cbmNsYXNzIFBsYXlUcmFuc2l0aW9uQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZXBlYXQgPSAxO1xuICAgICAgICB0aGlzLmRlbGF5ID0gMDtcbiAgICAgICAgdGhpcy5zdG9wT25FeGl0ID0gZmFsc2U7XG4gICAgfVxuICAgIGVudGVyKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgbGV0IHRyYW5zID0gY29udHJvbGxlci5wYXJlbnQuZ2V0VHJhbnNpdGlvbih0aGlzLnRyYW5zaXRpb25OYW1lKTtcbiAgICAgICAgaWYgKHRyYW5zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kY3VycmVudFRyYW5zaXRpb24gJiYgdGhpcy4kY3VycmVudFRyYW5zaXRpb24ucGxheWluZylcbiAgICAgICAgICAgICAgICB0cmFucy5jaGFuZ2VSZXBlYXQodGhpcy5yZXBlYXQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRyYW5zLnBsYXkoe1xuICAgICAgICAgICAgICAgICAgICB0aW1lczogdGhpcy5yZXBlYXQsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5OiB0aGlzLmRlbGF5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiRjdXJyZW50VHJhbnNpdGlvbiA9IHRyYW5zO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxlYXZlKCkge1xuICAgICAgICBpZiAodGhpcy5zdG9wT25FeGl0ICYmIHRoaXMuJGN1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLiRjdXJyZW50VHJhbnNpdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLiRjdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqQGludGVybmFsICovXG4gICAgc2V0dXAoeG1sKSB7XG4gICAgICAgIHN1cGVyLnNldHVwKHhtbCk7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbk5hbWUgPSB4bWwuYXR0cmlidXRlcy50cmFuc2l0aW9uO1xuICAgICAgICBsZXQgc3RyO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5yZXBlYXQ7XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLnJlcGVhdCA9IHBhcnNlSW50KHN0cik7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmRlbGF5O1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgdGhpcy5kZWxheSA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgICAgICAgdGhpcy5zdG9wT25FeGl0ID0geG1sLmF0dHJpYnV0ZXMuc3RvcE9uRXhpdCA9PSBcInRydWVcIjtcbiAgICB9XG59XG5cbmNsYXNzIENvbnRyb2xsZXIgZXh0ZW5kcyBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLiRzZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy4kcHJldmlvdXNJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuJHBhZ2VJZHMgPSBbXTtcbiAgICAgICAgdGhpcy4kcGFnZU5hbWVzID0gW107XG4gICAgICAgIHRoaXMuJHNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy4kcHJldmlvdXNJbmRleCA9IC0xO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG5hbWU7XG4gICAgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJG5hbWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHBhcmVudDtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzZWxlY3RlZEluZGV4O1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWRJbmRleCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kc2VsZWN0ZWRJbmRleCAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gdGhpcy4kcGFnZUlkcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5kZXggb3V0IG9mIHJhbmdlOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kcHJldmlvdXNJbmRleCA9IHRoaXMuJHNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICB0aGlzLiRzZWxlY3RlZEluZGV4ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLiRwYXJlbnQuYXBwbHlDb250cm9sbGVyKHRoaXMpO1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX19zdGF0ZUNoYW5nZWRcIiAvKiBDSEFOR0VEICovLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL3NhbWUgZWZmZWN0IGFzIHNlbGVjdGVkSW5kZXggYnV0IHdpdGhvdXQgZXZlbnQgZW1pdHRlZFxuICAgIHNldFNlbGVjdGVkSW5kZXgodmFsdWUgPSAwKSB7XG4gICAgICAgIGlmICh0aGlzLiRzZWxlY3RlZEluZGV4ICE9IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiB0aGlzLiRwYWdlSWRzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmRleCBvdXQgb2YgcmFuZ2U6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiRwcmV2aW91c0luZGV4ID0gdGhpcy4kc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIHRoaXMuJHNlbGVjdGVkSW5kZXggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuJHBhcmVudC5hcHBseUNvbnRyb2xsZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwcmV2aXNvdXNJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHByZXZpb3VzSW5kZXg7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZFBhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLiRzZWxlY3RlZEluZGV4ID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwYWdlTmFtZXNbdGhpcy4kc2VsZWN0ZWRJbmRleF07XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZFBhZ2UodmFsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IE1hdGgubWF4KDAsIHRoaXMuJHBhZ2VOYW1lcy5pbmRleE9mKHZhbCkpO1xuICAgIH1cbiAgICBzZXRTZWxlY3RlZFBhZ2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEluZGV4KE1hdGgubWF4KDAsIHRoaXMuJHBhZ2VOYW1lcy5pbmRleE9mKHZhbHVlKSkpO1xuICAgIH1cbiAgICBnZXQgcHJldmlvdXNQYWdlKCkge1xuICAgICAgICBpZiAodGhpcy4kcHJldmlvdXNJbmRleCA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcGFnZU5hbWVzW3RoaXMuJHByZXZpb3VzSW5kZXhdO1xuICAgIH1cbiAgICBnZXQgcGFnZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcGFnZUlkcy5sZW5ndGg7XG4gICAgfVxuICAgIGdldFBhZ2VOYW1lKGluZGV4ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcGFnZU5hbWVzW2luZGV4XTtcbiAgICB9XG4gICAgYWRkUGFnZShuYW1lID0gJycpIHtcbiAgICAgICAgdGhpcy5hZGRQYWdlQXQobmFtZSwgdGhpcy4kcGFnZUlkcy5sZW5ndGgpO1xuICAgIH1cbiAgICBhZGRQYWdlQXQobmFtZSwgaW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBuaWQgPSBgJHtDb250cm9sbGVyLiRuZXh0UGFnZUlkKyt9YDtcbiAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuJHBhZ2VJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLiRwYWdlSWRzLnB1c2gobmlkKTtcbiAgICAgICAgICAgIHRoaXMuJHBhZ2VOYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kcGFnZUlkcy5zcGxpY2UoaW5kZXgsIDAsIG5pZCk7XG4gICAgICAgICAgICB0aGlzLiRwYWdlTmFtZXMuc3BsaWNlKGluZGV4LCAwLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVQYWdlKG5hbWUpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLiRwYWdlTmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgaWYgKGkgIT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuJHBhZ2VJZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdGhpcy4kcGFnZU5hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzZWxlY3RlZEluZGV4ID49IHRoaXMuJHBhZ2VJZHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMuJHNlbGVjdGVkSW5kZXggLSAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuJHBhcmVudC5hcHBseUNvbnRyb2xsZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlUGFnZUF0KGluZGV4ID0gMCkge1xuICAgICAgICB0aGlzLiRwYWdlSWRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMuJHBhZ2VOYW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAodGhpcy4kc2VsZWN0ZWRJbmRleCA+PSB0aGlzLiRwYWdlSWRzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMuJHNlbGVjdGVkSW5kZXggLSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRwYXJlbnQuYXBwbHlDb250cm9sbGVyKHRoaXMpO1xuICAgIH1cbiAgICBjbGVhclBhZ2VzKCkge1xuICAgICAgICB0aGlzLiRwYWdlSWRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuJHBhZ2VOYW1lcy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAodGhpcy4kc2VsZWN0ZWRJbmRleCAhPSAtMSlcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRwYXJlbnQuYXBwbHlDb250cm9sbGVyKHRoaXMpO1xuICAgIH1cbiAgICBoYXNQYWdlKGFOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRwYWdlTmFtZXMuaW5kZXhPZihhTmFtZSkgPj0gMDtcbiAgICB9XG4gICAgZ2V0UGFnZUluZGV4QnlJZChhSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHBhZ2VJZHMuaW5kZXhPZihhSWQpO1xuICAgIH1cbiAgICBnZXRQYWdlSWRCeU5hbWUoYU5hbWUpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLiRwYWdlTmFtZXMuaW5kZXhPZihhTmFtZSk7XG4gICAgICAgIGlmIChpICE9IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHBhZ2VJZHNbaV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRQYWdlTmFtZUJ5SWQoYUlkKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy4kcGFnZUlkcy5pbmRleE9mKGFJZCk7XG4gICAgICAgIGlmIChpICE9IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHBhZ2VOYW1lc1tpXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldFBhZ2VJZChpbmRleCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHBhZ2VJZHNbaW5kZXhdO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRQYWdlSWQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRzZWxlY3RlZEluZGV4ID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwYWdlSWRzW3RoaXMuJHNlbGVjdGVkSW5kZXhdO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWRQYWdlSWQodmFsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMuJHBhZ2VJZHMuaW5kZXhPZih2YWwpO1xuICAgIH1cbiAgICBzZXQgb3Bwb3NpdGVQYWdlSWQodmFsKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy4kcGFnZUlkcy5pbmRleE9mKHZhbCk7XG4gICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJHBhZ2VJZHMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IDE7XG4gICAgfVxuICAgIGdldCBwcmV2aW91c1BhZ2VJZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHByZXZpb3VzSW5kZXggPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHBhZ2VJZHNbdGhpcy4kcHJldmlvdXNJbmRleF07XG4gICAgfVxuICAgIGV4ZWN1dGVBY3Rpb25zKCkge1xuICAgICAgICBpZiAodGhpcy4kYWN0aW9ucyAmJiB0aGlzLiRhY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuJGFjdGlvbnMuZm9yRWFjaChhID0+IHtcbiAgICAgICAgICAgICAgICBhLmV4ZWN1dGUodGhpcywgdGhpcy5wcmV2aW91c1BhZ2VJZCwgdGhpcy5zZWxlY3RlZFBhZ2VJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVBY3Rpb24odHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BsYXlfdHJhbnNpdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQbGF5VHJhbnNpdGlvbkFjdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAnY2hhbmdlX3BhZ2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhbmdlUGFnZUFjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXR1cCh4bWwpIHtcbiAgICAgICAgdGhpcy4kbmFtZSA9IHhtbC5hdHRyaWJ1dGVzLm5hbWU7XG4gICAgICAgIHRoaXMuJGF1dG9SYWRpb0dyb3VwRGVwdGggPSB4bWwuYXR0cmlidXRlcy5hdXRvUmFkaW9Hcm91cERlcHRoID09ICd0cnVlJztcbiAgICAgICAgbGV0IHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnBhZ2VzO1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICBsZXQgYXJyID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBsZXQgY250ID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY250OyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRwYWdlSWRzLnB1c2goYXJyW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRwYWdlTmFtZXMucHVzaChhcnJbaSArIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29sID0geG1sLmNoaWxkcmVuO1xuICAgICAgICBpZiAoY29sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuJGFjdGlvbnMgPSB0aGlzLiRhY3Rpb25zIHx8IFtdO1xuICAgICAgICAgICAgY29sLmZvckVhY2goY3htbCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMuY3JlYXRlQWN0aW9uKGN4bWwuYXR0cmlidXRlcy50eXBlKTtcbiAgICAgICAgICAgICAgICBhY3Rpb24uc2V0dXAoY3htbCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy50cmFuc2l0aW9ucztcbiAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgdGhpcy4kYWN0aW9ucyA9IHRoaXMuJGFjdGlvbnMgfHwgW107XG4gICAgICAgICAgICBsZXQgaywgZTtcbiAgICAgICAgICAgIHN0ci5zcGxpdCgnLCcpLmZvckVhY2goc3RyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyICYmIHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHB0ID0gbmV3IFBsYXlUcmFuc2l0aW9uQWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBzdHIuaW5kZXhPZignPScpO1xuICAgICAgICAgICAgICAgICAgICBwdC50cmFuc2l0aW9uTmFtZSA9IHN0ci5zdWJzdHIoayArIDEpO1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGspO1xuICAgICAgICAgICAgICAgICAgICBrID0gc3RyLmluZGV4T2YoJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoayArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPCB0aGlzLiRwYWdlSWRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0LnRvUGFnZSA9IFt0aGlzLiRwYWdlSWRzW2VdXTtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ciAhPSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBwYXJzZUludChzdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgPCB0aGlzLiRwYWdlSWRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdC5mcm9tUGFnZSA9IFt0aGlzLiRwYWdlSWRzW2VdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwdC5zdG9wT25FeGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kYWN0aW9ucy5wdXNoKHB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kcGFyZW50ICYmIHRoaXMuJHBhZ2VJZHMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHRoaXMuJHNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRzZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgfVxufVxuQ29udHJvbGxlci4kbmV4dFBhZ2VJZCA9IDA7XG5cbmNsYXNzIE51bWJlclV0aWwge1xuICAgIHN0YXRpYyBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgbWluKVxuICAgICAgICAgICAgdmFsdWUgPSBtaW47XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID4gbWF4KVxuICAgICAgICAgICAgdmFsdWUgPSBtYXg7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIGNsYW1wMDEodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gMSlcbiAgICAgICAgICAgIHZhbHVlID0gMTtcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAwKVxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHN0YXRpYyBpc051bWJlcihuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiAhPSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGlzTmFOKG4pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3RhdGljIHNpZ24oeCkge1xuICAgICAgICB4ID0gTnVtYmVyKHgpO1xuICAgICAgICBpZiAoeCA9PT0gMCB8fCBpc05hTih4KSlcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICByZXR1cm4geCA+IDAgPyAxIDogLTE7XG4gICAgfVxuICAgIHN0YXRpYyBhbmdsZVRvUmFkaWFuKG4pIHtcbiAgICAgICAgcmV0dXJuIG4gKiBOdW1iZXJVdGlsLlJBRElBTjtcbiAgICB9XG4gICAgc3RhdGljIGxlcnAocywgZSwgcCkge1xuICAgICAgICByZXR1cm4gcyArIHAgKiAoZSAtIHMpO1xuICAgIH1cbn1cbk51bWJlclV0aWwuUkFESUFOID0gTWF0aC5QSSAvIDE4MDtcblxuY29uc3QgaXNNb2JpbGUgPSBpc01vYmlsZUNhbGwod2luZG93Lm5hdmlnYXRvcik7XG5cbmNsYXNzIFNjcm9sbFBhbmUgZXh0ZW5kcyBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBzY3JvbGxUeXBlLCBzY3JvbGxCYXJNYXJnaW4sIHNjcm9sbEJhckRpc3BsYXksIGZsYWdzLCB2dFNjcm9sbEJhclJlcywgaHpTY3JvbGxCYXJSZXMsIGhlYWRlclJlcywgZm9vdGVyUmVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuJGlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kb3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy4kbWFza0NvbnRhaW5lciA9IG5ldyBVSUNvbnRhaW5lcihudWxsKTtcbiAgICAgICAgdGhpcy4kb3duZXIuJHJvb3RDb250YWluZXIuYWRkQ2hpbGQodGhpcy4kbWFza0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lciA9IHRoaXMuJG93bmVyLiRjb250YWluZXI7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci54ID0gMDtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnkgPSAwO1xuICAgICAgICB0aGlzLiRtYXNrQ29udGFpbmVyLmFkZENoaWxkKHRoaXMuJGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuJHNjcm9sbEJhck1hcmdpbiA9IHNjcm9sbEJhck1hcmdpbjtcbiAgICAgICAgdGhpcy4kc2Nyb2xsVHlwZSA9IHNjcm9sbFR5cGU7XG4gICAgICAgIHRoaXMuJHNjcm9sbFNwZWVkID0gVUlDb25maWcuZGVmYXVsdFNjcm9sbFNwZWVkO1xuICAgICAgICB0aGlzLiRtb3VzZVdoZWVsU3BlZWQgPSB0aGlzLiRzY3JvbGxTcGVlZCAqIDI7XG4gICAgICAgIHRoaXMuJGRlY2VsZXJhdGlvblJhdGUgPSBVSUNvbmZpZy5kZWZhdWx0U2Nyb2xsRGVjZWxlcmF0aW9uUmF0ZTtcbiAgICAgICAgdGhpcy4kZGlzcGxheU9uTGVmdCA9IChmbGFncyAmIDEgLyogRGlzcGxheU9uTGVmdCAqLykgIT0gMDtcbiAgICAgICAgdGhpcy4kc25hcFRvSXRlbSA9IChmbGFncyAmIDIgLyogU25hcFRvSXRlbSAqLykgIT0gMDtcbiAgICAgICAgdGhpcy4kZGlzcGxheU9uRGVtYW5kID0gKGZsYWdzICYgNCAvKiBEaXNwbGF5T25EZW1hbmQgKi8pICE9IDA7XG4gICAgICAgIHRoaXMuJHBhZ2VNb2RlID0gKGZsYWdzICYgOCAvKiBQYWdlTW9kZSAqLykgIT0gMDtcbiAgICAgICAgaWYgKGZsYWdzICYgMTYgLyogVG91Y2hFZmZlY3QgKi8pXG4gICAgICAgICAgICB0aGlzLiR0b3VjaEVmZmVjdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGZsYWdzICYgMzIgLyogRGlzYWJsZVRvdWNoRWZmZWN0ICovKVxuICAgICAgICAgICAgdGhpcy4kdG91Y2hFZmZlY3QgPSBmYWxzZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kdG91Y2hFZmZlY3QgPSBVSUNvbmZpZy5kZWZhdWx0U2Nyb2xsVG91Y2hFZmZlY3Q7XG4gICAgICAgIGlmIChmbGFncyAmIDY0IC8qIEJvdW5jZUVmZmVjdCAqLylcbiAgICAgICAgICAgIHRoaXMuJGJvdW5jZWJhY2tFZmZlY3QgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChmbGFncyAmIDEyOCAvKiBEaXNhYmxlQm91bmNlRWZmZWN0ICovKVxuICAgICAgICAgICAgdGhpcy4kYm91bmNlYmFja0VmZmVjdCA9IGZhbHNlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRib3VuY2ViYWNrRWZmZWN0ID0gVUlDb25maWcuZGVmYXVsdFNjcm9sbEJvdW5jZUVmZmVjdDtcbiAgICAgICAgdGhpcy4kaW5lcnRpYURpc2FibGVkID0gKGZsYWdzICYgMjU2IC8qIERpc2FibGVJbmVydGlhICovKSAhPSAwO1xuICAgICAgICBpZiAoKGZsYWdzICYgNTEyIC8qIERpc2FibGVTY2lzc29yUmVjdCAqLykgPT0gMClcbiAgICAgICAgICAgIHRoaXMuJG1hc2tDb250YWluZXIuc2Nyb2xsUmVjdCA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKTtcbiAgICAgICAgdGhpcy4kc2Nyb2xsQmFyVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuJG1vdXNlV2hlZWxFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4keFBvcyA9IDA7XG4gICAgICAgIHRoaXMuJHlQb3MgPSAwO1xuICAgICAgICB0aGlzLiRhbmlGbGFnID0gMDtcbiAgICAgICAgdGhpcy4kZm9vdGVyTG9ja2VkU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuJGhlYWRlckxvY2tlZFNpemUgPSAwO1xuICAgICAgICBpZiAoc2Nyb2xsQmFyRGlzcGxheSA9PSAwIC8qIERlZmF1bHQgKi8pXG4gICAgICAgICAgICBzY3JvbGxCYXJEaXNwbGF5ID0gVUlDb25maWcuZGVmYXVsdFNjcm9sbEJhckRpc3BsYXk7XG4gICAgICAgIHRoaXMuJHZpZXdTaXplID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG4gICAgICAgIHRoaXMuJGNvbnRlbnRTaXplID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG4gICAgICAgIHRoaXMuJHBhZ2VTaXplID0gbmV3IGNyZWF0ZWpzLlBvaW50KDEsIDEpO1xuICAgICAgICB0aGlzLiRvdmVybGFwU2l6ZSA9IG5ldyBjcmVhdGVqcy5Qb2ludCgpO1xuICAgICAgICB0aGlzLiR0d2VlbmluZyA9IDA7XG4gICAgICAgIHRoaXMuJHR3ZWVuVGltZSA9IG5ldyBjcmVhdGVqcy5Qb2ludCgpO1xuICAgICAgICB0aGlzLiR0d2VlblN0YXJ0ID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG4gICAgICAgIHRoaXMuJHR3ZWVuRHVyYXRpb24gPSBuZXcgY3JlYXRlanMuUG9pbnQoKTtcbiAgICAgICAgdGhpcy4kdHdlZW5DaGFuZ2UgPSBuZXcgY3JlYXRlanMuUG9pbnQoKTtcbiAgICAgICAgdGhpcy4kdmVsb2NpdHkgPSBuZXcgY3JlYXRlanMuUG9pbnQoKTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyUG9zID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG4gICAgICAgIHRoaXMuJGJlZ2luVG91Y2hQb3MgPSBuZXcgY3JlYXRlanMuUG9pbnQoKTtcbiAgICAgICAgdGhpcy4kbGFzdFRvdWNoUG9zID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG4gICAgICAgIHRoaXMuJGxhc3RUb3VjaEdsb2JhbFBvcyA9IG5ldyBjcmVhdGVqcy5Qb2ludCgpO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBpZiAoc2Nyb2xsQmFyRGlzcGxheSAhPSAzIC8qIEhpZGRlbiAqLykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFR5cGUgPT0gMiAvKiBCb3RoICovIHx8IHRoaXMuJHNjcm9sbFR5cGUgPT0gMSAvKiBWZXJ0aWNhbCAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHZ0U2Nyb2xsQmFyUmVzID8gdnRTY3JvbGxCYXJSZXMgOiBVSUNvbmZpZy52ZXJ0aWNhbFNjcm9sbEJhcjtcbiAgICAgICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHZ0U2Nyb2xsQmFyID0gVUlQYWNrYWdlLmNyZWF0ZU9iamVjdEZyb21VUkwocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLiR2dFNjcm9sbEJhcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNyZWF0ZSBzY3JvbGxiYXIgZnJvbSAke3Jlc31gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdnRTY3JvbGxCYXIuc2V0U2Nyb2xsUGFuZSh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kb3duZXIuJHJvb3RDb250YWluZXIuYWRkQ2hpbGQodGhpcy4kdnRTY3JvbGxCYXIuZGlzcGxheU9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFR5cGUgPT0gMiAvKiBCb3RoICovIHx8IHRoaXMuJHNjcm9sbFR5cGUgPT0gMCAvKiBIb3Jpem9udGFsICovKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gaHpTY3JvbGxCYXJSZXMgPyBoelNjcm9sbEJhclJlcyA6IFVJQ29uZmlnLmhvcml6b250YWxTY3JvbGxCYXI7XG4gICAgICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRoelNjcm9sbEJhciA9IFVJUGFja2FnZS5jcmVhdGVPYmplY3RGcm9tVVJMKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy4kaHpTY3JvbGxCYXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcmVhdGUgc2Nyb2xsYmFyIGZyb20gJHtyZXN9YCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGh6U2Nyb2xsQmFyLnNldFNjcm9sbFBhbmUodGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRvd25lci4kcm9vdENvbnRhaW5lci5hZGRDaGlsZCh0aGlzLiRoelNjcm9sbEJhci5kaXNwbGF5T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRzY3JvbGxCYXJEaXNwbGF5QXV0byA9IHNjcm9sbEJhckRpc3BsYXkgPT0gMiAvKiBBdXRvICovO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjcm9sbEJhckRpc3BsYXlBdXRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kc2Nyb2xsQmFyVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiR2dFNjcm9sbEJhcilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdnRTY3JvbGxCYXIuZGlzcGxheU9iamVjdC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGh6U2Nyb2xsQmFyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRoelNjcm9sbEJhci5kaXNwbGF5T2JqZWN0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRtb3VzZVdoZWVsRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaGVhZGVyUmVzKSB7XG4gICAgICAgICAgICB0aGlzLiRoZWFkZXIgPSBVSVBhY2thZ2UuY3JlYXRlT2JqZWN0RnJvbVVSTChoZWFkZXJSZXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGhlYWRlciA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNyZWF0ZSBzY3JvbGxQYW5lLmhlYWRlciBmcm9tICR7cmVzfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb290ZXJSZXMpIHtcbiAgICAgICAgICAgIHRoaXMuJGZvb3RlciA9IFVJUGFja2FnZS5jcmVhdGVPYmplY3RGcm9tVVJMKGZvb3RlclJlcyk7XG4gICAgICAgICAgICBpZiAodGhpcy4kZm9vdGVyID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIHNjcm9sbFBhbmUuZm9vdGVyIGZyb20gJHtyZXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGhlYWRlciAhPSBudWxsIHx8IHRoaXMuJGZvb3RlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy4kcmVmcmVzaEJhckF4aXMgPVxuICAgICAgICAgICAgICAgIHRoaXMuJHNjcm9sbFR5cGUgPT0gMiAvKiBCb3RoICovIHx8IHRoaXMuJHNjcm9sbFR5cGUgPT0gMSAvKiBWZXJ0aWNhbCAqLyA/ICd5JyA6ICd4JztcbiAgICAgICAgdGhpcy5zZXRTaXplKG93bmVyLndpZHRoLCBvd25lci5oZWlnaHQpO1xuICAgICAgICB0aGlzLiRvd25lci5vbihJbnRlcmFjdGl2ZUV2ZW50cy5PdmVyLCB0aGlzLiRyb2xsT3ZlciwgdGhpcyk7XG4gICAgICAgIHRoaXMuJG93bmVyLm9uKEludGVyYWN0aXZlRXZlbnRzLk91dCwgdGhpcy4kcm9sbE91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuJG93bmVyLm9uKEludGVyYWN0aXZlRXZlbnRzLkRvd24sIHRoaXMuJG1vdXNlRG93biwgdGhpcyk7XG4gICAgICAgIHRoaXMuJG93bmVyLm9uKFwiX19tb3VzZVdoZWVsXCIgLyogTU9VU0VfV0hFRUwgKi8sIHRoaXMuJG1vdXNlV2hlZWwsIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgb3duZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRvd25lcjtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHR3ZWVuaW5nICE9IDApXG4gICAgICAgICAgICBHVGltZXIuaW5zdC5yZW1vdmUodGhpcy50d2VlblVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuJHBhZ2VDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuJGh6U2Nyb2xsQmFyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLiRoelNjcm9sbEJhci5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLiR2dFNjcm9sbEJhciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy4kdnRTY3JvbGxCYXIuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy4kaGVhZGVyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLiRoZWFkZXIuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy4kZm9vdGVyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLiRmb290ZXIuZGlzcG9zZSgpO1xuICAgICAgICBEZWNscyQxLkdSb290Lmluc3QubmF0aXZlU3RhZ2Uub2ZmKEludGVyYWN0aXZlRXZlbnRzLk1vdmUsIHRoaXMuJG1vdXNlTW92ZUV2ZW50KTtcbiAgICAgICAgRGVjbHMkMS5HUm9vdC5pbnN0Lm5hdGl2ZVN0YWdlLm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5VcCwgdGhpcy4kbW91c2VVcEV2ZW50KTtcbiAgICAgICAgRGVjbHMkMS5HUm9vdC5pbnN0Lm5hdGl2ZVN0YWdlLm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5DbGljaywgdGhpcy4kY2xpY2tFdmVudCk7XG4gICAgICAgIHRoaXMuJG93bmVyLm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5PdmVyLCB0aGlzLiRyb2xsT3Zlcik7XG4gICAgICAgIHRoaXMuJG93bmVyLm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5PdXQsIHRoaXMuJHJvbGxPdXQpO1xuICAgICAgICB0aGlzLiRvd25lci5vZmYoSW50ZXJhY3RpdmVFdmVudHMuRG93biwgdGhpcy4kbW91c2VEb3duKTtcbiAgICAgICAgdGhpcy4kb3duZXIub2ZmKFwiX19tb3VzZVdoZWVsXCIgLyogTU9VU0VfV0hFRUwgKi8sIHRoaXMuJG1vdXNlV2hlZWwpO1xuICAgIH1cbiAgICBnZXQgaG9yelNjcm9sbEJhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGh6U2Nyb2xsQmFyO1xuICAgIH1cbiAgICBnZXQgdmVydFNjcm9sbEJhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHZ0U2Nyb2xsQmFyO1xuICAgIH1cbiAgICBnZXQgaGVhZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaGVhZGVyO1xuICAgIH1cbiAgICBnZXQgZm9vdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZm9vdGVyO1xuICAgIH1cbiAgICBnZXQgYm91bmNlYmFja0VmZmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGJvdW5jZWJhY2tFZmZlY3Q7XG4gICAgfVxuICAgIHNldCBib3VuY2ViYWNrRWZmZWN0KHNjKSB7XG4gICAgICAgIHRoaXMuJGJvdW5jZWJhY2tFZmZlY3QgPSBzYztcbiAgICB9XG4gICAgZ2V0IHRvdWNoRWZmZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdG91Y2hFZmZlY3Q7XG4gICAgfVxuICAgIHNldCB0b3VjaEVmZmVjdChzYykge1xuICAgICAgICB0aGlzLiR0b3VjaEVmZmVjdCA9IHNjO1xuICAgIH1cbiAgICBzZXQgc2Nyb2xsU3BlZWQodmFsKSB7XG4gICAgICAgIHRoaXMuJHNjcm9sbFNwZWVkID0gdmFsO1xuICAgICAgICBpZiAodGhpcy4kc2Nyb2xsU3BlZWQgPT0gMClcbiAgICAgICAgICAgIHRoaXMuJHNjcm9sbFNwZWVkID0gVUlDb25maWcuZGVmYXVsdFNjcm9sbFNwZWVkO1xuICAgICAgICB0aGlzLiRtb3VzZVdoZWVsU3BlZWQgPSB0aGlzLiRzY3JvbGxTcGVlZCAqIDI7XG4gICAgfVxuICAgIGdldCBzY3JvbGxTcGVlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNjcm9sbFNwZWVkO1xuICAgIH1cbiAgICBnZXQgc25hcFRvSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNuYXBUb0l0ZW07XG4gICAgfVxuICAgIHNldCBzbmFwVG9JdGVtKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJHNuYXBUb0l0ZW0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IG1vdXNlV2hlZWxFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kbW91c2VXaGVlbEVuYWJsZWQ7XG4gICAgfVxuICAgIHNldCBtb3VzZVdoZWVsRW5hYmxlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiRtb3VzZVdoZWVsRW5hYmxlZCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZGVjZWxlcmF0aW9uUmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGRlY2VsZXJhdGlvblJhdGU7XG4gICAgfVxuICAgIHNldCBkZWNlbGVyYXRpb25SYXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJGRlY2VsZXJhdGlvblJhdGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHBlcmNYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kb3ZlcmxhcFNpemUueCA9PSAwID8gMCA6IHRoaXMuJHhQb3MgLyB0aGlzLiRvdmVybGFwU2l6ZS54O1xuICAgIH1cbiAgICBzZXQgcGVyY1godmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRQZXJjWCh2YWx1ZSwgZmFsc2UpO1xuICAgIH1cbiAgICBzZXRQZXJjWCh2YWx1ZSwgYW5pID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy4kb3duZXIuZW5zdXJlQm91bmRzQ29ycmVjdCgpO1xuICAgICAgICB0aGlzLnNldFBvc1godGhpcy4kb3ZlcmxhcFNpemUueCAqIE51bWJlclV0aWwuY2xhbXAwMSh2YWx1ZSksIGFuaSk7XG4gICAgfVxuICAgIGdldCBwZXJjWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG92ZXJsYXBTaXplLnkgPT0gMCA/IDAgOiB0aGlzLiR5UG9zIC8gdGhpcy4kb3ZlcmxhcFNpemUueTtcbiAgICB9XG4gICAgc2V0IHBlcmNZKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0UGVyY1kodmFsdWUsIGZhbHNlKTtcbiAgICB9XG4gICAgc2V0UGVyY1kodmFsdWUsIGFuaSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuJG93bmVyLmVuc3VyZUJvdW5kc0NvcnJlY3QoKTtcbiAgICAgICAgdGhpcy5zZXRQb3NZKHRoaXMuJG92ZXJsYXBTaXplLnkgKiBOdW1iZXJVdGlsLmNsYW1wMDEodmFsdWUpLCBhbmkpO1xuICAgIH1cbiAgICBnZXQgcG9zWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHhQb3M7XG4gICAgfVxuICAgIHNldCBwb3NYKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0UG9zWCh2YWx1ZSwgZmFsc2UpO1xuICAgIH1cbiAgICBzZXRQb3NYKHZhbHVlLCBhbmkgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLiRvd25lci5lbnN1cmVCb3VuZHNDb3JyZWN0KCk7XG4gICAgICAgIGlmICh0aGlzLiRsb29wID09IDEpXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMubG9vcENoZWNraW5nTmV3UG9zKHZhbHVlLCAneCcpO1xuICAgICAgICB2YWx1ZSA9IE51bWJlclV0aWwuY2xhbXAodmFsdWUsIDAsIHRoaXMuJG92ZXJsYXBTaXplLngpO1xuICAgICAgICBpZiAodmFsdWUgIT0gdGhpcy4keFBvcykge1xuICAgICAgICAgICAgdGhpcy4keFBvcyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wb3NDaGFuZ2VkKGFuaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHBvc1koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR5UG9zO1xuICAgIH1cbiAgICBzZXQgcG9zWSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldFBvc1kodmFsdWUsIGZhbHNlKTtcbiAgICB9XG4gICAgc2V0UG9zWSh2YWx1ZSwgYW5pID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy4kb3duZXIuZW5zdXJlQm91bmRzQ29ycmVjdCgpO1xuICAgICAgICBpZiAodGhpcy4kbG9vcCA9PSAxKVxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmxvb3BDaGVja2luZ05ld1Bvcyh2YWx1ZSwgJ3knKTtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXJVdGlsLmNsYW1wKHZhbHVlLCAwLCB0aGlzLiRvdmVybGFwU2l6ZS55KTtcbiAgICAgICAgaWYgKHZhbHVlICE9IHRoaXMuJHlQb3MpIHtcbiAgICAgICAgICAgIHRoaXMuJHlQb3MgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucG9zQ2hhbmdlZChhbmkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb250ZW50V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjb250ZW50U2l6ZS54O1xuICAgIH1cbiAgICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRlbnRTaXplLnk7XG4gICAgfVxuICAgIGdldCB2aWV3V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR2aWV3U2l6ZS54O1xuICAgIH1cbiAgICBzZXQgdmlld1dpZHRoKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgKyB0aGlzLiRvd25lci5tYXJnaW4ubGVmdCArIHRoaXMuJG93bmVyLm1hcmdpbi5yaWdodDtcbiAgICAgICAgaWYgKHRoaXMuJHZ0U2Nyb2xsQmFyICE9IG51bGwpXG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLiR2dFNjcm9sbEJhci53aWR0aDtcbiAgICAgICAgdGhpcy4kb3duZXIud2lkdGggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHZpZXdIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR2aWV3U2l6ZS55O1xuICAgIH1cbiAgICBzZXQgdmlld0hlaWdodCh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlICsgdGhpcy4kb3duZXIubWFyZ2luLnRvcCArIHRoaXMuJG93bmVyLm1hcmdpbi5ib3R0b207XG4gICAgICAgIGlmICh0aGlzLiRoelNjcm9sbEJhciAhPSBudWxsKVxuICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy4kaHpTY3JvbGxCYXIuaGVpZ2h0O1xuICAgICAgICB0aGlzLiRvd25lci5oZWlnaHQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRQYWdlWCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRwYWdlTW9kZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB2YXIgcGFnZSA9IE1hdGguZmxvb3IodGhpcy4keFBvcyAvIHRoaXMuJHBhZ2VTaXplLngpO1xuICAgICAgICBpZiAodGhpcy4keFBvcyAtIHBhZ2UgKiB0aGlzLiRwYWdlU2l6ZS54ID4gdGhpcy4kcGFnZVNpemUueCAqIDAuNSlcbiAgICAgICAgICAgIHBhZ2UrKztcbiAgICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfVxuICAgIHNldCBjdXJyZW50UGFnZVgodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJHBhZ2VNb2RlICYmIHRoaXMuJG92ZXJsYXBTaXplLnggPiAwKVxuICAgICAgICAgICAgdGhpcy5zZXRQb3NYKHZhbHVlICogdGhpcy4kcGFnZVNpemUueCwgZmFsc2UpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFBhZ2VZKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHBhZ2VNb2RlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBwYWdlID0gTWF0aC5mbG9vcih0aGlzLiR5UG9zIC8gdGhpcy4kcGFnZVNpemUueSk7XG4gICAgICAgIGlmICh0aGlzLiR5UG9zIC0gcGFnZSAqIHRoaXMuJHBhZ2VTaXplLnkgPiB0aGlzLiRwYWdlU2l6ZS55ICogMC41KVxuICAgICAgICAgICAgcGFnZSsrO1xuICAgICAgICByZXR1cm4gcGFnZTtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRQYWdlWSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kcGFnZU1vZGUgJiYgdGhpcy4kb3ZlcmxhcFNpemUueSA+IDApXG4gICAgICAgICAgICB0aGlzLnNldFBvc1kodmFsdWUgKiB0aGlzLiRwYWdlU2l6ZS55LCBmYWxzZSk7XG4gICAgfVxuICAgIGdldCBpc0JvdHRvbU1vc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR5UG9zID09IHRoaXMuJG92ZXJsYXBTaXplLnkgfHwgdGhpcy4kb3ZlcmxhcFNpemUueSA9PSAwO1xuICAgIH1cbiAgICBnZXQgaXNSaWdodE1vc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR4UG9zID09IHRoaXMuJG92ZXJsYXBTaXplLnggfHwgdGhpcy4kb3ZlcmxhcFNpemUueCA9PSAwO1xuICAgIH1cbiAgICBnZXQgcGFnZUNvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRwYWdlQ29udHJvbGxlcjtcbiAgICB9XG4gICAgc2V0IHBhZ2VDb250cm9sbGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJHBhZ2VDb250cm9sbGVyID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBzY3JvbGxpbmdQb3NYKCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyVXRpbC5jbGFtcCgtdGhpcy4kY29udGFpbmVyLngsIDAsIHRoaXMuJG92ZXJsYXBTaXplLngpO1xuICAgIH1cbiAgICBnZXQgc2Nyb2xsaW5nUG9zWSgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlclV0aWwuY2xhbXAoLXRoaXMuJGNvbnRhaW5lci55LCAwLCB0aGlzLiRvdmVybGFwU2l6ZS55KTtcbiAgICB9XG4gICAgc2Nyb2xsVG9wKGFuaSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc2V0UGVyY1koMCwgYW5pKTtcbiAgICB9XG4gICAgc2Nyb2xsQm90dG9tKGFuaSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc2V0UGVyY1koMSwgYW5pKTtcbiAgICB9XG4gICAgc2Nyb2xsVXAocmF0aW8gPSAxLCBhbmkgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy4kcGFnZU1vZGUpXG4gICAgICAgICAgICB0aGlzLnNldFBvc1kodGhpcy4keVBvcyAtIHRoaXMuJHBhZ2VTaXplLnkgKiByYXRpbywgYW5pKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zZXRQb3NZKHRoaXMuJHlQb3MgLSB0aGlzLiRzY3JvbGxTcGVlZCAqIHJhdGlvLCBhbmkpO1xuICAgIH1cbiAgICBzY3JvbGxEb3duKHJhdGlvID0gMSwgYW5pID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuJHBhZ2VNb2RlKVxuICAgICAgICAgICAgdGhpcy5zZXRQb3NZKHRoaXMuJHlQb3MgKyB0aGlzLiRwYWdlU2l6ZS55ICogcmF0aW8sIGFuaSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zWSh0aGlzLiR5UG9zICsgdGhpcy4kc2Nyb2xsU3BlZWQgKiByYXRpbywgYW5pKTtcbiAgICB9XG4gICAgc2Nyb2xsTGVmdChyYXRpbyA9IDEsIGFuaSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLiRwYWdlTW9kZSlcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zWCh0aGlzLiR4UG9zIC0gdGhpcy4kcGFnZVNpemUueCAqIHJhdGlvLCBhbmkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNldFBvc1godGhpcy4keFBvcyAtIHRoaXMuJHNjcm9sbFNwZWVkICogcmF0aW8sIGFuaSk7XG4gICAgfVxuICAgIHNjcm9sbFJpZ2h0KHJhdGlvID0gMSwgYW5pID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuJHBhZ2VNb2RlKVxuICAgICAgICAgICAgdGhpcy5zZXRQb3NYKHRoaXMuJHhQb3MgKyB0aGlzLiRwYWdlU2l6ZS54ICogcmF0aW8sIGFuaSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zWCh0aGlzLiR4UG9zICsgdGhpcy4kc2Nyb2xsU3BlZWQgKiByYXRpbywgYW5pKTtcbiAgICB9XG4gICAgc2Nyb2xsVG9WaWV3KHRhcmdldCwgYW5pID0gZmFsc2UsIHNuYXBUb0ZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy4kb3duZXIuZW5zdXJlQm91bmRzQ29ycmVjdCgpO1xuICAgICAgICBpZiAodGhpcy4kbmVlZFJlZnJlc2gpXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgbGV0IHJlY3Q7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBHT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LnBhcmVudCAhPSB0aGlzLiRvd25lcikge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wYXJlbnQubG9jYWxUb0dsb2JhbFJlY3QodGFyZ2V0LngsIHRhcmdldC55LCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHQsIFNjcm9sbFBhbmUuc0hlbHBlclJlY3QpO1xuICAgICAgICAgICAgICAgIHJlY3QgPSB0aGlzLiRvd25lci5nbG9iYWxUb0xvY2FsUmVjdChTY3JvbGxQYW5lLnNIZWxwZXJSZWN0LngsIFNjcm9sbFBhbmUuc0hlbHBlclJlY3QueSwgU2Nyb2xsUGFuZS5zSGVscGVyUmVjdC53aWR0aCwgU2Nyb2xsUGFuZS5zSGVscGVyUmVjdC5oZWlnaHQsIFNjcm9sbFBhbmUuc0hlbHBlclJlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjdCA9IFNjcm9sbFBhbmUuc0hlbHBlclJlY3Q7XG4gICAgICAgICAgICAgICAgcmVjdC54ID0gdGFyZ2V0Lng7XG4gICAgICAgICAgICAgICAgcmVjdC55ID0gdGFyZ2V0Lnk7XG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCA9IHRhcmdldC53aWR0aDtcbiAgICAgICAgICAgICAgICByZWN0LmhlaWdodCA9IHRhcmdldC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVjdCA9IHRhcmdldDtcbiAgICAgICAgaWYgKHRoaXMuJG92ZXJsYXBTaXplLnkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSB0aGlzLiR5UG9zICsgdGhpcy4kdmlld1NpemUueTtcbiAgICAgICAgICAgIGlmIChzbmFwVG9GaXJzdCB8fCByZWN0LnkgPD0gdGhpcy4keVBvcyB8fCByZWN0LmhlaWdodCA+PSB0aGlzLiR2aWV3U2l6ZS55KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHBhZ2VNb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc1koTWF0aC5mbG9vcihyZWN0LnkgLyB0aGlzLiRwYWdlU2l6ZS55KSAqIHRoaXMuJHBhZ2VTaXplLnksIGFuaSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc1kocmVjdC55LCBhbmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVjdC55ICsgcmVjdC5oZWlnaHQgPiBib3R0b20pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kcGFnZU1vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zWShNYXRoLmZsb29yKHJlY3QueSAvIHRoaXMuJHBhZ2VTaXplLnkpICogdGhpcy4kcGFnZVNpemUueSwgYW5pKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LmhlaWdodCA8PSB0aGlzLiR2aWV3U2l6ZS55IC8gMilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NZKHJlY3QueSArIHJlY3QuaGVpZ2h0ICogMiAtIHRoaXMuJHZpZXdTaXplLnksIGFuaSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc1kocmVjdC55ICsgcmVjdC5oZWlnaHQgLSB0aGlzLiR2aWV3U2l6ZS55LCBhbmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRvdmVybGFwU2l6ZS54ID4gMCkge1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gdGhpcy4keFBvcyArIHRoaXMuJHZpZXdTaXplLng7XG4gICAgICAgICAgICBpZiAoc25hcFRvRmlyc3QgfHwgcmVjdC54IDw9IHRoaXMuJHhQb3MgfHwgcmVjdC53aWR0aCA+PSB0aGlzLiR2aWV3U2l6ZS54KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHBhZ2VNb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc1goTWF0aC5mbG9vcihyZWN0LnggLyB0aGlzLiRwYWdlU2l6ZS54KSAqIHRoaXMuJHBhZ2VTaXplLngsIGFuaSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc1gocmVjdC54LCBhbmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVjdC54ICsgcmVjdC53aWR0aCA+IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHBhZ2VNb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc1goTWF0aC5mbG9vcihyZWN0LnggLyB0aGlzLiRwYWdlU2l6ZS54KSAqIHRoaXMuJHBhZ2VTaXplLngsIGFuaSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC53aWR0aCA8PSB0aGlzLiR2aWV3U2l6ZS54IC8gMilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NYKHJlY3QueCArIHJlY3Qud2lkdGggKiAyIC0gdGhpcy4kdmlld1NpemUueCwgYW5pKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zWChyZWN0LnggKyByZWN0LndpZHRoIC0gdGhpcy4kdmlld1NpemUueCwgYW5pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFuaSAmJiB0aGlzLiRuZWVkUmVmcmVzaClcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbiAgICBpc0NoaWxkSW5WaWV3KG9iaikge1xuICAgICAgICBpZiAodGhpcy4kb3ZlcmxhcFNpemUueSA+IDApIHtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gb2JqLnkgKyB0aGlzLiRjb250YWluZXIueTtcbiAgICAgICAgICAgIGlmIChkaXN0IDwgLW9iai5oZWlnaHQgfHwgZGlzdCA+IHRoaXMuJHZpZXdTaXplLnkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRvdmVybGFwU2l6ZS54ID4gMCkge1xuICAgICAgICAgICAgZGlzdCA9IG9iai54ICsgdGhpcy4kY29udGFpbmVyLng7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IC1vYmoud2lkdGggfHwgZGlzdCA+IHRoaXMuJHZpZXdTaXplLngpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYW5jZWxEcmFnZ2luZygpIHtcbiAgICAgICAgRGVjbHMkMS5HUm9vdC5pbnN0Lm5hdGl2ZVN0YWdlLm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5Nb3ZlLCB0aGlzLiRtb3VzZU1vdmVFdmVudCk7XG4gICAgICAgIERlY2xzJDEuR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vZmYoSW50ZXJhY3RpdmVFdmVudHMuVXAsIHRoaXMuJG1vdXNlVXBFdmVudCk7XG4gICAgICAgIERlY2xzJDEuR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vZmYoSW50ZXJhY3RpdmVFdmVudHMuQ2xpY2ssIHRoaXMuJGNsaWNrRXZlbnQpO1xuICAgICAgICBpZiAoU2Nyb2xsUGFuZS5kcmFnZ2luZ1BhbmUgPT0gdGhpcylcbiAgICAgICAgICAgIFNjcm9sbFBhbmUuZHJhZ2dpbmdQYW5lID0gbnVsbDtcbiAgICAgICAgU2Nyb2xsUGFuZS4kZ2VzdHVyZUZsYWcgPSAwO1xuICAgICAgICB0aGlzLiRpc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJG1hc2tDb250YWluZXIubW91c2VFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRpc0RyYWdnaW5nO1xuICAgIH1cbiAgICBsb2NrSGVhZGVyKHNpemUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGhlYWRlckxvY2tlZFNpemUgPT0gc2l6ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaGVhZGVyTG9ja2VkU2l6ZSA9IHNpemU7XG4gICAgICAgIGlmICghdGhpcy4kcmVmcmVzaEV2ZW50RGlzcGF0Y2hpbmcgJiZcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lclt0aGlzLiRyZWZyZXNoQmFyQXhpc10gPj0gMCkge1xuICAgICAgICAgICAgdGhpcy4kdHdlZW5TdGFydC5zZXRWYWx1ZXModGhpcy4kY29udGFpbmVyLngsIHRoaXMuJGNvbnRhaW5lci55KTtcbiAgICAgICAgICAgIHRoaXMuJHR3ZWVuQ2hhbmdlLnNldFZhbHVlcygwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuJHR3ZWVuQ2hhbmdlW3RoaXMuJHJlZnJlc2hCYXJBeGlzXSA9XG4gICAgICAgICAgICAgICAgdGhpcy4kaGVhZGVyTG9ja2VkU2l6ZSAtIHRoaXMuJHR3ZWVuU3RhcnRbdGhpcy4kcmVmcmVzaEJhckF4aXNdO1xuICAgICAgICAgICAgdGhpcy4kdHdlZW5EdXJhdGlvbi5zZXRWYWx1ZXMoU2Nyb2xsUGFuZS5UV0VFTl9ERUZBVUxUX0RVUkFUSU9OLCBTY3JvbGxQYW5lLlRXRUVOX0RFRkFVTFRfRFVSQVRJT04pO1xuICAgICAgICAgICAgdGhpcy4kdHdlZW5UaW1lLnNldFZhbHVlcygwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuJHR3ZWVuaW5nID0gMjtcbiAgICAgICAgICAgIEdUaW1lci5pbnN0LmFkZExvb3AoMSwgdGhpcy50d2VlblVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9ja0Zvb3RlcihzaXplKSB7XG4gICAgICAgIGlmICh0aGlzLiRmb290ZXJMb2NrZWRTaXplID09IHNpemUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJGZvb3RlckxvY2tlZFNpemUgPSBzaXplO1xuICAgICAgICBpZiAoIXRoaXMuJHJlZnJlc2hFdmVudERpc3BhdGNoaW5nICYmXG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXJbdGhpcy4kcmVmcmVzaEJhckF4aXNdIDw9XG4gICAgICAgICAgICAgICAgLXRoaXMuJG92ZXJsYXBTaXplW3RoaXMuJHJlZnJlc2hCYXJBeGlzXSkge1xuICAgICAgICAgICAgdGhpcy4kdHdlZW5TdGFydC5zZXRWYWx1ZXModGhpcy4kY29udGFpbmVyLngsIHRoaXMuJGNvbnRhaW5lci55KTtcbiAgICAgICAgICAgIHRoaXMuJHR3ZWVuQ2hhbmdlLnNldFZhbHVlcygwLCAwKTtcbiAgICAgICAgICAgIGxldCBtYXggPSB0aGlzLiRvdmVybGFwU2l6ZVt0aGlzLiRyZWZyZXNoQmFyQXhpc107XG4gICAgICAgICAgICBpZiAobWF4ID09IDApXG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgodGhpcy4kY29udGVudFNpemVbdGhpcy4kcmVmcmVzaEJhckF4aXNdICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9vdGVyTG9ja2VkU2l6ZSAtXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHZpZXdTaXplW3RoaXMuJHJlZnJlc2hCYXJBeGlzXSwgMCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWF4ICs9IHRoaXMuJGZvb3RlckxvY2tlZFNpemU7XG4gICAgICAgICAgICB0aGlzLiR0d2VlbkNoYW5nZVt0aGlzLiRyZWZyZXNoQmFyQXhpc10gPVxuICAgICAgICAgICAgICAgIC1tYXggLSB0aGlzLiR0d2VlblN0YXJ0W3RoaXMuJHJlZnJlc2hCYXJBeGlzXTtcbiAgICAgICAgICAgIHRoaXMuJHR3ZWVuRHVyYXRpb24uc2V0VmFsdWVzKFNjcm9sbFBhbmUuVFdFRU5fREVGQVVMVF9EVVJBVElPTiwgU2Nyb2xsUGFuZS5UV0VFTl9ERUZBVUxUX0RVUkFUSU9OKTtcbiAgICAgICAgICAgIHRoaXMuJHR3ZWVuVGltZS5zZXRWYWx1ZXMoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLiR0d2VlbmluZyA9IDI7XG4gICAgICAgICAgICBHVGltZXIuaW5zdC5hZGRMb29wKDEsIHRoaXMudHdlZW5VcGRhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG9uT3duZXJTaXplQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy5zZXRTaXplKHRoaXMuJG93bmVyLndpZHRoLCB0aGlzLiRvd25lci5oZWlnaHQpO1xuICAgICAgICB0aGlzLnBvc0NoYW5nZWQoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBoYW5kbGVDb250cm9sbGVyQ2hhbmdlZChjKSB7XG4gICAgICAgIGlmICh0aGlzLiRwYWdlQ29udHJvbGxlciA9PSBjKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2Nyb2xsVHlwZSA9PSAwIC8qIEhvcml6b250YWwgKi8pXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFnZVggPSBjLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFnZVkgPSBjLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlUGFnZUNvbnRyb2xsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiRwYWdlQ29udHJvbGxlciAhPSBudWxsICYmICF0aGlzLiRwYWdlQ29udHJvbGxlci4kdXBkYXRpbmcpIHtcbiAgICAgICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzY3JvbGxUeXBlID09IDAgLyogSG9yaXpvbnRhbCAqLylcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuY3VycmVudFBhZ2VYO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5jdXJyZW50UGFnZVk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLiRwYWdlQ29udHJvbGxlci5wYWdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gdGhpcy4kcGFnZUNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgICAgdGhpcy4kcGFnZUNvbnRyb2xsZXIgPSBudWxsOyAvL3ByZXZlbnQgZnJvbSBoYW5kbGVDb250cm9sbGVyQ2hhbmdlZCBjYWxsaW5nXG4gICAgICAgICAgICAgICAgYy5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy4kcGFnZUNvbnRyb2xsZXIgPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFkanVzdE1hc2tDb250YWluZXIoKSB7XG4gICAgICAgIGxldCB4LCB5O1xuICAgICAgICBpZiAodGhpcy4kZGlzcGxheU9uTGVmdCAmJiB0aGlzLiR2dFNjcm9sbEJhciAhPSBudWxsKVxuICAgICAgICAgICAgeCA9IE1hdGguZmxvb3IodGhpcy4kb3duZXIubWFyZ2luLmxlZnQgKyB0aGlzLiR2dFNjcm9sbEJhci53aWR0aCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKHRoaXMuJG93bmVyLm1hcmdpbi5sZWZ0KTtcbiAgICAgICAgeSA9IE1hdGguZmxvb3IodGhpcy4kb3duZXIubWFyZ2luLnRvcCk7XG4gICAgICAgIHRoaXMuJG1hc2tDb250YWluZXIuc2V0KHsgeCwgeSB9KTtcbiAgICAgICAgaWYgKHRoaXMuJG93bmVyLiRhbGlnbk9mZnNldC54ICE9IDAgfHwgdGhpcy4kb3duZXIuJGFsaWduT2Zmc2V0LnkgIT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGFsaWduQ29udGFpbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRhbGlnbkNvbnRhaW5lciA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRtYXNrQ29udGFpbmVyLmFkZENoaWxkKHRoaXMuJGFsaWduQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRhbGlnbkNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLiRjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kYWxpZ25Db250YWluZXIuc2V0KHsgeDogdGhpcy4kb3duZXIuJGFsaWduT2Zmc2V0LngsIHk6IHRoaXMuJG93bmVyLiRhbGlnbk9mZnNldC55IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJGFsaWduQ29udGFpbmVyKVxuICAgICAgICAgICAgdGhpcy4kYWxpZ25Db250YWluZXIuc2V0KHsgeDogMCwgeTogMCB9KTtcbiAgICB9XG4gICAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuYWRqdXN0TWFza0NvbnRhaW5lcigpO1xuICAgICAgICBpZiAodGhpcy4kaHpTY3JvbGxCYXIpIHtcbiAgICAgICAgICAgIHRoaXMuJGh6U2Nyb2xsQmFyLnkgPSBoZWlnaHQgLSB0aGlzLiRoelNjcm9sbEJhci5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAodGhpcy4kdnRTY3JvbGxCYXIgJiYgIXRoaXMuJHZTY3JvbGxOb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaHpTY3JvbGxCYXIud2lkdGggPVxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAtIHRoaXMuJHZ0U2Nyb2xsQmFyLndpZHRoIC0gdGhpcy4kc2Nyb2xsQmFyTWFyZ2luLmxlZnQgLSB0aGlzLiRzY3JvbGxCYXJNYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGRpc3BsYXlPbkxlZnQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGh6U2Nyb2xsQmFyLnggPSB0aGlzLiRzY3JvbGxCYXJNYXJnaW4ubGVmdCArIHRoaXMuJHZ0U2Nyb2xsQmFyLndpZHRoO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaHpTY3JvbGxCYXIueCA9IHRoaXMuJHNjcm9sbEJhck1hcmdpbi5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaHpTY3JvbGxCYXIud2lkdGggPSB3aWR0aCAtIHRoaXMuJHNjcm9sbEJhck1hcmdpbi5sZWZ0IC0gdGhpcy4kc2Nyb2xsQmFyTWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuJGh6U2Nyb2xsQmFyLnggPSB0aGlzLiRzY3JvbGxCYXJNYXJnaW4ubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kdnRTY3JvbGxCYXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kZGlzcGxheU9uTGVmdClcbiAgICAgICAgICAgICAgICB0aGlzLiR2dFNjcm9sbEJhci54ID0gd2lkdGggLSB0aGlzLiR2dFNjcm9sbEJhci53aWR0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLiRoelNjcm9sbEJhcilcbiAgICAgICAgICAgICAgICB0aGlzLiR2dFNjcm9sbEJhci5oZWlnaHQgPVxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgLVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kaHpTY3JvbGxCYXIuaGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHNjcm9sbEJhck1hcmdpbi50b3AgLVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2Nyb2xsQmFyTWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLiR2dFNjcm9sbEJhci5oZWlnaHQgPSBoZWlnaHQgLSB0aGlzLiRzY3JvbGxCYXJNYXJnaW4udG9wIC0gdGhpcy4kc2Nyb2xsQmFyTWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIHRoaXMuJHZ0U2Nyb2xsQmFyLnkgPSB0aGlzLiRzY3JvbGxCYXJNYXJnaW4udG9wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHZpZXdTaXplLnggPSB3aWR0aDtcbiAgICAgICAgdGhpcy4kdmlld1NpemUueSA9IGhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuJGh6U2Nyb2xsQmFyICYmICF0aGlzLiRoU2Nyb2xsTm9uZSlcbiAgICAgICAgICAgIHRoaXMuJHZpZXdTaXplLnkgLT0gdGhpcy4kaHpTY3JvbGxCYXIuaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy4kdnRTY3JvbGxCYXIgJiYgIXRoaXMuJHZTY3JvbGxOb25lKVxuICAgICAgICAgICAgdGhpcy4kdmlld1NpemUueCAtPSB0aGlzLiR2dFNjcm9sbEJhci53aWR0aDtcbiAgICAgICAgdGhpcy4kdmlld1NpemUueCAtPSB0aGlzLiRvd25lci5tYXJnaW4ubGVmdCArIHRoaXMuJG93bmVyLm1hcmdpbi5yaWdodDtcbiAgICAgICAgdGhpcy4kdmlld1NpemUueSAtPSB0aGlzLiRvd25lci5tYXJnaW4udG9wICsgdGhpcy4kb3duZXIubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy4kdmlld1NpemUueCA9IE1hdGgubWF4KDEsIHRoaXMuJHZpZXdTaXplLngpO1xuICAgICAgICB0aGlzLiR2aWV3U2l6ZS55ID0gTWF0aC5tYXgoMSwgdGhpcy4kdmlld1NpemUueSk7XG4gICAgICAgIHRoaXMuJHBhZ2VTaXplLnggPSB0aGlzLiR2aWV3U2l6ZS54O1xuICAgICAgICB0aGlzLiRwYWdlU2l6ZS55ID0gdGhpcy4kdmlld1NpemUueTtcbiAgICAgICAgdGhpcy5oYW5kbGVTaXplQ2hhbmdlZCgpO1xuICAgIH1cbiAgICBzZXRDb250ZW50U2l6ZSh3LCBoKSB7XG4gICAgICAgIGlmICh0aGlzLiRjb250ZW50U2l6ZS54ID09IHcgJiYgdGhpcy4kY29udGVudFNpemUueSA9PSBoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRjb250ZW50U2l6ZS54ID0gdztcbiAgICAgICAgdGhpcy4kY29udGVudFNpemUueSA9IGg7XG4gICAgICAgIHRoaXMuaGFuZGxlU2l6ZUNoYW5nZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY2hhbmdlQ29udGVudFNpemVPblNjcm9sbGluZyhkZWx0YVdpZHRoLCBkZWx0YUhlaWdodCwgZGVsdGFQb3NYLCBkZWx0YVBvc1kpIHtcbiAgICAgICAgY29uc3QgaXNSaWdodG1vc3QgPSB0aGlzLiR4UG9zID09IHRoaXMuJG92ZXJsYXBTaXplLng7XG4gICAgICAgIGNvbnN0IGlzQm90dG9tID0gdGhpcy4keVBvcyA9PSB0aGlzLiRvdmVybGFwU2l6ZS55O1xuICAgICAgICB0aGlzLiRjb250ZW50U2l6ZS54ICs9IGRlbHRhV2lkdGg7XG4gICAgICAgIHRoaXMuJGNvbnRlbnRTaXplLnkgKz0gZGVsdGFIZWlnaHQ7XG4gICAgICAgIHRoaXMuaGFuZGxlU2l6ZUNoYW5nZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuJHR3ZWVuaW5nID09IDEpIHtcbiAgICAgICAgICAgIC8vaWYgdGhlIGxhc3Qgc2Nyb2xsIGlzIENMSU5HSU5HLVNJREUsIHRoZW4ganVzdCBjb250aW51ZSB0byBjbGluZ1xuICAgICAgICAgICAgaWYgKGRlbHRhV2lkdGggIT0gMCAmJiBpc1JpZ2h0bW9zdCAmJiB0aGlzLiR0d2VlbkNoYW5nZS54IDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHhQb3MgPSB0aGlzLiRvdmVybGFwU2l6ZS54O1xuICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuQ2hhbmdlLnggPSAtdGhpcy4keFBvcyAtIHRoaXMuJHR3ZWVuU3RhcnQueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWx0YUhlaWdodCAhPSAwICYmIGlzQm90dG9tICYmIHRoaXMuJHR3ZWVuQ2hhbmdlLnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4keVBvcyA9IHRoaXMuJG92ZXJsYXBTaXplLnk7XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5DaGFuZ2UueSA9IC10aGlzLiR5UG9zIC0gdGhpcy4kdHdlZW5TdGFydC55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJHR3ZWVuaW5nID09IDIpIHtcbiAgICAgICAgICAgIC8vcmUtcG9zIHRvIGVuc3VyZSB0aGUgc2Nyb2xsaW5nIHdpbGwgZ28gb24gc21vb3RoXG4gICAgICAgICAgICBpZiAoZGVsdGFQb3NYICE9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIueCAtPSBkZWx0YVBvc1g7XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5TdGFydC54IC09IGRlbHRhUG9zWDtcbiAgICAgICAgICAgICAgICB0aGlzLiR4UG9zID0gLXRoaXMuJGNvbnRhaW5lci54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhUG9zWSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnkgLT0gZGVsdGFQb3NZO1xuICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuU3RhcnQueSAtPSBkZWx0YVBvc1k7XG4gICAgICAgICAgICAgICAgdGhpcy4keVBvcyA9IC10aGlzLiRjb250YWluZXIueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiRpc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBpZiAoZGVsdGFQb3NYICE9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIueCAtPSBkZWx0YVBvc1g7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyUG9zLnggLT0gZGVsdGFQb3NYO1xuICAgICAgICAgICAgICAgIHRoaXMuJHhQb3MgPSAtdGhpcy4kY29udGFpbmVyLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVsdGFQb3NZICE9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIueSAtPSBkZWx0YVBvc1k7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyUG9zLnkgLT0gZGVsdGFQb3NZO1xuICAgICAgICAgICAgICAgIHRoaXMuJHlQb3MgPSAtdGhpcy4kY29udGFpbmVyLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL2lmIHRoZSBsYXN0IHNjcm9sbCBpcyBDTElOR0lORy1TSURFLCB0aGVuIGp1c3QgY29udGludWUgdG8gY2xpbmdcbiAgICAgICAgICAgIGlmIChkZWx0YVdpZHRoICE9IDAgJiYgaXNSaWdodG1vc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR4UG9zID0gdGhpcy4kb3ZlcmxhcFNpemUueDtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIueCA9IC10aGlzLiR4UG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhSGVpZ2h0ICE9IDAgJiYgaXNCb3R0b20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR5UG9zID0gdGhpcy4kb3ZlcmxhcFNpemUueTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIueSA9IC10aGlzLiR5UG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRwYWdlTW9kZSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFnZUNvbnRyb2xsZXIoKTtcbiAgICB9XG4gICAgaGFuZGxlU2l6ZUNoYW5nZWQob25TY3JvbGxpbmcgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy4kZGlzcGxheU9uRGVtYW5kKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kdnRTY3JvbGxCYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kY29udGVudFNpemUueSA8PSB0aGlzLiR2aWV3U2l6ZS55KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy4kdlNjcm9sbE5vbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHZTY3JvbGxOb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHZpZXdTaXplLnggKz0gdGhpcy4kdnRTY3JvbGxCYXIud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiR2U2Nyb2xsTm9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kdlNjcm9sbE5vbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHZpZXdTaXplLnggLT0gdGhpcy4kdnRTY3JvbGxCYXIud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kaHpTY3JvbGxCYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kY29udGVudFNpemUueCA8PSB0aGlzLiR2aWV3U2l6ZS54KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy4kaFNjcm9sbE5vbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGhTY3JvbGxOb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHZpZXdTaXplLnkgKz0gdGhpcy4kaHpTY3JvbGxCYXIuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kaFNjcm9sbE5vbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGhTY3JvbGxOb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiR2aWV3U2l6ZS55IC09IHRoaXMuJGh6U2Nyb2xsQmFyLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kdnRTY3JvbGxCYXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR2aWV3U2l6ZS55IDwgdGhpcy4kdnRTY3JvbGxCYXIubWluU2l6ZSlcbiAgICAgICAgICAgICAgICAvL3VzZSB0aGlzLiR2dFNjcm9sbEJhci5kaXNwbGF5T2JqZWN0LnZpc2libGUgaW5zdGVhZCBvZiB0aGlzLiR2dFNjcm9sbEJhci52aXNpYmxlLi4uIFNjcm9sbEJhciBhY3R1YWxseSBpcyBub3QgaW4gaXRzIG93bmVyJ3MgZGlzcGxheSB0cmVlLCBzbyB2dFNjcm9sbEJhci52aXNpYmxlIHdpbGwgbm90IHdvcmtcbiAgICAgICAgICAgICAgICB0aGlzLiR2dFNjcm9sbEJhci5kaXNwbGF5T2JqZWN0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJHZ0U2Nyb2xsQmFyLmRpc3BsYXlPYmplY3QudmlzaWJsZSA9IHRoaXMuJHNjcm9sbEJhclZpc2libGUgJiYgIXRoaXMuJHZTY3JvbGxOb25lO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRjb250ZW50U2l6ZS55ID09IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHZ0U2Nyb2xsQmFyLmRpc3BsYXlQZXJjID0gMDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHZ0U2Nyb2xsQmFyLmRpc3BsYXlQZXJjID0gTWF0aC5taW4oMSwgdGhpcy4kdmlld1NpemUueSAvIHRoaXMuJGNvbnRlbnRTaXplLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRoelNjcm9sbEJhcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHZpZXdTaXplLnggPCB0aGlzLiRoelNjcm9sbEJhci5taW5TaXplKVxuICAgICAgICAgICAgICAgIHRoaXMuJGh6U2Nyb2xsQmFyLmRpc3BsYXlPYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaHpTY3JvbGxCYXIuZGlzcGxheU9iamVjdC52aXNpYmxlID0gdGhpcy4kc2Nyb2xsQmFyVmlzaWJsZSAmJiAhdGhpcy4kaFNjcm9sbE5vbmU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGNvbnRlbnRTaXplLnggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaHpTY3JvbGxCYXIuZGlzcGxheVBlcmMgPSAwO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaHpTY3JvbGxCYXIuZGlzcGxheVBlcmMgPSBNYXRoLm1pbigxLCB0aGlzLiR2aWV3U2l6ZS54IC8gdGhpcy4kY29udGVudFNpemUueCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMuJG1hc2tDb250YWluZXIuc2Nyb2xsUmVjdDtcbiAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgIHJlY3Qud2lkdGggPSB0aGlzLiR2aWV3U2l6ZS54O1xuICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSB0aGlzLiR2aWV3U2l6ZS55O1xuICAgICAgICAgICAgdGhpcy4kbWFza0NvbnRhaW5lci5zY3JvbGxSZWN0ID0gcmVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kc2Nyb2xsVHlwZSA9PSAwIC8qIEhvcml6b250YWwgKi8gfHwgdGhpcy4kc2Nyb2xsVHlwZSA9PSAyIC8qIEJvdGggKi8pXG4gICAgICAgICAgICB0aGlzLiRvdmVybGFwU2l6ZS54ID0gTWF0aC5jZWlsKE1hdGgubWF4KDAsIHRoaXMuJGNvbnRlbnRTaXplLnggLSB0aGlzLiR2aWV3U2l6ZS54KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuJG92ZXJsYXBTaXplLnggPSAwO1xuICAgICAgICBpZiAodGhpcy4kc2Nyb2xsVHlwZSA9PSAxIC8qIFZlcnRpY2FsICovIHx8IHRoaXMuJHNjcm9sbFR5cGUgPT0gMiAvKiBCb3RoICovKVxuICAgICAgICAgICAgdGhpcy4kb3ZlcmxhcFNpemUueSA9IE1hdGguY2VpbChNYXRoLm1heCgwLCB0aGlzLiRjb250ZW50U2l6ZS55IC0gdGhpcy4kdmlld1NpemUueSkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRvdmVybGFwU2l6ZS55ID0gMDtcbiAgICAgICAgLy9ib3VuZHMgY2hlY2tpbmdcbiAgICAgICAgdGhpcy4keFBvcyA9IE51bWJlclV0aWwuY2xhbXAodGhpcy4keFBvcywgMCwgdGhpcy4kb3ZlcmxhcFNpemUueCk7XG4gICAgICAgIHRoaXMuJHlQb3MgPSBOdW1iZXJVdGlsLmNsYW1wKHRoaXMuJHlQb3MsIDAsIHRoaXMuJG92ZXJsYXBTaXplLnkpO1xuICAgICAgICBpZiAodGhpcy4kcmVmcmVzaEJhckF4aXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG1heCA9IHRoaXMuJG92ZXJsYXBTaXplW3RoaXMuJHJlZnJlc2hCYXJBeGlzXTtcbiAgICAgICAgICAgIGlmIChtYXggPT0gMClcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heCh0aGlzLiRjb250ZW50U2l6ZVt0aGlzLiRyZWZyZXNoQmFyQXhpc10gK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb290ZXJMb2NrZWRTaXplIC1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdmlld1NpemVbdGhpcy4kcmVmcmVzaEJhckF4aXNdLCAwKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYXggKz0gdGhpcy4kZm9vdGVyTG9ja2VkU2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRyZWZyZXNoQmFyQXhpcyA9PSAneCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgeDogTnVtYmVyVXRpbC5jbGFtcCh0aGlzLiRjb250YWluZXIueCwgLW1heCwgdGhpcy4kaGVhZGVyTG9ja2VkU2l6ZSksXG4gICAgICAgICAgICAgICAgICAgIHk6IE51bWJlclV0aWwuY2xhbXAodGhpcy4kY29udGFpbmVyLnksIC10aGlzLiRvdmVybGFwU2l6ZS55LCAwKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnNldCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IE51bWJlclV0aWwuY2xhbXAodGhpcy4kY29udGFpbmVyLngsIC10aGlzLiRvdmVybGFwU2l6ZS54LCAwKSxcbiAgICAgICAgICAgICAgICAgICAgeTogTnVtYmVyVXRpbC5jbGFtcCh0aGlzLiRjb250YWluZXIueSwgLW1heCwgdGhpcy4kaGVhZGVyTG9ja2VkU2l6ZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRoZWFkZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRyZWZyZXNoQmFyQXhpcyA9PSAneCcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGhlYWRlci5oZWlnaHQgPSB0aGlzLiR2aWV3U2l6ZS55O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaGVhZGVyLndpZHRoID0gdGhpcy4kdmlld1NpemUueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRmb290ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRyZWZyZXNoQmFyQXhpcyA9PSAneScpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvb3Rlci5oZWlnaHQgPSB0aGlzLiR2aWV3U2l6ZS55O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9vdGVyLndpZHRoID0gdGhpcy4kdmlld1NpemUueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5zZXQoe1xuICAgICAgICAgICAgICAgIHg6IE51bWJlclV0aWwuY2xhbXAodGhpcy4kY29udGFpbmVyLngsIC10aGlzLiRvdmVybGFwU2l6ZS54LCAwKSxcbiAgICAgICAgICAgICAgICB5OiBOdW1iZXJVdGlsLmNsYW1wKHRoaXMuJGNvbnRhaW5lci55LCAtdGhpcy4kb3ZlcmxhcFNpemUueSwgMClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3luY1Njcm9sbEJhcigpO1xuICAgICAgICB0aGlzLmNoZWNrUmVmcmVzaEJhcigpO1xuICAgICAgICBpZiAodGhpcy4kcGFnZU1vZGUpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhZ2VDb250cm9sbGVyKCk7XG4gICAgfVxuICAgIHBvc0NoYW5nZWQoYW5pKSB7XG4gICAgICAgIGlmICh0aGlzLiRhbmlGbGFnID09IDApXG4gICAgICAgICAgICB0aGlzLiRhbmlGbGFnID0gYW5pID8gMSA6IC0xO1xuICAgICAgICBlbHNlIGlmICh0aGlzLiRhbmlGbGFnID09IDEgJiYgIWFuaSlcbiAgICAgICAgICAgIHRoaXMuJGFuaUZsYWcgPSAtMTtcbiAgICAgICAgdGhpcy4kbmVlZFJlZnJlc2ggPSB0cnVlO1xuICAgICAgICBHVGltZXIuaW5zdC5jYWxsTGF0ZXIodGhpcy5yZWZyZXNoLCB0aGlzKTtcbiAgICB9XG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy4kbmVlZFJlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgR1RpbWVyLmluc3QucmVtb3ZlKHRoaXMucmVmcmVzaCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLiRwYWdlTW9kZSB8fCB0aGlzLiRzbmFwVG9JdGVtKSB7XG4gICAgICAgICAgICBTY3JvbGxQYW5lLnNFbmRQb3Muc2V0VmFsdWVzKC10aGlzLiR4UG9zLCAtdGhpcy4keVBvcyk7XG4gICAgICAgICAgICB0aGlzLmFsaWduUG9zaXRpb24oU2Nyb2xsUGFuZS5zRW5kUG9zLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiR4UG9zID0gLVNjcm9sbFBhbmUuc0VuZFBvcy54O1xuICAgICAgICAgICAgdGhpcy4keVBvcyA9IC1TY3JvbGxQYW5lLnNFbmRQb3MueTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2gyKCk7XG4gICAgICAgIGxldCBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJfX3Njcm9sbFwiIC8qIFNDUk9MTCAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuJG5lZWRSZWZyZXNoKSB7XG4gICAgICAgICAgICAvL2RldmVsb3BlciBtaWdodCBtb2RpZnkgcG9zaXRpb24gaW4gdGhlIGNhbGxiYWNrLCBzbyBoZXJlIHJlZnJlc2ggYWdhaW4gdG8gYXZvaWQgZmxpY2tlcmluZ1xuICAgICAgICAgICAgdGhpcy4kbmVlZFJlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIEdUaW1lci5pbnN0LnJlbW92ZSh0aGlzLnJlZnJlc2gsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoMigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3luY1Njcm9sbEJhcigpO1xuICAgICAgICB0aGlzLiRhbmlGbGFnID0gMDtcbiAgICB9XG4gICAgcmVmcmVzaDIoKSB7XG4gICAgICAgIGlmICh0aGlzLiRhbmlGbGFnID09IDEgJiYgIXRoaXMuJGlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGxldCBwb3NYO1xuICAgICAgICAgICAgbGV0IHBvc1k7XG4gICAgICAgICAgICBpZiAodGhpcy4kb3ZlcmxhcFNpemUueCA+IDApXG4gICAgICAgICAgICAgICAgcG9zWCA9IC1NYXRoLmZsb29yKHRoaXMuJHhQb3MpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGNvbnRhaW5lci54ICE9IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci54ID0gMDtcbiAgICAgICAgICAgICAgICBwb3NYID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRvdmVybGFwU2l6ZS55ID4gMClcbiAgICAgICAgICAgICAgICBwb3NZID0gLU1hdGguZmxvb3IodGhpcy4keVBvcyk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kY29udGFpbmVyLnkgIT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnkgPSAwO1xuICAgICAgICAgICAgICAgIHBvc1kgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc1ggIT0gdGhpcy4kY29udGFpbmVyLnggfHwgcG9zWSAhPSB0aGlzLiRjb250YWluZXIueSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuaW5nID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlblRpbWUuc2V0VmFsdWVzKDAsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuRHVyYXRpb24uc2V0VmFsdWVzKFNjcm9sbFBhbmUuVFdFRU5fTUFOVUFMTFlfU0VUX0RVUkFUSU9OLCBTY3JvbGxQYW5lLlRXRUVOX01BTlVBTExZX1NFVF9EVVJBVElPTik7XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5TdGFydC5zZXRWYWx1ZXModGhpcy4kY29udGFpbmVyLngsIHRoaXMuJGNvbnRhaW5lci55KTtcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlbkNoYW5nZS5zZXRWYWx1ZXMocG9zWCAtIHRoaXMuJHR3ZWVuU3RhcnQueCwgcG9zWSAtIHRoaXMuJHR3ZWVuU3RhcnQueSk7XG4gICAgICAgICAgICAgICAgR1RpbWVyLmluc3QuYWRkTG9vcCgxLCB0aGlzLnR3ZWVuVXBkYXRlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJHR3ZWVuaW5nICE9IDApXG4gICAgICAgICAgICAgICAgdGhpcy5raWxsVHdlZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0d2VlbmluZyAhPSAwKVxuICAgICAgICAgICAgICAgIHRoaXMua2lsbFR3ZWVuKCk7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIuc2V0KHsgeDogTWF0aC5mbG9vcigtdGhpcy4keFBvcyksIHk6IE1hdGguZmxvb3IoLXRoaXMuJHlQb3MpIH0pO1xuICAgICAgICAgICAgdGhpcy5sb29wQ2hlY2tpbmdDdXJyZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJHBhZ2VNb2RlKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVQYWdlQ29udHJvbGxlcigpO1xuICAgIH1cbiAgICBzeW5jU2Nyb2xsQmFyKGVuZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLiR2dFNjcm9sbEJhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiR2dFNjcm9sbEJhci5zY3JvbGxQZXJjID1cbiAgICAgICAgICAgICAgICB0aGlzLiRvdmVybGFwU2l6ZS55ID09IDBcbiAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgIDogTnVtYmVyVXRpbC5jbGFtcCgtdGhpcy4kY29udGFpbmVyLnksIDAsIHRoaXMuJG92ZXJsYXBTaXplLnkpIC8gdGhpcy4kb3ZlcmxhcFNpemUueTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzY3JvbGxCYXJEaXNwbGF5QXV0bylcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dTY3JvbGxCYXIoIWVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGh6U2Nyb2xsQmFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuJGh6U2Nyb2xsQmFyLnNjcm9sbFBlcmMgPVxuICAgICAgICAgICAgICAgIHRoaXMuJG92ZXJsYXBTaXplLnggPT0gMFxuICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiBOdW1iZXJVdGlsLmNsYW1wKC10aGlzLiRjb250YWluZXIueCwgMCwgdGhpcy4kb3ZlcmxhcFNpemUueCkgLyB0aGlzLiRvdmVybGFwU2l6ZS54O1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjcm9sbEJhckRpc3BsYXlBdXRvKVxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Njcm9sbEJhcighZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kKVxuICAgICAgICAgICAgdGhpcy4kbWFza0NvbnRhaW5lci5tb3VzZUVuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICAkbW91c2VEb3duKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLiR0b3VjaEVmZmVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuJHR3ZWVuaW5nICE9IDApIHtcbiAgICAgICAgICAgIHRoaXMua2lsbFR3ZWVuKCk7XG4gICAgICAgICAgICB0aGlzLiRpc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRpc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGdsb2JhbE1vdXNlID0gaXNNb2JpbGUuYW55XG4gICAgICAgICAgICA/IHRoaXMuJG93bmVyLmdsb2JhbFRvTG9jYWwoZS5sb2NhbFgsIGUubG9jYWxZKVxuICAgICAgICAgICAgOiB0aGlzLiRvd25lci5nbG9iYWxUb0xvY2FsKERlY2xzJDEuR1Jvb3QuZ2xvYmFsTW91c2VTdGF0dXMubW91c2VYLCBEZWNscyQxLkdSb290Lmdsb2JhbE1vdXNlU3RhdHVzLm1vdXNlWSwgU2Nyb2xsUGFuZS5zSGVscGVyUG9pbnQpO1xuICAgICAgICB0aGlzLiRjb250YWluZXJQb3Muc2V0VmFsdWVzKHRoaXMuJGNvbnRhaW5lci54LCB0aGlzLiRjb250YWluZXIueSk7XG4gICAgICAgIHRoaXMuJGJlZ2luVG91Y2hQb3MuY29weShnbG9iYWxNb3VzZSk7XG4gICAgICAgIHRoaXMuJGxhc3RUb3VjaFBvcy5jb3B5KGdsb2JhbE1vdXNlKTtcbiAgICAgICAgdGhpcy4kbGFzdFRvdWNoR2xvYmFsUG9zLmNvcHkoZ2xvYmFsTW91c2UpO1xuICAgICAgICB0aGlzLiRpc0hvbGRBcmVhRG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiR2ZWxvY2l0eS5zZXRWYWx1ZXMoMCwgMCk7XG4gICAgICAgIHRoaXMuJHZlbG9jaXR5U2NhbGUgPSAxO1xuICAgICAgICB0aGlzLiRsYXN0TW92ZVRpbWUgPSBHVGltZXIuaW5zdC5jdXJUaW1lIC8gMTAwMDtcbiAgICAgICAgdGhpcy4kbW91c2VNb3ZlRXZlbnQgPSBEZWNscyQxLkdSb290Lmluc3QubmF0aXZlU3RhZ2Uub24oSW50ZXJhY3RpdmVFdmVudHMuTW92ZSwgdGhpcy4kbW91c2VNb3ZlLCB0aGlzKTtcbiAgICAgICAgdGhpcy4kbW91c2VVcEV2ZW50ID0gRGVjbHMkMS5HUm9vdC5pbnN0Lm5hdGl2ZVN0YWdlLm9uKEludGVyYWN0aXZlRXZlbnRzLlVwLCB0aGlzLiRtb3VzZVVwLCB0aGlzKTtcbiAgICAgICAgdGhpcy4kY2xpY2tFdmVudCA9IERlY2xzJDEuR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vbihJbnRlcmFjdGl2ZUV2ZW50cy5DbGljaywgdGhpcy4kY2xpY2ssIHRoaXMpO1xuICAgIH1cbiAgICAkbW91c2VNb3ZlKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHRvdWNoRWZmZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoKFNjcm9sbFBhbmUuZHJhZ2dpbmdQYW5lICE9IG51bGwgJiYgU2Nyb2xsUGFuZS5kcmFnZ2luZ1BhbmUgIT0gdGhpcykgfHxcbiAgICAgICAgICAgIEdPYmplY3QuZHJhZ2dpbmdPYmplY3QgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHNlbnNpdGl2aXR5ID0gVUlDb25maWcudG91Y2hTY3JvbGxTZW5zaXRpdml0eTtcbiAgICAgICAgY29uc3QgZ2xvYmFsTW91c2UgPSB0aGlzLiRvd25lci5nbG9iYWxUb0xvY2FsKERlY2xzJDEuR1Jvb3QuZ2xvYmFsTW91c2VTdGF0dXMubW91c2VYLCBEZWNscyQxLkdSb290Lmdsb2JhbE1vdXNlU3RhdHVzLm1vdXNlWSwgU2Nyb2xsUGFuZS5zSGVscGVyUG9pbnQpO1xuICAgICAgICBsZXQgZGlmZiwgZGlmZjI7XG4gICAgICAgIGxldCBzdiwgc2g7XG4gICAgICAgIGlmICh0aGlzLiRzY3JvbGxUeXBlID09IDEgLyogVmVydGljYWwgKi8pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kaXNIb2xkQXJlYURvbmUpIHtcbiAgICAgICAgICAgICAgICAvL2dlc3R1cmUgb24gdmVydGljYWwgZGlyIGlzIGJlaW5nIG9ic2VydmVkXG4gICAgICAgICAgICAgICAgU2Nyb2xsUGFuZS4kZ2VzdHVyZUZsYWcgfD0gMTtcbiAgICAgICAgICAgICAgICBkaWZmID0gTWF0aC5hYnModGhpcy4kYmVnaW5Ub3VjaFBvcy55IC0gZ2xvYmFsTW91c2UueSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgPCBzZW5zaXRpdml0eSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICgoU2Nyb2xsUGFuZS4kZ2VzdHVyZUZsYWcgJiAyKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmYyID0gTWF0aC5hYnModGhpcy4kYmVnaW5Ub3VjaFBvcy54IC0gZ2xvYmFsTW91c2UueCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWZmIDwgZGlmZjIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3YgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJHNjcm9sbFR5cGUgPT0gMCAvKiBIb3Jpem9udGFsICovKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJGlzSG9sZEFyZWFEb25lKSB7XG4gICAgICAgICAgICAgICAgU2Nyb2xsUGFuZS4kZ2VzdHVyZUZsYWcgfD0gMjsgLy9nZXN0dXJlIG9uIGhvcnogZGlyIGlzIGJlaW5nIG9ic2VydmVkXG4gICAgICAgICAgICAgICAgZGlmZiA9IE1hdGguYWJzKHRoaXMuJGJlZ2luVG91Y2hQb3MueCAtIGdsb2JhbE1vdXNlLngpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmIDwgc2Vuc2l0aXZpdHkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoKFNjcm9sbFBhbmUuJGdlc3R1cmVGbGFnICYgMSkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmMiA9IE1hdGguYWJzKHRoaXMuJGJlZ2luVG91Y2hQb3MueSAtIGdsb2JhbE1vdXNlLnkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA8IGRpZmYyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFNjcm9sbFBhbmUuJGdlc3R1cmVGbGFnID0gMzsgLy9ib3RoXG4gICAgICAgICAgICBpZiAoIXRoaXMuJGlzSG9sZEFyZWFEb25lKSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IE1hdGguYWJzKHRoaXMuJGJlZ2luVG91Y2hQb3MueSAtIGdsb2JhbE1vdXNlLnkpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmIDwgc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA9IE1hdGguYWJzKHRoaXMuJGJlZ2luVG91Y2hQb3MueCAtIGdsb2JhbE1vdXNlLngpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA8IHNlbnNpdGl2aXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN2ID0gc2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdQb3NYID0gTWF0aC5mbG9vcih0aGlzLiRjb250YWluZXJQb3MueCArIGdsb2JhbE1vdXNlLnggLSB0aGlzLiRiZWdpblRvdWNoUG9zLngpO1xuICAgICAgICBsZXQgbmV3UG9zWSA9IE1hdGguZmxvb3IodGhpcy4kY29udGFpbmVyUG9zLnkgKyBnbG9iYWxNb3VzZS55IC0gdGhpcy4kYmVnaW5Ub3VjaFBvcy55KTtcbiAgICAgICAgaWYgKHN2KSB7XG4gICAgICAgICAgICBpZiAobmV3UG9zWSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuJGJvdW5jZWJhY2tFZmZlY3QpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci55ID0gMDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRoZWFkZXIgIT0gbnVsbCAmJiB0aGlzLiRoZWFkZXIuaGVpZ2h0ICE9IDApXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETzogaGVpZ2h0IC0+IG1heEhlaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIueSA9IE1hdGguZmxvb3IoTWF0aC5taW4obmV3UG9zWSAqIDAuNSwgdGhpcy4kaGVhZGVyLmhlaWdodCkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnkgPSBNYXRoLmZsb29yKE1hdGgubWluKG5ld1Bvc1kgKiAwLjUsIHRoaXMuJHZpZXdTaXplLnkgKiBTY3JvbGxQYW5lLlBVTExfRElTVF9SQVRJTykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV3UG9zWSA8IC10aGlzLiRvdmVybGFwU2l6ZS55KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiRib3VuY2ViYWNrRWZmZWN0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIueSA9IC10aGlzLiRvdmVybGFwU2l6ZS55O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJGZvb3RlciAhPSBudWxsICYmIHRoaXMuJGZvb3Rlci5oZWlnaHQgPiAwKVxuICAgICAgICAgICAgICAgICAgICAvL1RPRE86IGhlaWdodCAtPiBtYXhIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnkgPSBNYXRoLmZsb29yKE1hdGgubWF4KChuZXdQb3NZICsgdGhpcy4kb3ZlcmxhcFNpemUueSkgKiAwLjUsIC10aGlzLiRmb290ZXIuaGVpZ2h0KSAtXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRvdmVybGFwU2l6ZS55KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci55ID0gTWF0aC5mbG9vcihNYXRoLm1heCgobmV3UG9zWSArIHRoaXMuJG92ZXJsYXBTaXplLnkpICogMC41LCAtdGhpcy4kdmlld1NpemUueSAqIFNjcm9sbFBhbmUuUFVMTF9ESVNUX1JBVElPKSAtIHRoaXMuJG92ZXJsYXBTaXplLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci55ID0gbmV3UG9zWTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2gpIHtcbiAgICAgICAgICAgIGlmIChuZXdQb3NYID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy4kYm91bmNlYmFja0VmZmVjdClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnggPSAwO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJGhlYWRlciAhPSBudWxsICYmIHRoaXMuJGhlYWRlci53aWR0aCAhPSAwKVxuICAgICAgICAgICAgICAgICAgICAvL1RPRE86IHdpZHRoIC0+IG1heFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci54ID0gTWF0aC5mbG9vcihNYXRoLm1pbihuZXdQb3NYICogMC41LCB0aGlzLiRoZWFkZXIud2lkdGgpKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci54ID0gTWF0aC5mbG9vcihNYXRoLm1pbihuZXdQb3NYICogMC41LCB0aGlzLiR2aWV3U2l6ZS54ICogU2Nyb2xsUGFuZS5QVUxMX0RJU1RfUkFUSU8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld1Bvc1ggPCAwIC0gdGhpcy4kb3ZlcmxhcFNpemUueCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy4kYm91bmNlYmFja0VmZmVjdClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnggPSAtdGhpcy4kb3ZlcmxhcFNpemUueDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRmb290ZXIgIT0gbnVsbCAmJiB0aGlzLiRmb290ZXIud2lkdGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAvL1RPRE86IHdpZHRoIC0+IG1heFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci54ID0gTWF0aC5mbG9vcihNYXRoLm1heCgobmV3UG9zWCArIHRoaXMuJG92ZXJsYXBTaXplLngpICogMC41LCAtdGhpcy4kZm9vdGVyLndpZHRoKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRvdmVybGFwU2l6ZS54KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci54ID0gTWF0aC5mbG9vcihNYXRoLm1heCgobmV3UG9zWCArIHRoaXMuJG92ZXJsYXBTaXplLngpICogMC41LCAtdGhpcy4kdmlld1NpemUueCAqIFNjcm9sbFBhbmUuUFVMTF9ESVNUX1JBVElPKSAtIHRoaXMuJG92ZXJsYXBTaXplLngpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci54ID0gbmV3UG9zWDtcbiAgICAgICAgfVxuICAgICAgICAvL3VwZGF0ZSBhY2NlbGVyYXRpb25cbiAgICAgICAgY29uc3QgZnJhbWVSYXRlID0gY3JlYXRlanMuVGlja2VyLmZyYW1lcmF0ZTtcbiAgICAgICAgY29uc3Qgbm93ID0gR1RpbWVyLmluc3QuY3VyVGltZSAvIDEwMDA7XG4gICAgICAgIGNvbnN0IGRlbHRhVGltZSA9IE1hdGgubWF4KG5vdyAtIHRoaXMuJGxhc3RNb3ZlVGltZSwgMSAvIGZyYW1lUmF0ZSk7XG4gICAgICAgIGxldCBkZWx0YVBvc2l0aW9uWCA9IGdsb2JhbE1vdXNlLnggLSB0aGlzLiRsYXN0VG91Y2hQb3MueDtcbiAgICAgICAgbGV0IGRlbHRhUG9zaXRpb25ZID0gZ2xvYmFsTW91c2UueSAtIHRoaXMuJGxhc3RUb3VjaFBvcy55O1xuICAgICAgICBpZiAoIXNoKVxuICAgICAgICAgICAgZGVsdGFQb3NpdGlvblggPSAwO1xuICAgICAgICBpZiAoIXN2KVxuICAgICAgICAgICAgZGVsdGFQb3NpdGlvblkgPSAwO1xuICAgICAgICBpZiAoZGVsdGFUaW1lICE9IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVsYXBzZWQgPSBkZWx0YVRpbWUgKiBmcmFtZVJhdGUgLSAxO1xuICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gTWF0aC5wb3coMC44MzMsIGVsYXBzZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHZlbG9jaXR5LnggPSB0aGlzLiR2ZWxvY2l0eS54ICogZmFjdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuJHZlbG9jaXR5LnkgPSB0aGlzLiR2ZWxvY2l0eS55ICogZmFjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kdmVsb2NpdHkueCA9IE51bWJlclV0aWwubGVycCh0aGlzLiR2ZWxvY2l0eS54LCAoZGVsdGFQb3NpdGlvblggKiA2MCkgLyBmcmFtZVJhdGUgLyBkZWx0YVRpbWUsIGRlbHRhVGltZSAqIDEwKTtcbiAgICAgICAgICAgIHRoaXMuJHZlbG9jaXR5LnkgPSBOdW1iZXJVdGlsLmxlcnAodGhpcy4kdmVsb2NpdHkueSwgKGRlbHRhUG9zaXRpb25ZICogNjApIC8gZnJhbWVSYXRlIC8gZGVsdGFUaW1lLCBkZWx0YVRpbWUgKiAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9pbiB0aGUgaW5lcnRpYSBzY3JvbGxpbmcgd2UgbmVlZCB0aGUgb2Zmc2V0IHZhbHVlIHRvIHNjcmVlbiBzcGFjZSwgc28gaGVyZSB3ZSBuZWVkIHRvIHJlb2NyZCB0aGUgb2Zmc2V0IHJhdGlvXG4gICAgICAgIGNvbnN0IGRlbHRhR2xvYmFsUG9zaXRpb25YID0gdGhpcy4kbGFzdFRvdWNoR2xvYmFsUG9zLnggLSBnbG9iYWxNb3VzZS54O1xuICAgICAgICBjb25zdCBkZWx0YUdsb2JhbFBvc2l0aW9uWSA9IHRoaXMuJGxhc3RUb3VjaEdsb2JhbFBvcy55IC0gZ2xvYmFsTW91c2UueTtcbiAgICAgICAgaWYgKGRlbHRhUG9zaXRpb25YICE9IDApXG4gICAgICAgICAgICB0aGlzLiR2ZWxvY2l0eVNjYWxlID0gTWF0aC5hYnMoZGVsdGFHbG9iYWxQb3NpdGlvblggLyBkZWx0YVBvc2l0aW9uWCk7XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhUG9zaXRpb25ZICE9IDApXG4gICAgICAgICAgICB0aGlzLiR2ZWxvY2l0eVNjYWxlID0gTWF0aC5hYnMoZGVsdGFHbG9iYWxQb3NpdGlvblkgLyBkZWx0YVBvc2l0aW9uWSk7XG4gICAgICAgIHRoaXMuJGxhc3RUb3VjaFBvcy5jb3B5KGdsb2JhbE1vdXNlKTtcbiAgICAgICAgdGhpcy4kbGFzdFRvdWNoR2xvYmFsUG9zLmNvcHkoZ2xvYmFsTW91c2UpO1xuICAgICAgICB0aGlzLiRsYXN0TW92ZVRpbWUgPSBub3c7XG4gICAgICAgIC8vdXBkYXRlIHBvc2l0aW9uXG4gICAgICAgIGlmICh0aGlzLiRvdmVybGFwU2l6ZS54ID4gMClcbiAgICAgICAgICAgIHRoaXMuJHhQb3MgPSBOdW1iZXJVdGlsLmNsYW1wKC10aGlzLiRjb250YWluZXIueCwgMCwgdGhpcy4kb3ZlcmxhcFNpemUueCk7XG4gICAgICAgIGlmICh0aGlzLiRvdmVybGFwU2l6ZS55ID4gMClcbiAgICAgICAgICAgIHRoaXMuJHlQb3MgPSBOdW1iZXJVdGlsLmNsYW1wKC10aGlzLiRjb250YWluZXIueSwgMCwgdGhpcy4kb3ZlcmxhcFNpemUueSk7XG4gICAgICAgIGlmICh0aGlzLiRsb29wICE9IDApIHtcbiAgICAgICAgICAgIG5ld1Bvc1ggPSB0aGlzLiRjb250YWluZXIueDtcbiAgICAgICAgICAgIG5ld1Bvc1kgPSB0aGlzLiRjb250YWluZXIueTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvb3BDaGVja2luZ0N1cnJlbnQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lclBvcy54ICs9IHRoaXMuJGNvbnRhaW5lci54IC0gbmV3UG9zWDtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXJQb3MueSArPSB0aGlzLiRjb250YWluZXIueSAtIG5ld1Bvc1k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgU2Nyb2xsUGFuZS5kcmFnZ2luZ1BhbmUgPSB0aGlzO1xuICAgICAgICB0aGlzLiRpc0hvbGRBcmVhRG9uZSA9IHRydWU7XG4gICAgICAgIHRoaXMuJGlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAvLyB0aGlzLiRtYXNrQ29udGFpbmVyLmludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3luY1Njcm9sbEJhcigpO1xuICAgICAgICB0aGlzLmNoZWNrUmVmcmVzaEJhcigpO1xuICAgICAgICBpZiAodGhpcy4kcGFnZU1vZGUpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhZ2VDb250cm9sbGVyKCk7XG4gICAgICAgIGxldCBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJfX3Njcm9sbFwiIC8qIFNDUk9MTCAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0LCB0aGlzKTtcbiAgICB9XG4gICAgJG1vdXNlVXAoKSB7XG4gICAgICAgIERlY2xzJDEuR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vZmYoSW50ZXJhY3RpdmVFdmVudHMuTW92ZSwgdGhpcy4kbW91c2VNb3ZlRXZlbnQpO1xuICAgICAgICBEZWNscyQxLkdSb290Lmluc3QubmF0aXZlU3RhZ2Uub2ZmKEludGVyYWN0aXZlRXZlbnRzLlVwLCB0aGlzLiRtb3VzZU1vdmVFdmVudCk7XG4gICAgICAgIERlY2xzJDEuR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vZmYoSW50ZXJhY3RpdmVFdmVudHMuQ2xpY2ssIHRoaXMuJGNsaWNrRXZlbnQpO1xuICAgICAgICBpZiAoU2Nyb2xsUGFuZS5kcmFnZ2luZ1BhbmUgPT0gdGhpcylcbiAgICAgICAgICAgIFNjcm9sbFBhbmUuZHJhZ2dpbmdQYW5lID0gbnVsbDtcbiAgICAgICAgU2Nyb2xsUGFuZS4kZ2VzdHVyZUZsYWcgPSAwO1xuICAgICAgICBpZiAoIXRoaXMuJGlzRHJhZ2dpbmcgfHwgIXRoaXMuJHRvdWNoRWZmZWN0KSB7XG4gICAgICAgICAgICB0aGlzLiRpc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRtYXNrQ29udGFpbmVyLm1vdXNlRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRtYXNrQ29udGFpbmVyLm1vdXNlRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuJHR3ZWVuU3RhcnQuc2V0VmFsdWVzKHRoaXMuJGNvbnRhaW5lci54LCB0aGlzLiRjb250YWluZXIueSk7XG4gICAgICAgIFNjcm9sbFBhbmUuc0VuZFBvcy5zZXRWYWx1ZXModGhpcy4kdHdlZW5TdGFydC54LCB0aGlzLiR0d2VlblN0YXJ0LnkpO1xuICAgICAgICBsZXQgZmxhZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4kY29udGFpbmVyLnggPiAwKSB7XG4gICAgICAgICAgICBTY3JvbGxQYW5lLnNFbmRQb3MueCA9IDA7XG4gICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiRjb250YWluZXIueCA8IC10aGlzLiRvdmVybGFwU2l6ZS54KSB7XG4gICAgICAgICAgICBTY3JvbGxQYW5lLnNFbmRQb3MueCA9IC10aGlzLiRvdmVybGFwU2l6ZS54O1xuICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGNvbnRhaW5lci55ID4gMCkge1xuICAgICAgICAgICAgU2Nyb2xsUGFuZS5zRW5kUG9zLnkgPSAwO1xuICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy4kY29udGFpbmVyLnkgPCAtdGhpcy4kb3ZlcmxhcFNpemUueSkge1xuICAgICAgICAgICAgU2Nyb2xsUGFuZS5zRW5kUG9zLnkgPSAtdGhpcy4kb3ZlcmxhcFNpemUueTtcbiAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICAgICB0aGlzLiR0d2VlbkNoYW5nZS5zZXRWYWx1ZXMoU2Nyb2xsUGFuZS5zRW5kUG9zLnggLSB0aGlzLiR0d2VlblN0YXJ0LngsIFNjcm9sbFBhbmUuc0VuZFBvcy55IC0gdGhpcy4kdHdlZW5TdGFydC55KTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0d2VlbkNoYW5nZS54IDwgLVVJQ29uZmlnLnRvdWNoRHJhZ1NlbnNpdGl2aXR5IHx8XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5DaGFuZ2UueSA8IC1VSUNvbmZpZy50b3VjaERyYWdTZW5zaXRpdml0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnJlc2hFdmVudERpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX19wdWxsRG93blJlbGVhc2VcIiAvKiBQVUxMX0RPV05fUkVMRUFTRSAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnJlc2hFdmVudERpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLiR0d2VlbkNoYW5nZS54ID4gVUlDb25maWcudG91Y2hEcmFnU2Vuc2l0aXZpdHkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlbkNoYW5nZS55ID4gVUlDb25maWcudG91Y2hEcmFnU2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZyZXNoRXZlbnREaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcIl9fcHVsbFVwUmVsZWFzZVwiIC8qIFBVTExfVVBfUkVMRUFTRSAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnJlc2hFdmVudERpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kaGVhZGVyTG9ja2VkU2l6ZSA+IDAgJiZcbiAgICAgICAgICAgICAgICBTY3JvbGxQYW5lLnNFbmRQb3NbdGhpcy4kcmVmcmVzaEJhckF4aXNdID09IDApIHtcbiAgICAgICAgICAgICAgICBTY3JvbGxQYW5lLnNFbmRQb3NbdGhpcy4kcmVmcmVzaEJhckF4aXNdID0gdGhpcy4kaGVhZGVyTG9ja2VkU2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlbkNoYW5nZS54ID0gU2Nyb2xsUGFuZS5zRW5kUG9zLnggLSB0aGlzLiR0d2VlblN0YXJ0Lng7XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5DaGFuZ2UueSA9IFNjcm9sbFBhbmUuc0VuZFBvcy55IC0gdGhpcy4kdHdlZW5TdGFydC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4kZm9vdGVyTG9ja2VkU2l6ZSA+IDAgJiZcbiAgICAgICAgICAgICAgICBTY3JvbGxQYW5lLnNFbmRQb3NbdGhpcy4kcmVmcmVzaEJhckF4aXNdID09XG4gICAgICAgICAgICAgICAgICAgIC10aGlzLiRvdmVybGFwU2l6ZVt0aGlzLiRyZWZyZXNoQmFyQXhpc10pIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4ID0gdGhpcy4kb3ZlcmxhcFNpemVbdGhpcy4kcmVmcmVzaEJhckF4aXNdO1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgodGhpcy4kY29udGVudFNpemVbdGhpcy4kcmVmcmVzaEJhckF4aXNdICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvb3RlckxvY2tlZFNpemUgLVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kdmlld1NpemVbdGhpcy4kcmVmcmVzaEJhckF4aXNdLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG1heCArPSB0aGlzLiRmb290ZXJMb2NrZWRTaXplO1xuICAgICAgICAgICAgICAgIFNjcm9sbFBhbmUuc0VuZFBvc1t0aGlzLiRyZWZyZXNoQmFyQXhpc10gPSAtbWF4O1xuICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuQ2hhbmdlLnggPSBTY3JvbGxQYW5lLnNFbmRQb3MueCAtIHRoaXMuJHR3ZWVuU3RhcnQueDtcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlbkNoYW5nZS55ID0gU2Nyb2xsUGFuZS5zRW5kUG9zLnkgLSB0aGlzLiR0d2VlblN0YXJ0Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiR0d2VlbkR1cmF0aW9uLnNldFZhbHVlcyhTY3JvbGxQYW5lLlRXRUVOX0RFRkFVTFRfRFVSQVRJT04sIFNjcm9sbFBhbmUuVFdFRU5fREVGQVVMVF9EVVJBVElPTik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJGluZXJ0aWFEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lUmF0ZSA9IGNyZWF0ZWpzLlRpY2tlci5mcmFtZXJhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IChHVGltZXIuaW5zdC5jdXJUaW1lIC8gMTAwMCAtIHRoaXMuJGxhc3RNb3ZlVGltZSkgKiBmcmFtZVJhdGUgLSAxO1xuICAgICAgICAgICAgICAgIGlmIChlbGFwc2VkID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmYWN0b3IgPSBNYXRoLnBvdygwLjgzMywgZWxhcHNlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHZlbG9jaXR5LnggPSB0aGlzLiR2ZWxvY2l0eS54ICogZmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR2ZWxvY2l0eS55ID0gdGhpcy4kdmVsb2NpdHkueSAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9jYWxjIGRpc3QgJiBkdXJhdGlvbiBieSBzcGVlZFxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGFyZ2V0QW5kRHVyYXRpb24odGhpcy4kdHdlZW5TdGFydCwgU2Nyb2xsUGFuZS5zRW5kUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlbkR1cmF0aW9uLnNldFZhbHVlcyhTY3JvbGxQYW5lLlRXRUVOX0RFRkFVTFRfRFVSQVRJT04sIFNjcm9sbFBhbmUuVFdFRU5fREVGQVVMVF9EVVJBVElPTik7XG4gICAgICAgICAgICBTY3JvbGxQYW5lLnNPbGRDaGFuZ2Uuc2V0VmFsdWVzKFNjcm9sbFBhbmUuc0VuZFBvcy54IC0gdGhpcy4kdHdlZW5TdGFydC54LCBTY3JvbGxQYW5lLnNFbmRQb3MueSAtIHRoaXMuJHR3ZWVuU3RhcnQueSk7XG4gICAgICAgICAgICAvL2FkanVzdFxuICAgICAgICAgICAgdGhpcy5sb29wQ2hlY2tpbmdUYXJnZXQoU2Nyb2xsUGFuZS5zRW5kUG9zKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRwYWdlTW9kZSB8fCB0aGlzLiRzbmFwVG9JdGVtKVxuICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25Qb3NpdGlvbihTY3JvbGxQYW5lLnNFbmRQb3MsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy4kdHdlZW5DaGFuZ2UueCA9IFNjcm9sbFBhbmUuc0VuZFBvcy54IC0gdGhpcy4kdHdlZW5TdGFydC54O1xuICAgICAgICAgICAgdGhpcy4kdHdlZW5DaGFuZ2UueSA9IFNjcm9sbFBhbmUuc0VuZFBvcy55IC0gdGhpcy4kdHdlZW5TdGFydC55O1xuICAgICAgICAgICAgaWYgKHRoaXMuJHR3ZWVuQ2hhbmdlLnggPT0gMCAmJiB0aGlzLiR0d2VlbkNoYW5nZS55ID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kc2Nyb2xsQmFyRGlzcGxheUF1dG8pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Njcm9sbEJhcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuJHBhZ2VNb2RlIHx8IHRoaXMuJHNuYXBUb0l0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpeER1cmF0aW9uKCd4JywgU2Nyb2xsUGFuZS5zT2xkQ2hhbmdlLngpO1xuICAgICAgICAgICAgICAgIHRoaXMuZml4RHVyYXRpb24oJ3knLCBTY3JvbGxQYW5lLnNPbGRDaGFuZ2UueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kdHdlZW5pbmcgPSAyO1xuICAgICAgICB0aGlzLiR0d2VlblRpbWUuc2V0VmFsdWVzKDAsIDApO1xuICAgICAgICBHVGltZXIuaW5zdC5hZGRMb29wKDEsIHRoaXMudHdlZW5VcGRhdGUsIHRoaXMpO1xuICAgIH1cbiAgICAkY2xpY2soKSB7XG4gICAgICAgIHRoaXMuJGlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgJG1vdXNlV2hlZWwoZXZ0KSB7XG4gICAgICAgIGxldCBldmVudCA9IGV2dC5kYXRhLmV2ZW50O1xuICAgICAgICBpZiAoIXRoaXMuJG1vdXNlV2hlZWxFbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGV2ZW50LmRlbHRhID4gMCA/IC0xIDogZXZlbnQuZGVsdGEgPCAwID8gMSA6IDA7XG4gICAgICAgIGlmICh0aGlzLiRvdmVybGFwU2l6ZS54ID4gMCAmJiB0aGlzLiRvdmVybGFwU2l6ZS55ID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRwYWdlTW9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBvc1godGhpcy4keFBvcyArIHRoaXMuJHBhZ2VTaXplLnggKiBkZWx0YSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zWCh0aGlzLiR4UG9zICsgdGhpcy4kbW91c2VXaGVlbFNwZWVkICogZGVsdGEsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRwYWdlTW9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBvc1kodGhpcy4keVBvcyArIHRoaXMuJHBhZ2VTaXplLnkgKiBkZWx0YSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zWSh0aGlzLiR5UG9zICsgdGhpcy4kbW91c2VXaGVlbFNwZWVkICogZGVsdGEsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAkcm9sbE92ZXIoKSB7XG4gICAgICAgIHRoaXMuc2hvd1Njcm9sbEJhcih0cnVlKTtcbiAgICB9XG4gICAgJHJvbGxPdXQoKSB7XG4gICAgICAgIHRoaXMuc2hvd1Njcm9sbEJhcihmYWxzZSk7XG4gICAgfVxuICAgIHNob3dTY3JvbGxCYXIodmlzaWJsZSkge1xuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgR1RpbWVyLmluc3QucmVtb3ZlKHRoaXMuc2V0U2Nyb2xsQmFyVmlzaWJsZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNldFNjcm9sbEJhclZpc2libGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgR1RpbWVyLmluc3QuYWRkKDUwMCwgMSwgdGhpcy5zZXRTY3JvbGxCYXJWaXNpYmxlLCB0aGlzLCB2aXNpYmxlKTtcbiAgICB9XG4gICAgc2V0U2Nyb2xsQmFyVmlzaWJsZSh2aXNpYmxlKSB7XG4gICAgICAgIHRoaXMuJHNjcm9sbEJhclZpc2libGUgPSB2aXNpYmxlICYmIHRoaXMuJHZpZXdTaXplLnggPiAwICYmIHRoaXMuJHZpZXdTaXplLnkgPiAwO1xuICAgICAgICBpZiAodGhpcy4kdnRTY3JvbGxCYXIpXG4gICAgICAgICAgICB0aGlzLiR2dFNjcm9sbEJhci5kaXNwbGF5T2JqZWN0LnZpc2libGUgPSB0aGlzLiRzY3JvbGxCYXJWaXNpYmxlICYmICF0aGlzLiR2U2Nyb2xsTm9uZTtcbiAgICAgICAgaWYgKHRoaXMuJGh6U2Nyb2xsQmFyKVxuICAgICAgICAgICAgdGhpcy4kaHpTY3JvbGxCYXIuZGlzcGxheU9iamVjdC52aXNpYmxlID0gdGhpcy4kc2Nyb2xsQmFyVmlzaWJsZSAmJiAhdGhpcy4kaFNjcm9sbE5vbmU7XG4gICAgfVxuICAgIGdldExvb3BQYXJ0U2l6ZShkaXZpc2lvbiwgYXhpcykge1xuICAgICAgICBsZXQgcGFkID0gMDtcbiAgICAgICAgLy8gaWYgKHRoaXMuJG93bmVyIGluc3RhbmNlb2YgR0xpc3QpXG4gICAgICAgIC8vICAgICBwYWQgPSBheGlzID09IFwieFwiID8gdGhpcy4kb3duZXIuY29sdW1uR2FwIDogdGhpcy4kb3duZXIubGluZUdhcDtcbiAgICAgICAgcmV0dXJuICh0aGlzLiRjb250ZW50U2l6ZVtheGlzXSArIHBhZCkgLyBkaXZpc2lvbjtcbiAgICB9XG4gICAgbG9vcENoZWNraW5nQ3VycmVudCgpIHtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuJGxvb3AgPT0gMSAmJiB0aGlzLiRvdmVybGFwU2l6ZS54ID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHhQb3MgPCAwLjAwMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHhQb3MgKz0gdGhpcy5nZXRMb29wUGFydFNpemUoMiwgJ3gnKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJHhQb3MgPj0gdGhpcy4kb3ZlcmxhcFNpemUueCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHhQb3MgLT0gdGhpcy5nZXRMb29wUGFydFNpemUoMiwgJ3gnKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiRsb29wID09IDIgJiYgdGhpcy4kb3ZlcmxhcFNpemUueSA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR5UG9zIDwgMC4wMDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR5UG9zICs9IHRoaXMuZ2V0TG9vcFBhcnRTaXplKDIsICd5Jyk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLiR5UG9zID49IHRoaXMuJG92ZXJsYXBTaXplLnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR5UG9zIC09IHRoaXMuZ2V0TG9vcFBhcnRTaXplKDIsICd5Jyk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIuc2V0KHsgeDogTWF0aC5mbG9vcigtdGhpcy4keFBvcyksIHk6IE1hdGguZmxvb3IoLXRoaXMuJHlQb3MpIH0pO1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgbG9vcENoZWNraW5nVGFyZ2V0KGVuZFBvcykge1xuICAgICAgICBpZiAodGhpcy4kbG9vcCA9PSAxKVxuICAgICAgICAgICAgdGhpcy5sb29wQ2hlY2tpbmdUYXJnZXQyKGVuZFBvcywgJ3gnKTtcbiAgICAgICAgaWYgKHRoaXMuJGxvb3AgPT0gMilcbiAgICAgICAgICAgIHRoaXMubG9vcENoZWNraW5nVGFyZ2V0MihlbmRQb3MsICd5Jyk7XG4gICAgfVxuICAgIGxvb3BDaGVja2luZ1RhcmdldDIoZW5kUG9zLCBheGlzKSB7XG4gICAgICAgIGxldCBoYWxmU2l6ZTtcbiAgICAgICAgbGV0IHRtcDtcbiAgICAgICAgaWYgKGVuZFBvc1theGlzXSA+IDApIHtcbiAgICAgICAgICAgIGhhbGZTaXplID0gdGhpcy5nZXRMb29wUGFydFNpemUoMiwgYXhpcyk7XG4gICAgICAgICAgICB0bXAgPSB0aGlzLiR0d2VlblN0YXJ0W2F4aXNdIC0gaGFsZlNpemU7XG4gICAgICAgICAgICBpZiAodG1wIDw9IDAgJiYgdG1wID49IC10aGlzLiRvdmVybGFwU2l6ZVtheGlzXSkge1xuICAgICAgICAgICAgICAgIGVuZFBvc1theGlzXSAtPSBoYWxmU2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlblN0YXJ0W2F4aXNdID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVuZFBvc1theGlzXSA8IC10aGlzLiRvdmVybGFwU2l6ZVtheGlzXSkge1xuICAgICAgICAgICAgaGFsZlNpemUgPSB0aGlzLmdldExvb3BQYXJ0U2l6ZSgyLCBheGlzKTtcbiAgICAgICAgICAgIHRtcCA9IHRoaXMuJHR3ZWVuU3RhcnRbYXhpc10gKyBoYWxmU2l6ZTtcbiAgICAgICAgICAgIGlmICh0bXAgPD0gMCAmJiB0bXAgPj0gLXRoaXMuJG92ZXJsYXBTaXplW2F4aXNdKSB7XG4gICAgICAgICAgICAgICAgZW5kUG9zW2F4aXNdICs9IGhhbGZTaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuU3RhcnRbYXhpc10gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9vcENoZWNraW5nTmV3UG9zKHZhbHVlLCBheGlzKSB7XG4gICAgICAgIGlmICh0aGlzLiRvdmVybGFwU2l6ZVtheGlzXSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBsZXQgcG9zID0gYXhpcyA9PSAneCcgPyB0aGlzLiR4UG9zIDogdGhpcy4keVBvcztcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAuMDAxKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLmdldExvb3BQYXJ0U2l6ZSgyLCBheGlzKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IHBvcykge1xuICAgICAgICAgICAgICAgIHYgPSB0aGlzLmdldExvb3BQYXJ0U2l6ZSg2LCBheGlzKTtcbiAgICAgICAgICAgICAgICB2ID0gTWF0aC5jZWlsKCh2YWx1ZSAtIHBvcykgLyB2KSAqIHY7XG4gICAgICAgICAgICAgICAgcG9zID0gTnVtYmVyVXRpbC5jbGFtcChwb3MgKyB2LCAwLCB0aGlzLiRvdmVybGFwU2l6ZVtheGlzXSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPj0gdGhpcy4kb3ZlcmxhcFNpemVbYXhpc10pIHtcbiAgICAgICAgICAgIHZhbHVlIC09IHRoaXMuZ2V0TG9vcFBhcnRTaXplKDIsIGF4aXMpO1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgcG9zKSB7XG4gICAgICAgICAgICAgICAgdiA9IHRoaXMuZ2V0TG9vcFBhcnRTaXplKDYsIGF4aXMpO1xuICAgICAgICAgICAgICAgIHYgPSBNYXRoLmNlaWwoKHBvcyAtIHZhbHVlKSAvIHYpICogdjtcbiAgICAgICAgICAgICAgICBwb3MgPSBOdW1iZXJVdGlsLmNsYW1wKHBvcyAtIHYsIDAsIHRoaXMuJG92ZXJsYXBTaXplW2F4aXNdKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKGF4aXMgPT0gJ3gnKVxuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci54ID0gLU1hdGguZmxvb3IocG9zKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIueSA9IC1NYXRoLmZsb29yKHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBhbGlnblBvc2l0aW9uKHBvcywgaW5lcnRpYWxTY3JvbGxpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuJHBhZ2VNb2RlKSB7XG4gICAgICAgICAgICBwb3MueCA9IHRoaXMuYWxpZ25CeVBhZ2UocG9zLngsICd4JywgaW5lcnRpYWxTY3JvbGxpbmcpO1xuICAgICAgICAgICAgcG9zLnkgPSB0aGlzLmFsaWduQnlQYWdlKHBvcy55LCAneScsIGluZXJ0aWFsU2Nyb2xsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiRzbmFwVG9JdGVtKSB7XG4gICAgICAgICAgICB2YXIgcHQgPSB0aGlzLiRvd25lci5nZXRTbmFwcGluZ1Bvc2l0aW9uKC1wb3MueCwgLXBvcy55LCBTY3JvbGxQYW5lLnNIZWxwZXJQb2ludCk7XG4gICAgICAgICAgICBpZiAocG9zLnggPCAwICYmIHBvcy54ID4gLXRoaXMuJG92ZXJsYXBTaXplLngpXG4gICAgICAgICAgICAgICAgcG9zLnggPSAtcHQueDtcbiAgICAgICAgICAgIGlmIChwb3MueSA8IDAgJiYgcG9zLnkgPiAtdGhpcy4kb3ZlcmxhcFNpemUueSlcbiAgICAgICAgICAgICAgICBwb3MueSA9IC1wdC55O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFsaWduQnlQYWdlKHBvcywgYXhpcywgaW5lcnRpYWxTY3JvbGxpbmcpIHtcbiAgICAgICAgbGV0IHBhZ2U7XG4gICAgICAgIGlmIChwb3MgPiAwKVxuICAgICAgICAgICAgcGFnZSA9IDA7XG4gICAgICAgIGVsc2UgaWYgKHBvcyA8IC10aGlzLiRvdmVybGFwU2l6ZVtheGlzXSlcbiAgICAgICAgICAgIHBhZ2UgPVxuICAgICAgICAgICAgICAgIE1hdGguY2VpbCh0aGlzLiRjb250ZW50U2l6ZVtheGlzXSAvIHRoaXMuJHBhZ2VTaXplW2F4aXNdKSAtIDE7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFnZSA9IE1hdGguZmxvb3IoLXBvcyAvIHRoaXMuJHBhZ2VTaXplW2F4aXNdKTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBpbmVydGlhbFNjcm9sbGluZ1xuICAgICAgICAgICAgICAgID8gcG9zIC0gdGhpcy4kY29udGFpbmVyUG9zW2F4aXNdXG4gICAgICAgICAgICAgICAgOiBwb3MgLSB0aGlzLiRjb250YWluZXJbYXhpc107XG4gICAgICAgICAgICB2YXIgdGVzdFBhZ2VTaXplID0gTWF0aC5taW4odGhpcy4kcGFnZVNpemVbYXhpc10sIHRoaXMuJGNvbnRlbnRTaXplW2F4aXNdIC1cbiAgICAgICAgICAgICAgICAocGFnZSArIDEpICogdGhpcy4kcGFnZVNpemVbYXhpc10pO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gLXBvcyAtIHBhZ2UgKiB0aGlzLiRwYWdlU2l6ZVtheGlzXTtcbiAgICAgICAgICAgIC8vcGFnZSBtb2RlIG1hZ25ldGljXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoY2hhbmdlKSA+IHRoaXMuJHBhZ2VTaXplW2F4aXNdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhID4gdGVzdFBhZ2VTaXplICogMC41KVxuICAgICAgICAgICAgICAgICAgICBwYWdlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGEgPiB0ZXN0UGFnZVNpemUgKiAoY2hhbmdlIDwgMCA/IDAuMyA6IDAuNykpXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vcmUtY2FsYyBkaXN0XG4gICAgICAgICAgICBjb25zdCBkc3QgPSB0aGlzLiRwYWdlU2l6ZVtheGlzXTtcbiAgICAgICAgICAgIHBvcyA9IC1wYWdlICogZHN0O1xuICAgICAgICAgICAgaWYgKHBvcyA8IC1kc3QpXG4gICAgICAgICAgICAgICAgcG9zID0gLWRzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5lcnRpYWxTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHZhciBvbGRQb3MgPSB0aGlzLiR0d2VlblN0YXJ0W2F4aXNdO1xuICAgICAgICAgICAgdmFyIG9sZFBhZ2U7XG4gICAgICAgICAgICBpZiAob2xkUG9zID4gMClcbiAgICAgICAgICAgICAgICBvbGRQYWdlID0gMDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9sZFBvcyA8IC10aGlzLiRvdmVybGFwU2l6ZVtheGlzXSlcbiAgICAgICAgICAgICAgICBvbGRQYWdlID1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKHRoaXMuJGNvbnRlbnRTaXplW2F4aXNdIC8gdGhpcy4kcGFnZVNpemVbYXhpc10pIC0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvbGRQYWdlID0gTWF0aC5mbG9vcigtb2xkUG9zIC8gdGhpcy4kcGFnZVNpemVbYXhpc10pO1xuICAgICAgICAgICAgdmFyIHN0YXJ0UGFnZSA9IE1hdGguZmxvb3IoLXRoaXMuJGNvbnRhaW5lclBvc1theGlzXSAvIHRoaXMuJHBhZ2VTaXplW2F4aXNdKTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhwYWdlIC0gc3RhcnRQYWdlKSA+IDEgJiYgTWF0aC5hYnMob2xkUGFnZSAtIHN0YXJ0UGFnZSkgPD0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChwYWdlID4gc3RhcnRQYWdlKVxuICAgICAgICAgICAgICAgICAgICBwYWdlID0gc3RhcnRQYWdlICsgMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UgPSBzdGFydFBhZ2UgLSAxO1xuICAgICAgICAgICAgICAgIHBvcyA9IC1wYWdlICogdGhpcy4kcGFnZVNpemVbYXhpc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgdXBkYXRlVGFyZ2V0QW5kRHVyYXRpb24ob3JpZ25Qb3MsIHJlc3VsdFBvcykge1xuICAgICAgICByZXN1bHRQb3MueCA9IHRoaXMudXBkYXRlVGFyZ2V0QW5kRHVyYXRpb24yKG9yaWduUG9zLngsICd4Jyk7XG4gICAgICAgIHJlc3VsdFBvcy55ID0gdGhpcy51cGRhdGVUYXJnZXRBbmREdXJhdGlvbjIob3JpZ25Qb3MueSwgJ3knKTtcbiAgICB9XG4gICAgdXBkYXRlVGFyZ2V0QW5kRHVyYXRpb24yKHBvcywgYXhpcykge1xuICAgICAgICBsZXQgdiA9IHRoaXMuJHZlbG9jaXR5W2F4aXNdO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSAwO1xuICAgICAgICBpZiAocG9zID4gMClcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIGVsc2UgaWYgKHBvcyA8IC10aGlzLiRvdmVybGFwU2l6ZVtheGlzXSlcbiAgICAgICAgICAgIHBvcyA9IC10aGlzLiRvdmVybGFwU2l6ZVtheGlzXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdjIgPSBNYXRoLmFicyh2KSAqIHRoaXMuJHZlbG9jaXR5U2NhbGU7XG4gICAgICAgICAgICBpZiAoaXNNb2JpbGUuYW55KVxuICAgICAgICAgICAgICAgIHYyICo9XG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KERlY2xzJDEuR1Jvb3QuaW5zdC5zdGFnZVdyYXBwZXIuZGVzaWduV2lkdGgsIERlY2xzJDEuR1Jvb3QuaW5zdC5zdGFnZVdyYXBwZXIuZGVzaWduSGVpZ2h0KSAvIE1hdGgubWF4KERlY2xzJDEuR1Jvb3QuaW5zdC5zdGFnZVdpZHRoLCBEZWNscyQxLkdSb290Lmluc3Quc3RhZ2VIZWlnaHQpO1xuICAgICAgICAgICAgLy90aHJlc2hvbGQsIGlmIHRvbyBzbG93LCBzdG9wIGl0XG4gICAgICAgICAgICBsZXQgcmF0aW8gPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHBhZ2VNb2RlIHx8ICFpc01vYmlsZS5hbnkpIHtcbiAgICAgICAgICAgICAgICBpZiAodjIgPiA1MDApXG4gICAgICAgICAgICAgICAgICAgIHJhdGlvID0gTWF0aC5wb3coKHYyIC0gNTAwKSAvIDUwMCwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodjIgPiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICByYXRpbyA9IE1hdGgucG93KCh2MiAtIDEwMDApIC8gMTAwMCwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmF0aW8gIT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChyYXRpbyA+IDEpXG4gICAgICAgICAgICAgICAgICAgIHJhdGlvID0gMTtcbiAgICAgICAgICAgICAgICB2MiAqPSByYXRpbztcbiAgICAgICAgICAgICAgICB2ICo9IHJhdGlvO1xuICAgICAgICAgICAgICAgIHRoaXMuJHZlbG9jaXR5W2F4aXNdID0gdjtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubG9nKDYwIC8gdjIpIC8gTWF0aC5sb2codGhpcy4kZGVjZWxlcmF0aW9uUmF0ZSkgLyA2MDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSAodiAvIDYwIC0gMSkgLyAoMSAtIHRoaXMuJGRlY2VsZXJhdGlvblJhdGUpO1xuICAgICAgICAgICAgICAgIC8vY29uc3QgY2hhbmdlOiBudW1iZXIgPSBNYXRoLmZsb29yKHYgKiBkdXJhdGlvbiAqIDAuNCk7XG4gICAgICAgICAgICAgICAgcG9zICs9IGNoYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZHVyYXRpb24gPCBTY3JvbGxQYW5lLlRXRUVOX0RFRkFVTFRfRFVSQVRJT04pXG4gICAgICAgICAgICBkdXJhdGlvbiA9IFNjcm9sbFBhbmUuVFdFRU5fREVGQVVMVF9EVVJBVElPTjtcbiAgICAgICAgdGhpcy4kdHdlZW5EdXJhdGlvbltheGlzXSA9IGR1cmF0aW9uO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBmaXhEdXJhdGlvbihheGlzLCBvbGRDaGFuZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuJHR3ZWVuQ2hhbmdlW2F4aXNdID09IDAgfHxcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuJHR3ZWVuQ2hhbmdlW2F4aXNdKSA+PSBNYXRoLmFicyhvbGRDaGFuZ2UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbmV3RHVyYXRpb24gPSBNYXRoLmFicyh0aGlzLiR0d2VlbkNoYW5nZVtheGlzXSAvIG9sZENoYW5nZSkgKlxuICAgICAgICAgICAgdGhpcy4kdHdlZW5EdXJhdGlvbltheGlzXTtcbiAgICAgICAgaWYgKG5ld0R1cmF0aW9uIDwgU2Nyb2xsUGFuZS5UV0VFTl9ERUZBVUxUX0RVUkFUSU9OKVxuICAgICAgICAgICAgbmV3RHVyYXRpb24gPSBTY3JvbGxQYW5lLlRXRUVOX0RFRkFVTFRfRFVSQVRJT047XG4gICAgICAgIHRoaXMuJHR3ZWVuRHVyYXRpb25bYXhpc10gPSBuZXdEdXJhdGlvbjtcbiAgICB9XG4gICAga2lsbFR3ZWVuKCkge1xuICAgICAgICAvL3R3ZWVuaW5nID09IDE6IHNldCB0byBlbmQgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKHRoaXMuJHR3ZWVuaW5nID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5zZXQoe1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuJHR3ZWVuU3RhcnQueCArIHRoaXMuJHR3ZWVuQ2hhbmdlLngsXG4gICAgICAgICAgICAgICAgeTogdGhpcy4kdHdlZW5TdGFydC55ICsgdGhpcy4kdHdlZW5DaGFuZ2UueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX19zY3JvbGxcIiAvKiBTQ1JPTEwgKi8sIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHR3ZWVuaW5nID0gMDtcbiAgICAgICAgR1RpbWVyLmluc3QucmVtb3ZlKHRoaXMudHdlZW5VcGRhdGUsIHRoaXMpO1xuICAgICAgICBsZXQgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX19zY3JvbGxFbmRcIiAvKiBTQ1JPTExfRU5EICovLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQsIHRoaXMpO1xuICAgIH1cbiAgICBjaGVja1JlZnJlc2hCYXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiRoZWFkZXIgPT0gbnVsbCAmJiB0aGlzLiRmb290ZXIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy4kY29udGFpbmVyW3RoaXMuJHJlZnJlc2hCYXJBeGlzXTtcbiAgICAgICAgaWYgKHRoaXMuJGhlYWRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocG9zID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRoZWFkZXIuZGlzcGxheU9iamVjdC5wYXJlbnQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbWFza0NvbnRhaW5lci5hZGRDaGlsZEF0KHRoaXMuJGhlYWRlci5kaXNwbGF5T2JqZWN0LCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwdCA9IFNjcm9sbFBhbmUuc0hlbHBlclBvaW50O1xuICAgICAgICAgICAgICAgIHB0LnNldFZhbHVlcyh0aGlzLiRoZWFkZXIud2lkdGgsIHRoaXMuJGhlYWRlci5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHB0W3RoaXMuJHJlZnJlc2hCYXJBeGlzXSA9IHBvcztcbiAgICAgICAgICAgICAgICB0aGlzLiRoZWFkZXIuc2V0U2l6ZShwdC54LCBwdC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRoZWFkZXIuZGlzcGxheU9iamVjdC5wYXJlbnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbWFza0NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLiRoZWFkZXIuZGlzcGxheU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGZvb3RlciAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbWF4ID0gdGhpcy4kb3ZlcmxhcFNpemVbdGhpcy4kcmVmcmVzaEJhckF4aXNdO1xuICAgICAgICAgICAgaWYgKHBvcyA8IC1tYXggfHwgKG1heCA9PSAwICYmIHRoaXMuJGZvb3RlckxvY2tlZFNpemUgPiAwKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRmb290ZXIuZGlzcGxheU9iamVjdC5wYXJlbnQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbWFza0NvbnRhaW5lci5hZGRDaGlsZEF0KHRoaXMuJGZvb3Rlci5kaXNwbGF5T2JqZWN0LCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwdCA9IFNjcm9sbFBhbmUuc0hlbHBlclBvaW50O1xuICAgICAgICAgICAgICAgIHB0LnNldFZhbHVlcyh0aGlzLiRmb290ZXIueCwgdGhpcy4kZm9vdGVyLnkpO1xuICAgICAgICAgICAgICAgIGlmIChtYXggPiAwKVxuICAgICAgICAgICAgICAgICAgICBwdFt0aGlzLiRyZWZyZXNoQmFyQXhpc10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICsgdGhpcy4kY29udGVudFNpemVbdGhpcy4kcmVmcmVzaEJhckF4aXNdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcHRbdGhpcy4kcmVmcmVzaEJhckF4aXNdID0gTWF0aC5tYXgoTWF0aC5taW4ocG9zICsgdGhpcy4kdmlld1NpemVbdGhpcy4kcmVmcmVzaEJhckF4aXNdLCB0aGlzLiR2aWV3U2l6ZVt0aGlzLiRyZWZyZXNoQmFyQXhpc10gLSB0aGlzLiRmb290ZXJMb2NrZWRTaXplKSwgdGhpcy4kdmlld1NpemVbdGhpcy4kcmVmcmVzaEJhckF4aXNdIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRlbnRTaXplW3RoaXMuJHJlZnJlc2hCYXJBeGlzXSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZm9vdGVyLnNldFhZKHB0LngsIHB0LnkpO1xuICAgICAgICAgICAgICAgIHB0LnNldFZhbHVlcyh0aGlzLiRmb290ZXIud2lkdGgsIHRoaXMuJGZvb3Rlci5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChtYXggPiAwKVxuICAgICAgICAgICAgICAgICAgICBwdFt0aGlzLiRyZWZyZXNoQmFyQXhpc10gPSAtbWF4IC0gcG9zO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcHRbdGhpcy4kcmVmcmVzaEJhckF4aXNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHZpZXdTaXplW3RoaXMuJHJlZnJlc2hCYXJBeGlzXSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9vdGVyW3RoaXMuJHJlZnJlc2hCYXJBeGlzXTtcbiAgICAgICAgICAgICAgICB0aGlzLiRmb290ZXIuc2V0U2l6ZShwdC54LCBwdC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRmb290ZXIuZGlzcGxheU9iamVjdC5wYXJlbnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbWFza0NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLiRmb290ZXIuZGlzcGxheU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHdlZW5VcGRhdGUoKSB7XG4gICAgICAgIHZhciBueCA9IHRoaXMucnVuVHdlZW4oJ3gnKTtcbiAgICAgICAgdmFyIG55ID0gdGhpcy5ydW5Ud2VlbigneScpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIuc2V0KHsgeDogbngsIHk6IG55IH0pO1xuICAgICAgICBpZiAodGhpcy4kdHdlZW5pbmcgPT0gMikge1xuICAgICAgICAgICAgaWYgKHRoaXMuJG92ZXJsYXBTaXplLnggPiAwKVxuICAgICAgICAgICAgICAgIHRoaXMuJHhQb3MgPSBOdW1iZXJVdGlsLmNsYW1wKC1ueCwgMCwgdGhpcy4kb3ZlcmxhcFNpemUueCk7XG4gICAgICAgICAgICBpZiAodGhpcy4kb3ZlcmxhcFNpemUueSA+IDApXG4gICAgICAgICAgICAgICAgdGhpcy4keVBvcyA9IE51bWJlclV0aWwuY2xhbXAoLW55LCAwLCB0aGlzLiRvdmVybGFwU2l6ZS55KTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRwYWdlTW9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBhZ2VDb250cm9sbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJHR3ZWVuQ2hhbmdlLnggPT0gMCAmJiB0aGlzLiR0d2VlbkNoYW5nZS55ID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuJHR3ZWVuaW5nID0gMDtcbiAgICAgICAgICAgIEdUaW1lci5pbnN0LnJlbW92ZSh0aGlzLnR3ZWVuVXBkYXRlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubG9vcENoZWNraW5nQ3VycmVudCgpO1xuICAgICAgICAgICAgdGhpcy5zeW5jU2Nyb2xsQmFyKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlZnJlc2hCYXIoKTtcbiAgICAgICAgICAgIGxldCBzY3JvbGxFdmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcIl9fc2Nyb2xsXCIgLyogU0NST0xMICovLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc2Nyb2xsRXZlbnQsIHRoaXMpO1xuICAgICAgICAgICAgbGV0IHNjcm9sbEVuZEV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX19zY3JvbGxFbmRcIiAvKiBTQ1JPTExfRU5EICovLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc2Nyb2xsRW5kRXZlbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zeW5jU2Nyb2xsQmFyKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZWZyZXNoQmFyKCk7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsRXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJfX3Njcm9sbFwiIC8qIFNDUk9MTCAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHNjcm9sbEV2ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5Ud2VlbihheGlzKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gY3JlYXRlanMuVGlja2VyLmludGVydmFsO1xuICAgICAgICBsZXQgbmV3VmFsdWU7XG4gICAgICAgIGlmICh0aGlzLiR0d2VlbkNoYW5nZVtheGlzXSAhPSAwKSB7XG4gICAgICAgICAgICB0aGlzLiR0d2VlblRpbWVbYXhpc10gKz0gZGVsdGEgKiBjcmVhdGVqcy5UaWNrZXIuZnJhbWVyYXRlO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHR3ZWVuVGltZVtheGlzXSA+PSB0aGlzLiR0d2VlbkR1cmF0aW9uW2F4aXNdKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiR0d2VlblN0YXJ0W2F4aXNdICsgdGhpcy4kdHdlZW5DaGFuZ2VbYXhpc107XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5DaGFuZ2VbYXhpc10gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPSBTY3JvbGxQYW5lLiRlYXNlVHlwZUZ1bmModGhpcy4kdHdlZW5UaW1lW2F4aXNdLCB0aGlzLiR0d2VlbkR1cmF0aW9uW2F4aXNdKTtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuU3RhcnRbYXhpc10gK1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzLiR0d2VlbkNoYW5nZVtheGlzXSAqIHJhdGlvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0aHJlc2hvbGQxID0gMDtcbiAgICAgICAgICAgIHZhciB0aHJlc2hvbGQyID0gLXRoaXMuJG92ZXJsYXBTaXplW2F4aXNdO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGhlYWRlckxvY2tlZFNpemUgPiAwICYmIHRoaXMuJHJlZnJlc2hCYXJBeGlzID09IGF4aXMpXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkMSA9IHRoaXMuJGhlYWRlckxvY2tlZFNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy4kZm9vdGVyTG9ja2VkU2l6ZSA+IDAgJiYgdGhpcy4kcmVmcmVzaEJhckF4aXMgPT0gYXhpcykge1xuICAgICAgICAgICAgICAgIHZhciBtYXggPSB0aGlzLiRvdmVybGFwU2l6ZVt0aGlzLiRyZWZyZXNoQmFyQXhpc107XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heCh0aGlzLiRjb250ZW50U2l6ZVt0aGlzLiRyZWZyZXNoQmFyQXhpc10gK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9vdGVyTG9ja2VkU2l6ZSAtXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiR2aWV3U2l6ZVt0aGlzLiRyZWZyZXNoQmFyQXhpc10sIDApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbWF4ICs9IHRoaXMuJGZvb3RlckxvY2tlZFNpemU7XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkMiA9IC1tYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kdHdlZW5pbmcgPT0gMiAmJiB0aGlzLiRib3VuY2ViYWNrRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKChuZXdWYWx1ZSA+IDIwICsgdGhyZXNob2xkMSAmJiB0aGlzLiR0d2VlbkNoYW5nZVtheGlzXSA+IDApIHx8XG4gICAgICAgICAgICAgICAgICAgIChuZXdWYWx1ZSA+IHRocmVzaG9sZDEgJiYgdGhpcy4kdHdlZW5DaGFuZ2VbYXhpc10gPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5UaW1lW2F4aXNdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5EdXJhdGlvbltheGlzXSA9IFNjcm9sbFBhbmUuVFdFRU5fREVGQVVMVF9EVVJBVElPTjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5DaGFuZ2VbYXhpc10gPSAtbmV3VmFsdWUgKyB0aHJlc2hvbGQxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR0d2VlblN0YXJ0W2F4aXNdID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChuZXdWYWx1ZSA8IHRocmVzaG9sZDIgLSAyMCAmJiB0aGlzLiR0d2VlbkNoYW5nZVtheGlzXSA8IDApIHx8XG4gICAgICAgICAgICAgICAgICAgIChuZXdWYWx1ZSA8IHRocmVzaG9sZDIgJiYgdGhpcy4kdHdlZW5DaGFuZ2VbYXhpc10gPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5UaW1lW2F4aXNdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5EdXJhdGlvbltheGlzXSA9IFNjcm9sbFBhbmUuVFdFRU5fREVGQVVMVF9EVVJBVElPTjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5DaGFuZ2VbYXhpc10gPSB0aHJlc2hvbGQyIC0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHR3ZWVuU3RhcnRbYXhpc10gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgPiB0aHJlc2hvbGQxKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhyZXNob2xkMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5DaGFuZ2VbYXhpc10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSA8IHRocmVzaG9sZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aHJlc2hvbGQyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR0d2VlbkNoYW5nZVtheGlzXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy4kY29udGFpbmVyW2F4aXNdO1xuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfVxufVxuU2Nyb2xsUGFuZS4kZWFzZVR5cGVGdW5jID0gKHQsIGQpID0+IHtcbiAgICByZXR1cm4gKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKyAxO1xufTsgLy9jdWJpYyBvdXRcblNjcm9sbFBhbmUuJGdlc3R1cmVGbGFnID0gMDtcblNjcm9sbFBhbmUuc0hlbHBlclBvaW50ID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG5TY3JvbGxQYW5lLnNIZWxwZXJSZWN0ID0gbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgpO1xuU2Nyb2xsUGFuZS5zRW5kUG9zID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG5TY3JvbGxQYW5lLnNPbGRDaGFuZ2UgPSBuZXcgY3JlYXRlanMuUG9pbnQoKTtcblNjcm9sbFBhbmUuVFdFRU5fREVGQVVMVF9EVVJBVElPTiA9IDAuNDtcblNjcm9sbFBhbmUuVFdFRU5fTUFOVUFMTFlfU0VUX0RVUkFUSU9OID0gMC41OyAvL3R3ZWVuIGR1cmF0aW9uIHVzZWQgd2hlbiBjYWxsIHNldFBvcyh1c2VBbmk9dHJ1ZSlcblNjcm9sbFBhbmUuUFVMTF9ESVNUX1JBVElPID0gMC41OyAvL3B1bGxkb3duIC8gcHVsbHVwIGRpc3RhbmNlIHJhdGlvIG9mIHRoZSB3aG9sZSB2aWV3cG9ydFxuXG5jbGFzcyBCaW5kZXIge1xuICAgIHN0YXRpYyBjcmVhdGUoZnVuYywgY29udGV4dCwgLi4uYXJncykge1xuICAgICAgICBpZiAoIWNvbnRleHQpXG4gICAgICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgZnVsbGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCA/IFtdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKS5jb25jYXQoYXJncykgOiBbXS5jb25jYXQoYXJncyk7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bGxhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcikge1xuICAgICAgICB0aGlzLmF1dG9QbGF5UmVwZWF0ID0gMTtcbiAgICAgICAgdGhpcy5hdXRvUGxheURlbGF5ID0gMDtcbiAgICAgICAgdGhpcy4kb3duZXJCYXNlWCA9IDA7XG4gICAgICAgIHRoaXMuJG93bmVyQmFzZVkgPSAwO1xuICAgICAgICB0aGlzLiR0b3RhbFRpbWVzID0gMDtcbiAgICAgICAgdGhpcy4kc3RhcnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy4kdG90YWxUYXNrcyA9IDA7XG4gICAgICAgIHRoaXMuJHBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kb3B0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMuJG1heFRpbWUgPSAwO1xuICAgICAgICB0aGlzLiRvd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLiRpdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLiRvd25lci5vbihcIl9fdmlzaWJsZUNoYW5nZWRcIiAvKiBWSVNJQkxFX0NIQU5HRUQgKi8sIHRoaXMuJG93bmVyVmlzaWJsZUNoYW5nZWQsIHRoaXMpO1xuICAgIH1cbiAgICAvLyBwcml2YXRlICRvd25lclZpc2libGVDaGFuZ2VkKHZpczogYm9vbGVhbiwgb3duZXI6IEdDb21wb25lbnQpOiB2b2lkIHtcbiAgICAkb3duZXJWaXNpYmxlQ2hhbmdlZChldmVudCkge1xuICAgICAgICBsZXQgdmlzID0gZXZlbnQuZGF0YTtcbiAgICAgICAgaWYgKCh0aGlzLiRvcHRpb25zICYgVHJhbnNpdGlvbi5PUFRJT05fQVVUT19TVE9QX0RJU0FCTEVEKSA9PSAwICYmIHZpcyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnN0b3AoKHRoaXMuJG9wdGlvbnMgJiBUcmFuc2l0aW9uLk9QVElPTl9BVVRPX1NUT1BfQVRfRU5EKSAhPSAwID8gdHJ1ZSA6IGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuICAgIGdldCBhdXRvUGxheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGF1dG9QbGF5O1xuICAgIH1cbiAgICBzZXQgYXV0b1BsYXkodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGF1dG9QbGF5ICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRhdXRvUGxheSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGF1dG9QbGF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJG93bmVyLm9uU3RhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lczogdGhpcy5hdXRvUGxheVJlcGVhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiB0aGlzLmF1dG9QbGF5RGVsYXlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuJG93bmVyLm9uU3RhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcChmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hhbmdlUmVwZWF0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJHRvdGFsVGltZXMgPSB2YWx1ZSB8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICogUGxheSB0cmFuc2l0aW9uIGJ5IHNwZWNpZmllZCBzZXR0aW5nczpcbiAgICAgICAqIDEpIHBhc3Mgd2hvbGUgcGFyYW1ldGVyczpcbiAgICAgICAgICAgICAgb25Db21wbGV0ZT86ICguLi5hcmdzOmFueVtdKSA9PiB2b2lkLFxuICAgICAgICAgICAgICBvbkNvbXBsZXRlT2JqPzogYW55LFxuICAgICAgICAgICAgICBvbkNvbXBsZXRlUGFyYW0/OiBhbnksXG4gICAgICAgICAgICAgIHRpbWVzOiBudW1iZXIsXG4gICAgICAgICAgICAgIGRlbGF5OiBudW1iZXJcbiAgICAgICAqIDIpIGp1c3QgcGFzcyAxIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIFRyYW5zaXRpb25QbGF5U2V0dGluZyAocmVjb21tZW5kZWQpXG4gICAgICAgKi9cbiAgICBwbGF5KC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICYmIHR5cGVvZiBhcmdzWzBdID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBsZXQgb2JqID0gYXJnc1swXTtcbiAgICAgICAgICAgIHRoaXMuJHBsYXkob2JqLm9uQ29tcGxldGUsIG9iai5vbkNvbXBsZXRlT2JqLCBvYmoub25Db21wbGV0ZVBhcmFtLCBvYmoudGltZXMgfHwgMSwgb2JqLmRlbGF5IHx8IDAsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRwbGF5KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10gfHwgMSwgYXJnc1s0XSB8fCAwLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICogUGxheSB0cmFuc2l0aW9uIGJ5IHNwZWNpZmllZCBzZXR0aW5nczpcbiAgICAgICAqIDEpIHBhc3Mgd2hvbGUgcGFyYW1ldGVyczpcbiAgICAgICAgICAgICAgb25Db21wbGV0ZT86ICguLi5hcmdzOmFueVtdKSA9PiB2b2lkLFxuICAgICAgICAgICAgICBvbkNvbXBsZXRlT2JqPzogYW55LFxuICAgICAgICAgICAgICBvbkNvbXBsZXRlUGFyYW0/OiBhbnksXG4gICAgICAgICAgICAgIHRpbWVzOiBudW1iZXIsXG4gICAgICAgICAgICAgIGRlbGF5OiBudW1iZXJcbiAgICAgICAqIDIpIGp1c3QgcGFzcyAxIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIFRyYW5zaXRpb25QbGF5U2V0dGluZyAocmVjb21tZW5kZWQpXG4gICAgICAgKi9cbiAgICBwbGF5UmV2ZXJzZSguLi5hcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCAmJiB0eXBlb2YgYXJnc1swXSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbGV0IG9iaiA9IGFyZ3NbMF07XG4gICAgICAgICAgICB0aGlzLiRwbGF5KG9iai5vbkNvbXBsZXRlLCBvYmoub25Db21wbGV0ZU9iaiwgb2JqLm9uQ29tcGxldGVQYXJhbSwgb2JqLnRpbWVzIHx8IDEsIG9iai5kZWxheSB8fCAwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRwbGF5KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10gfHwgMSwgYXJnc1s0XSB8fCAwLCB0cnVlKTtcbiAgICB9XG4gICAgJHBsYXkob25Db21wbGV0ZSwgb25Db21wbGV0ZU9iaiwgb25Db21wbGV0ZVBhcmFtLCB0aW1lcywgZGVsYXksIHJldmVyc2VkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmICh0aW1lcyA9PSAwKVxuICAgICAgICAgICAgdGltZXMgPSAxO1xuICAgICAgICBlbHNlIGlmICh0aW1lcyA9PSAtMSlcbiAgICAgICAgICAgIHRpbWVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdGhpcy4kdG90YWxUaW1lcyA9IHRpbWVzO1xuICAgICAgICB0aGlzLiRzdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLiRyZXZlcnNlZCA9IHJldmVyc2VkO1xuICAgICAgICB0aGlzLmludGVybmFsUGxheShkZWxheSk7XG4gICAgICAgIHRoaXMuJHBsYXlpbmcgPSB0aGlzLiR0b3RhbFRhc2tzID4gMDtcbiAgICAgICAgaWYgKHRoaXMuJHBsYXlpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuJG9uQ29tcGxldGUgPSBvbkNvbXBsZXRlO1xuICAgICAgICAgICAgdGhpcy4kb25Db21wbGV0ZVBhcmFtID0gb25Db21wbGV0ZVBhcmFtO1xuICAgICAgICAgICAgdGhpcy4kb25Db21wbGV0ZU9iaiA9IG9uQ29tcGxldGVPYmo7XG4gICAgICAgICAgICBpZiAoKHRoaXMuJG9wdGlvbnMgJiBUcmFuc2l0aW9uLk9QVElPTl9JR05PUkVfRElTUExBWV9DT05UUk9MTEVSKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udGFyZ2V0ICE9IG51bGwgJiYgaXRlbS50YXJnZXQgIT0gdGhpcy4kb3duZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmxvY2tUb2tlbiA9IGl0ZW0udGFyZ2V0LmxvY2tHZWFyRGlzcGxheSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgb25Db21wbGV0ZVBhcmFtICYmIG9uQ29tcGxldGVQYXJhbS5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IG9uQ29tcGxldGUuYXBwbHkob25Db21wbGV0ZU9iaiwgb25Db21wbGV0ZVBhcmFtKVxuICAgICAgICAgICAgICAgIDogb25Db21wbGV0ZS5jYWxsKG9uQ29tcGxldGVPYmosIG9uQ29tcGxldGVQYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcChzZXRUb0NvbXBsZXRlID0gdHJ1ZSwgcHJvY2Vzc0NhbGxiYWNrID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuJHBsYXlpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuJHBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuJHRvdGFsVGFza3MgPSAwO1xuICAgICAgICAgICAgdGhpcy4kdG90YWxUaW1lcyA9IDA7XG4gICAgICAgICAgICBsZXQgZnVuYyA9IHRoaXMuJG9uQ29tcGxldGU7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLiRvbkNvbXBsZXRlUGFyYW07XG4gICAgICAgICAgICBsZXQgdGhpc09iaiA9IHRoaXMuJG9uQ29tcGxldGVPYmo7XG4gICAgICAgICAgICB0aGlzLiRvbkNvbXBsZXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJG9uQ29tcGxldGVQYXJhbSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLiRvbkNvbXBsZXRlT2JqID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBjbnQgPSB0aGlzLiRpdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaXRlbTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRyZXZlcnNlZCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjbnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy4kaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcEl0ZW0oaXRlbSwgc2V0VG9Db21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy4kaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcEl0ZW0oaXRlbSwgc2V0VG9Db21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3NDYWxsYmFjayAmJiBmdW5jICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcGFyYW0gJiYgcGFyYW0ubGVuZ3RoID4gMCA/IGZ1bmMuYXBwbHkodGhpc09iaiwgcGFyYW0pIDogZnVuYy5jYWxsKHRoaXNPYmosIHBhcmFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wSXRlbShpdGVtLCBzZXRUb0NvbXBsZXRlKSB7XG4gICAgICAgIGlmIChpdGVtLmxvY2tUb2tlbiAhPSAwKSB7XG4gICAgICAgICAgICBpdGVtLnRhcmdldC5yZWxlYXNlR2VhckRpc3BsYXkoaXRlbS5sb2NrVG9rZW4pO1xuICAgICAgICAgICAgaXRlbS5sb2NrVG9rZW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT0gMTIgLyogQ29sb3JGaWx0ZXIgKi8gJiYgaXRlbS5maWx0ZXJDcmVhdGVkKVxuICAgICAgICAgICAgaXRlbS50YXJnZXQuZmlsdGVycyA9IG51bGw7XG4gICAgICAgIGlmIChpdGVtLmNvbXBsZXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5kaXNwb3NlVHdlZW4oaXRlbSk7XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT0gMTAgLyogVHJhbnNpdGlvbiAqLykge1xuICAgICAgICAgICAgbGV0IHRyYW5zID0gaXRlbS50YXJnZXQuZ2V0VHJhbnNpdGlvbihpdGVtLnZhbHVlLnMpO1xuICAgICAgICAgICAgaWYgKHRyYW5zICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdHJhbnMuc3RvcChzZXRUb0NvbXBsZXRlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbS50eXBlID09IDExIC8qIFNoYWtlICovKSB7XG4gICAgICAgICAgICBHVGltZXIuaW5zdC5yZW1vdmUoaXRlbS4kc2hha2UsIGl0ZW0pO1xuICAgICAgICAgICAgaXRlbS50YXJnZXQuJGdlYXJMb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgaXRlbS50YXJnZXQuc2V0WFkoaXRlbS50YXJnZXQueCAtIGl0ZW0uc3RhcnRWYWx1ZS5mMSwgaXRlbS50YXJnZXQueSAtIGl0ZW0uc3RhcnRWYWx1ZS5mMik7XG4gICAgICAgICAgICBpdGVtLnRhcmdldC4kZ2VhckxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNldFRvQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50d2Vlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ueW95byB8fCBpdGVtLnJlcGVhdCAlIDIgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlWYWx1ZShpdGVtLCB0aGlzLiRyZXZlcnNlZCA/IGl0ZW0uc3RhcnRWYWx1ZSA6IGl0ZW0uZW5kVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VmFsdWUoaXRlbSwgdGhpcy4kcmV2ZXJzZWQgPyBpdGVtLmVuZFZhbHVlIDogaXRlbS5zdGFydFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS50eXBlICE9IDkgLyogU291bmQgKi8pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlWYWx1ZShpdGVtLCBpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBHVGltZXIuaW5zdC5yZW1vdmUodGhpcy5pbnRlcm5hbFBsYXksIHRoaXMpO1xuICAgICAgICB0aGlzLiRvd25lci5vZmYoXCJfX3Zpc2libGVDaGFuZ2VkXCIgLyogVklTSUJMRV9DSEFOR0VEICovLCB0aGlzLiRvd25lclZpc2libGVDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy4kcGxheWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0udGFyZ2V0ID09IG51bGwgfHwgaXRlbS5jb21wbGV0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlVHdlZW4oaXRlbSk7XG4gICAgICAgICAgICBpZiAoaXRlbS50eXBlID09IDEwIC8qIFRyYW5zaXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhbnMgPSBpdGVtLnRhcmdldC5nZXRUcmFuc2l0aW9uKGl0ZW0udmFsdWUucyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0udHlwZSA9PSAxMSAvKiBTaGFrZSAqLylcbiAgICAgICAgICAgICAgICBHVGltZXIuaW5zdC5yZW1vdmUoaXRlbS4kc2hha2UsIGl0ZW0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHBsYXlpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRwbGF5aW5nO1xuICAgIH1cbiAgICBzZXRWYWx1ZShsYWJlbCwgLi4uYXJncykge1xuICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0ubGFiZWwgPT0gbnVsbCAmJiBpdGVtLmxhYmVsMiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpdGVtLmxhYmVsID09IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udHdlZW4pXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRlbS5zdGFydFZhbHVlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5sYWJlbDIgPT0gbGFiZWwpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpdGVtLmVuZFZhbHVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN3aXRjaCAoaXRlbS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIFhZICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBTaXplICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBQaXZvdCAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogU2NhbGUgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxMyAvKiBTa2V3ICovOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5iMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmIyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZjEgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mMiA9IHBhcnNlRmxvYXQoYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBBbHBoYSAqLzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZjEgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDUgLyogUm90YXRpb24gKi86XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmkgPSBwYXJzZUludChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2IC8qIENvbG9yICovOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5jID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3IC8qIEFuaW1hdGlvbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuaSA9IHBhcnNlSW50KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuYiA9IGFyZ3NbMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOCAvKiBWaXNpYmxlICovOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5iID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5IC8qIFNvdW5kICovOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmYxID0gcGFyc2VGbG9hdChhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMCAvKiBUcmFuc2l0aW9uICovOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmkgPSBwYXJzZUludChhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMSAvKiBTaGFrZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZjEgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZjIgPSBwYXJzZUZsb2F0KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyIC8qIENvbG9yRmlsdGVyICovOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mMSA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmYyID0gcGFyc2VGbG9hdChhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZjMgPSBwYXJzZUZsb2F0KGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mNCA9IHBhcnNlRmxvYXQoYXJnc1szXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgc2V0SG9vayhsYWJlbCwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgbGV0IGNudCA9IHRoaXMuJGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLiRpdGVtc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtLmxhYmVsID09IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5ob29rID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgaXRlbS5ob29rT2JqID0gdGhpc09iajtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0ubGFiZWwyID09IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5ob29rMiA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGl0ZW0uaG9vazJPYmogPSB0aGlzT2JqO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFySG9va3MoKSB7XG4gICAgICAgIHRoaXMuJGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLmhvb2sgPSBudWxsO1xuICAgICAgICAgICAgaXRlbS5ob29rT2JqID0gbnVsbDtcbiAgICAgICAgICAgIGl0ZW0uaG9vazIgPSBudWxsO1xuICAgICAgICAgICAgaXRlbS5ob29rMk9iaiA9IG51bGw7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBzZXRUYXJnZXQobGFiZWwsIG5ld1RhcmdldCkge1xuICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0ubGFiZWwgPT0gbGFiZWwpXG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXRJZCA9IG5ld1RhcmdldC5pZDtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIHNldER1cmF0aW9uKGxhYmVsLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0udHdlZW4gJiYgaXRlbS5sYWJlbCA9PSBsYWJlbClcbiAgICAgICAgICAgICAgICBpdGVtLmR1cmF0aW9uID0gdmFsdWU7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICB1cGRhdGVGcm9tUmVsYXRpb25zKHRhcmdldElkLCBkeCwgZHkpIHtcbiAgICAgICAgdGhpcy4kaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT0gMCAvKiBYWSAqLyAmJiBpdGVtLnRhcmdldElkID09IHRhcmdldElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udHdlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGFydFZhbHVlLmYxICs9IGR4O1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXJ0VmFsdWUuZjIgKz0gZHk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZW5kVmFsdWUuZjEgKz0gZHg7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZW5kVmFsdWUuZjIgKz0gZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnZhbHVlLmYxICs9IGR4O1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnZhbHVlLmYyICs9IGR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGludGVybmFsUGxheShkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy4kb3duZXJCYXNlWCA9IHRoaXMuJG93bmVyLng7XG4gICAgICAgIHRoaXMuJG93bmVyQmFzZVkgPSB0aGlzLiRvd25lci55O1xuICAgICAgICB0aGlzLiR0b3RhbFRhc2tzID0gMDtcbiAgICAgICAgdGhpcy4kaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnRhcmdldElkKVxuICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0ID0gdGhpcy4kb3duZXIuZ2V0Q2hpbGRCeUlkKGl0ZW0udGFyZ2V0SWQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0ID0gdGhpcy4kb3duZXI7XG4gICAgICAgICAgICBpZiAoaXRlbS50YXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc3RhcnRUaW1lO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlVHdlZW4oaXRlbSk7XG4gICAgICAgICAgICBpZiAoaXRlbS50d2Vlbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRyZXZlcnNlZClcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gZGVsYXkgKyB0aGlzLiRtYXhUaW1lIC0gaXRlbS50aW1lIC0gaXRlbS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IGRlbGF5ICsgaXRlbS50aW1lO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydFRpbWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHRvdGFsVGFza3MrKztcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50d2VlbmVyID0gY3JlYXRlanMuVHdlZW4uZ2V0KGl0ZW0udmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2FpdChzdGFydFRpbWUgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwodGhpcy4kZGVsYXlDYWxsLCBbaXRlbV0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUd2VlbihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRyZXZlcnNlZClcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gZGVsYXkgKyB0aGlzLiRtYXhUaW1lIC0gaXRlbS50aW1lO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gZGVsYXkgKyBpdGVtLnRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VmFsdWUoaXRlbSwgaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHRvdGFsVGFza3MrKztcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50d2VlbmVyID0gY3JlYXRlanMuVHdlZW4uZ2V0KGl0ZW0udmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2FpdChzdGFydFRpbWUgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwodGhpcy4kZGVsYXlDYWxsMiwgW2l0ZW1dLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBwcmVwYXJlVmFsdWUoaXRlbSwgdG9Qcm9wcywgcmV2ZXJzZWQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgc3RhcnRWYWx1ZTtcbiAgICAgICAgbGV0IGVuZFZhbHVlO1xuICAgICAgICBpZiAocmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWUgPSBpdGVtLmVuZFZhbHVlO1xuICAgICAgICAgICAgZW5kVmFsdWUgPSBpdGVtLnN0YXJ0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydFZhbHVlID0gaXRlbS5zdGFydFZhbHVlO1xuICAgICAgICAgICAgZW5kVmFsdWUgPSBpdGVtLmVuZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoaXRlbS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogWFkgKi86XG4gICAgICAgICAgICBjYXNlIDEgLyogU2l6ZSAqLzpcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09IDAgLyogWFkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udGFyZ2V0ID09IHRoaXMuJG93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0VmFsdWUuYjEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZS5mMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0VmFsdWUuYjIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZS5mMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0VmFsdWUuYjEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZS5mMSA9IGl0ZW0udGFyZ2V0Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0VmFsdWUuYjIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZS5mMiA9IGl0ZW0udGFyZ2V0Lnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhcnRWYWx1ZS5iMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWUuZjEgPSBpdGVtLnRhcmdldC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGFydFZhbHVlLmIyKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZS5mMiA9IGl0ZW0udGFyZ2V0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbS52YWx1ZS5mMSA9IHN0YXJ0VmFsdWUuZjE7XG4gICAgICAgICAgICAgICAgaXRlbS52YWx1ZS5mMiA9IHN0YXJ0VmFsdWUuZjI7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmRWYWx1ZS5iMSlcbiAgICAgICAgICAgICAgICAgICAgZW5kVmFsdWUuZjEgPSBpdGVtLnZhbHVlLmYxO1xuICAgICAgICAgICAgICAgIGlmICghZW5kVmFsdWUuYjIpXG4gICAgICAgICAgICAgICAgICAgIGVuZFZhbHVlLmYyID0gaXRlbS52YWx1ZS5mMjtcbiAgICAgICAgICAgICAgICBpdGVtLnZhbHVlLmIxID0gc3RhcnRWYWx1ZS5iMSB8fCBlbmRWYWx1ZS5iMTtcbiAgICAgICAgICAgICAgICBpdGVtLnZhbHVlLmIyID0gc3RhcnRWYWx1ZS5iMiB8fCBlbmRWYWx1ZS5iMjtcbiAgICAgICAgICAgICAgICB0b1Byb3BzLmYxID0gZW5kVmFsdWUuZjE7XG4gICAgICAgICAgICAgICAgdG9Qcm9wcy5mMiA9IGVuZFZhbHVlLmYyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIFNjYWxlICovOlxuICAgICAgICAgICAgY2FzZSAxMyAvKiBTa2V3ICovOlxuICAgICAgICAgICAgICAgIGl0ZW0udmFsdWUuZjEgPSBzdGFydFZhbHVlLmYxO1xuICAgICAgICAgICAgICAgIGl0ZW0udmFsdWUuZjIgPSBzdGFydFZhbHVlLmYyO1xuICAgICAgICAgICAgICAgIHRvUHJvcHMuZjEgPSBlbmRWYWx1ZS5mMTtcbiAgICAgICAgICAgICAgICB0b1Byb3BzLmYyID0gZW5kVmFsdWUuZjI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQgLyogQWxwaGEgKi86XG4gICAgICAgICAgICAgICAgaXRlbS52YWx1ZS5mMSA9IHN0YXJ0VmFsdWUuZjE7XG4gICAgICAgICAgICAgICAgdG9Qcm9wcy5mMSA9IGVuZFZhbHVlLmYxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1IC8qIFJvdGF0aW9uICovOlxuICAgICAgICAgICAgICAgIGl0ZW0udmFsdWUuaSA9IHN0YXJ0VmFsdWUuaTtcbiAgICAgICAgICAgICAgICB0b1Byb3BzLmkgPSBlbmRWYWx1ZS5pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMiAvKiBDb2xvckZpbHRlciAqLzpcbiAgICAgICAgICAgICAgICBpdGVtLnZhbHVlLmYxID0gc3RhcnRWYWx1ZS5mMTtcbiAgICAgICAgICAgICAgICBpdGVtLnZhbHVlLmYyID0gc3RhcnRWYWx1ZS5mMjtcbiAgICAgICAgICAgICAgICBpdGVtLnZhbHVlLmYzID0gc3RhcnRWYWx1ZS5mMztcbiAgICAgICAgICAgICAgICBpdGVtLnZhbHVlLmY0ID0gc3RhcnRWYWx1ZS5mNDtcbiAgICAgICAgICAgICAgICB0b1Byb3BzLmYxID0gZW5kVmFsdWUuZjE7XG4gICAgICAgICAgICAgICAgdG9Qcm9wcy5mMiA9IGVuZFZhbHVlLmYyO1xuICAgICAgICAgICAgICAgIHRvUHJvcHMuZjMgPSBlbmRWYWx1ZS5mMztcbiAgICAgICAgICAgICAgICB0b1Byb3BzLmY0ID0gZW5kVmFsdWUuZjQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRUd2VlbihpdGVtKSB7XG4gICAgICAgIGxldCB0b1Byb3BzID0gbmV3IFRyYW5zaXRpb25WYWx1ZSgpO1xuICAgICAgICB0aGlzLnByZXBhcmVWYWx1ZShpdGVtLCB0b1Byb3BzLCB0aGlzLiRyZXZlcnNlZCk7XG4gICAgICAgIHRoaXMuYXBwbHlWYWx1ZShpdGVtLCBpdGVtLnZhbHVlKTtcbiAgICAgICAgbGV0IGNvbXBsZXRlSGFuZGxlcjtcbiAgICAgICAgaWYgKGl0ZW0ucmVwZWF0ICE9IDApIHtcbiAgICAgICAgICAgIGl0ZW0udHdlZW5UaW1lcyA9IDA7XG4gICAgICAgICAgICBjb21wbGV0ZUhhbmRsZXIgPSBCaW5kZXIuY3JlYXRlKHRoaXMuJHR3ZWVuUmVwZWF0Q29tcGxldGUsIHRoaXMsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbXBsZXRlSGFuZGxlciA9IEJpbmRlci5jcmVhdGUodGhpcy4kdHdlZW5Db21wbGV0ZSwgdGhpcywgaXRlbSk7XG4gICAgICAgIHRoaXMuJHRvdGFsVGFza3MrKztcbiAgICAgICAgaXRlbS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmVwYXJlVmFsdWUoaXRlbSwgdG9Qcm9wcywgdGhpcy4kcmV2ZXJzZWQpO1xuICAgICAgICBpdGVtLnR3ZWVuZXIgPSBjcmVhdGVqcy5Ud2Vlbi5nZXQoaXRlbS52YWx1ZSwge1xuICAgICAgICAgICAgb25DaGFuZ2U6IEJpbmRlci5jcmVhdGUodGhpcy4kdHdlZW5VcGRhdGUsIHRoaXMsIGl0ZW0pXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudG8odG9Qcm9wcywgaXRlbS5kdXJhdGlvbiAqIDEwMDAsIGl0ZW0uZWFzZVR5cGUpXG4gICAgICAgICAgICAuY2FsbChjb21wbGV0ZUhhbmRsZXIpO1xuICAgICAgICBpZiAoaXRlbS5ob29rICE9IG51bGwpXG4gICAgICAgICAgICBpdGVtLmhvb2suY2FsbChpdGVtLmhvb2tPYmopO1xuICAgIH1cbiAgICAkZGVsYXlDYWxsKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlVHdlZW4oaXRlbSk7XG4gICAgICAgIHRoaXMuJHRvdGFsVGFza3MtLTtcbiAgICAgICAgdGhpcy5zdGFydFR3ZWVuKGl0ZW0pO1xuICAgIH1cbiAgICAkZGVsYXlDYWxsMihpdGVtKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZVR3ZWVuKGl0ZW0pO1xuICAgICAgICB0aGlzLiR0b3RhbFRhc2tzLS07XG4gICAgICAgIGl0ZW0uY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHBseVZhbHVlKGl0ZW0sIGl0ZW0udmFsdWUpO1xuICAgICAgICBpZiAoaXRlbS5ob29rICE9IG51bGwpXG4gICAgICAgICAgICBpdGVtLmhvb2suY2FsbChpdGVtLmhvb2tPYmopO1xuICAgICAgICB0aGlzLmNoZWNrQWxsQ29tcGxldGUoKTtcbiAgICB9XG4gICAgJHR3ZWVuVXBkYXRlKGV2ZW50LCBpdGVtKSB7XG4gICAgICAgIHRoaXMuYXBwbHlWYWx1ZShpdGVtLCBpdGVtLnZhbHVlKTtcbiAgICB9XG4gICAgJHR3ZWVuQ29tcGxldGUoZXZlbnQsIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlVHdlZW4oaXRlbSk7XG4gICAgICAgIHRoaXMuJHRvdGFsVGFza3MtLTtcbiAgICAgICAgaXRlbS5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoaXRlbS5ob29rMiAhPSBudWxsKVxuICAgICAgICAgICAgaXRlbS5ob29rMi5jYWxsKGl0ZW0uaG9vazJPYmopO1xuICAgICAgICB0aGlzLmNoZWNrQWxsQ29tcGxldGUoKTtcbiAgICB9XG4gICAgJHR3ZWVuUmVwZWF0Q29tcGxldGUoZXZlbnQsIGl0ZW0pIHtcbiAgICAgICAgaXRlbS50d2VlblRpbWVzKys7XG4gICAgICAgIGlmIChpdGVtLnJlcGVhdCA9PSAtMSB8fCBpdGVtLnR3ZWVuVGltZXMgPCBpdGVtLnJlcGVhdCArIDEpIHtcbiAgICAgICAgICAgIGxldCB0b1Byb3BzID0gbmV3IFRyYW5zaXRpb25WYWx1ZSgpO1xuICAgICAgICAgICAgbGV0IHJldmVyc2VkO1xuICAgICAgICAgICAgaWYgKGl0ZW0ueW95bykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRyZXZlcnNlZClcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZWQgPSBpdGVtLnR3ZWVuVGltZXMgJSAyID09IDA7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlZCA9IGl0ZW0udHdlZW5UaW1lcyAlIDIgPT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXZlcnNlZCA9IHRoaXMuJHJldmVyc2VkO1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlVmFsdWUoaXRlbSwgdG9Qcm9wcywgcmV2ZXJzZWQpO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlVHdlZW4oaXRlbSk7XG4gICAgICAgICAgICBpdGVtLnR3ZWVuZXIgPSBjcmVhdGVqcy5Ud2Vlbi5nZXQoaXRlbS52YWx1ZSwge1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBCaW5kZXIuY3JlYXRlKHRoaXMuJHR3ZWVuVXBkYXRlLCB0aGlzLCBpdGVtKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudG8odG9Qcm9wcywgaXRlbS5kdXJhdGlvbiAqIDEwMDAsIGl0ZW0uZWFzZVR5cGUpXG4gICAgICAgICAgICAgICAgLmNhbGwodGhpcy4kdHdlZW5SZXBlYXRDb21wbGV0ZSwgW251bGwsIGl0ZW1dLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiR0d2VlbkNvbXBsZXRlKG51bGwsIGl0ZW0pO1xuICAgIH1cbiAgICBkaXNwb3NlVHdlZW4oaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChpdGVtLnR3ZWVuZXIpIHtcbiAgICAgICAgICAgIGl0ZW0udHdlZW5lci5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgaXRlbS50d2VlbmVyLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjcmVhdGVqcy5Ud2Vlbi5yZW1vdmVUd2VlbnMoaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICBpdGVtLnR3ZWVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgICRwbGF5VHJhbnNDb21wbGV0ZShpdGVtKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZVR3ZWVuKGl0ZW0pO1xuICAgICAgICB0aGlzLiR0b3RhbFRhc2tzLS07XG4gICAgICAgIGl0ZW0uY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGVja0FsbENvbXBsZXRlKCk7XG4gICAgfVxuICAgIGNoZWNrQWxsQ29tcGxldGUoKSB7XG4gICAgICAgIGlmICh0aGlzLiRwbGF5aW5nICYmIHRoaXMuJHRvdGFsVGFza3MgPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHRvdGFsVGltZXMgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy90aGUgcmVhc29uIHdlIGRvbid0IGNhbGwgJ2ludGVybmFsUGxheScgaW1tZWRpYXRlbHkgaGVyZSBpcyBiZWNhdXNlIG9mIHRoZSBvbkNoYW5nZSBoYW5kbGVyIGlzc3VlLCB0aGUgaGFuZGxlcidzIGJlZW4gY2FsbGluZyBhbGwgdGhlIHRpbWUgZXZlbiB0aGUgdHdlZW4gaXMgaW4gd2FpdGluZy9jb21wbGV0ZSBzdGF0dXMuXG4gICAgICAgICAgICAgICAgR1RpbWVyLmluc3QuY2FsbExhdGVyKHRoaXMuaW50ZXJuYWxQbGF5LCB0aGlzLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRvdGFsVGltZXMtLTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kdG90YWxUaW1lcyA+IDApXG4gICAgICAgICAgICAgICAgICAgIEdUaW1lci5pbnN0LmNhbGxMYXRlcih0aGlzLmludGVybmFsUGxheSwgdGhpcywgMCk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ubG9ja1Rva2VuICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50YXJnZXQucmVsZWFzZUdlYXJEaXNwbGF5KGl0ZW0ubG9ja1Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5sb2NrVG9rZW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5maWx0ZXJDcmVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZmlsdGVyQ3JlYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRhcmdldC5maWx0ZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlVHdlZW4oaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kb25Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnVuYyA9IHRoaXMuJG9uQ29tcGxldGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLiRvbkNvbXBsZXRlUGFyYW07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGhpc09iaiA9IHRoaXMuJG9uQ29tcGxldGVPYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRvbkNvbXBsZXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJG9uQ29tcGxldGVQYXJhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRvbkNvbXBsZXRlT2JqID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtICYmIHBhcmFtLmxlbmd0aCA/IGZ1bmMuYXBwbHkodGhpc09iaiwgcGFyYW0pIDogZnVuYy5jYWxsKHRoaXNPYmosIHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseVZhbHVlKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgIGl0ZW0udGFyZ2V0LiRnZWFyTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBYWSAqLzpcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50YXJnZXQgPT0gdGhpcy4kb3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGYxID0gMCwgZjIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmIxKVxuICAgICAgICAgICAgICAgICAgICAgICAgZjEgPSBpdGVtLnRhcmdldC54O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBmMSA9IHZhbHVlLmYxICsgdGhpcy4kb3duZXJCYXNlWDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5iMilcbiAgICAgICAgICAgICAgICAgICAgICAgIGYyID0gaXRlbS50YXJnZXQueTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZjIgPSB2YWx1ZS5mMiArIHRoaXMuJG93bmVyQmFzZVk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0LnNldFhZKGYxLCBmMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmIxKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZjEgPSBpdGVtLnRhcmdldC54O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmIyKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZjIgPSBpdGVtLnRhcmdldC55O1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnRhcmdldC5zZXRYWSh2YWx1ZS5mMSwgdmFsdWUuZjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBTaXplICovOlxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUuYjEpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmYxID0gaXRlbS50YXJnZXQud2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5iMilcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZjIgPSBpdGVtLnRhcmdldC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXQuc2V0U2l6ZSh2YWx1ZS5mMSwgdmFsdWUuZjIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFBpdm90ICovOlxuICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0LnNldFBpdm90KHZhbHVlLmYxLCB2YWx1ZS5mMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQgLyogQWxwaGEgKi86XG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXQuYWxwaGEgPSB2YWx1ZS5mMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNSAvKiBSb3RhdGlvbiAqLzpcbiAgICAgICAgICAgICAgICBpdGVtLnRhcmdldC5yb3RhdGlvbiA9IHZhbHVlLmk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogU2NhbGUgKi86XG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXQuc2V0U2NhbGUodmFsdWUuZjEsIHZhbHVlLmYyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTMgLyogU2tldyAqLzpcbiAgICAgICAgICAgICAgICBpdGVtLnRhcmdldC5zZXRTa2V3KHZhbHVlLmYxLCB2YWx1ZS5mMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYgLyogQ29sb3IgKi86XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29sb3JHZWFyKGl0ZW0udGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50YXJnZXQuY29sb3IgPSB2YWx1ZS5jO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3IC8qIEFuaW1hdGlvbiAqLzpcbiAgICAgICAgICAgICAgICBpZiAoaXNBbmltYXRpb25HZWFyKGl0ZW0udGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmIxKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuaSA9IGl0ZW0udGFyZ2V0LmZyYW1lO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnRhcmdldC5mcmFtZSA9IHZhbHVlLmk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0LnBsYXlpbmcgPSB2YWx1ZS5iO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOCAvKiBWaXNpYmxlICovOlxuICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0LnZpc2libGUgPSB2YWx1ZS5iO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMCAvKiBUcmFuc2l0aW9uICovOlxuICAgICAgICAgICAgICAgIGxldCB0cmFucyA9IGl0ZW0udGFyZ2V0LmdldFRyYW5zaXRpb24odmFsdWUucyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmkgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLnN0b3AoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmFucy5wbGF5aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuJHRvdGFsVGltZXMgPSB2YWx1ZS5pID09IC0xID8gTnVtYmVyLk1BWF9WQUxVRSA6IHZhbHVlLmk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHRvdGFsVGFza3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRyZXZlcnNlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5wbGF5UmV2ZXJzZSh0aGlzLiRwbGF5VHJhbnNDb21wbGV0ZSwgdGhpcywgaXRlbSwgaXRlbS52YWx1ZS5pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5wbGF5KHRoaXMuJHBsYXlUcmFuc0NvbXBsZXRlLCB0aGlzLCBpdGVtLCBpdGVtLnZhbHVlLmkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA5IC8qIFNvdW5kICovOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRwbGF5aW5nICYmIGl0ZW0udGltZSA+PSB0aGlzLiRzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5hdWRpb0NsaXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaSA9IFVJUGFja2FnZS5nZXRJdGVtQnlVUkwodmFsdWUucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuYXVkaW9DbGlwID0gcGkub3duZXIuZ2V0SXRlbUFzc2V0KHBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuYXVkaW9DbGlwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBEZWNscyQxLkdSb290Lmluc3QucGxheU9uZVNob3RTb3VuZCh2YWx1ZS5hdWRpb0NsaXAsIHZhbHVlLmYxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTEgLyogU2hha2UgKi86XG4gICAgICAgICAgICAgICAgaXRlbS5zdGFydFZhbHVlLmYxID0gMDsgLy9vZmZzZXRYXG4gICAgICAgICAgICAgICAgaXRlbS5zdGFydFZhbHVlLmYyID0gMDsgLy9vZmZzZXRZXG4gICAgICAgICAgICAgICAgaXRlbS5zdGFydFZhbHVlLmYzID0gaXRlbS52YWx1ZS5mMjsgLy9zaGFrZVBlcmlvZFxuICAgICAgICAgICAgICAgIEdUaW1lci5pbnN0LmFkZCgxLCAwLCBpdGVtLiRzaGFrZSwgaXRlbSwgW3RoaXNdKTtcbiAgICAgICAgICAgICAgICB0aGlzLiR0b3RhbFRhc2tzKys7XG4gICAgICAgICAgICAgICAgaXRlbS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTIgLyogQ29sb3JGaWx0ZXIgKi86XG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXQudXBkYXRlQ29sb3JDb21wb25lbnRzKHZhbHVlLmYxLCB2YWx1ZS5mMiwgdmFsdWUuZjMsIHZhbHVlLmY0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpdGVtLnRhcmdldC4kZ2VhckxvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipAaW50ZXJuYWwgKi9cbiAgICAkc2hha2VJdGVtKGl0ZW0sIGVsYXBzZWRNUykge1xuICAgICAgICBsZXQgciA9IE1hdGguY2VpbCgoaXRlbS52YWx1ZS5mMSAqIGl0ZW0uc3RhcnRWYWx1ZS5mMykgLyBpdGVtLnZhbHVlLmYyKTtcbiAgICAgICAgbGV0IHJ4ID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiByO1xuICAgICAgICBsZXQgcnkgPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIHI7XG4gICAgICAgIHJ4ID0gcnggPiAwID8gTWF0aC5jZWlsKHJ4KSA6IE1hdGguZmxvb3IocngpO1xuICAgICAgICByeSA9IHJ5ID4gMCA/IE1hdGguY2VpbChyeSkgOiBNYXRoLmZsb29yKHJ5KTtcbiAgICAgICAgaXRlbS50YXJnZXQuJGdlYXJMb2NrZWQgPSB0cnVlO1xuICAgICAgICBpdGVtLnRhcmdldC5zZXRYWShpdGVtLnRhcmdldC54IC0gaXRlbS5zdGFydFZhbHVlLmYxICsgcngsIGl0ZW0udGFyZ2V0LnkgLSBpdGVtLnN0YXJ0VmFsdWUuZjIgKyByeSk7XG4gICAgICAgIGl0ZW0udGFyZ2V0LiRnZWFyTG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGl0ZW0uc3RhcnRWYWx1ZS5mMSA9IHJ4O1xuICAgICAgICBpdGVtLnN0YXJ0VmFsdWUuZjIgPSByeTtcbiAgICAgICAgaXRlbS5zdGFydFZhbHVlLmYzIC09IGVsYXBzZWRNUyAvIDEwMDA7XG4gICAgICAgIGlmIChpdGVtLnN0YXJ0VmFsdWUuZjMgPD0gMCkge1xuICAgICAgICAgICAgaXRlbS50YXJnZXQuJGdlYXJMb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgaXRlbS50YXJnZXQuc2V0WFkoaXRlbS50YXJnZXQueCAtIGl0ZW0uc3RhcnRWYWx1ZS5mMSwgaXRlbS50YXJnZXQueSAtIGl0ZW0uc3RhcnRWYWx1ZS5mMik7XG4gICAgICAgICAgICBpdGVtLnRhcmdldC4kZ2VhckxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaXRlbS5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kdG90YWxUYXNrcy0tO1xuICAgICAgICAgICAgR1RpbWVyLmluc3QucmVtb3ZlKGl0ZW0uJHNoYWtlLCBpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tBbGxDb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldHVwKHhtbCkge1xuICAgICAgICB0aGlzLm5hbWUgPSB4bWwuYXR0cmlidXRlcy5uYW1lO1xuICAgICAgICBsZXQgc3RyID0geG1sLmF0dHJpYnV0ZXMub3B0aW9ucztcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuJG9wdGlvbnMgPSBwYXJzZUludChzdHIpO1xuICAgICAgICB0aGlzLiRhdXRvUGxheSA9IHhtbC5hdHRyaWJ1dGVzLmF1dG9QbGF5ID09ICd0cnVlJztcbiAgICAgICAgaWYgKHRoaXMuJGF1dG9QbGF5KSB7XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5hdXRvUGxheVJlcGVhdDtcbiAgICAgICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvUGxheVJlcGVhdCA9IHBhcnNlSW50KHN0cik7XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5hdXRvUGxheURlbGF5O1xuICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9QbGF5RGVsYXkgPSBwYXJzZUZsb2F0KHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbCA9IHhtbC5jaGlsZHJlbjtcbiAgICAgICAgY29sLmZvckVhY2goY3htbCA9PiB7XG4gICAgICAgICAgICBpZiAoY3htbC5ub2RlTmFtZSAhPSAnaXRlbScpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgVHJhbnNpdGlvbkl0ZW0oKTtcbiAgICAgICAgICAgIHRoaXMuJGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBpdGVtLnRpbWUgPSBwYXJzZUludChjeG1sLmF0dHJpYnV0ZXMudGltZSkgLyBUcmFuc2l0aW9uLkZSQU1FX1JBVEU7XG4gICAgICAgICAgICBpdGVtLnRhcmdldElkID0gY3htbC5hdHRyaWJ1dGVzLnRhcmdldDtcbiAgICAgICAgICAgIHN0ciA9IGN4bWwuYXR0cmlidXRlcy50eXBlO1xuICAgICAgICAgICAgc3dpdGNoIChzdHIpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdYWSc6XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udHlwZSA9IDAgLyogWFkgKi87XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NpemUnOlxuICAgICAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSAxIC8qIFNpemUgKi87XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NjYWxlJzpcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50eXBlID0gMiAvKiBTY2FsZSAqLztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUGl2b3QnOlxuICAgICAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSAzIC8qIFBpdm90ICovO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdBbHBoYSc6XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udHlwZSA9IDQgLyogQWxwaGEgKi87XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1JvdGF0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50eXBlID0gNSAvKiBSb3RhdGlvbiAqLztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ29sb3InOlxuICAgICAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSA2IC8qIENvbG9yICovO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdBbmltYXRpb24nOlxuICAgICAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSA3IC8qIEFuaW1hdGlvbiAqLztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVmlzaWJsZSc6XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udHlwZSA9IDggLyogVmlzaWJsZSAqLztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnU291bmQnOlxuICAgICAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSA5IC8qIFNvdW5kICovO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUcmFuc2l0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50eXBlID0gMTAgLyogVHJhbnNpdGlvbiAqLztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnU2hha2UnOlxuICAgICAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSAxMSAvKiBTaGFrZSAqLztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ29sb3JGaWx0ZXInOlxuICAgICAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSAxMiAvKiBDb2xvckZpbHRlciAqLztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnU2tldyc6XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udHlwZSA9IDEzIC8qIFNrZXcgKi87XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udHlwZSA9IDE0IC8qIFVua25vd24gKi87XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS50d2VlbiA9IGN4bWwuYXR0cmlidXRlcy50d2VlbiA9PSAndHJ1ZSc7XG4gICAgICAgICAgICBpdGVtLmxhYmVsID0gY3htbC5hdHRyaWJ1dGVzLmxhYmVsO1xuICAgICAgICAgICAgaWYgKGl0ZW0udHdlZW4pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmR1cmF0aW9uID0gcGFyc2VJbnQoY3htbC5hdHRyaWJ1dGVzLmR1cmF0aW9uKSAvIFRyYW5zaXRpb24uRlJBTUVfUkFURTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50aW1lICsgaXRlbS5kdXJhdGlvbiA+IHRoaXMuJG1heFRpbWUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG1heFRpbWUgPSBpdGVtLnRpbWUgKyBpdGVtLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIHN0ciA9IGN4bWwuYXR0cmlidXRlcy5lYXNlO1xuICAgICAgICAgICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZWFzZVR5cGUgPSBQYXJzZUVhc2VUeXBlKHN0cik7XG4gICAgICAgICAgICAgICAgc3RyID0gY3htbC5hdHRyaWJ1dGVzLnJlcGVhdDtcbiAgICAgICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlcGVhdCA9IHBhcnNlSW50KHN0cik7XG4gICAgICAgICAgICAgICAgaXRlbS55b3lvID0gY3htbC5hdHRyaWJ1dGVzLnlveW8gPT0gJ3RydWUnO1xuICAgICAgICAgICAgICAgIGl0ZW0ubGFiZWwyID0gY3htbC5hdHRyaWJ1dGVzLmxhYmVsMjtcbiAgICAgICAgICAgICAgICBsZXQgdiA9IGN4bWwuYXR0cmlidXRlcy5lbmRWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZVZhbHVlKGl0ZW0udHlwZSwgY3htbC5hdHRyaWJ1dGVzLnN0YXJ0VmFsdWUsIGl0ZW0uc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlVmFsdWUoaXRlbS50eXBlLCB2LCBpdGVtLmVuZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udHdlZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVWYWx1ZShpdGVtLnR5cGUsIGN4bWwuYXR0cmlidXRlcy5zdGFydFZhbHVlLCBpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50aW1lID4gdGhpcy4kbWF4VGltZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbWF4VGltZSA9IGl0ZW0udGltZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZVZhbHVlKGl0ZW0udHlwZSwgY3htbC5hdHRyaWJ1dGVzLnZhbHVlLCBpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKHR5cGUsIHN0ciwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGFycjtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogWFkgKi86XG4gICAgICAgICAgICBjYXNlIDEgLyogU2l6ZSAqLzpcbiAgICAgICAgICAgIGNhc2UgMyAvKiBQaXZvdCAqLzpcbiAgICAgICAgICAgIGNhc2UgMTMgLyogU2tldyAqLzpcbiAgICAgICAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJyWzBdID09ICctJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5iMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZjEgPSBwYXJzZUZsb2F0KGFyclswXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmIxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFyclsxXSA9PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYjIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmYyID0gcGFyc2VGbG9hdChhcnJbMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5iMiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0IC8qIEFscGhhICovOlxuICAgICAgICAgICAgICAgIHZhbHVlLmYxID0gcGFyc2VGbG9hdChzdHIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1IC8qIFJvdGF0aW9uICovOlxuICAgICAgICAgICAgICAgIHZhbHVlLmkgPSBwYXJzZUludChzdHIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIFNjYWxlICovOlxuICAgICAgICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIHZhbHVlLmYxID0gcGFyc2VGbG9hdChhcnJbMF0pO1xuICAgICAgICAgICAgICAgIHZhbHVlLmYyID0gcGFyc2VGbG9hdChhcnJbMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2IC8qIENvbG9yICovOlxuICAgICAgICAgICAgICAgIHZhbHVlLmMgPSBTdHJpbmdVdGlsLkhFWDJSR0Ioc3RyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNyAvKiBBbmltYXRpb24gKi86XG4gICAgICAgICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgaWYgKGFyclswXSA9PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYjEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmkgPSBwYXJzZUludChhcnJbMF0pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5iMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlLmIgPSBhcnJbMV0gPT0gJ3AnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4IC8qIFZpc2libGUgKi86XG4gICAgICAgICAgICAgICAgdmFsdWUuYiA9IHN0ciA9PSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDkgLyogU291bmQgKi86XG4gICAgICAgICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgdmFsdWUucyA9IGFyclswXTtcbiAgICAgICAgICAgICAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludHYgPSBwYXJzZUludChhcnJbMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50diA9PSAwIHx8IGludHYgPT0gMTAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZjEgPSAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mMSA9IGludHYgLyAxMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZjEgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMCAvKiBUcmFuc2l0aW9uICovOlxuICAgICAgICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIHZhbHVlLnMgPSBhcnJbMF07XG4gICAgICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5pID0gcGFyc2VJbnQoYXJyWzFdKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmkgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMSAvKiBTaGFrZSAqLzpcbiAgICAgICAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mMSA9IHBhcnNlRmxvYXQoYXJyWzBdKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mMiA9IHBhcnNlRmxvYXQoYXJyWzFdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTIgLyogQ29sb3JGaWx0ZXIgKi86XG4gICAgICAgICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgdmFsdWUuZjEgPSBwYXJzZUZsb2F0KGFyclswXSk7XG4gICAgICAgICAgICAgICAgdmFsdWUuZjIgPSBwYXJzZUZsb2F0KGFyclsxXSk7XG4gICAgICAgICAgICAgICAgdmFsdWUuZjMgPSBwYXJzZUZsb2F0KGFyclsyXSk7XG4gICAgICAgICAgICAgICAgdmFsdWUuZjQgPSBwYXJzZUZsb2F0KGFyclszXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5UcmFuc2l0aW9uLk9QVElPTl9JR05PUkVfRElTUExBWV9DT05UUk9MTEVSID0gMTtcblRyYW5zaXRpb24uT1BUSU9OX0FVVE9fU1RPUF9ESVNBQkxFRCA9IDEgPj4gMTtcblRyYW5zaXRpb24uT1BUSU9OX0FVVE9fU1RPUF9BVF9FTkQgPSAxID4+IDI7XG5UcmFuc2l0aW9uLkZSQU1FX1JBVEUgPSAyNDtcbmNsYXNzIFRyYW5zaXRpb25JdGVtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50aW1lID0gMDtcbiAgICAgICAgdGhpcy50eXBlID0gMDtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMucmVwZWF0ID0gMDtcbiAgICAgICAgdGhpcy55b3lvID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHdlZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50d2VlblRpbWVzID0gMDtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2NrVG9rZW4gPSAwO1xuICAgICAgICB0aGlzLmVhc2VUeXBlID0gUGFyc2VFYXNlVHlwZSgnUXVhZC5PdXQnKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBUcmFuc2l0aW9uVmFsdWUoKTtcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gbmV3IFRyYW5zaXRpb25WYWx1ZSgpO1xuICAgICAgICB0aGlzLmVuZFZhbHVlID0gbmV3IFRyYW5zaXRpb25WYWx1ZSgpO1xuICAgIH1cbiAgICAvKipAaW50ZXJuYWwgKi9cbiAgICAkc2hha2UodHJhbnMsIGVsYXBzZWRNUykge1xuICAgICAgICB0cmFucy4kc2hha2VJdGVtKHRoaXMsIGVsYXBzZWRNUyk7XG4gICAgfVxufVxuY2xhc3MgVHJhbnNpdGlvblZhbHVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mMSA9IDA7XG4gICAgICAgIHRoaXMuZjIgPSAwO1xuICAgICAgICB0aGlzLmYzID0gMDtcbiAgICAgICAgdGhpcy5mNCA9IDA7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuYiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmIxID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5iMiA9IHRydWU7XG4gICAgfVxufVxuXG5jbGFzcyBNYXJnaW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxlZnQgPSAwO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IDA7XG4gICAgfVxuICAgIHBhcnNlKHN0cikge1xuICAgICAgICBpZiAoIXN0cikge1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5yaWdodCA9IHRoaXMudG9wID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhcnIgPSBzdHIuc3BsaXQoXCIsXCIpO1xuICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgayA9IHBhcnNlSW50KGFyclswXSk7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSB0aGlzLnJpZ2h0ID0gdGhpcy50b3AgPSB0aGlzLmJvdHRvbSA9IGs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHBhcnNlSW50KGFyclswXSk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IHBhcnNlSW50KGFyclsxXSk7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBwYXJzZUludChhcnJbMl0pO1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHBhcnNlSW50KGFyclszXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weShzb3VyY2UpIHtcbiAgICAgICAgdGhpcy50b3AgPSBzb3VyY2UudG9wO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XG4gICAgICAgIHRoaXMubGVmdCA9IHNvdXJjZS5sZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xuICAgIH1cbn1cblxuY2xhc3MgR0NvbXBvbmVudCBleHRlbmRzIEdPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLiRzb3J0aW5nQ2hpbGRDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuJGNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuJGNvbnRyb2xsZXJzID0gW107XG4gICAgICAgIHRoaXMuJHRyYW5zaXRpb25zID0gW107XG4gICAgICAgIHRoaXMuJG1hcmdpbiA9IG5ldyBNYXJnaW4oKTtcbiAgICAgICAgdGhpcy4kYWxpZ25PZmZzZXQgPSBuZXcgY3JlYXRlanMuUG9pbnQoKTtcbiAgICB9XG4gICAgY3JlYXRlRGlzcGxheU9iamVjdCgpIHtcbiAgICAgICAgdGhpcy4kcm9vdENvbnRhaW5lciA9IG5ldyBVSUNvbnRhaW5lcih0aGlzKTtcbiAgICAgICAgdGhpcy5zZXREaXNwbGF5T2JqZWN0KHRoaXMuJHJvb3RDb250YWluZXIpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIgPSB0aGlzLiRyb290Q29udGFpbmVyO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBHVGltZXIuaW5zdC5yZW1vdmUodGhpcy4kdmFsaWRhdGUsIHRoaXMpO1xuICAgICAgICB0aGlzLm9mZignYWRkZWQnLCB0aGlzLiRhZGRlZCk7XG4gICAgICAgIHRoaXMub2ZmKCdyZW1vdmVkJywgdGhpcy4kcmVtb3ZlZCk7XG4gICAgICAgIHRoaXMuJHRyYW5zaXRpb25zLmZvckVhY2goKHRyYW5zKSA9PiB7XG4gICAgICAgICAgICB0cmFucy5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbnVtQ2hpbGRyZW4gPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSBudW1DaGlsZHJlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgICAgICBvYmoucGFyZW50ID0gbnVsbDsgLy9hdm9pZCByZW1vdmVGcm9tUGFyZW50IGNhbGxcbiAgICAgICAgICAgIG9iai5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kYm91bmRzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4kc2Nyb2xsUGFuZSlcbiAgICAgICAgICAgIHRoaXMuJHNjcm9sbFBhbmUuZGlzcG9zZSgpO1xuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGdldCBkaXNwbGF5TGlzdENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRhaW5lcjtcbiAgICB9XG4gICAgYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgdGhpcy5hZGRDaGlsZEF0KGNoaWxkLCB0aGlzLiRjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGFkZENoaWxkQXQoY2hpbGQsIGluZGV4ID0gMCkge1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoaWxkJyk7XG4gICAgICAgIGxldCBudW1DaGlsZHJlbiA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gbnVtQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT0gdGhpcylcbiAgICAgICAgICAgICAgICB0aGlzLnNldENoaWxkSW5kZXgoY2hpbGQsIGluZGV4KTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZUZyb21QYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGxldCBjbnQgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnNvcnRpbmdPcmRlciAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHNvcnRpbmdDaGlsZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5nZXRJbnNlcnRQb3NGb3JTb3J0aW5nQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRzb3J0aW5nQ2hpbGRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gY250IC0gdGhpcy4kc29ydGluZ0NoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNudCAtIHRoaXMuJHNvcnRpbmdDaGlsZENvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gY250KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRTdGF0ZUNoYW5nZWQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Qm91bmRzQ2hhbmdlZEZsYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hpbGQgaW5kZXgnKTtcbiAgICB9XG4gICAgZ2V0SW5zZXJ0UG9zRm9yU29ydGluZ0NoaWxkKHRhcmdldCkge1xuICAgICAgICBsZXQgY250ID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5zb3J0aW5nT3JkZXIgPCBjaGlsZC5zb3J0aW5nT3JkZXIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkKGNoaWxkLCBkaXNwb3NlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGNoaWxkSW5kZXggPSB0aGlzLiRjaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggIT0gLTEpXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkQXQoY2hpbGRJbmRleCwgZGlzcG9zZSk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgcmVtb3ZlQ2hpbGRBdChpbmRleCwgZGlzcG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5udW1DaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy4kY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjaGlsZC5zb3J0aW5nT3JkZXIgIT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLiRzb3J0aW5nQ2hpbGRDb3VudC0tO1xuICAgICAgICAgICAgdGhpcy4kY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5pbkNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQuZGlzcGxheU9iamVjdCk7XG4gICAgICAgICAgICBpZiAoZGlzcG9zZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBjaGlsZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnNldEJvdW5kc0NoYW5nZWRGbGFnKCk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoaWxkIGluZGV4Jyk7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuKGJlZ2luSW5kZXggPSAwLCBlbmRJbmRleCA9IC0xLCBkaXNwb3NlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGVuZEluZGV4IDwgMCB8fCBlbmRJbmRleCA+PSB0aGlzLm51bUNoaWxkcmVuKVxuICAgICAgICAgICAgZW5kSW5kZXggPSB0aGlzLm51bUNoaWxkcmVuIC0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGJlZ2luSW5kZXg7IGkgPD0gZW5kSW5kZXg7ICsraSlcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGRBdChiZWdpbkluZGV4LCBkaXNwb3NlKTtcbiAgICB9XG4gICAgZ2V0Q2hpbGRBdChpbmRleCA9IDApIHtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLm51bUNoaWxkcmVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoaWxkIGluZGV4Jyk7XG4gICAgfVxuICAgIGdldENoaWxkKG5hbWUpIHtcbiAgICAgICAgbGV0IGNudCA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbnQ7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGNoaWxkcmVuW2ldLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkSW5Hcm91cChuYW1lLCBncm91cCkge1xuICAgICAgICBsZXQgY250ID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNudDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLiRjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5ncm91cCA9PSBncm91cCAmJiBjaGlsZC5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IGNudCA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbnQ7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGNoaWxkcmVuW2ldLmlkID09IGlkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRjaGlsZHJlbltpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRJbmRleChjaGlsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgfVxuICAgIHNldENoaWxkSW5kZXgoY2hpbGQsIGluZGV4ID0gMCkge1xuICAgICAgICBsZXQgb2xkSW5kZXggPSB0aGlzLiRjaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgaWYgKG9sZEluZGV4ID09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBzdWNoIGNoaWxkIGZvdW5kJyk7XG4gICAgICAgIGlmIChjaGlsZC5zb3J0aW5nT3JkZXIgIT0gMClcbiAgICAgICAgICAgIC8vbm8gZWZmZWN0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjbnQgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLiRzb3J0aW5nQ2hpbGRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IGNudCAtIHRoaXMuJHNvcnRpbmdDaGlsZENvdW50IC0gMSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNudCAtIHRoaXMuJHNvcnRpbmdDaGlsZENvdW50IC0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzZXRDaGlsZEluZGV4KGNoaWxkLCBvbGRJbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBzZXRDaGlsZEluZGV4QmVmb3JlKGNoaWxkLCBpbmRleCkge1xuICAgICAgICBsZXQgb2xkSW5kZXggPSB0aGlzLiRjaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgaWYgKG9sZEluZGV4ID09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBzdWNoIGNoaWxkIGZvdW5kJyk7XG4gICAgICAgIGlmIChjaGlsZC5zb3J0aW5nT3JkZXIgIT0gMClcbiAgICAgICAgICAgIC8vbm8gZWZmZWN0XG4gICAgICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICAgIGxldCBjbnQgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLiRzb3J0aW5nQ2hpbGRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IGNudCAtIHRoaXMuJHNvcnRpbmdDaGlsZENvdW50IC0gMSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNudCAtIHRoaXMuJHNvcnRpbmdDaGlsZENvdW50IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkSW5kZXggPCBpbmRleClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRzZXRDaGlsZEluZGV4KGNoaWxkLCBvbGRJbmRleCwgaW5kZXggLSAxKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNldENoaWxkSW5kZXgoY2hpbGQsIG9sZEluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgICRzZXRDaGlsZEluZGV4KGNoaWxkLCBvbGRJbmRleCwgaW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBjbnQgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGlmIChpbmRleCA+IGNudClcbiAgICAgICAgICAgIGluZGV4ID0gY250O1xuICAgICAgICBpZiAob2xkSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICAgIHRoaXMuJGNoaWxkcmVuLnNwbGljZShvbGRJbmRleCwgMSk7XG4gICAgICAgIHRoaXMuJGNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGQuaW5Db250YWluZXIpIHtcbiAgICAgICAgICAgIGxldCBkaXNwbGF5SW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IGNoaWxkQ291bnQgPSB0aGlzLiRjb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGcgPSB0aGlzLiRjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoZy5pbkNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzcGxheUluZGV4ID09IGNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgZGlzcGxheUluZGV4LS07XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIuc2V0Q2hpbGRJbmRleChjaGlsZC5kaXNwbGF5T2JqZWN0LCBkaXNwbGF5SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zZXRCb3VuZHNDaGFuZ2VkRmxhZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgc3dhcENoaWxkcmVuKGNoaWxkMSwgY2hpbGQyKSB7XG4gICAgICAgIGxldCBpbmRleDEgPSB0aGlzLiRjaGlsZHJlbi5pbmRleE9mKGNoaWxkMSk7XG4gICAgICAgIGxldCBpbmRleDIgPSB0aGlzLiRjaGlsZHJlbi5pbmRleE9mKGNoaWxkMik7XG4gICAgICAgIGlmIChpbmRleDEgPT0gLTEgfHwgaW5kZXgyID09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBzdWNoIGNoaWxkIGZvdW5kJyk7XG4gICAgICAgIHRoaXMuc3dhcENoaWxkcmVuQXQoaW5kZXgxLCBpbmRleDIpO1xuICAgIH1cbiAgICBzd2FwQ2hpbGRyZW5BdChpbmRleDEsIGluZGV4MiA9IDApIHtcbiAgICAgICAgbGV0IGNoaWxkMSA9IHRoaXMuJGNoaWxkcmVuW2luZGV4MV07XG4gICAgICAgIGxldCBjaGlsZDIgPSB0aGlzLiRjaGlsZHJlbltpbmRleDJdO1xuICAgICAgICB0aGlzLnNldENoaWxkSW5kZXgoY2hpbGQxLCBpbmRleDIpO1xuICAgICAgICB0aGlzLnNldENoaWxkSW5kZXgoY2hpbGQyLCBpbmRleDEpO1xuICAgIH1cbiAgICBnZXQgbnVtQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgfVxuICAgIGlzQW5jZXN0b3JPZihjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHAgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBpZiAocCA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcCA9IHAucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWRkQ29udHJvbGxlcihjb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuJGNvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XG4gICAgICAgIGNvbnRyb2xsZXIuJHBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuYXBwbHlDb250cm9sbGVyKGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICBnZXRDb250cm9sbGVyQXQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRyb2xsZXJzW2luZGV4XTtcbiAgICB9XG4gICAgZ2V0Q29udHJvbGxlcihuYW1lKSB7XG4gICAgICAgIGxldCBjbnQgPSB0aGlzLiRjb250cm9sbGVycy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY250OyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjID0gdGhpcy4kY29udHJvbGxlcnNbaV07XG4gICAgICAgICAgICBpZiAoYy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJlbW92ZUNvbnRyb2xsZXIoYykge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLiRjb250cm9sbGVycy5pbmRleE9mKGMpO1xuICAgICAgICBpZiAoaW5kZXggPT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnRyb2xsZXIgbm90IGV4aXN0cycpO1xuICAgICAgICBjLiRwYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiRjb250cm9sbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGNoaWxkLmhhbmRsZUNvbnRyb2xsZXJDaGFuZ2VkKGMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xsZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY29udHJvbGxlcnM7XG4gICAgfVxuICAgIGNoaWxkU3RhdGVDaGFuZ2VkKGNoaWxkKSB7XG4gICAgICAgIGlmICh0aGlzLiRidWlsZGluZ0Rpc3BsYXlMaXN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goZyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGcuZ3JvdXAgPT0gY2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRTdGF0ZUNoYW5nZWQoZyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkLmRpc3BsYXlPYmplY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjaGlsZC5maW5hbFZpc2libGUpIHtcbiAgICAgICAgICAgIGlmICghY2hpbGQuZGlzcGxheU9iamVjdC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaTEgPSAwOyBpMSA8IGxlbjsgaTErKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZyA9IHRoaXMuJGNoaWxkcmVuW2kxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGcgPT0gY2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGcuZGlzcGxheU9iamVjdCAmJiBnLmRpc3BsYXlPYmplY3QucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmFkZENoaWxkQXQoY2hpbGQuZGlzcGxheU9iamVjdCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoaWxkLmRpc3BsYXlPYmplY3QucGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZC5kaXNwbGF5T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseUNvbnRyb2xsZXIoYykge1xuICAgICAgICB0aGlzLiRhcHBseWluZ0NvbnRyb2xsZXIgPSBjO1xuICAgICAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGNoaWxkLmhhbmRsZUNvbnRyb2xsZXJDaGFuZ2VkKGMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kYXBwbHlpbmdDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgYy5leGVjdXRlQWN0aW9ucygpO1xuICAgIH1cbiAgICBhcHBseUFsbENvbnRyb2xsZXJzKCkge1xuICAgICAgICB0aGlzLiRjb250cm9sbGVycy5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcHBseUNvbnRyb2xsZXIoYyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBhZGp1c3RSYWRpb0dyb3VwRGVwdGgob2JqLCBjKSB7XG4gICAgICAgIGxldCBteUluZGV4ID0gLTEsIG1heEluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT0gb2JqKSB7XG4gICAgICAgICAgICAgICAgbXlJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoXCJyZWxhdGVkQ29udHJvbGxlclwiIGluIGNoaWxkKSAmJiBjaGlsZC5yZWxhdGVkQ29udHJvbGxlciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiBtYXhJbmRleClcbiAgICAgICAgICAgICAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG15SW5kZXggPCBtYXhJbmRleCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGFwcGx5aW5nQ29udHJvbGxlciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuJGNoaWxkcmVuW21heEluZGV4XS5oYW5kbGVDb250cm9sbGVyQ2hhbmdlZCh0aGlzLiRhcHBseWluZ0NvbnRyb2xsZXIpOyAvL1RPRE86IHR3aWNlXG4gICAgICAgICAgICB0aGlzLnN3YXBDaGlsZHJlbkF0KG15SW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUcmFuc2l0aW9uQXQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHRyYW5zaXRpb25zW2luZGV4XTtcbiAgICB9XG4gICAgZ2V0VHJhbnNpdGlvbih0cmFuc05hbWUpIHtcbiAgICAgICAgbGV0IGNudCA9IHRoaXMuJHRyYW5zaXRpb25zLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbnQ7ICsraSkge1xuICAgICAgICAgICAgbGV0IHRyYW5zID0gdGhpcy4kdHJhbnNpdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAodHJhbnMubmFtZSA9PSB0cmFuc05hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpc0NoaWxkSW5WaWV3KGNoaWxkKSB7XG4gICAgICAgIGlmICh0aGlzLiRyb290Q29udGFpbmVyLnNjcm9sbFJlY3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIChjaGlsZC54ICsgY2hpbGQud2lkdGggPj0gMCAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLnggPD0gdGhpcy53aWR0aCAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLnkgKyBjaGlsZC5oZWlnaHQgPj0gMCAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLnkgPD0gdGhpcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJHNjcm9sbFBhbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNjcm9sbFBhbmUuaXNDaGlsZEluVmlldyhjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldEZpcnN0Q2hpbGRJblZpZXcoKSB7XG4gICAgICAgIGxldCBjbnQgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY250OyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuJGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDaGlsZEluVmlldyhjaGlsZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBnZXQgc2Nyb2xsUGFuZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNjcm9sbFBhbmU7XG4gICAgfVxuICAgIGdldCBvcGFxdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRvcGFxdWU7XG4gICAgfVxuICAgIHNldCBvcGFxdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJG9wYXF1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kb3BhcXVlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy4kb3BhcXVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVPcGFxdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRyb290Q29udGFpbmVyLmhpdEFyZWEgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcm9vdENvbnRhaW5lci5oaXRBcmVhIGluc3RhbmNlb2YgY3JlYXRlanMuRGlzcGxheU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRyb290Q29udGFpbmVyLmhpdEFyZWEgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kbWFyZ2luO1xuICAgIH1cbiAgICBzZXQgbWFyZ2luKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJG1hcmdpbi5jb3B5KHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuJHJvb3RDb250YWluZXIuc2Nyb2xsUmVjdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIueCA9IHRoaXMuJG1hcmdpbi5sZWZ0ICsgdGhpcy4kYWxpZ25PZmZzZXQueDtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci55ID0gdGhpcy4kbWFyZ2luLnRvcCArIHRoaXMuJGFsaWduT2Zmc2V0Lnk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVTaXplQ2hhbmdlZCgpO1xuICAgIH1cbiAgICBnZXQgbWFzaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJvb3RDb250YWluZXIubWFzaztcbiAgICB9XG4gICAgc2V0IG1hc2sob2JqKSB7XG4gICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgY3JlYXRlanMuU2hhcGUpXG4gICAgICAgICAgICB0aGlzLiRyb290Q29udGFpbmVyLm1hc2sgPSBvYmo7XG4gICAgfVxuICAgIHVwZGF0ZU9wYXF1ZSgpIHtcbiAgICAgICAgLy8gdG9kb1xuICAgICAgICAvLyBJZiBoaXRBcmVhIHNldCBvbiBhIENvbnRhaW5lciwgY2hpbGRyZW4gb2YgdGhlIENvbnRhaW5lciB3aWxsIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50cy4gIFxuICAgICAgICAvLyBpZiAoIXRoaXMuJGhpdEFyZWEpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuJGhpdEFyZWEgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB0aGlzLiRoaXRBcmVhLmdyYXBoaWNzLmJlZ2luRmlsbCgnIzAwMCcpLmRyYXdSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTsgXG4gICAgICAgIC8vICg8Y3JlYXRlanMuU2hhcGU+dGhpcy4kcm9vdENvbnRhaW5lci5oaXRBcmVhKSA9IHRoaXMuJGhpdEFyZWE7XG4gICAgfVxuICAgIHVwZGF0ZVNjcm9sbFJlY3QoKSB7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy4kcm9vdENvbnRhaW5lci5zY3JvbGxSZWN0O1xuICAgICAgICBpZiAocmVjdCA9PSBudWxsKVxuICAgICAgICAgICAgcmVjdCA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLndpZHRoIC0gdGhpcy4kbWFyZ2luLnJpZ2h0O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaGVpZ2h0IC0gdGhpcy4kbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgcmVjdC54ID0gcmVjdC55ID0gMDtcbiAgICAgICAgcmVjdC53aWR0aCA9IHc7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0gaDtcbiAgICAgICAgdGhpcy4kcm9vdENvbnRhaW5lci5zY3JvbGxSZWN0ID0gcmVjdDtcbiAgICB9XG4gICAgc2V0dXBTY3JvbGwoc2Nyb2xsQmFyTWFyZ2luLCBzY3JvbGwsIHNjcm9sbEJhckRpc3BsYXksIGZsYWdzLCB2dFNjcm9sbEJhclJlcywgaHpTY3JvbGxCYXJSZXMsIGhlYWRlclJlcywgZm9vdGVyUmVzKSB7XG4gICAgICAgIGlmICh0aGlzLiRyb290Q29udGFpbmVyID09IHRoaXMuJGNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICAgICAgICAgICAgdGhpcy4kcm9vdENvbnRhaW5lci5hZGRDaGlsZCh0aGlzLiRjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHNjcm9sbFBhbmUgPSBuZXcgU2Nyb2xsUGFuZSh0aGlzLCBzY3JvbGwsIHNjcm9sbEJhck1hcmdpbiwgc2Nyb2xsQmFyRGlzcGxheSwgZmxhZ3MsIHZ0U2Nyb2xsQmFyUmVzLCBoelNjcm9sbEJhclJlcywgaGVhZGVyUmVzLCBmb290ZXJSZXMpO1xuICAgIH1cbiAgICBzZXR1cE92ZXJmbG93KG92ZXJmbG93KSB7XG4gICAgICAgIGlmIChvdmVyZmxvdyA9PSAxIC8qIEhpZGRlbiAqLykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHJvb3RDb250YWluZXIgPT0gdGhpcy4kY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJvb3RDb250YWluZXIuYWRkQ2hpbGQodGhpcy4kY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsUmVjdCgpO1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnggPSB0aGlzLiRtYXJnaW4ubGVmdDtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci55ID0gdGhpcy4kbWFyZ2luLnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiRtYXJnaW4ubGVmdCAhPSAwIHx8IHRoaXMuJG1hcmdpbi50b3AgIT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHJvb3RDb250YWluZXIgPT0gdGhpcy4kY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJvb3RDb250YWluZXIuYWRkQ2hpbGQodGhpcy4kY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci54ID0gdGhpcy4kbWFyZ2luLmxlZnQ7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIueSA9IHRoaXMuJG1hcmdpbi50b3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRCb3VuZHNDaGFuZ2VkRmxhZygpO1xuICAgIH1cbiAgICBoYW5kbGVTaXplQ2hhbmdlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFBhbmUpXG4gICAgICAgICAgICB0aGlzLiRzY3JvbGxQYW5lLm9uT3duZXJTaXplQ2hhbmdlZCgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLiRyb290Q29udGFpbmVyLnNjcm9sbFJlY3QgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsUmVjdCgpO1xuICAgICAgICBpZiAodGhpcy4kaGl0QXJlYSlcbiAgICAgICAgICAgIHRoaXMuJGhpdEFyZWEuZ3JhcGhpY3MuZHJhd1JlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiRoaXRBcmVhKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygxKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LiRkaXNwbGF5T2JqZWN0LmhpdEFyZWEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRvcGFxdWUpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU9wYXF1ZSgpO1xuICAgIH1cbiAgICBoYW5kbGVHcmF5ZWRDaGFuZ2VkKCkge1xuICAgICAgICBsZXQgYyA9IHRoaXMuZ2V0Q29udHJvbGxlcignZ3JheWVkJyk7XG4gICAgICAgIGlmIChjICE9IG51bGwpXG4gICAgICAgICAgICBjLnNlbGVjdGVkSW5kZXggPSB0aGlzLmdyYXllZCA/IDEgOiAwO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdXBlci5oYW5kbGVHcmF5ZWRDaGFuZ2VkKCk7XG4gICAgfVxuICAgIHNldEJvdW5kc0NoYW5nZWRGbGFnKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHNjcm9sbFBhbmUgJiYgIXRoaXMuJHRyYWNrQm91bmRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuJGJvdW5kc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuJGJvdW5kc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgR1RpbWVyLmluc3QuY2FsbExhdGVyKHRoaXMuJHZhbGlkYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAkdmFsaWRhdGUoZHQpIHtcbiAgICAgICAgaWYgKHRoaXMuJGJvdW5kc0NoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgIH1cbiAgICBlbnN1cmVCb3VuZHNDb3JyZWN0KCkge1xuICAgICAgICBpZiAodGhpcy4kYm91bmRzQ2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XG4gICAgfVxuICAgIHVwZGF0ZUJvdW5kcygpIHtcbiAgICAgICAgbGV0IGF4ID0gMCwgYXkgPSAwLCBhdyA9IDAsIGFoID0gMDtcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgIChheCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSksIChheSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgICAgICBsZXQgYXIgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIGFiID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgbGV0IHRtcCA9IDA7XG4gICAgICAgICAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZC5lbnN1cmVTaXplQ29ycmVjdCgpO1xuICAgICAgICAgICAgICAgIHRtcCA9IGNoaWxkLng7XG4gICAgICAgICAgICAgICAgaWYgKHRtcCA8IGF4KVxuICAgICAgICAgICAgICAgICAgICBheCA9IHRtcDtcbiAgICAgICAgICAgICAgICB0bXAgPSBjaGlsZC55O1xuICAgICAgICAgICAgICAgIGlmICh0bXAgPCBheSlcbiAgICAgICAgICAgICAgICAgICAgYXkgPSB0bXA7XG4gICAgICAgICAgICAgICAgdG1wID0gY2hpbGQueCArIGNoaWxkLmFjdHVhbFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmICh0bXAgPiBhcilcbiAgICAgICAgICAgICAgICAgICAgYXIgPSB0bXA7XG4gICAgICAgICAgICAgICAgdG1wID0gY2hpbGQueSArIGNoaWxkLmFjdHVhbEhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAodG1wID4gYWIpXG4gICAgICAgICAgICAgICAgICAgIGFiID0gdG1wO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhdyA9IGFyIC0gYXg7XG4gICAgICAgICAgICBhaCA9IGFiIC0gYXk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRCb3VuZHMoYXgsIGF5LCBhdywgYWgpO1xuICAgIH1cbiAgICBzZXRCb3VuZHMoYXgsIGF5LCBhdywgYWggPSAwKSB7XG4gICAgICAgIHRoaXMuJGJvdW5kc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFBhbmUpXG4gICAgICAgICAgICB0aGlzLiRzY3JvbGxQYW5lLnNldENvbnRlbnRTaXplKE1hdGgucm91bmQoYXggKyBhdyksIE1hdGgucm91bmQoYXkgKyBhaCkpO1xuICAgIH1cbiAgICBnZXQgdmlld1dpZHRoKCkge1xuICAgICAgICBpZiAodGhpcy4kc2Nyb2xsUGFuZSAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNjcm9sbFBhbmUudmlld1dpZHRoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAtIHRoaXMuJG1hcmdpbi5sZWZ0IC0gdGhpcy4kbWFyZ2luLnJpZ2h0O1xuICAgIH1cbiAgICBzZXQgdmlld1dpZHRoKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRzY3JvbGxQYW5lICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLiRzY3JvbGxQYW5lLnZpZXdXaWR0aCA9IHZhbHVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdmFsdWUgKyB0aGlzLiRtYXJnaW4ubGVmdCArIHRoaXMuJG1hcmdpbi5yaWdodDtcbiAgICB9XG4gICAgZ2V0IHZpZXdIZWlnaHQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRzY3JvbGxQYW5lICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kc2Nyb2xsUGFuZS52aWV3SGVpZ2h0O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQgLSB0aGlzLiRtYXJnaW4udG9wIC0gdGhpcy4kbWFyZ2luLmJvdHRvbTtcbiAgICB9XG4gICAgc2V0IHZpZXdIZWlnaHQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFBhbmUgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuJHNjcm9sbFBhbmUudmlld0hlaWdodCA9IHZhbHVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHZhbHVlICsgdGhpcy4kbWFyZ2luLnRvcCArIHRoaXMuJG1hcmdpbi5ib3R0b207XG4gICAgfVxuICAgIGdldFNuYXBwaW5nUG9zaXRpb24oeFZhbHVlLCB5VmFsdWUsIHJlc3VsdFBvaW50KSB7XG4gICAgICAgIGlmICghcmVzdWx0UG9pbnQpXG4gICAgICAgICAgICByZXN1bHRQb2ludCA9IG5ldyBjcmVhdGVqcy5Qb2ludCgpO1xuICAgICAgICBsZXQgY250ID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAoY250IDw9IDApIHtcbiAgICAgICAgICAgIHJlc3VsdFBvaW50LnggPSAwO1xuICAgICAgICAgICAgcmVzdWx0UG9pbnQueSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0UG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbnN1cmVCb3VuZHNDb3JyZWN0KCk7XG4gICAgICAgIGxldCBvYmogPSBudWxsO1xuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgaWYgKHlWYWx1ZSAhPSAwKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHlWYWx1ZSA8IG9iai55KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSB0aGlzLiRjaGlsZHJlbltpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeVZhbHVlIDwgcHJldi55ICsgcHJldi5hY3R1YWxIZWlnaHQgLyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdG9wIGhhbGYgcGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlWYWx1ZSA9IHByZXYueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYm90dG9tIGhhbGYgcGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlWYWx1ZSA9IG9iai55O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBjbnQpXG4gICAgICAgICAgICAgICAgeVZhbHVlID0gb2JqLnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhWYWx1ZSAhPSAwKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApXG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIG9iaiA9IHRoaXMuJGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmICh4VmFsdWUgPCBvYmoueCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4VmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gdGhpcy4kY2hpbGRyZW5baSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhWYWx1ZSA8IHByZXYueCArIHByZXYuYWN0dWFsV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdG9wIGhhbGYgcGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhWYWx1ZSA9IHByZXYueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYm90dG9tIGhhbGYgcGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhWYWx1ZSA9IG9iai54O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBjbnQpXG4gICAgICAgICAgICAgICAgeFZhbHVlID0gb2JqLng7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0UG9pbnQueCA9IHhWYWx1ZTtcbiAgICAgICAgcmVzdWx0UG9pbnQueSA9IHlWYWx1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFBvaW50O1xuICAgIH1cbiAgICBjaGlsZFNvcnRpbmdPcmRlckNoYW5nZWQoY2hpbGQsIG9sZFZhbHVlLCBuZXdWYWx1ZSA9IDApIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuJHNvcnRpbmdDaGlsZENvdW50LS07XG4gICAgICAgICAgICB0aGlzLnNldENoaWxkSW5kZXgoY2hpbGQsIHRoaXMuJGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLiRzb3J0aW5nQ2hpbGRDb3VudCsrO1xuICAgICAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy4kY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmdldEluc2VydFBvc0ZvclNvcnRpbmdDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICBpZiAob2xkSW5kZXggPCBpbmRleClcbiAgICAgICAgICAgICAgICB0aGlzLiRzZXRDaGlsZEluZGV4KGNoaWxkLCBvbGRJbmRleCwgaW5kZXggLSAxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLiRzZXRDaGlsZEluZGV4KGNoaWxkLCBvbGRJbmRleCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKkBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdEZyb21SZXNvdXJjZSgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RJbnRlcm5hbChudWxsLCAwKTtcbiAgICB9XG4gICAgY29uc3RydWN0SW50ZXJuYWwob2JqZWN0UG9vbCwgcG9vbEluZGV4KSB7XG4gICAgICAgIGxldCB4bWwgPSB0aGlzLnBhY2thZ2VJdGVtLm93bmVyLmdldEl0ZW1Bc3NldCh0aGlzLnBhY2thZ2VJdGVtKTtcbiAgICAgICAgdGhpcy4kaW5Qcm9ncmVzc0J1aWxkaW5nID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgbGV0IGFycjtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuc2l6ZTtcbiAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICAgIHRoaXMuJHNvdXJjZVdpZHRoID0gcGFyc2VJbnQoYXJyWzBdKTtcbiAgICAgICAgdGhpcy4kc291cmNlSGVpZ2h0ID0gcGFyc2VJbnQoYXJyWzFdKTtcbiAgICAgICAgdGhpcy4kaW5pdFdpZHRoID0gdGhpcy4kc291cmNlV2lkdGg7XG4gICAgICAgIHRoaXMuJGluaXRIZWlnaHQgPSB0aGlzLiRzb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuc2V0U2l6ZSh0aGlzLiRzb3VyY2VXaWR0aCwgdGhpcy4kc291cmNlSGVpZ2h0KTtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMucGl2b3Q7XG4gICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuYW5jaG9yO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFNldFBpdm90KHBhcnNlRmxvYXQoYXJyWzBdKSwgcGFyc2VGbG9hdChhcnJbMV0pLCBzdHIgPT0gJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5vcGFxdWU7IC8vIGRlZmF1bHQgZmFsc2VcbiAgICAgICAgdGhpcy5vcGFxdWUgPSBzdHIgIT0gJ2ZhbHNlJztcbiAgICAgICAgbGV0IG92ZXJmbG93O1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5vdmVyZmxvdztcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIG92ZXJmbG93ID0gUGFyc2VPdmVyZmxvd1R5cGUoc3RyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb3ZlcmZsb3cgPSAwIC8qIFZpc2libGUgKi87XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLm1hcmdpbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuJG1hcmdpbi5wYXJzZShzdHIpO1xuICAgICAgICBpZiAob3ZlcmZsb3cgPT0gMiAvKiBTY3JvbGwgKi8pIHtcbiAgICAgICAgICAgIGxldCBzY3JvbGw7XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5zY3JvbGw7XG4gICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgIHNjcm9sbCA9IFBhcnNlU2Nyb2xsVHlwZShzdHIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNjcm9sbCA9IDEgLyogVmVydGljYWwgKi87XG4gICAgICAgICAgICBsZXQgc2Nyb2xsQmFyRGlzcGxheTtcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnNjcm9sbEJhcjtcbiAgICAgICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICAgICAgc2Nyb2xsQmFyRGlzcGxheSA9IFBhcnNlU2Nyb2xsQmFyRGlzcGxheVR5cGUoc3RyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzY3JvbGxCYXJEaXNwbGF5ID0gMCAvKiBEZWZhdWx0ICovO1xuICAgICAgICAgICAgbGV0IHNjcm9sbEJhckZsYWdzO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuc2Nyb2xsQmFyRmxhZ3M7XG4gICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgIHNjcm9sbEJhckZsYWdzID0gcGFyc2VJbnQoc3RyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzY3JvbGxCYXJGbGFncyA9IDA7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsQmFyTWFyZ2luID0gbmV3IE1hcmdpbigpO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuc2Nyb2xsQmFyTWFyZ2luO1xuICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICBzY3JvbGxCYXJNYXJnaW4ucGFyc2Uoc3RyKTtcbiAgICAgICAgICAgIGxldCB2dFNjcm9sbEJhclJlcztcbiAgICAgICAgICAgIGxldCBoelNjcm9sbEJhclJlcztcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnNjcm9sbEJhclJlcztcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICB2dFNjcm9sbEJhclJlcyA9IGFyclswXTtcbiAgICAgICAgICAgICAgICBoelNjcm9sbEJhclJlcyA9IGFyclsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBoZWFkZXJSZXMsIGZvb3RlclJlcztcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnB0clJlcztcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJSZXMgPSBhcnJbMF07XG4gICAgICAgICAgICAgICAgZm9vdGVyUmVzID0gYXJyWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXR1cFNjcm9sbChzY3JvbGxCYXJNYXJnaW4sIHNjcm9sbCwgc2Nyb2xsQmFyRGlzcGxheSwgc2Nyb2xsQmFyRmxhZ3MsIHZ0U2Nyb2xsQmFyUmVzLCBoelNjcm9sbEJhclJlcywgaGVhZGVyUmVzLCBmb290ZXJSZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2V0dXBPdmVyZmxvdyhvdmVyZmxvdyk7XG4gICAgICAgIHRoaXMuJGJ1aWxkaW5nRGlzcGxheUxpc3QgPSB0cnVlO1xuICAgICAgICBsZXQgY29sID0geG1sLmNoaWxkcmVuO1xuICAgICAgICBjb2wuZm9yRWFjaChjeG1sID0+IHtcbiAgICAgICAgICAgIGlmIChjeG1sLm5vZGVOYW1lID09ICdjb250cm9sbGVyJykge1xuICAgICAgICAgICAgICAgIGxldCBjID0gbmV3IENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250cm9sbGVycy5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIGMuJHBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgYy5zZXR1cChjeG1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBkaXNwbGF5TGlzdCA9IHRoaXMucGFja2FnZUl0ZW0uZGlzcGxheUxpc3Q7XG4gICAgICAgIGRpc3BsYXlMaXN0LmZvckVhY2goKGRpLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2hpbGQ7XG4gICAgICAgICAgICBpZiAob2JqZWN0UG9vbCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGNoaWxkID0gb2JqZWN0UG9vbFtwb29sSW5kZXggKyBpXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpLnBhY2thZ2VJdGVtKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBEZWNscy5VSU9iamVjdEZhY3RvcnkubmV3T2JqZWN0KGRpLnBhY2thZ2VJdGVtKTtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYWNrYWdlSXRlbSA9IGRpLnBhY2thZ2VJdGVtO1xuICAgICAgICAgICAgICAgIGNoaWxkLmNvbnN0cnVjdEZyb21SZXNvdXJjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNoaWxkID0gRGVjbHMuVUlPYmplY3RGYWN0b3J5Lm5ld09iamVjdERpcmVjdGx5KGRpLnR5cGUpO1xuICAgICAgICAgICAgY2hpbGQuJGluUHJvZ3Jlc3NCdWlsZGluZyA9IHRydWU7XG4gICAgICAgICAgICBjaGlsZC5zZXR1cEJlZm9yZUFkZChkaS5kZXNjKTtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLiRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubWFzaykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXNrLnNldCh7IHg6IGNoaWxkLm1hc2sueCArIGNoaWxkLngsIHk6IGNoaWxkLm1hc2sueSArIGNoaWxkLnkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5yZWxhdGlvbnMuc2V0dXAoeG1sKTtcbiAgICAgICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgICAgIGNoaWxkLnJlbGF0aW9ucy5zZXR1cChkaXNwbGF5TGlzdFtpXS5kZXNjKTtcbiAgICAgICAgICAgIGNoaWxkLnNldHVwQWZ0ZXJBZGQoZGlzcGxheUxpc3RbaV0uZGVzYyk7XG4gICAgICAgICAgICBjaGlsZC4kaW5Qcm9ncmVzc0J1aWxkaW5nID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5tYXNrO1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5nZXRDaGlsZEJ5SWQoc3RyKTtcbiAgICAgICAgICAgIGxldCBtYXNrT2JqID0gb2JqLmRpc3BsYXlPYmplY3Q7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKG9iaik7XG4gICAgICAgICAgICBpZiAobWFza09iaiBpbnN0YW5jZW9mIGNyZWF0ZWpzLlNoYXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXNrID0gbWFza09iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hc2tPYmpbJyRkaXNwJ10gaW5zdGFuY2VvZiBTcHJpdGUpIDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgU3ByaXRlIG9yIEdyYXBoaWNzIGNhbiBiZSBhcHBsaWVkIGFzIG1hc2sgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29sLmZvckVhY2goY3htbCA9PiB7XG4gICAgICAgICAgICBpZiAoY3htbC5ub2RlTmFtZSA9PSAndHJhbnNpdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhbnMgPSBuZXcgVHJhbnNpdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiR0cmFuc2l0aW9ucy5wdXNoKHRyYW5zKTtcbiAgICAgICAgICAgICAgICB0cmFucy5zZXR1cChjeG1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLiR0cmFuc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm9uKCdhZGRlZCcsIHRoaXMuJGFkZGVkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub24oJ3JlbW92ZWQnLCB0aGlzLiRyZW1vdmVkLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGx5QWxsQ29udHJvbGxlcnMoKTtcbiAgICAgICAgdGhpcy4kYnVpbGRpbmdEaXNwbGF5TGlzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRpblByb2dyZXNzQnVpbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZHJlbkxpc3QoKTtcbiAgICAgICAgdGhpcy5zZXRCb3VuZHNDaGFuZ2VkRmxhZygpO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdEZyb21YTUwoeG1sKTtcbiAgICB9XG4gICAgYXBwZW5kQ2hpbGRyZW5MaXN0KCkge1xuICAgICAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5kaXNwbGF5T2JqZWN0ICE9IG51bGwgJiYgY2hpbGQuZmluYWxWaXNpYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDaGlsZChjaGlsZC5kaXNwbGF5T2JqZWN0KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdEZyb21YTUwoeG1sKSB7IH1cbiAgICAkYWRkZWQoZCkge1xuICAgICAgICB0aGlzLiR0cmFuc2l0aW9ucy5mb3JFYWNoKHRyYW5zID0+IHtcbiAgICAgICAgICAgIGlmICh0cmFucy5hdXRvUGxheSlcbiAgICAgICAgICAgICAgICB0cmFucy5wbGF5KHsgdGltZXM6IHRyYW5zLmF1dG9QbGF5UmVwZWF0LCBkZWxheTogdHJhbnMuYXV0b1BsYXlEZWxheSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgICRyZW1vdmVkKGQpIHtcbiAgICAgICAgdGhpcy4kdHJhbnNpdGlvbnMuZm9yRWFjaCh0cmFucyA9PiB7XG4gICAgICAgICAgICB0cmFucy5zdG9wKGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgV2luZG93IGV4dGVuZHMgR0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuJHJlcXVlc3RpbmdDbWQgPSAwO1xuICAgICAgICB0aGlzLmZvY3VzYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuJHVpU291cmNlcyA9IFtdO1xuICAgICAgICB0aGlzLmJyaW5nVG9Gcm9udE9uQ2xpY2sgPSBVSUNvbmZpZy5icmluZ1dpbmRvd1RvRnJvbnRPbkNsaWNrO1xuICAgICAgICB0aGlzLm9uKCdhZGRlZCcsIHRoaXMuJG9uU2hvd24sIHRoaXMpO1xuICAgICAgICB0aGlzLm9uKCdyZW1vdmVkJywgdGhpcy4kb25IaWRkZW4sIHRoaXMpO1xuICAgICAgICB0aGlzLm9uKEludGVyYWN0aXZlRXZlbnRzLkRvd24sIHRoaXMuJG1vdXNlRG93biwgdGhpcyk7XG4gICAgfVxuICAgIGFkZFVJU291cmNlKHNvdXJjZSkge1xuICAgICAgICB0aGlzLiR1aVNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cbiAgICBzZXQgY29udGVudFBhbmUodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLiRjb250ZW50UGFuZSAhPSB2YWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRjb250ZW50UGFuZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy4kY29udGVudFBhbmUpO1xuICAgICAgICAgICAgdGhpcy4kY29udGVudFBhbmUgPSB2YWw7XG4gICAgICAgICAgICBpZiAodGhpcy4kY29udGVudFBhbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy4kY29udGVudFBhbmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2l6ZSh0aGlzLiRjb250ZW50UGFuZS53aWR0aCwgdGhpcy4kY29udGVudFBhbmUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50UGFuZS5hZGRSZWxhdGlvbih0aGlzLCAyNCAvKiBTaXplICovKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRmcmFtZSA9IHRoaXMuJGNvbnRlbnRQYW5lLmdldENoaWxkKCdmcmFtZScpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRmcmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VCdXR0b24gPSB0aGlzLiRmcmFtZS5nZXRDaGlsZCgnY2xvc2VCdXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnQXJlYSA9IHRoaXMuJGZyYW1lLmdldENoaWxkKCdkcmFnQXJlYScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRBcmVhID0gdGhpcy4kZnJhbWUuZ2V0Q2hpbGQoJ2NvbnRlbnRBcmVhJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb250ZW50UGFuZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRlbnRQYW5lO1xuICAgIH1cbiAgICBnZXQgZnJhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmcmFtZTtcbiAgICB9XG4gICAgZ2V0IGNsb3NlQnV0dG9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY2xvc2VCdXR0b247XG4gICAgfVxuICAgIHNldCBjbG9zZUJ1dHRvbih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kY2xvc2VCdXR0b24gIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuJGNsb3NlQnV0dG9uLnJlbW92ZUNsaWNrKHRoaXMuY2xvc2VFdmVudEhhbmRsZXIpO1xuICAgICAgICB0aGlzLiRjbG9zZUJ1dHRvbiA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy4kY2xvc2VCdXR0b24gIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuJGNsb3NlQnV0dG9uLmNsaWNrKHRoaXMuY2xvc2VFdmVudEhhbmRsZXIsIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZHJhZ0FyZWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRkcmFnQXJlYTtcbiAgICB9XG4gICAgc2V0IGRyYWdBcmVhKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRkcmFnQXJlYSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGRyYWdBcmVhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkcmFnQXJlYS5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLiRkcmFnQXJlYS5vZmYoXCJfX2RyYWdTdGFydFwiIC8qIFNUQVJUICovLCB0aGlzLiRkcmFnU3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kZHJhZ0FyZWEgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRkcmFnQXJlYSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGRyYWdBcmVhIGluc3RhbmNlb2YgR0dyYXBoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRkcmFnQXJlYS5kcmF3UmVjdCgwLCAnIzAwMCcsICcjMDAwJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZHJhZ0FyZWEuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiRkcmFnQXJlYS5vbihcIl9fZHJhZ1N0YXJ0XCIgLyogU1RBUlQgKi8sIHRoaXMuJGRyYWdTdGFydCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRBcmVhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY29udGVudEFyZWE7XG4gICAgfVxuICAgIHNldCBjb250ZW50QXJlYSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiRjb250ZW50QXJlYSA9IHZhbHVlO1xuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgICBEZWNscyQxLkdSb290Lmluc3Quc2hvd1dpbmRvdyh0aGlzKTtcbiAgICB9XG4gICAgc2hvd09uKHJvb3QpIHtcbiAgICAgICAgcm9vdC5zaG93V2luZG93KHRoaXMpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Nob3dpbmcpXG4gICAgICAgICAgICB0aGlzLmRvSGlkZUFuaW1hdGlvbigpO1xuICAgIH1cbiAgICBoaWRlSW1tZWRpYXRlbHkoKSB7XG4gICAgICAgIERlY2xzJDEuR1Jvb3QuaW5zdC5oaWRlV2luZG93SW1tZWRpYXRlbHkodGhpcyk7XG4gICAgfVxuICAgIGNlbnRlck9uKHIsIGF1dG9VcGRhdGUgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNldFhZKE1hdGgucm91bmQoKHIud2lkdGggLSB0aGlzLndpZHRoKSAqIDAuNSksIE1hdGgucm91bmQoKHIuaGVpZ2h0IC0gdGhpcy5oZWlnaHQpICogMC41KSk7XG4gICAgICAgIGlmIChhdXRvVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFJlbGF0aW9uKHIsIDMgLyogQ2VudGVyX0NlbnRlciAqLyk7XG4gICAgICAgICAgICB0aGlzLmFkZFJlbGF0aW9uKHIsIDEwIC8qIE1pZGRsZV9NaWRkbGUgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvZ2dsZVZpc2libGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVG9wKVxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgICBnZXQgaXNTaG93aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgIT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGlzVG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgIT0gbnVsbCAmJiB0aGlzLnBhcmVudC5nZXRDaGlsZEluZGV4KHRoaXMpID09IHRoaXMucGFyZW50Lm51bUNoaWxkcmVuIC0gMTtcbiAgICB9XG4gICAgZ2V0IG1vZGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kbW9kYWw7XG4gICAgfVxuICAgIHNldCBtb2RhbCh2YWwpIHtcbiAgICAgICAgdGhpcy4kbW9kYWwgPSB2YWw7XG4gICAgfVxuICAgIGJyaW5nVG9Gcm9udCgpIHtcbiAgICAgICAgRGVjbHMkMS5HUm9vdC5pbnN0LmJyaW5nVG9Gcm9udCh0aGlzKTtcbiAgICB9XG4gICAgc2hvd01vZGFsV2FpdChtc2csIGNtZCA9IDApIHtcbiAgICAgICAgaWYgKGNtZCAhPSAwKVxuICAgICAgICAgICAgdGhpcy4kcmVxdWVzdGluZ0NtZCA9IGNtZDtcbiAgICAgICAgaWYgKFVJQ29uZmlnLndpbmRvd01vZGFsV2FpdGluZykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiRtb2RhbFdhaXRQYW5lKVxuICAgICAgICAgICAgICAgIHRoaXMuJG1vZGFsV2FpdFBhbmUgPSBVSVBhY2thZ2UuY3JlYXRlT2JqZWN0RnJvbVVSTChVSUNvbmZpZy53aW5kb3dNb2RhbFdhaXRpbmcpO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRNb2RhbFdhaXRQYW5lKG1zZyk7XG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMuJG1vZGFsV2FpdFBhbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxheW91dE1vZGFsV2FpdFBhbmUobXNnKSB7XG4gICAgICAgIGlmICh0aGlzLiRjb250ZW50QXJlYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcHQgPSB0aGlzLiRmcmFtZS5sb2NhbFRvR2xvYmFsKCk7XG4gICAgICAgICAgICBwdCA9IHRoaXMuZ2xvYmFsVG9Mb2NhbChwdC54LCBwdC55LCBwdCk7XG4gICAgICAgICAgICB0aGlzLiRtb2RhbFdhaXRQYW5lLnNldFhZKHB0LnggKyB0aGlzLiRjb250ZW50QXJlYS54LCBwdC55ICsgdGhpcy4kY29udGVudEFyZWEueSk7XG4gICAgICAgICAgICB0aGlzLiRtb2RhbFdhaXRQYW5lLnNldFNpemUodGhpcy4kY29udGVudEFyZWEud2lkdGgsIHRoaXMuJGNvbnRlbnRBcmVhLmhlaWdodCk7XG4gICAgICAgICAgICBpZiAobXNnICYmIG1zZy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy4kbW9kYWxXYWl0UGFuZS50ZXh0ID0gbXNnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuJG1vZGFsV2FpdFBhbmUuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIGNsb3NlTW9kYWxXYWl0KGNtZCA9IDApIHtcbiAgICAgICAgaWYgKGNtZCAhPSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kcmVxdWVzdGluZ0NtZCAhPSBjbWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHJlcXVlc3RpbmdDbWQgPSAwO1xuICAgICAgICBpZiAodGhpcy4kbW9kYWxXYWl0UGFuZSAmJiB0aGlzLiRtb2RhbFdhaXRQYW5lLnBhcmVudCAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLiRtb2RhbFdhaXRQYW5lKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBtb2RhbFdhaXRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRtb2RhbFdhaXRQYW5lICYmIHRoaXMuJG1vZGFsV2FpdFBhbmUucGFyZW50ICE9IG51bGw7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRpbml0ZWQgfHwgdGhpcy4kbG9hZGluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuJHVpU291cmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLiRsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiR1aVNvdXJjZXMuZm9yRWFjaChvID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW8ubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG8ubG9hZCh0aGlzLiR1aUxvYWRDb21wbGV0ZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLiRsb2FkaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMuJGluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRpbml0KCk7XG4gICAgfVxuICAgIG9uSW5pdCgpIHsgfVxuICAgIG9uU2hvd24oKSB7IH1cbiAgICBvbkhpZGUoKSB7IH1cbiAgICBkb1Nob3dBbmltYXRpb24oKSB7XG4gICAgICAgIHRoaXMub25TaG93bigpO1xuICAgIH1cbiAgICBkb0hpZGVBbmltYXRpb24oKSB7XG4gICAgICAgIHRoaXMuaGlkZUltbWVkaWF0ZWx5KCk7XG4gICAgfVxuICAgICR1aUxvYWRDb21wbGV0ZSgpIHtcbiAgICAgICAgbGV0IGNudCA9IHRoaXMuJHVpU291cmNlcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kdWlTb3VyY2VzW2ldLmxvYWRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRpbml0KCk7XG4gICAgfVxuICAgICRpbml0KCkge1xuICAgICAgICB0aGlzLiRpbml0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uSW5pdCgpO1xuICAgICAgICBpZiAodGhpcy5pc1Nob3dpbmcpXG4gICAgICAgICAgICB0aGlzLmRvU2hvd0FuaW1hdGlvbigpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLm9mZignYWRkZWQnLCB0aGlzLiRvblNob3duKTtcbiAgICAgICAgdGhpcy5vZmYoJ3JlbW92ZWQnLCB0aGlzLiRvbkhpZGRlbik7XG4gICAgICAgIHRoaXMub2ZmKEludGVyYWN0aXZlRXZlbnRzLkRvd24sIHRoaXMuJG1vdXNlRG93bik7XG4gICAgICAgIGlmICh0aGlzLiRkcmFnQXJlYSlcbiAgICAgICAgICAgIHRoaXMuJGRyYWdBcmVhLm9mZihcIl9fZHJhZ1N0YXJ0XCIgLyogU1RBUlQgKi8sIHRoaXMuJGRyYWdTdGFydCk7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5oaWRlSW1tZWRpYXRlbHkoKTtcbiAgICAgICAgaWYgKHRoaXMuJG1vZGFsV2FpdFBhbmUpXG4gICAgICAgICAgICB0aGlzLiRtb2RhbFdhaXRQYW5lLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuJGNvbnRlbnRQYW5lKVxuICAgICAgICAgICAgdGhpcy4kY29udGVudFBhbmUuZGlzcG9zZSgpO1xuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGNsb3NlRXZlbnRIYW5kbGVyKGV2dCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gICAgJG9uU2hvd24odGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGhpcy4kaW5pdGVkKVxuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZG9TaG93QW5pbWF0aW9uKCk7XG4gICAgfVxuICAgICRvbkhpZGRlbih0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5jbG9zZU1vZGFsV2FpdCgpO1xuICAgICAgICB0aGlzLm9uSGlkZSgpO1xuICAgIH1cbiAgICAkbW91c2VEb3duKGV2dCkge1xuICAgICAgICBpZiAodGhpcy5pc1Nob3dpbmcgJiYgdGhpcy5icmluZ1RvRnJvbnRPbkNsaWNrKVxuICAgICAgICAgICAgdGhpcy5icmluZ1RvRnJvbnQoKTtcbiAgICB9XG4gICAgJGRyYWdTdGFydChldnQpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRUYXJnZXQgPSBldnQuZGF0YS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICBHT2JqZWN0LmNhc3RGcm9tTmF0aXZlT2JqZWN0KGN1cnJlbnRUYXJnZXQpLnN0b3BEcmFnKCk7XG4gICAgICAgIHRoaXMuc3RhcnREcmFnKGV2dC5kYXRhLnBvaW50ZXJJRCk7XG4gICAgfVxufVxuXG5sZXQgX2luc3Q7XG5jbGFzcyBHUm9vdE1vdXNlU3RhdHVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50b3VjaERvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZVggPSAwO1xuICAgICAgICB0aGlzLm1vdXNlWSA9IDA7XG4gICAgfVxufVxuY2xhc3MgR1Jvb3QgZXh0ZW5kcyBHQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4kdm9sdW1lU2NhbGUgPSAxO1xuICAgICAgICBpZiAoX2luc3QgPT0gbnVsbClcbiAgICAgICAgICAgIF9pbnN0ID0gdGhpcztcbiAgICAgICAgdGhpcy5vcGFxdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kcG9wdXBTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLiRqdXN0Q2xvc2VkUG9wdXBzID0gW107XG4gICAgICAgIHRoaXMuJHVpZCA9IEdSb290LnVuaXF1ZUlEKys7XG4gICAgICAgIERPTUV2ZW50TWFuYWdlci5pbnN0Lm9uKFwiX19tb3VzZVdoZWVsXCIgLyogTU9VU0VfV0hFRUwgKi8sIHRoaXMuZGlzcGF0Y2hNb3VzZVdoZWVsLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZpbmRGb3Iob2JqKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBHUm9vdClcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgcmV0dXJuIF9pbnN0O1xuICAgICAgICB2YXIgcCA9IG9iai5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEdSb290KVxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgcCA9IHAucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfaW5zdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgR1Jvb3Qgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGdldCBpbnN0KCkge1xuICAgICAgICBpZiAoX2luc3QgPT0gbnVsbClcbiAgICAgICAgICAgIF9pbnN0ID0gbmV3IEdSb290KCk7XG4gICAgICAgIHJldHVybiBfaW5zdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhlIGN1cnJlbnQgbW91c2UvcG9pbnRlciBkYXRhXG4gICAgICovXG4gICAgc3RhdGljIGdldCBnbG9iYWxNb3VzZVN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIEdSb290LiRnbVN0YXR1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhlIG1haW4gZW50cnkgdG8gbGF1Y2ggdGhlIFVJIHJvb3QsIGUuZy46IEdSb290Lmluc3QuYXR0YWNoVG8oYXBwLCBvcHRpb25zKVxuICAgICAqIEBwYXJhbSBhcHAgeW91ciBjcmVhdGVqcy5TdGFnZSBpbnN0YW5jZSB0byBiZSB1c2VkIGluIHRoaXMgR1Jvb3QgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gc3RhZ2VPcHRpb25zIHN0YWdlIHJvdGF0aW9uIC8gcmVzaXplIG9wdGlvbnNcbiAgICAgKi9cbiAgICBhdHRhY2hUbyhzdGFnZSwgc3RhZ2VPcHRpb25zKSB7XG4gICAgICAgIGNyZWF0ZWpzLlRvdWNoLmVuYWJsZShzdGFnZSk7XG4gICAgICAgIHN0YWdlLm1vdXNlRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHN0YWdlLm1vdXNlQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICBzdGFnZS5lbmFibGVNb3VzZU92ZXIoNTApO1xuICAgICAgICAvLyBpZiAodGhpcy4kdWlTdGFnZSkge1xuICAgICAgICAvLyAgICAgdGhpcy4kdWlTdGFnZS5vZmYoRGlzcGxheU9iamVjdEV2ZW50LlNJWkVfQ0hBTkdFRCwgdGhpcy4kd2luUmVzaXplKTtcbiAgICAgICAgLy8gICAgIHRoaXMuJHVpU3RhZ2UubmF0aXZlU3RhZ2Uub2ZmKEludGVyYWN0aXZlRXZlbnRzLkRvd24sIHRoaXMuJHN0YWdlRG93bik7XG4gICAgICAgIC8vICAgICB0aGlzLiR1aVN0YWdlLm5hdGl2ZVN0YWdlLm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5VcCwgdGhpcy4kc3RhZ2VVcCk7XG4gICAgICAgIC8vICAgICB0aGlzLiR1aVN0YWdlLm5hdGl2ZVN0YWdlLm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5Nb3ZlLCB0aGlzLiRzdGFnZU1vdmUpO1xuICAgICAgICAvLyAgICAgdGhpcy4kdWlTdGFnZS5uYXRpdmVTdGFnZS5vZmYodGhpcy4kZGlzcGxheU9iamVjdCk7XG4gICAgICAgIC8vICAgICB0aGlzLiR1aVN0YWdlLmRpc3Bvc2UoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICB0aGlzLiR1aVN0YWdlID0gbmV3IFVJU3RhZ2Uoc3RhZ2UsIHN0YWdlT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuJHVpU3RhZ2Uub24oXCJfX3NpemVDaGFuZ2VkXCIgLyogU0laRV9DSEFOR0VEICovLCB0aGlzLiR3aW5SZXNpemUsIHRoaXMpO1xuICAgICAgICB0aGlzLiR1aVN0YWdlLm5hdGl2ZVN0YWdlLm9uKEludGVyYWN0aXZlRXZlbnRzLkRvd24sIHRoaXMuJHN0YWdlRG93biwgdGhpcyk7XG4gICAgICAgIHRoaXMuJHVpU3RhZ2UubmF0aXZlU3RhZ2Uub24oSW50ZXJhY3RpdmVFdmVudHMuVXAsIHRoaXMuJHN0YWdlVXAsIHRoaXMpO1xuICAgICAgICB0aGlzLiR1aVN0YWdlLm5hdGl2ZVN0YWdlLm9uKEludGVyYWN0aXZlRXZlbnRzLk1vdmUsIHRoaXMuJHN0YWdlTW92ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuJHVpU3RhZ2UubmF0aXZlU3RhZ2Uub24oSW50ZXJhY3RpdmVFdmVudHMuQ2xpY2ssIHRoaXMuJGNsaWNrLCB0aGlzKTtcbiAgICAgICAgdGhpcy4kdWlTdGFnZS5uYXRpdmVTdGFnZS5hZGRDaGlsZCh0aGlzLiRkaXNwbGF5T2JqZWN0KTtcbiAgICAgICAgdGhpcy4kd2luUmVzaXplKHRoaXMuJHVpU3RhZ2UpO1xuICAgICAgICBpZiAoIXRoaXMuJG1vZGFsTGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJG1vZGFsTGF5ZXIgPSBuZXcgR0dyYXBoKCk7XG4gICAgICAgICAgICB0aGlzLiRtb2RhbExheWVyLnNldFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy4kbW9kYWxMYXllci5kcmF3UmVjdCgwLCAnJywgVUlDb25maWcubW9kYWxMYXllckNvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuJG1vZGFsTGF5ZXIuYWRkUmVsYXRpb24odGhpcywgMjQgLyogU2l6ZSAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHVuaXF1ZUlEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdWlkO1xuICAgIH1cbiAgICBnZXQgc3RhZ2VXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHVpU3RhZ2Uuc3RhZ2VXaWR0aDtcbiAgICB9XG4gICAgZ2V0IHN0YWdlSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdWlTdGFnZS5zdGFnZUhlaWdodDtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRTY2FsZUZhY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHVpU3RhZ2UucmVzb2x1dGlvbjtcbiAgICB9XG4gICAgZ2V0IGFwcGxpY2F0aW9uQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHVpU3RhZ2UuYXBwbGljYXRpb25Db250ZXh0O1xuICAgIH1cbiAgICBnZXQgbmF0aXZlU3RhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR1aVN0YWdlLm5hdGl2ZVN0YWdlO1xuICAgIH1cbiAgICBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR1aVN0YWdlLm9yaWVudGF0aW9uO1xuICAgIH1cbiAgICBnZXQgc3RhZ2VXcmFwcGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdWlTdGFnZTtcbiAgICB9XG4gICAgZGlzcGF0Y2hNb3VzZVdoZWVsKGV2dCkge1xuICAgICAgICBsZXQgZXZlbnQgPSBldnQuZGF0YS5ldmVudDtcbiAgICAgICAgbGV0IGNoaWxkVW5kZXJNb3VzZSA9IHRoaXMuZ2V0T2JqZWN0VW5kZXJQb2ludChHUm9vdC5nbG9iYWxNb3VzZVN0YXR1cy5tb3VzZVgsIEdSb290Lmdsb2JhbE1vdXNlU3RhdHVzLm1vdXNlWSk7XG4gICAgICAgIGlmIChjaGlsZFVuZGVyTW91c2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy9idWJibGVcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZFVuZGVyTW91c2UucGFyZW50ICYmIGNoaWxkVW5kZXJNb3VzZS5wYXJlbnQgIT0gdGhpcykge1xuICAgICAgICAgICAgICAgIGxldCBtb3VzZVdoZWVsRXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJfX21vdXNlV2hlZWxcIiAvKiBNT1VTRV9XSEVFTCAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIG1vdXNlV2hlZWxFdmVudC5kYXRhID0geyBldmVudCB9O1xuICAgICAgICAgICAgICAgIGNoaWxkVW5kZXJNb3VzZS5kaXNwYXRjaEV2ZW50KG1vdXNlV2hlZWxFdmVudCk7XG4gICAgICAgICAgICAgICAgY2hpbGRVbmRlck1vdXNlID0gY2hpbGRVbmRlck1vdXNlLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG9iamVjdHMgd2hpY2ggYXJlIHBsYWNlZCB1bmRlcm5lYXRoIHRoZSBnaXZlbiBzdGFnZSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIGdsb2JhbFggdGhlIHN0YWdlIFhcbiAgICAgKiBAcGFyYW0gZ2xvYmFsWSB0aGUgc3RhZ2UgWVxuICAgICAqL1xuICAgIGdldE9iamVjdFVuZGVyUG9pbnQoZ2xvYmFsWCwgZ2xvYmFsWSkge1xuICAgICAgICBHUm9vdC5zSGVscGVyUG9pbnQuc2V0VmFsdWVzKGdsb2JhbFgsIGdsb2JhbFkpO1xuICAgICAgICB3aW5kb3dbJ3Rlc3QnXSA9IHRydWU7XG4gICAgICAgIGxldCByZXQgPSB0aGlzLiR1aVN0YWdlLmFwcGxpY2F0aW9uQ29udGV4dC5nZXRPYmplY3RVbmRlclBvaW50KEdSb290LnNIZWxwZXJQb2ludC54LCBHUm9vdC5zSGVscGVyUG9pbnQueSwgMCk7XG4gICAgICAgIHJldHVybiBHT2JqZWN0LmNhc3RGcm9tTmF0aXZlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIHNob3dXaW5kb3cod2luKSB7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQod2luKTtcbiAgICAgICAgd2luLnJlcXVlc3RGb2N1cygpO1xuICAgICAgICBpZiAod2luLnggPiB0aGlzLndpZHRoKVxuICAgICAgICAgICAgd2luLnggPSB0aGlzLndpZHRoIC0gd2luLndpZHRoO1xuICAgICAgICBlbHNlIGlmICh3aW4ueCArIHdpbi53aWR0aCA8IDApXG4gICAgICAgICAgICB3aW4ueCA9IDA7XG4gICAgICAgIGlmICh3aW4ueSA+IHRoaXMuaGVpZ2h0KVxuICAgICAgICAgICAgd2luLnkgPSB0aGlzLmhlaWdodCAtIHdpbi5oZWlnaHQ7XG4gICAgICAgIGVsc2UgaWYgKHdpbi55ICsgd2luLmhlaWdodCA8IDApXG4gICAgICAgICAgICB3aW4ueSA9IDA7XG4gICAgICAgIHRoaXMuYWRqdXN0TW9kYWxMYXllcigpO1xuICAgIH1cbiAgICBoaWRlV2luZG93KHdpbikge1xuICAgICAgICB3aW4uaGlkZSgpO1xuICAgIH1cbiAgICBoaWRlV2luZG93SW1tZWRpYXRlbHkod2luKSB7XG4gICAgICAgIGlmICh3aW4ucGFyZW50ID09IHRoaXMpXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHdpbik7XG4gICAgICAgIHRoaXMuYWRqdXN0TW9kYWxMYXllcigpO1xuICAgIH1cbiAgICBicmluZ1RvRnJvbnQod2luKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpZiAodGhpcy4kbW9kYWxMYXllci5wYXJlbnQgIT0gbnVsbCAmJiAhd2luLm1vZGFsKVxuICAgICAgICAgICAgaSA9IHRoaXMuZ2V0Q2hpbGRJbmRleCh0aGlzLiRtb2RhbExheWVyKSAtIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGkgPSB0aGlzLm51bUNoaWxkcmVuIC0gMTtcbiAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgZyA9IHRoaXMuZ2V0Q2hpbGRBdChpKTtcbiAgICAgICAgICAgIGlmIChnID09IHdpbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoZyBpbnN0YW5jZW9mIFdpbmRvdylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgdGhpcy5zZXRDaGlsZEluZGV4KHdpbiwgaSk7XG4gICAgfVxuICAgIHNob3dNb2RhbFdhaXQobXNnID0gbnVsbCkge1xuICAgICAgICBpZiAoVUlDb25maWcuZ2xvYmFsTW9kYWxXYWl0aW5nICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRtb2RhbFdhaXRQYW5lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRtb2RhbFdhaXRQYW5lID0gVUlQYWNrYWdlLmNyZWF0ZU9iamVjdEZyb21VUkwoVUlDb25maWcuZ2xvYmFsTW9kYWxXYWl0aW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRtb2RhbFdhaXRQYW5lLmFkZFJlbGF0aW9uKHRoaXMsIDI0IC8qIFNpemUgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kbW9kYWxXYWl0UGFuZS5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy4kbW9kYWxXYWl0UGFuZSk7XG4gICAgICAgICAgICB0aGlzLiRtb2RhbFdhaXRQYW5lLnRleHQgPSBtc2c7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2VNb2RhbFdhaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRtb2RhbFdhaXRQYW5lICE9IG51bGwgJiYgdGhpcy4kbW9kYWxXYWl0UGFuZS5wYXJlbnQgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy4kbW9kYWxXYWl0UGFuZSk7XG4gICAgfVxuICAgIGNsb3NlQWxsRXhjZXB0TW9kYWxzKCkge1xuICAgICAgICBsZXQgYXJyID0gdGhpcy4kY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgYXJyLmZvckVhY2goZyA9PiB7XG4gICAgICAgICAgICBpZiAoZyBpbnN0YW5jZW9mIFdpbmRvdyAmJiAhZy5tb2RhbClcbiAgICAgICAgICAgICAgICBnLmhpZGUoKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGNsb3NlQWxsV2luZG93cygpIHtcbiAgICAgICAgbGV0IGFyciA9IHRoaXMuJGNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgIGFyci5mb3JFYWNoKGcgPT4ge1xuICAgICAgICAgICAgaWYgKGcgaW5zdGFuY2VvZiBXaW5kb3cpXG4gICAgICAgICAgICAgICAgZy5oaWRlKCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBnZXRUb3BXaW5kb3coKSB7XG4gICAgICAgIGxldCBjbnQgPSB0aGlzLm51bUNoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBpID0gY250IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBnID0gdGhpcy5nZXRDaGlsZEF0KGkpO1xuICAgICAgICAgICAgaWYgKGcgaW5zdGFuY2VvZiBXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGhhc01vZGFsV2luZG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kbW9kYWxMYXllci5wYXJlbnQgIT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IG1vZGFsV2FpdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG1vZGFsV2FpdFBhbmUgJiYgdGhpcy4kbW9kYWxXYWl0UGFuZS5pbkNvbnRhaW5lcjtcbiAgICB9XG4gICAgc2hvd1BvcHVwKHBvcHVwLCB0YXJnZXQgPSBudWxsLCBkaXIgPSAwIC8qIEF1dG8gKi8pIHtcbiAgICAgICAgaWYgKHRoaXMuJHBvcHVwU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGsgPSB0aGlzLiRwb3B1cFN0YWNrLmluZGV4T2YocG9wdXApO1xuICAgICAgICAgICAgaWYgKGsgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4kcG9wdXBTdGFjay5sZW5ndGggLSAxOyBpID49IGs7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLiRwb3B1cFN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRwb3B1cFN0YWNrLnB1c2gocG9wdXApO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHBvcHVwKTtcbiAgICAgICAgdGhpcy5hZGp1c3RNb2RhbExheWVyKCk7XG4gICAgICAgIGxldCBwb3M7XG4gICAgICAgIGxldCBzaXplVyA9IDAsIHNpemVIID0gMDtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgcG9zID0gdGFyZ2V0LmxvY2FsVG9Sb290KCk7XG4gICAgICAgICAgICBzaXplVyA9IHRhcmdldC53aWR0aDtcbiAgICAgICAgICAgIHNpemVIID0gdGFyZ2V0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwb3MgPSB0aGlzLmdsb2JhbFRvTG9jYWwoR1Jvb3QuJGdtU3RhdHVzLm1vdXNlWCwgR1Jvb3QuJGdtU3RhdHVzLm1vdXNlWSk7XG4gICAgICAgIGxldCB4eCwgeXk7XG4gICAgICAgIHh4ID0gcG9zLng7XG4gICAgICAgIGlmICh4eCArIHBvcHVwLndpZHRoID4gdGhpcy53aWR0aClcbiAgICAgICAgICAgIHh4ID0geHggKyBzaXplVyAtIHBvcHVwLndpZHRoO1xuICAgICAgICB5eSA9IHBvcy55ICsgc2l6ZUg7XG4gICAgICAgIGlmICgoZGlyID09IDAgLyogQXV0byAqLyAmJiB5eSArIHBvcHVwLmhlaWdodCA+IHRoaXMuaGVpZ2h0KSB8fFxuICAgICAgICAgICAgZGlyID09IDIgLyogVXAgKi8pIHtcbiAgICAgICAgICAgIHl5ID0gcG9zLnkgLSBwb3B1cC5oZWlnaHQgLSAxO1xuICAgICAgICAgICAgaWYgKHl5IDwgMCkge1xuICAgICAgICAgICAgICAgIHl5ID0gMDtcbiAgICAgICAgICAgICAgICB4eCArPSBzaXplVyAqIDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3B1cC54ID0geHg7XG4gICAgICAgIHBvcHVwLnkgPSB5eTtcbiAgICB9XG4gICAgdG9nZ2xlUG9wdXAocG9wdXAsIHRhcmdldCA9IG51bGwsIGRpcikge1xuICAgICAgICBpZiAodGhpcy4kanVzdENsb3NlZFBvcHVwcy5pbmRleE9mKHBvcHVwKSAhPSAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zaG93UG9wdXAocG9wdXAsIHRhcmdldCwgZGlyKTtcbiAgICB9XG4gICAgaGlkZVBvcHVwKHBvcHVwID0gbnVsbCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKHBvcHVwICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBrID0gdGhpcy4kcG9wdXBTdGFjay5pbmRleE9mKHBvcHVwKTtcbiAgICAgICAgICAgIGlmIChrICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gdGhpcy4kcG9wdXBTdGFjay5sZW5ndGggLSAxOyBpID49IGs7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVBvcHVwKHRoaXMuJHBvcHVwU3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNudCA9IHRoaXMuJHBvcHVwU3RhY2subGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gY250IC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVBvcHVwKHRoaXMuJHBvcHVwU3RhY2tbaV0pO1xuICAgICAgICAgICAgdGhpcy4kcG9wdXBTdGFjay5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBoYXNBbnlQb3B1cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHBvcHVwU3RhY2subGVuZ3RoICE9IDA7XG4gICAgfVxuICAgIGNsb3NlUG9wdXAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cpXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmhpZGUoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvd1Rvb2x0aXBzKG1zZykge1xuICAgICAgICBpZiAodGhpcy4kZGVmYXVsdFRvb2x0aXBXaW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlc291cmNlVVJMID0gVUlDb25maWcudG9vbHRpcHNXaW47XG4gICAgICAgICAgICBpZiAoIXJlc291cmNlVVJMKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVUlDb25maWcudG9vbHRpcHNXaW4gbm90IGRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRkZWZhdWx0VG9vbHRpcFdpbiA9IFVJUGFja2FnZS5jcmVhdGVPYmplY3RGcm9tVVJMKHJlc291cmNlVVJMKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRkZWZhdWx0VG9vbHRpcFdpbi50ZXh0ID0gbXNnO1xuICAgICAgICB0aGlzLnNob3dUb29sdGlwc1dpbih0aGlzLiRkZWZhdWx0VG9vbHRpcFdpbik7XG4gICAgfVxuICAgIHNob3dUb29sdGlwc1dpbih0b29sdGlwV2luLCBwb3NpdGlvbiA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5oaWRlVG9vbHRpcHMoKTtcbiAgICAgICAgdGhpcy4kdG9vbHRpcFdpbiA9IHRvb2x0aXBXaW47XG4gICAgICAgIGxldCB4eCA9IDA7XG4gICAgICAgIGxldCB5eSA9IDA7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB4eCA9IEdSb290LiRnbVN0YXR1cy5tb3VzZVggKyAxMDtcbiAgICAgICAgICAgIHl5ID0gR1Jvb3QuJGdtU3RhdHVzLm1vdXNlWSArIDIwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeHggPSBwb3NpdGlvbi54O1xuICAgICAgICAgICAgeXkgPSBwb3NpdGlvbi55O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdCA9IHRoaXMuZ2xvYmFsVG9Mb2NhbCh4eCwgeXkpO1xuICAgICAgICB4eCA9IHB0Lng7XG4gICAgICAgIHl5ID0gcHQueTtcbiAgICAgICAgaWYgKHh4ICsgdGhpcy4kdG9vbHRpcFdpbi53aWR0aCA+IHRoaXMud2lkdGgpIHtcbiAgICAgICAgICAgIHh4ID0geHggLSB0aGlzLiR0b29sdGlwV2luLndpZHRoIC0gMTtcbiAgICAgICAgICAgIGlmICh4eCA8IDApXG4gICAgICAgICAgICAgICAgeHggPSAxMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeXkgKyB0aGlzLiR0b29sdGlwV2luLmhlaWdodCA+IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICB5eSA9IHl5IC0gdGhpcy4kdG9vbHRpcFdpbi5oZWlnaHQgLSAxO1xuICAgICAgICAgICAgaWYgKHh4IC0gdGhpcy4kdG9vbHRpcFdpbi53aWR0aCAtIDEgPiAwKVxuICAgICAgICAgICAgICAgIHh4ID0geHggLSB0aGlzLiR0b29sdGlwV2luLndpZHRoIC0gMTtcbiAgICAgICAgICAgIGlmICh5eSA8IDApXG4gICAgICAgICAgICAgICAgeXkgPSAxMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR0b29sdGlwV2luLnggPSB4eDtcbiAgICAgICAgdGhpcy4kdG9vbHRpcFdpbi55ID0geXk7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy4kdG9vbHRpcFdpbik7XG4gICAgfVxuICAgIGhpZGVUb29sdGlwcygpIHtcbiAgICAgICAgaWYgKHRoaXMuJHRvb2x0aXBXaW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHRvb2x0aXBXaW4ucGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy4kdG9vbHRpcFdpbik7XG4gICAgICAgICAgICB0aGlzLiR0b29sdGlwV2luID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZm9jdXMoKSB7XG4gICAgICAgIGlmICh0aGlzLiRmb2N1c2VkT2JqZWN0ICYmICF0aGlzLiRmb2N1c2VkT2JqZWN0Lm9uU3RhZ2UpXG4gICAgICAgICAgICB0aGlzLiRmb2N1c2VkT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGZvY3VzZWRPYmplY3Q7XG4gICAgfVxuICAgIHNldCBmb2N1cyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgKCF2YWx1ZS5mb2N1c2FibGUgfHwgIXZhbHVlLm9uU3RhZ2UpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhcmdldCB0byBmb2N1cycpO1xuICAgICAgICB0aGlzLnNldEZvY3VzKHZhbHVlKTtcbiAgICB9XG4gICAgc2V0Rm9jdXModmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGZvY3VzZWRPYmplY3QgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGZvY3VzZWRPYmplY3QgPSB2YWx1ZTtcbiAgICAgICAgICAgIGxldCBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJfX2ZvY3VzQ2hhbmdlZFwiIC8qIENIQU5HRUQgKi8sIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB2b2x1bWVTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHZvbHVtZVNjYWxlO1xuICAgIH1cbiAgICBzZXQgdm9sdW1lU2NhbGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kdm9sdW1lU2NhbGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcGxheU9uZVNob3RTb3VuZChzb3VuZCwgdm9sdW1lU2NhbGUgPSAxKSB7XG4gICAgICAgIHZhciB2cyA9IHRoaXMuJHZvbHVtZVNjYWxlICogdm9sdW1lU2NhbGU7XG4gICAgICAgIHNvdW5kLnBsYXkoeyB2b2x1bWU6IHZzIH0pO1xuICAgIH1cbiAgICBhZGp1c3RNb2RhbExheWVyKCkge1xuICAgICAgICBsZXQgY250ID0gdGhpcy5udW1DaGlsZHJlbjtcbiAgICAgICAgaWYgKHRoaXMuJG1vZGFsV2FpdFBhbmUgIT0gbnVsbCAmJiB0aGlzLiRtb2RhbFdhaXRQYW5lLnBhcmVudCAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZXRDaGlsZEluZGV4KHRoaXMuJG1vZGFsV2FpdFBhbmUsIGNudCAtIDEpO1xuICAgICAgICBmb3IgKGxldCBpID0gY250IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBnID0gdGhpcy5nZXRDaGlsZEF0KGkpO1xuICAgICAgICAgICAgaWYgKGcgaW5zdGFuY2VvZiBXaW5kb3cgJiYgZy5tb2RhbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRtb2RhbExheWVyLnBhcmVudCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkQXQodGhpcy4kbW9kYWxMYXllciwgaSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENoaWxkSW5kZXhCZWZvcmUodGhpcy4kbW9kYWxMYXllciwgaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRtb2RhbExheWVyLnBhcmVudCAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLiRtb2RhbExheWVyKTtcbiAgICB9XG4gICAgJHN0YWdlRG93bihldnQpIHtcbiAgICAgICAgLy8gc2VlIERyYWcgJiBEcm9wXG4gICAgICAgIEdSb290LiRnbVN0YXR1cy5tb3VzZVggPSBldnQuc3RhZ2VYO1xuICAgICAgICBHUm9vdC4kZ21TdGF0dXMubW91c2VZID0gZXZ0LnN0YWdlWTtcbiAgICAgICAgR1Jvb3QuJGdtU3RhdHVzLnRvdWNoRG93biA9IHRydWU7XG4gICAgICAgIC8vY2hlY2sgZm9jdXNcbiAgICAgICAgbGV0IG1jID0gZXZ0LnRhcmdldDtcbiAgICAgICAgd2hpbGUgKG1jICYmIG1jICE9IHRoaXMubmF0aXZlU3RhZ2UpIHtcbiAgICAgICAgICAgIGlmIChpc1VJT2JqZWN0KG1jKSkge1xuICAgICAgICAgICAgICAgIGxldCBnID0gbWMuVUlPd25lcjtcbiAgICAgICAgICAgICAgICBpZiAoZy50b3VjaGFibGUgJiYgZy5mb2N1c2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRGb2N1cyhnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWMgPSBtYy5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJHRvb2x0aXBXaW4gIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuaGlkZVRvb2x0aXBzKCk7XG4gICAgICAgIHRoaXMuY2hlY2tQb3B1cHMoZXZ0LnRhcmdldCk7XG4gICAgfVxuICAgIGNoZWNrUG9wdXBzKHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy4kY2hlY2tpbmdQb3B1cHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJGNoZWNraW5nUG9wdXBzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kanVzdENsb3NlZFBvcHVwcy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAodGhpcy4kcG9wdXBTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgbWMgPSB0YXJnZXQ7XG4gICAgICAgICAgICB3aGlsZSAobWMgJiYgbWMgIT0gdGhpcy5uYXRpdmVTdGFnZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1VJT2JqZWN0KG1jKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGluZGV4ID0gdGhpcy4kcG9wdXBTdGFjay5pbmRleE9mKG1jLlVJT3duZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9wdXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4kcG9wdXBTdGFjay5sZW5ndGggLSAxOyBpID4gcGluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3B1cCA9IHRoaXMuJHBvcHVwU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVBvcHVwKHBvcHVwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRqdXN0Q2xvc2VkUG9wdXBzLnB1c2gocG9wdXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1jID0gbWMucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNudCA9IHRoaXMuJHBvcHVwU3RhY2subGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHBvcHVwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgcG9wdXAgPSB0aGlzLiRwb3B1cFN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VQb3B1cChwb3B1cCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kanVzdENsb3NlZFBvcHVwcy5wdXNoKHBvcHVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHBvcHVwU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAkc3RhZ2VNb3ZlKGV2dCkge1xuICAgICAgICBHUm9vdC4kZ21TdGF0dXMubW91c2VYID0gZXZ0LnN0YWdlWDtcbiAgICAgICAgR1Jvb3QuJGdtU3RhdHVzLm1vdXNlWSA9IGV2dC5zdGFnZVk7XG4gICAgfVxuICAgICRzdGFnZVVwKGV2dCkge1xuICAgICAgICBHUm9vdC4kZ21TdGF0dXMudG91Y2hEb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGNoZWNraW5nUG9wdXBzID0gZmFsc2U7XG4gICAgfVxuICAgICRjbGljayhldnQpIHsgfVxuICAgICR3aW5SZXNpemUoc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRTaXplKHN0YWdlLnN0YWdlV2lkdGgsIHN0YWdlLnN0YWdlSGVpZ2h0KTtcbiAgICB9XG59XG5HUm9vdC51bmlxdWVJRCA9IDA7XG5HUm9vdC4kZ21TdGF0dXMgPSBuZXcgR1Jvb3RNb3VzZVN0YXR1cygpO1xuRGVjbHMkMS5HUm9vdCA9IEdSb290O1xuXG52YXIgVEVYVF9HUkFESUVOVDtcbihmdW5jdGlvbiAoVEVYVF9HUkFESUVOVCkge1xuICAgIFRFWFRfR1JBRElFTlRbVEVYVF9HUkFESUVOVFtcIkxJTkVBUl9WRVJUSUNBTFwiXSA9IDBdID0gXCJMSU5FQVJfVkVSVElDQUxcIjtcbiAgICBURVhUX0dSQURJRU5UW1RFWFRfR1JBRElFTlRbXCJMSU5FQVJfSE9SSVpPTlRBTFwiXSA9IDFdID0gXCJMSU5FQVJfSE9SSVpPTlRBTFwiO1xufSkoVEVYVF9HUkFESUVOVCB8fCAoVEVYVF9HUkFESUVOVCA9IHt9KSk7XG5jb25zdCBkZWZhdWx0U3R5bGUgPSB7XG4gICAgYWxpZ246ICdsZWZ0JyxcbiAgICBicmVha1dvcmRzOiBmYWxzZSxcbiAgICBkcm9wU2hhZG93OiBmYWxzZSxcbiAgICBkcm9wU2hhZG93QWxwaGE6IDEsXG4gICAgZHJvcFNoYWRvd0FuZ2xlOiBNYXRoLlBJIC8gNixcbiAgICBkcm9wU2hhZG93Qmx1cjogMCxcbiAgICBkcm9wU2hhZG93Q29sb3I6ICdibGFjaycsXG4gICAgZHJvcFNoYWRvd0Rpc3RhbmNlOiA1LFxuICAgIGRyb3BTaGFkb3dPZmZzZXRYOiAwLFxuICAgIGRyb3BTaGFkb3dPZmZzZXRZOiAwLFxuICAgIGZpbGw6ICdibGFjaycsXG4gICAgZmlsbEdyYWRpZW50VHlwZTogVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwsXG4gICAgZmlsbEdyYWRpZW50U3RvcHM6IFtdLFxuICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgZm9udFNpemU6IDI2LFxuICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsXG4gICAgZm9udFZhcmlhbnQ6ICdub3JtYWwnLFxuICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgIGxldHRlclNwYWNpbmc6IDAsXG4gICAgbGluZUhlaWdodDogMCxcbiAgICBsaW5lSm9pbjogJ21pdGVyJyxcbiAgICBtaXRlckxpbWl0OiAxMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICBzdHJva2VUaGlja25lc3M6IDAsXG4gICAgdGV4dEJhc2VsaW5lOiAnYWxwaGFiZXRpYycsXG4gICAgdHJpbTogZmFsc2UsXG4gICAgd2hpdGVTcGFjZTogJ3ByZScsXG4gICAgd29yZFdyYXA6IGZhbHNlLFxuICAgIHdvcmRXcmFwV2lkdGg6IDEwMCxcbiAgICBsZWFkaW5nOiAwXG59O1xuY29uc3QgZ2VuZXJpY0ZvbnRGYW1pbGllcyA9IFsnc2VyaWYnLCAnc2Fucy1zZXJpZicsICdtb25vc3BhY2UnLCAnY3Vyc2l2ZScsICdmYW50YXN5JywgJ3N5c3RlbS11aSddO1xuY2xhc3MgVGV4dFN0eWxlIHtcbiAgICBjb25zdHJ1Y3RvcihzdHlsZSkge1xuICAgICAgICB0aGlzLnN0eWxlSUQgPSAwO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIFV0aWxzLmRlZXBDb3B5UHJvcGVydGllcyh0aGlzLCBzdHlsZSwgc3R5bGUpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkUHJvcGVydGllcyA9IHt9O1xuICAgICAgICBVdGlscy5kZWVwQ29weVByb3BlcnRpZXMoY2xvbmVkUHJvcGVydGllcywgdGhpcywgZGVmYXVsdFN0eWxlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0U3R5bGUoY2xvbmVkUHJvcGVydGllcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgcHJvcGVydGllcyB0byB0aGUgZGVmYXVsdHMgc3BlY2lmaWVkIGluIFRleHRTdHlsZS5wcm90b3R5cGUuX2RlZmF1bHRcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgVXRpbHMuZGVlcENvcHlQcm9wZXJ0aWVzKHRoaXMsIGRlZmF1bHRTdHlsZSwgZGVmYXVsdFN0eWxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYWxpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGlnbjtcbiAgICB9XG4gICAgc2V0IGFsaWduKGFsaWduKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbGlnbiAhPT0gYWxpZ24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FsaWduID0gYWxpZ247XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgbGluZXMgY2FuIGJlIHdyYXBwZWQgd2l0aGluIHdvcmRzLCBpdCBuZWVkcyB3b3JkV3JhcCB0byBiZSBzZXQgdG8gdHJ1ZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgYnJlYWtXb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JyZWFrV29yZHM7XG4gICAgfVxuICAgIHNldCBicmVha1dvcmRzKGJyZWFrV29yZHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JyZWFrV29yZHMgIT09IGJyZWFrV29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2JyZWFrV29yZHMgPSBicmVha1dvcmRzO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgZHJvcCBzaGFkb3cgZm9yIHRoZSB0ZXh0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBkcm9wU2hhZG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvdztcbiAgICB9XG4gICAgc2V0IGRyb3BTaGFkb3coZHJvcFNoYWRvdykge1xuICAgICAgICBpZiAodGhpcy5fZHJvcFNoYWRvdyAhPT0gZHJvcFNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvdyA9IGRyb3BTaGFkb3c7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYWxwaGEgZm9yIHRoZSBkcm9wIHNoYWRvd1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBkcm9wU2hhZG93QWxwaGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93QWxwaGE7XG4gICAgfVxuICAgIHNldCBkcm9wU2hhZG93QWxwaGEoZHJvcFNoYWRvd0FscGhhKSB7XG4gICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93QWxwaGEgIT09IGRyb3BTaGFkb3dBbHBoYSkge1xuICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvd0FscGhhID0gZHJvcFNoYWRvd0FscGhhO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgYW5nbGUgb2YgdGhlIGRyb3Agc2hhZG93XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGRyb3BTaGFkb3dBbmdsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dBbmdsZTtcbiAgICB9XG4gICAgc2V0IGRyb3BTaGFkb3dBbmdsZShkcm9wU2hhZG93QW5nbGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dBbmdsZSAhPT0gZHJvcFNoYWRvd0FuZ2xlKSB7XG4gICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93QW5nbGUgPSBkcm9wU2hhZG93QW5nbGU7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBzaGFkb3cgYmx1ciByYWRpdXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZHJvcFNoYWRvd0JsdXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93Qmx1cjtcbiAgICB9XG4gICAgc2V0IGRyb3BTaGFkb3dCbHVyKGRyb3BTaGFkb3dCbHVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93Qmx1ciAhPT0gZHJvcFNoYWRvd0JsdXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dCbHVyID0gZHJvcFNoYWRvd0JsdXI7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZpbGwgc3R5bGUgdG8gYmUgdXNlZCBvbiB0aGUgZHJvcHNoYWRvdyBlLmcgJ3JlZCcsICcjMDBGRjAwJ1xuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZHJvcFNoYWRvd0NvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0NvbG9yO1xuICAgIH1cbiAgICBzZXQgZHJvcFNoYWRvd0NvbG9yKGRyb3BTaGFkb3dDb2xvcikge1xuICAgICAgICBjb25zdCBvdXRwdXRDb2xvciA9IGdldENvbG9yKGRyb3BTaGFkb3dDb2xvcik7XG4gICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93Q29sb3IgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93Q29sb3IgPSBvdXRwdXRDb2xvcjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIGRpc3RhbmNlIG9mIHRoZSBkcm9wIHNoYWRvd1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBkcm9wU2hhZG93RGlzdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfVxuICAgIHNldCBkcm9wU2hhZG93RGlzdGFuY2UoZHJvcFNoYWRvd0Rpc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93RGlzdGFuY2UgIT09IGRyb3BTaGFkb3dEaXN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvd0Rpc3RhbmNlID0gZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgb2Zmc2V0WCBvZiB0aGUgZHJvcCBzaGFkb3dcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZHJvcFNoYWRvd09mZnNldFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93T2Zmc2V0WDtcbiAgICB9XG4gICAgc2V0IGRyb3BTaGFkb3dPZmZzZXRYKGRyb3BTaGFkb3dPZmZzZXRYKSB7XG4gICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93T2Zmc2V0WCAhPT0gZHJvcFNoYWRvd09mZnNldFgpIHtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dPZmZzZXRYID0gZHJvcFNoYWRvd09mZnNldFg7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBvZmZzZXRZIG9mIHRoZSBkcm9wIHNoYWRvd1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBkcm9wU2hhZG93T2Zmc2V0WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dPZmZzZXRZO1xuICAgIH1cbiAgICBzZXQgZHJvcFNoYWRvd09mZnNldFkoZHJvcFNoYWRvd09mZnNldFkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dPZmZzZXRZICE9PSBkcm9wU2hhZG93T2Zmc2V0WSkge1xuICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvd09mZnNldFkgPSBkcm9wU2hhZG93T2Zmc2V0WTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY2FudmFzIGZpbGxzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCBvbiB0aGUgdGV4dCBlLmcgJ3JlZCcsICcjMDBGRjAwJy5cbiAgICAgKiBDYW4gYmUgYW4gYXJyYXkgdG8gY3JlYXRlIGEgZ3JhZGllbnQgZWcgWycjMDAwMDAwJywnI0ZGRkZGRiddXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZmlsbFN0eWxlfE1ETn1cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xzdHJpbmdbXXxudW1iZXJ8bnVtYmVyW118Q2FudmFzR3JhZGllbnR8Q2FudmFzUGF0dGVybn1cbiAgICAgKi9cbiAgICBnZXQgZmlsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGw7XG4gICAgfVxuICAgIHNldCBmaWxsKGZpbGwpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0Q29sb3IgPSBnZXRDb2xvcihmaWxsKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZpbGwgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsID0gb3V0cHV0Q29sb3I7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZmlsbEdyYWRpZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxHcmFkaWVudFR5cGU7XG4gICAgfVxuICAgIHNldCBmaWxsR3JhZGllbnRUeXBlKGZpbGxHcmFkaWVudFR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpbGxHcmFkaWVudFR5cGUgIT09IGZpbGxHcmFkaWVudFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudFR5cGUgPSBmaWxsR3JhZGllbnRUeXBlO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpbGxHcmFkaWVudFN0b3BzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsbEdyYWRpZW50U3RvcHM7XG4gICAgfVxuICAgIHNldCBmaWxsR3JhZGllbnRTdG9wcyhmaWxsR3JhZGllbnRTdG9wcykge1xuICAgICAgICBpZiAoIWFyZUFycmF5c0VxdWFsKHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzLCBmaWxsR3JhZGllbnRTdG9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzID0gZmlsbEdyYWRpZW50U3RvcHM7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZm9udEZhbWlseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRGYW1pbHk7XG4gICAgfVxuICAgIHNldCBmb250RmFtaWx5KGZvbnRGYW1pbHkpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9udEZhbWlseSAhPT0gZm9udEZhbWlseSkge1xuICAgICAgICAgICAgdGhpcy5fZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZm9udFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250U2l6ZTtcbiAgICB9XG4gICAgc2V0IGZvbnRTaXplKGZvbnRTaXplKSB7XG4gICAgICAgIGlmICh0aGlzLl9mb250U2l6ZSAhPT0gZm9udFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZm9udFN0eWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9udFN0eWxlO1xuICAgIH1cbiAgICBzZXQgZm9udFN0eWxlKGZvbnRTdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5fZm9udFN0eWxlICE9PSBmb250U3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmb250IHZhcmlhbnRcbiAgICAgKiAoJ25vcm1hbCcgb3IgJ3NtYWxsLWNhcHMnKVxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBmb250VmFyaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRWYXJpYW50O1xuICAgIH1cbiAgICBzZXQgZm9udFZhcmlhbnQoZm9udFZhcmlhbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnRWYXJpYW50ICE9PSBmb250VmFyaWFudCkge1xuICAgICAgICAgICAgdGhpcy5fZm9udFZhcmlhbnQgPSBmb250VmFyaWFudDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmb250IHdlaWdodFxuICAgICAqICgnbm9ybWFsJywgJ2JvbGQnLCAnYm9sZGVyJywgJ2xpZ2h0ZXInIGFuZCAnMTAwJywgJzIwMCcsICczMDAnLCAnNDAwJywgJzUwMCcsICc2MDAnLCAnNzAwJywgODAwJyBvciAnOTAwJylcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgZm9udFdlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRXZWlnaHQ7XG4gICAgfVxuICAgIHNldCBmb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnRXZWlnaHQgIT09IGZvbnRXZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFtb3VudCBvZiBzcGFjaW5nIGJldHdlZW4gbGV0dGVycywgZGVmYXVsdCBpcyAwXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGxldHRlclNwYWNpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICAgIH1cbiAgICBzZXQgbGV0dGVyU3BhY2luZyhsZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZXR0ZXJTcGFjaW5nICE9PSBsZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nID0gbGV0dGVyU3BhY2luZztcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lIGhlaWdodCwgYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IGEgbGV0dGVyIHVzZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbGluZUhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gICAgfVxuICAgIHNldCBsaW5lSGVpZ2h0KGxpbmVIZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVIZWlnaHQgIT09IGxpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNwYWNlIGJldHdlZW4gbGluZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbGVhZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWRpbmc7XG4gICAgfVxuICAgIHNldCBsZWFkaW5nKGxlYWRpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlYWRpbmcgIT09IGxlYWRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2xlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxpbmVKb2luIHByb3BlcnR5IHNldHMgdGhlIHR5cGUgb2YgY29ybmVyIGNyZWF0ZWQsIGl0IGNhbiByZXNvbHZlIHNwaWtlZCB0ZXh0IGlzc3Vlcy5cbiAgICAgKiBEZWZhdWx0IGlzICdtaXRlcicgKGNyZWF0ZXMgYSBzaGFycCBjb3JuZXIpLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBsaW5lSm9pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVKb2luO1xuICAgIH1cbiAgICBzZXQgbGluZUpvaW4obGluZUpvaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVKb2luICE9PSBsaW5lSm9pbikge1xuICAgICAgICAgICAgdGhpcy5fbGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtaXRlciBsaW1pdCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ21pdGVyJyBsaW5lSm9pbiBtb2RlXG4gICAgICogVGhpcyBjYW4gcmVkdWNlIG9yIGluY3JlYXNlIHRoZSBzcGlraW5lc3Mgb2YgcmVuZGVyZWQgdGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbWl0ZXJMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pdGVyTGltaXQ7XG4gICAgfVxuICAgIHNldCBtaXRlckxpbWl0KG1pdGVyTGltaXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX21pdGVyTGltaXQgIT09IG1pdGVyTGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMuX21pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT2NjYXNpb25hbGx5IHNvbWUgZm9udHMgYXJlIGNyb3BwZWQuIEFkZGluZyBzb21lIHBhZGRpbmcgd2lsbCBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmdcbiAgICAgKiBieSBhZGRpbmcgcGFkZGluZyB0byBhbGwgc2lkZXMgb2YgdGhlIHRleHQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHBhZGRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgIH1cbiAgICBzZXQgcGFkZGluZyhwYWRkaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYWRkaW5nICE9PSBwYWRkaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY2FudmFzIGZpbGxzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCBvbiB0aGUgdGV4dCBzdHJva2VcbiAgICAgKiBlLmcgJ2JsdWUnLCAnI0ZDRkYwMCdcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgc3Ryb2tlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlO1xuICAgIH1cbiAgICBzZXQgc3Ryb2tlKHN0cm9rZSkge1xuICAgICAgICAvLyBUT0RPOiBDYW4ndCBoYXZlIGRpZmZlcmVudCB0eXBlcyBmb3IgZ2V0dGVyIGFuZCBzZXR0ZXIuIFRoZSBnZXR0ZXIgc2hvdWxkbid0IGhhdmUgdGhlIG51bWJlciB0eXBlIGFzXG4gICAgICAgIC8vICAgICAgIHRoZSBzZXR0ZXIgY29udmVydHMgdG8gc3RyaW5nLiBTZWUgdGhpcyB0aHJlYWQgZm9yIG1vcmUgZGV0YWlsczpcbiAgICAgICAgLy8gICAgICAgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yNTIxXG4gICAgICAgIGNvbnN0IG91dHB1dENvbG9yID0gZ2V0Q29sb3Ioc3Ryb2tlKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0cm9rZSAhPT0gb3V0cHV0Q29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZSA9IG91dHB1dENvbG9yO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB0aGlja25lc3Mgb2YgdGhlIHN0cm9rZS5cbiAgICAgKiBEZWZhdWx0IGlzIDAgKG5vIHN0cm9rZSlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3Ryb2tlVGhpY2tuZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlVGhpY2tuZXNzO1xuICAgIH1cbiAgICBzZXQgc3Ryb2tlVGhpY2tuZXNzKHN0cm9rZVRoaWNrbmVzcykge1xuICAgICAgICBpZiAodGhpcy5fc3Ryb2tlVGhpY2tuZXNzICE9PSBzdHJva2VUaGlja25lc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZVRoaWNrbmVzcyA9IHN0cm9rZVRoaWNrbmVzcztcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlbGluZSBvZiB0aGUgdGV4dCB0aGF0IGlzIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB0ZXh0QmFzZWxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0QmFzZWxpbmU7XG4gICAgfVxuICAgIHNldCB0ZXh0QmFzZWxpbmUodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0QmFzZWxpbmUgIT09IHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpbSB0cmFuc3BhcmVudCBib3JkZXJzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCB0cmltKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpbTtcbiAgICB9XG4gICAgc2V0IHRyaW0odHJpbSkge1xuICAgICAgICBpZiAodGhpcy5fdHJpbSAhPT0gdHJpbSkge1xuICAgICAgICAgICAgdGhpcy5fdHJpbSA9IHRyaW07XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIb3cgbmV3bGluZXMgYW5kIHNwYWNlcyBzaG91bGQgYmUgaGFuZGxlZC5cbiAgICAgKiBEZWZhdWx0IGlzICdwcmUnIChwcmVzZXJ2ZSwgcHJlc2VydmUpLlxuICAgICAqXG4gICAgICogIHZhbHVlICAgICAgIHwgTmV3IGxpbmVzICAgICB8ICAgU3BhY2VzXG4gICAgICogIC0tLSAgICAgICAgIHwgLS0tICAgICAgICAgICB8ICAgLS0tXG4gICAgICogJ25vcm1hbCcgICAgIHwgQ29sbGFwc2UgICAgICB8ICAgQ29sbGFwc2VcbiAgICAgKiAncHJlJyAgICAgICAgfCBQcmVzZXJ2ZSAgICAgIHwgICBQcmVzZXJ2ZVxuICAgICAqICdwcmUtbGluZScgICB8IFByZXNlcnZlICAgICAgfCAgIENvbGxhcHNlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHdoaXRlU3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGl0ZVNwYWNlO1xuICAgIH1cbiAgICBzZXQgd2hpdGVTcGFjZSh3aGl0ZVNwYWNlKSB7XG4gICAgICAgIGlmICh0aGlzLl93aGl0ZVNwYWNlICE9PSB3aGl0ZVNwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLl93aGl0ZVNwYWNlID0gd2hpdGVTcGFjZTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB3b3JkIHdyYXAgc2hvdWxkIGJlIHVzZWRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHdvcmRXcmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd29yZFdyYXA7XG4gICAgfVxuICAgIHNldCB3b3JkV3JhcCh3b3JkV3JhcCkge1xuICAgICAgICBpZiAodGhpcy5fd29yZFdyYXAgIT09IHdvcmRXcmFwKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JkV3JhcCA9IHdvcmRXcmFwO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIGF0IHdoaWNoIHRleHQgd2lsbCB3cmFwLCBpdCBuZWVkcyB3b3JkV3JhcCB0byBiZSBzZXQgdG8gdHJ1ZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB3b3JkV3JhcFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd29yZFdyYXBXaWR0aDtcbiAgICB9XG4gICAgc2V0IHdvcmRXcmFwV2lkdGgod29yZFdyYXBXaWR0aCkge1xuICAgICAgICBpZiAodGhpcy5fd29yZFdyYXBXaWR0aCAhPT0gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fd29yZFdyYXBXaWR0aCA9IHdvcmRXcmFwV2lkdGg7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBmb250IHN0eWxlIHN0cmluZyB0byB1c2UgZm9yIGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udCgpYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gRm9udCBzdHlsZSBzdHJpbmcsIGZvciBwYXNzaW5nIHRvIGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udCgpYFxuICAgICAqL1xuICAgIHRvRm9udFN0cmluZygpIHtcbiAgICAgICAgLy8gYnVpbGQgY2FudmFzIGFwaSBmb250IHNldHRpbmcgZnJvbSBpbmRpdmlkdWFsIGNvbXBvbmVudHMuIENvbnZlcnQgYSBudW1lcmljIHRoaXMuZm9udFNpemUgdG8gcHhcbiAgICAgICAgY29uc3QgZm9udFNpemVTdHJpbmcgPSB0eXBlb2YgdGhpcy5mb250U2l6ZSA9PT0gJ251bWJlcicgPyBgJHt0aGlzLmZvbnRTaXplfXB4YCA6IHRoaXMuZm9udFNpemU7XG4gICAgICAgIC8vIENsZWFuLXVwIGZvbnRGYW1pbHkgcHJvcGVydHkgYnkgcXVvdGluZyBlYWNoIGZvbnQgbmFtZVxuICAgICAgICAvLyB0aGlzIHdpbGwgc3VwcG9ydCBmb250IG5hbWVzIHdpdGggc3BhY2VzXG4gICAgICAgIGxldCBmb250RmFtaWxpZXMgPSB0aGlzLmZvbnRGYW1pbHk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmZvbnRGYW1pbHkpKSB7XG4gICAgICAgICAgICBmb250RmFtaWxpZXMgPSB0aGlzLmZvbnRGYW1pbHkuc3BsaXQoJywnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gZm9udEZhbWlsaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAvLyBUcmltIGFueSBleHRyYSB3aGl0ZS1zcGFjZVxuICAgICAgICAgICAgbGV0IGZvbnRGYW1pbHkgPSBmb250RmFtaWxpZXNbaV0udHJpbSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZm9udCBhbHJlYWR5IGNvbnRhaW5zIHN0cmluZ3NcbiAgICAgICAgICAgIGlmICghLyhbXFxcIlxcJ10pW15cXCdcXFwiXStcXDEvLnRlc3QoZm9udEZhbWlseSkgJiYgZ2VuZXJpY0ZvbnRGYW1pbGllcy5pbmRleE9mKGZvbnRGYW1pbHkpIDwgMCkge1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBgXCIke2ZvbnRGYW1pbHl9XCJgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9udEZhbWlsaWVzW2ldID0gZm9udEZhbWlseTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5mb250U3R5bGV9ICR7dGhpcy5mb250VmFyaWFudH0gJHt0aGlzLmZvbnRXZWlnaHR9ICR7Zm9udFNpemVTdHJpbmd9ICR7Zm9udEZhbWlsaWVzLmpvaW4oJywnKX1gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNpbmdsZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWwuY29udmVydFRvSHRtbENvbG9yKGNvbG9yKTtcbiAgICAgICAgLy8gLy8gdG9kb1xuICAgICAgICAvLyByZXR1cm4gY29sb3JcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY29sb3IuaW5kZXhPZignMHgnKSA9PT0gMCkge1xuICAgICAgICAgICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKCcweCcsICcjJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xufVxuZnVuY3Rpb24gZ2V0Q29sb3IoY29sb3IpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgICAgIHJldHVybiBnZXRTaW5nbGVDb2xvcihjb2xvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbG9yLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb2xvcltpXSA9IGdldFNpbmdsZUNvbG9yKGNvbG9yW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYXJyYXkxLCBhcnJheTIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkxKSB8fCAhQXJyYXkuaXNBcnJheShhcnJheTIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGFycmF5MS5sZW5ndGggIT09IGFycmF5Mi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuY2xhc3MgVUlUZXh0RmllbGQgZXh0ZW5kcyBjcmVhdGVqcy5UZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLiRtaW5IZWlnaHRJRCA9IC0xO1xuICAgICAgICB0aGlzLlVJT3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy5zdHlsZSA9IG5ldyBUZXh0U3R5bGUoe30pO1xuICAgICAgICAvLyB0aGlzLm1vdXNlRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAvLyB0aGlzLmludGVyYWN0aXZlID0gdGhpcy5pbnRlcmFjdGl2ZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgIC8vIHRoaXMuX3RleHR1cmUubm9GcmFtZSA9IGZhbHNlO1xuICAgICAgICAvLyB0aGlzLl93aWR0aCA9IHRoaXMuX3RleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgICAgIC8vIHRoaXMuX2hlaWdodCA9IHRoaXMuX3RleHR1cmUuZnJhbWUuaGVpZ2h0O1xuICAgICAgICAvLyB0aGlzLiRtaW5IZWlnaHQgPSAtMTtcbiAgICAgICAgLy8gdGhpcy5fdGV4dHVyZS5vbihcInVwZGF0ZVwiLCB0aGlzLnVwZGF0ZUZyYW1lLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG1pbkhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG1pbkhlaWdodDtcbiAgICB9XG4gICAgYXBwbHlTdHlsZSgpIHtcbiAgICAgICAgbGV0IGNhbnZhcyA9IERlY2xzJDEuR1Jvb3QuaW5zdC5hcHBsaWNhdGlvbkNvbnRleHQuY2FudmFzO1xuICAgICAgICB0aGlzLmZvbnQgPSB0aGlzLnN0eWxlLnRvRm9udFN0cmluZygpO1xuICAgICAgICB0aGlzLmNvbG9yID0gdGhpcy5zdHlsZS5maWxsO1xuICAgICAgICBsZXQgbGV0dGVyU3BhY2luZyA9IHRoaXMuc3R5bGUubGV0dGVyU3BhY2luZztcbiAgICAgICAgaWYgKGxldHRlclNwYWNpbmcpIHtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gYCR7bGV0dGVyU3BhY2luZ31weGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUubGV0dGVyU3BhY2luZyA9IGAwcHhgO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsZWFkaW5nID0gdGhpcy5zdHlsZS5sZWFkaW5nO1xuICAgICAgICBpZiAobGVhZGluZykge1xuICAgICAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gdGhpcy5nZXRNZWFzdXJlZExpbmVIZWlnaHQoKSArIGxlYWRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSB0aGlzLmdldE1lYXN1cmVkTGluZUhlaWdodCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdHJva2VUaGlja25lc3MgPSB0aGlzLnN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICAgICAgaWYgKHN0cm9rZVRoaWNrbmVzcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsZSA9IG5ldyBjcmVhdGVqcy5UZXh0KHRoaXMudGV4dCwgdGhpcy5mb250LCB0aGlzLmNvbG9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLlVJT3duZXIucGFyZW50LmRpc3BsYXlPYmplY3QuYWRkQ2hpbGQodGhpcy5tdWx0aXBsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm11bHRpcGxlLm91dGxpbmUgPSBzdHJva2VUaGlja25lc3M7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHlsZS5zdHJva2UgIT0gdGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbGUuY29sb3IgPSB0aGlzLnN0eWxlLnN0cm9rZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubXVsdGlwbGUubGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgICAgIHRoaXMubXVsdGlwbGUubGluZVdpZHRoID0gdGhpcy5saW5lV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNoYWRvdyA9IG5ldyBjcmVhdGVqcy5TaGFkb3codGhpcy5zdHlsZS5kcm9wU2hhZG93Q29sb3IsIHRoaXMuc3R5bGUuZHJvcFNoYWRvd09mZnNldFgsIHRoaXMuc3R5bGUuZHJvcFNoYWRvd09mZnNldFksIHRoaXMuc3R5bGUuZHJvcFNoYWRvd0JsdXIpO1xuICAgICAgICB0aGlzLnNoYWRvdyA9IHNoYWRvdztcbiAgICAgICAgbGV0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5zZXRCb3VuZHMoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIC8qKkBpbnRlcm5hbCAqL1xuICAgICR1cGRhdGVNaW5IZWlnaHQoKSB7XG4gICAgICAgIHRoaXMuJG1pbkhlaWdodCA9IHRoaXMuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0KCk7XG4gICAgfVxuICAgIC8vIHByb3RlY3RlZCB1cGRhdGVGcmFtZSgpOiB2b2lkIHtcbiAgICAvLyAgICAgR1RpbWVyLmluc3QuY2FsbExhdGVyKHRoaXMuaW50ZXJuYWxVcGRhdGVGcmFtZSwgdGhpcyk7XG4gICAgLy8gfVxuICAgIC8vIHByaXZhdGUgaW50ZXJuYWxVcGRhdGVGcmFtZSgpOiB2b2lkIHtcbiAgICAvLyBpZih0aGlzLl90ZXh0dXJlKSB7XG4gICAgLy8gICAgIGxldCBmcm0gPSB0aGlzLl90ZXh0dXJlLmZyYW1lO1xuICAgIC8vICAgICB0aGlzLl9oZWlnaHQgPSBNYXRoLm1heCh0aGlzLl9oZWlnaHQsIHRoaXMuJG1pbkhlaWdodCk7XG4gICAgLy8gICAgIGxldCB3ID0gZnJtLnggKyB0aGlzLl93aWR0aCwgaCA9IGZybS55ICsgdGhpcy5faGVpZ2h0O1xuICAgIC8vICAgICBpZih3ID4gdGhpcy5fdGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aClcbiAgICAvLyAgICAgICAgIHcgPSB0aGlzLl90ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoIC0gZnJtLng7XG4gICAgLy8gICAgIGlmKGggPiB0aGlzLl90ZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodClcbiAgICAvLyAgICAgICAgIGggPSB0aGlzLl90ZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodCAtIGZybS55O1xuICAgIC8vICAgICBmcm0ud2lkdGggPSB3IC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIC8vICAgICBmcm0uaGVpZ2h0ID0gaCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICAvLyAgICAgdGhpcy5fdGV4dHVyZS50cmltLndpZHRoID0gZnJtLndpZHRoO1xuICAgIC8vICAgICB0aGlzLl90ZXh0dXJlLnRyaW0uaGVpZ2h0ID0gZnJtLmhlaWdodDtcbiAgICAvLyAgICAgbGV0IHBhZGRpbmcgPSB0aGlzLl9zdHlsZS50cmltID8gMCA6IHRoaXMuX3N0eWxlLnBhZGRpbmc7XG4gICAgLy8gICAgIHRoaXMuX3RleHR1cmUudHJpbS54ID0gLXBhZGRpbmc7XG4gICAgLy8gICAgIHRoaXMuX3RleHR1cmUudHJpbS55ID0gLXBhZGRpbmc7XG4gICAgLy8gICAgIHRoaXMuX3RleHR1cmUuZnJhbWUgPSBmcm07XG4gICAgLy8gfVxuICAgIC8vIH1cbiAgICAvL2NhbmNlbCBzY2FsaW5nIHVwZGF0ZVxuICAgIC8vIHByb3RlY3RlZCBfb25UZXh0dXJlVXBkYXRlKCk6IHZvaWQge1xuICAgIC8vIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgIC8vIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcbiAgICAvLyB9XG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNZXRyaWNzKClbJ3dpZHRoJ107XG4gICAgfVxuICAgIHNldCB3aWR0aCh2KSB7XG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gdjtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlwbGUubGluZVdpZHRoID0gdjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0O1xuICAgIH1cbiAgICBzZXQgaGVpZ2h0KHYpIHtcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gdjtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlwbGUubGluZUhlaWdodCA9IHY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRleHRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1lYXN1cmVkSGVpZ2h0KCk7XG4gICAgfVxuICAgIHNldCB0ZXh0SGVpZ2h0KHYpIHsgfVxuICAgIGdldCB0ZXh0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1lYXN1cmVkV2lkdGgoKTtcbiAgICB9XG4gICAgc2V0IGNvbnRlbnQodikge1xuICAgICAgICB0aGlzLnRleHQgPSB2O1xuICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5tdWx0aXBsZS50ZXh0ID0gdjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gICAgdXBkYXRlTXVsdGlwbGVQb3NpdGlvbih4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLm11bHRpcGxlLnggPSB4O1xuICAgICAgICAgICAgdGhpcy5tdWx0aXBsZS55ID0geTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgVGV4dE1ldHJpY3Mge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHN0eWxlLCB3aWR0aCwgaGVpZ2h0LCBsaW5lcywgbGluZVdpZHRocywgbGluZUhlaWdodCwgbWF4TGluZVdpZHRoLCBmb250UHJvcGVydGllcykge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5saW5lV2lkdGhzID0gbGluZVdpZHRocztcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgdGhpcy5tYXhMaW5lV2lkdGggPSBtYXhMaW5lV2lkdGg7XG4gICAgICAgIHRoaXMuZm9udFByb3BlcnRpZXMgPSBmb250UHJvcGVydGllcztcbiAgICB9XG4gICAgc3RhdGljIG1lYXN1cmVUZXh0KHRleHQsIHN0eWxlLCB3b3JkV3JhcCwgY2FudmFzID0gVGV4dE1ldHJpY3MuX2NhbnZhcykge1xuICAgICAgICB3b3JkV3JhcCA9IHdvcmRXcmFwID09PSB1bmRlZmluZWQgfHwgd29yZFdyYXAgPT09IG51bGwgPyBzdHlsZS53b3JkV3JhcCA6IHdvcmRXcmFwO1xuICAgICAgICBjb25zdCBmb250ID0gc3R5bGUudG9Gb250U3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGZvbnRQcm9wZXJ0aWVzID0gVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoZm9udCk7XG4gICAgICAgIC8vIGZhbGxiYWNrIGluIGNhc2UgVUEgZGlzYWxsb3cgY2FudmFzIGRhdGEgZXh0cmFjdGlvblxuICAgICAgICAvLyAodG9EYXRhVVJJLCBnZXRJbWFnZURhdGEgZnVuY3Rpb25zKVxuICAgICAgICBpZiAoZm9udFByb3BlcnRpZXMuZm9udFNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplID0gc3R5bGUuZm9udFNpemU7XG4gICAgICAgICAgICBmb250UHJvcGVydGllcy5hc2NlbnQgPSBzdHlsZS5mb250U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgICAgIGNvbnN0IG91dHB1dFRleHQgPSB3b3JkV3JhcCA/IFRleHRNZXRyaWNzLndvcmRXcmFwKHRleHQsIHN0eWxlLCBjYW52YXMpIDogdGV4dDtcbiAgICAgICAgY29uc3QgbGluZXMgPSBvdXRwdXRUZXh0LnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKTtcbiAgICAgICAgY29uc3QgbGluZVdpZHRocyA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgICAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZVdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGggKyAobGluZXNbaV0ubGVuZ3RoIC0gMSkgKiBzdHlsZS5sZXR0ZXJTcGFjaW5nO1xuICAgICAgICAgICAgbGluZVdpZHRoc1tpXSA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGluZVdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2lkdGggPSBtYXhMaW5lV2lkdGggKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgICAgICAgICB3aWR0aCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IHN0eWxlLmxpbmVIZWlnaHQgfHwgZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgICAgIGxldCBoZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcykgK1xuICAgICAgICAgICAgKGxpbmVzLmxlbmd0aCAtIDEpICogKGxpbmVIZWlnaHQgKyBzdHlsZS5sZWFkaW5nKTtcbiAgICAgICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICAgICAgICAgIGhlaWdodCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0TWV0cmljcyh0ZXh0LCBzdHlsZSwgd2lkdGgsIGhlaWdodCwgbGluZXMsIGxpbmVXaWR0aHMsIGxpbmVIZWlnaHQgKyBzdHlsZS5sZWFkaW5nLCBtYXhMaW5lV2lkdGgsIGZvbnRQcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgc3RhdGljIHdvcmRXcmFwKHRleHQsIHN0eWxlLCBjYW52YXMgPSBUZXh0TWV0cmljcy5fY2FudmFzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGxpbmUgPSAnJztcbiAgICAgICAgbGV0IGxpbmVzID0gJyc7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY29uc3QgeyBsZXR0ZXJTcGFjaW5nLCB3aGl0ZVNwYWNlIH0gPSBzdHlsZTtcbiAgICAgICAgLy8gSG93IHRvIGhhbmRsZSB3aGl0ZXNwYWNlc1xuICAgICAgICBjb25zdCBjb2xsYXBzZVNwYWNlcyA9IFRleHRNZXRyaWNzLmNvbGxhcHNlU3BhY2VzKHdoaXRlU3BhY2UpO1xuICAgICAgICBjb25zdCBjb2xsYXBzZU5ld2xpbmVzID0gVGV4dE1ldHJpY3MuY29sbGFwc2VOZXdsaW5lcyh3aGl0ZVNwYWNlKTtcbiAgICAgICAgLy8gd2hldGhlciBvciBub3Qgc3BhY2VzIG1heSBiZSBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIGxpbmVzXG4gICAgICAgIGxldCBjYW5QcmVwZW5kU3BhY2VzID0gIWNvbGxhcHNlU3BhY2VzO1xuICAgICAgICBjb25zdCB3b3JkV3JhcFdpZHRoID0gc3R5bGUud29yZFdyYXBXaWR0aCArIGxldHRlclNwYWNpbmc7XG4gICAgICAgIC8vIGJyZWFrIHRleHQgaW50byB3b3Jkcywgc3BhY2VzIGFuZCBuZXdsaW5lIGNoYXJzXG4gICAgICAgIGNvbnN0IHRva2VucyA9IFRleHRNZXRyaWNzLnRva2VuaXplKHRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSB3b3JkLCBzcGFjZSBvciBuZXdsaW5lQ2hhclxuICAgICAgICAgICAgbGV0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgLy8gaWYgd29yZCBpcyBhIG5ldyBsaW5lXG4gICAgICAgICAgICBpZiAoVGV4dE1ldHJpY3MuaXNOZXdsaW5lKHRva2VuKSkge1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgdGhlIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKCFjb2xsYXBzZU5ld2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIGNvbGxhcHNlIG5ldyBsaW5lc1xuICAgICAgICAgICAgICAgIC8vIHdlIHNpbXBseSBjb252ZXJ0IGl0IGludG8gYSBzcGFjZVxuICAgICAgICAgICAgICAgIHRva2VuID0gJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIGNvbGxhcHNlIHJlcGVhdGVkIHdoaXRlc3BhY2VzXG4gICAgICAgICAgICBpZiAoY29sbGFwc2VTcGFjZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBib3RoIHRoaXMgYW5kIHRoZSBsYXN0IHRva2VucyBmb3Igc3BhY2VzXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycklzQnJlYWtpbmdTcGFjZSA9IFRleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdElzQnJlYWtpbmdTcGFjZSA9IFRleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZShsaW5lW2xpbmUubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJySXNCcmVha2luZ1NwYWNlICYmIGxhc3RJc0JyZWFraW5nU3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2V0IHdvcmQgd2lkdGggZnJvbSBjYWNoZSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgY29uc3QgdG9rZW5XaWR0aCA9IFRleHRNZXRyaWNzLmdldEZyb21DYWNoZSh0b2tlbiwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgLy8gd29yZCBpcyBsb25nZXIgdGhhbiBkZXNpcmVkIGJvdW5kc1xuICAgICAgICAgICAgaWYgKHRva2VuV2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBhbHJlYWR5IGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG5ld2xpbmVzIGZvciBvdmVyZmxvdyB3b3Jkc1xuICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYnJlYWsgbGFyZ2Ugd29yZCBvdmVyIG11bHRpcGxlIGxpbmVzXG4gICAgICAgICAgICAgICAgaWYgKFRleHRNZXRyaWNzLmNhbkJyZWFrV29yZHModG9rZW4sIHN0eWxlLmJyZWFrV29yZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJyZWFrIHdvcmQgaW50byBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlcnMgPSBUZXh0TWV0cmljcy53b3JkV3JhcFNwbGl0KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aGUgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoYXJhY3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGFyID0gY2hhcmFjdGVyc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBrID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgYXQgdGhlIGVuZCBvZiB0aGUgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJzW2ogKyBrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyID0gY2hhcmFjdGVyc1tqICsga107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdENoYXIgPSBjaGFyW2NoYXIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBzcGxpdCBjaGFyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVGV4dE1ldHJpY3MuY2FuQnJlYWtDaGFycyhsYXN0Q2hhciwgbmV4dENoYXIsIHRva2VuLCBqLCBzdHlsZS5icmVha1dvcmRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21iaW5lIGNoYXJzICYgbW92ZSBmb3J3YXJkIG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyICs9IG5leHRDaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gY2hhci5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhcmFjdGVyV2lkdGggPSBUZXh0TWV0cmljcy5nZXRGcm9tQ2FjaGUoY2hhciwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3RlcldpZHRoICsgd2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgKz0gVGV4dE1ldHJpY3MuYWRkTGluZShsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoICs9IGNoYXJhY3RlcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJ1biB3b3JkIG91dCBvZiB0aGUgYm91bmRzXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSB3b3JkcyBpbiB0aGlzIGxpbmUgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5pc2ggdGhhdCBsaW5lIGFuZCBzdGFydCBhIG5ldyBvbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgKz0gVGV4dE1ldHJpY3MuYWRkTGluZShsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xhc3RUb2tlbiA9IGkgPT09IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIGl0IGl0cyBvd24gbGluZSBpZiBpdCdzIG5vdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUodG9rZW4sICFpc0xhc3RUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd29yZCBjb3VsZCBmaXRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdvcmQgd29uJ3QgZml0IGJlY2F1c2Ugb2YgZXhpc3Rpbmcgd29yZHNcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXRzIGEgc3BhY2Ugd2UgZG9uJ3Qgd2FudCBpdFxuICAgICAgICAgICAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGEgbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBzcGFjZXMgdG8gdGhlIGJlZ2lubmluZyBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDAgfHwgIVRleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZSh0b2tlbikgfHwgY2FuUHJlcGVuZFNwYWNlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHdvcmQgdG8gdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgICAgICBsaW5lICs9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgd2lkdGggY291bnRlclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSB0b2tlbldpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICBzdGF0aWMgYWRkTGluZShsaW5lLCBuZXdMaW5lID0gdHJ1ZSkge1xuICAgICAgICBsaW5lID0gVGV4dE1ldHJpY3MudHJpbVJpZ2h0KGxpbmUpO1xuICAgICAgICBsaW5lID0gbmV3TGluZSA/IGAke2xpbmV9XFxuYCA6IGxpbmU7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RnJvbUNhY2hlKGtleSwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gY2FjaGVba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNpbmcgPSBrZXkubGVuZ3RoICogbGV0dGVyU3BhY2luZztcbiAgICAgICAgICAgIHdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChrZXkpLndpZHRoICsgc3BhY2luZztcbiAgICAgICAgICAgIGNhY2hlW2tleV0gPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICAgIHN0YXRpYyBjb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKSB7XG4gICAgICAgIHJldHVybiB3aGl0ZVNwYWNlID09PSAnbm9ybWFsJyB8fCB3aGl0ZVNwYWNlID09PSAncHJlLWxpbmUnO1xuICAgIH1cbiAgICBzdGF0aWMgY29sbGFwc2VOZXdsaW5lcyh3aGl0ZVNwYWNlKSB7XG4gICAgICAgIHJldHVybiB3aGl0ZVNwYWNlID09PSAnbm9ybWFsJztcbiAgICB9XG4gICAgc3RhdGljIHRyaW1SaWdodCh0ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IHRleHRbaV07XG4gICAgICAgICAgICBpZiAoIVRleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZShjaGFyKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBzdGF0aWMgaXNOZXdsaW5lKGNoYXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUZXh0TWV0cmljcy5fbmV3bGluZXMuaW5kZXhPZihjaGFyLmNoYXJDb2RlQXQoMCkpID49IDA7XG4gICAgfVxuICAgIHN0YXRpYyBpc0JyZWFraW5nU3BhY2UoY2hhciwgX25leHRDaGFyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hhciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVGV4dE1ldHJpY3MuX2JyZWFraW5nU3BhY2VzLmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKSA+PSAwO1xuICAgIH1cbiAgICBzdGF0aWMgdG9rZW5pemUodGV4dCkge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgICAgbGV0IHRva2VuID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gdGV4dFtpXTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyID0gdGV4dFtpICsgMV07XG4gICAgICAgICAgICBpZiAoVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGNoYXIsIG5leHRDaGFyKSB8fCBUZXh0TWV0cmljcy5pc05ld2xpbmUoY2hhcikpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goY2hhcik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiArPSBjaGFyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbiAhPT0gJycpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICBzdGF0aWMgY2FuQnJlYWtXb3JkcyhfdG9rZW4sIGJyZWFrV29yZHMpIHtcbiAgICAgICAgcmV0dXJuIGJyZWFrV29yZHM7XG4gICAgfVxuICAgIHN0YXRpYyBjYW5CcmVha0NoYXJzKF9jaGFyLCBfbmV4dENoYXIsIF90b2tlbiwgX2luZGV4LCBfYnJlYWtXb3Jkcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3RhdGljIHdvcmRXcmFwU3BsaXQodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLnNwbGl0KCcnKTtcbiAgICB9XG4gICAgc3RhdGljIG1lYXN1cmVGb250KGZvbnQpIHtcbiAgICAgICAgLy8gYXMgdGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcHJlcGFyaW5nIGFzc2V0cywgZG9uJ3QgcmVjYWxjdWxhdGUgdGhpbmdzIGlmIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgaWYgKFRleHRNZXRyaWNzLl9mb250c1tmb250XSkge1xuICAgICAgICAgICAgcmV0dXJuIFRleHRNZXRyaWNzLl9mb250c1tmb250XTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYXNjZW50OiAwLFxuICAgICAgICAgICAgZGVzY2VudDogMCxcbiAgICAgICAgICAgIGZvbnRTaXplOiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IFRleHRNZXRyaWNzLl9jYW52YXM7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBUZXh0TWV0cmljcy5fY29udGV4dDtcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICAgICAgY29uc3QgbWV0cmljc1N0cmluZyA9IFRleHRNZXRyaWNzLk1FVFJJQ1NfU1RSSU5HICsgVGV4dE1ldHJpY3MuQkFTRUxJTkVfU1lNQk9MO1xuICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChjb250ZXh0Lm1lYXN1cmVUZXh0KG1ldHJpY3NTdHJpbmcpLndpZHRoKTtcbiAgICAgICAgbGV0IGJhc2VsaW5lID0gTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQoVGV4dE1ldHJpY3MuQkFTRUxJTkVfU1lNQk9MKS53aWR0aCk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IDIgKiBiYXNlbGluZTtcbiAgICAgICAgYmFzZWxpbmUgPSAoYmFzZWxpbmUgKiBUZXh0TWV0cmljcy5CQVNFTElORV9NVUxUSVBMSUVSKSB8IDA7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjZjAwJztcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMwMDAnO1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KG1ldHJpY3NTdHJpbmcsIDAsIGJhc2VsaW5lKTtcbiAgICAgICAgY29uc3QgaW1hZ2VkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgICAgY29uc3QgcGl4ZWxzID0gaW1hZ2VkYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbGluZSA9IHdpZHRoICogNDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgbGV0IHN0b3AgPSBmYWxzZTtcbiAgICAgICAgLy8gYXNjZW50LiBzY2FuIGZyb20gdG9wIHRvIGJvdHRvbSB1bnRpbCB3ZSBmaW5kIGEgbm9uIHJlZCBwaXhlbFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZWxpbmU7ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lOyBqICs9IDQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIGpdICE9PSAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RvcCkge1xuICAgICAgICAgICAgICAgIGlkeCArPSBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcGVydGllcy5hc2NlbnQgPSBiYXNlbGluZSAtIGk7XG4gICAgICAgIGlkeCA9IHBpeGVscyAtIGxpbmU7XG4gICAgICAgIHN0b3AgPSBmYWxzZTtcbiAgICAgICAgLy8gZGVzY2VudC4gc2NhbiBmcm9tIGJvdHRvbSB0byB0b3AgdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcbiAgICAgICAgZm9yIChpID0gaGVpZ2h0OyBpID4gYmFzZWxpbmU7IC0taSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lOyBqICs9IDQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIGpdICE9PSAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RvcCkge1xuICAgICAgICAgICAgICAgIGlkeCAtPSBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcGVydGllcy5kZXNjZW50ID0gaSAtIGJhc2VsaW5lO1xuICAgICAgICBwcm9wZXJ0aWVzLmZvbnRTaXplID0gcHJvcGVydGllcy5hc2NlbnQgKyBwcm9wZXJ0aWVzLmRlc2NlbnQ7XG4gICAgICAgIFRleHRNZXRyaWNzLl9mb250c1tmb250XSA9IHByb3BlcnRpZXM7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBmb250IG1ldHJpY3MgaW4gbWV0cmljcyBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZvbnRdIC0gZm9udCBuYW1lLiBJZiBmb250IG5hbWUgbm90IHNldCB0aGVuIGNsZWFyIGNhY2hlIGZvciBhbGwgZm9udHMuXG4gICAgICovXG4gICAgc3RhdGljIGNsZWFyTWV0cmljcyhmb250ID0gJycpIHtcbiAgICAgICAgaWYgKGZvbnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBUZXh0TWV0cmljcy5fZm9udHNbZm9udF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBUZXh0TWV0cmljcy5fZm9udHMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGNhbnZhcyA9ICgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gT2Zmc2NyZWVuQ2FudmFzMkQgbWVhc3VyZVRleHQgY2FuIGJlIHVwIHRvIDQwJSBmYXN0ZXIuXG4gICAgICAgIGNvbnN0IGMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gYy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm1lYXN1cmVUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfVxuICAgIGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfVxufSkoKTtcbmNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxMDtcblRleHRNZXRyaWNzLl9jYW52YXMgPSBjYW52YXM7XG5UZXh0TWV0cmljcy5fY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuVGV4dE1ldHJpY3MuX2ZvbnRzID0ge307XG5UZXh0TWV0cmljcy5NRVRSSUNTX1NUUklORyA9ICd8w4lxw4UnO1xuVGV4dE1ldHJpY3MuQkFTRUxJTkVfU1lNQk9MID0gJ00nO1xuVGV4dE1ldHJpY3MuQkFTRUxJTkVfTVVMVElQTElFUiA9IDEuNDtcblRleHRNZXRyaWNzLl9uZXdsaW5lcyA9IFtcbiAgICAweDAwMGEsXG4gICAgMHgwMDBkIC8vIGNhcnJpYWdlIHJldHVyblxuXTtcblRleHRNZXRyaWNzLl9icmVha2luZ1NwYWNlcyA9IFtcbiAgICAweDAwMDksXG4gICAgMHgwMDIwLFxuICAgIDB4MjAwMCxcbiAgICAweDIwMDEsXG4gICAgMHgyMDAyLFxuICAgIDB4MjAwMyxcbiAgICAweDIwMDQsXG4gICAgMHgyMDA1LFxuICAgIDB4MjAwNixcbiAgICAweDIwMDgsXG4gICAgMHgyMDA5LFxuICAgIDB4MjAwYSxcbiAgICAweDIwNWYsXG4gICAgMHgzMDAwIC8vIGlkZW9ncmFwaGljIHNwYWNlXG5dO1xuXG5jbGFzcyBMaW5lSW5mbyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMudGV4dEhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQoKSB7XG4gICAgICAgIGlmIChMaW5lSW5mby5wb29sLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJldCA9IExpbmVJbmZvLnBvb2wucG9wKCk7XG4gICAgICAgICAgICByZXQud2lkdGggPSAwO1xuICAgICAgICAgICAgcmV0LmhlaWdodCA9IDA7XG4gICAgICAgICAgICByZXQudGV4dEhlaWdodCA9IDA7XG4gICAgICAgICAgICByZXQudGV4dCA9IG51bGw7XG4gICAgICAgICAgICByZXQueSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGluZUluZm8oKTtcbiAgICB9XG4gICAgc3RhdGljIHJlY3ljbGUodmFsdWUpIHtcbiAgICAgICAgTGluZUluZm8ucG9vbC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIHJlY3ljbGVNYW55KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2godiA9PiB7XG4gICAgICAgICAgICAgICAgTGluZUluZm8ucG9vbC5wdXNoKHYpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUubGVuZ3RoID0gMDtcbiAgICB9XG59XG5MaW5lSW5mby5wb29sID0gW107XG5jbGFzcyBHVGV4dEZpZWxkIGV4dGVuZHMgR09iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuJHZlcnRpY2FsQWxpZ24gPSAwIC8qIFRvcCAqLztcbiAgICAgICAgdGhpcy4kb2Zmc2V0ID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG4gICAgICAgIHRoaXMuJHNpbmdsZUxpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLiR0ZXh0ID0gJyc7XG4gICAgICAgIHRoaXMuJHRleHRXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuJHRleHRIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLiRzdHlsZSA9IG5ldyBUZXh0U3R5bGUoe1xuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgZm9udEZhbWlseTogVUlDb25maWcuZGVmYXVsdEZvbnQsXG4gICAgICAgICAgICBhbGlnbjogXCJsZWZ0XCIgLyogTGVmdCAqLyxcbiAgICAgICAgICAgIGxlYWRpbmc6IDMsXG4gICAgICAgICAgICBmaWxsOiAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiR2ZXJ0aWNhbEFsaWduID0gMCAvKiBUb3AgKi87XG4gICAgICAgIHRoaXMuJHRleHQgPSAnJztcbiAgICAgICAgdGhpcy4kYXV0b1NpemUgPSAxIC8qIEJvdGggKi87XG4gICAgICAgIHRoaXMuJHdpZHRoQXV0b1NpemUgPSB0cnVlO1xuICAgICAgICB0aGlzLiRoZWlnaHRBdXRvU2l6ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuJGJpdG1hcFBvb2wgPSBbXTtcbiAgICAgICAgdGhpcy50b3VjaGFibGUgPSBmYWxzZTsgLy9iYXNlIEdUZXh0RmllbGQgaGFzIG5vIGludGVyYWN0aW9uXG4gICAgfVxuICAgIGNyZWF0ZURpc3BsYXlPYmplY3QoKSB7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZCA9IG5ldyBVSVRleHRGaWVsZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXREaXNwbGF5T2JqZWN0KHRoaXMuJHRleHRGaWVsZCk7XG4gICAgfVxuICAgIHN3aXRjaEJpdG1hcE1vZGUodmFsKSB7XG4gICAgICAgIGlmICh2YWwgJiYgdGhpcy5kaXNwbGF5T2JqZWN0ID09IHRoaXMuJHRleHRGaWVsZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGJ0Q29udGFpbmVyID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy4kYnRDb250YWluZXIgPSBuZXcgVUlDb250YWluZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnN3aXRjaERpc3BsYXlPYmplY3QodGhpcy4kYnRDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF2YWwgJiYgdGhpcy5kaXNwbGF5T2JqZWN0ID09IHRoaXMuJGJ0Q29udGFpbmVyKVxuICAgICAgICAgICAgdGhpcy5zd2l0Y2hEaXNwbGF5T2JqZWN0KHRoaXMuJHRleHRGaWVsZCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIEdUaW1lci5pbnN0LnJlbW92ZSh0aGlzLiRyZW5kZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLiRiaXRtYXBGb250ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kYml0bWFwUG9vbC5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLiRiaXRtYXBQb29sID0gbnVsbDtcbiAgICAgICAgdGhpcy4kc3R5bGUgPSBudWxsO1xuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHNldCB0ZXh0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0VGV4dCh2YWx1ZSk7XG4gICAgfVxuICAgIHNldFRleHQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICBpZiAodGhpcy4kdGV4dCA9PSB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kdGV4dCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUdlYXIoNiAvKiBUZXh0ICovKTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiRpblByb2dyZXNzQnVpbGRpbmcpXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vdygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dCgpO1xuICAgIH1cbiAgICBnZXRUZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdGV4dDtcbiAgICB9XG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2xvcigpO1xuICAgIH1cbiAgICBnZXRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbG9yO1xuICAgIH1cbiAgICBzZXRDb2xvcih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kY29sb3IgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUdlYXIoNCAvKiBDb2xvciAqLyk7XG4gICAgICAgICAgICB0aGlzLiRzdHlsZS5maWxsID0gdGhpcy4kY29sb3I7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBjb2xvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldENvbG9yKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHRpdGxlQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yO1xuICAgIH1cbiAgICBzZXQgdGl0bGVDb2xvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbG9yID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBsaW5lSGVpZ2h0KCkge1xuICAgICAgICBpZiAodGhpcy4kc3R5bGUubGluZUhlaWdodCA+IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kc3R5bGUubGluZUhlaWdodDtcbiAgICAgICAgaWYgKCF0aGlzLiRmb250UHJvcGVydGllcylcbiAgICAgICAgICAgIHJldHVybiArdGhpcy4kc3R5bGUuZm9udFNpemUgKyB0aGlzLiRzdHlsZS5zdHJva2VUaGlja25lc3M7IC8vcm91Z2ggdmFsdWVcbiAgICAgICAgcmV0dXJuIHRoaXMuJGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgdGhpcy4kc3R5bGUuc3Ryb2tlVGhpY2tuZXNzICsgdGhpcy4kc3R5bGUubGVhZGluZztcbiAgICB9XG4gICAgc2V0IGxpbmVIZWlnaHQobGgpIHtcbiAgICAgICAgdGhpcy4kc3R5bGUubGluZUhlaWdodCA9IGxoO1xuICAgIH1cbiAgICBnZXQgZm9udCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGZvbnQgfHwgVUlDb25maWcuZGVmYXVsdEZvbnQ7XG4gICAgfVxuICAgIHNldCBmb250KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRmb250ICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRmb250ID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy4kZm9udCAmJiBTdHJpbmdVdGlsLnN0YXJ0c1dpdGgodGhpcy4kZm9udCwgJ3VpOi8vJykpXG4gICAgICAgICAgICAgICAgdGhpcy4kYml0bWFwRm9udCA9IFVJUGFja2FnZS5nZXRCaXRtYXBGb250QnlVUkwodGhpcy4kZm9udCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy4kc3R5bGUuZm9udEZhbWlseSA9IHRoaXMuJGZvbnQgfHwgVUlDb25maWcuZGVmYXVsdEZvbnQ7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmb250U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuICt0aGlzLiRzdHlsZS5mb250U2l6ZTtcbiAgICB9XG4gICAgc2V0IGZvbnRTaXplKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy4kc3R5bGUuZm9udFNpemUgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJHN0eWxlLmZvbnRTaXplID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhbGlnbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHN0eWxlLmFsaWduO1xuICAgIH1cbiAgICBzZXQgYWxpZ24odmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJHN0eWxlLmFsaWduICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRzdHlsZS5hbGlnbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdmVydGljYWxBbGlnbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHZlcnRpY2FsQWxpZ247XG4gICAgfVxuICAgIHNldCB2ZXJ0aWNhbEFsaWduKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiR2ZXJ0aWNhbEFsaWduICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiR2ZXJ0aWNhbEFsaWduID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJGluUHJvZ3Jlc3NCdWlsZGluZylcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dEFsaWduKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGxlYWRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzdHlsZS5sZWFkaW5nO1xuICAgIH1cbiAgICBzZXQgbGVhZGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kc3R5bGUubGVhZGluZyAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kc3R5bGUubGVhZGluZyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGV0dGVyU3BhY2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHN0eWxlLmxldHRlclNwYWNpbmc7XG4gICAgfVxuICAgIHNldCBsZXR0ZXJTcGFjaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRzdHlsZS5sZXR0ZXJTcGFjaW5nICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRzdHlsZS5sZXR0ZXJTcGFjaW5nID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB1bmRlcmxpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy9UT0RPOiBub3Qgc3VwcG9ydGVkIHlldFxuICAgIH1cbiAgICBzZXQgdW5kZXJsaW5lKHZhbHVlKSB7XG4gICAgICAgIC8vVE9ETzogbm90IHN1cHBvcnRlZCB5ZXRcbiAgICB9XG4gICAgZ2V0IGJvbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzdHlsZS5mb250V2VpZ2h0ID09ICdib2xkJztcbiAgICB9XG4gICAgc2V0IGJvbGQodmFsdWUpIHtcbiAgICAgICAgbGV0IHYgPSB2YWx1ZSA9PT0gdHJ1ZSA/ICdib2xkJyA6ICdub3JtYWwnO1xuICAgICAgICBpZiAodGhpcy4kc3R5bGUuZm9udFdlaWdodCAhPSB2KSB7XG4gICAgICAgICAgICB0aGlzLiRzdHlsZS5mb250V2VpZ2h0ID0gdjtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHdlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHN0eWxlLmZvbnRXZWlnaHQ7XG4gICAgfVxuICAgIHNldCB3ZWlnaHQodikge1xuICAgICAgICBpZiAodGhpcy4kc3R5bGUuZm9udFdlaWdodCAhPSB2KSB7XG4gICAgICAgICAgICB0aGlzLiRzdHlsZS5mb250V2VpZ2h0ID0gdjtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHZhcmlhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzdHlsZS5mb250VmFyaWFudDtcbiAgICB9XG4gICAgc2V0IHZhcmlhbnQodikge1xuICAgICAgICBpZiAodGhpcy4kc3R5bGUuZm9udFZhcmlhbnQgIT0gdikge1xuICAgICAgICAgICAgdGhpcy4kc3R5bGUuZm9udFZhcmlhbnQgPSB2O1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRhbGljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc3R5bGUuZm9udFN0eWxlID09ICdpdGFsaWMnO1xuICAgIH1cbiAgICBzZXQgaXRhbGljKHZhbHVlKSB7XG4gICAgICAgIGxldCB2ID0gdmFsdWUgPT09IHRydWUgPyAnaXRhbGljJyA6ICdub3JtYWwnO1xuICAgICAgICBpZiAodGhpcy4kc3R5bGUuZm9udFN0eWxlICE9IHYpIHtcbiAgICAgICAgICAgIHRoaXMuJHN0eWxlLmZvbnRTdHlsZSA9IHY7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBtdWx0aXBsZUxpbmUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy4kc2luZ2xlTGluZTtcbiAgICB9XG4gICAgc2V0IG11bHRpcGxlTGluZSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9ICF2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuJHNpbmdsZUxpbmUgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJHNpbmdsZUxpbmUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHN0cm9rZSgpIHtcbiAgICAgICAgcmV0dXJuICt0aGlzLiRzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgfVxuICAgIHNldCBzdHJva2UodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAhPSB2YWx1ZSlcbiAgICAgICAgICAgIHRoaXMuJHN0eWxlLnN0cm9rZVRoaWNrbmVzcyA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgc3Ryb2tlQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzdHlsZS5zdHJva2U7XG4gICAgfVxuICAgIHNldCBzdHJva2VDb2xvcih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kc3R5bGUuc3Ryb2tlICE9IHZhbHVlKVxuICAgICAgICAgICAgdGhpcy4kc3R5bGUuc3Ryb2tlID0gdmFsdWU7XG4gICAgfVxuICAgIHNldCBhdXRvU2l6ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kYXV0b1NpemUgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGF1dG9TaXplID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLiR3aWR0aEF1dG9TaXplID0gdmFsdWUgPT0gMSAvKiBCb3RoICovIHx8IHZhbHVlID09IDMgLyogU2hyaW5rICovO1xuICAgICAgICAgICAgdGhpcy4kaGVpZ2h0QXV0b1NpemUgPSB2YWx1ZSA9PSAxIC8qIEJvdGggKi8gfHwgdmFsdWUgPT0gMiAvKiBIZWlnaHQgKi87XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhdXRvU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGF1dG9TaXplO1xuICAgIH1cbiAgICBnZXQgdGV4dFdpZHRoKCkge1xuICAgICAgICBpZiAodGhpcy4kcmVxdWlyZVJlbmRlcilcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm93KCk7XG4gICAgICAgIHJldHVybiB0aGlzLiR0ZXh0V2lkdGg7XG4gICAgfVxuICAgIGdldCB0ZXh0SGVpZ2h0KCkge1xuICAgICAgICBpZiAodGhpcy4kcmVxdWlyZVJlbmRlcilcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm93KCk7XG4gICAgICAgIHJldHVybiB0aGlzLiR0ZXh0SGVpZ2h0O1xuICAgIH1cbiAgICBlbnN1cmVTaXplQ29ycmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHNpemVEaXJ0eSAmJiB0aGlzLiRyZXF1aXJlUmVuZGVyKVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJOb3coKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHJlcXVpcmVSZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJHJlcXVpcmVSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgR1RpbWVyLmluc3QuY2FsbExhdGVyKHRoaXMuJHJlbmRlciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLiRzaXplRGlydHkgJiYgKHRoaXMuJHdpZHRoQXV0b1NpemUgfHwgdGhpcy4kaGVpZ2h0QXV0b1NpemUpKSB7XG4gICAgICAgICAgICB0aGlzLiRzaXplRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcIl9fc2l6ZURlbGF5Q2hhbmdlXCIgLyogU0laRV9ERUxBWV9DSEFOR0UgKi8sIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5U3R5bGUoKSB7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5zdHlsZS5zdHJva2UgPSB0aGlzLiRzdHlsZS5zdHJva2U7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5zdHlsZS5zdHJva2VUaGlja25lc3MgPSB0aGlzLiRzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5zdHlsZS5mb250U3R5bGUgPSB0aGlzLiRzdHlsZS5mb250U3R5bGU7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5zdHlsZS5mb250VmFyaWFudCA9IHRoaXMuJHN0eWxlLmZvbnRWYXJpYW50O1xuICAgICAgICB0aGlzLiR0ZXh0RmllbGQuc3R5bGUuZm9udFdlaWdodCA9IHRoaXMuJHN0eWxlLmZvbnRXZWlnaHQ7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gdGhpcy4kc3R5bGUubGV0dGVyU3BhY2luZztcbiAgICAgICAgdGhpcy4kdGV4dEZpZWxkLnN0eWxlLmFsaWduID0gdGhpcy4kc3R5bGUuYWxpZ247XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5zdHlsZS5mb250U2l6ZSA9IHRoaXMuJHN0eWxlLmZvbnRTaXplO1xuICAgICAgICB0aGlzLiR0ZXh0RmllbGQuc3R5bGUuZm9udEZhbWlseSA9IHRoaXMuJHN0eWxlLmZvbnRGYW1pbHk7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5zdHlsZS5maWxsID0gdGhpcy4kc3R5bGUuZmlsbDtcbiAgICAgICAgdGhpcy4kdGV4dEZpZWxkLnN0eWxlLmRyb3BTaGFkb3dDb2xvciA9IHRoaXMuJHN0eWxlLmRyb3BTaGFkb3dDb2xvcjtcbiAgICAgICAgdGhpcy4kdGV4dEZpZWxkLnN0eWxlLmRyb3BTaGFkb3dPZmZzZXRYID0gdGhpcy4kc3R5bGUuZHJvcFNoYWRvd09mZnNldFg7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5zdHlsZS5kcm9wU2hhZG93T2Zmc2V0WSA9IHRoaXMuJHN0eWxlLmRyb3BTaGFkb3dPZmZzZXRZO1xuICAgICAgICB0aGlzLiR0ZXh0RmllbGQuc3R5bGUubGVhZGluZyA9IHRoaXMuJHN0eWxlLmxlYWRpbmc7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5hcHBseVN0eWxlKCk7XG4gICAgfVxuICAgICRyZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiRyZXF1aXJlUmVuZGVyKVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJOb3coKTtcbiAgICB9XG4gICAgcmVuZGVyTm93KHVwZGF0ZUJvdW5kcyA9IHRydWUpIHtcbiAgICAgICAgdGhpcy4kcmVxdWlyZVJlbmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRzaXplRGlydHkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuJGJpdG1hcEZvbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJXaXRoQml0bWFwRm9udCh1cGRhdGVCb3VuZHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3dpdGNoQml0bWFwTW9kZShmYWxzZSk7XG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZSgpO1xuICAgICAgICB0aGlzLiR0ZXh0RmllbGQuJHVwZGF0ZU1pbkhlaWdodCgpO1xuICAgICAgICBsZXQgd29yZFdyYXAgPSAhdGhpcy4kd2lkdGhBdXRvU2l6ZSAmJiB0aGlzLm11bHRpcGxlTGluZTtcbiAgICAgICAgdGhpcy4kdGV4dEZpZWxkLndpZHRoID0gdGhpcy4kdGV4dEZpZWxkLnN0eWxlLndvcmRXcmFwV2lkdGggPVxuICAgICAgICAgICAgd29yZFdyYXAgfHwgdGhpcy5hdXRvU2l6ZSA9PSAwIC8qIE5vbmUgKi8gPyBNYXRoLmNlaWwodGhpcy53aWR0aCkgOiAxMDAwMDtcbiAgICAgICAgdGhpcy4kdGV4dEZpZWxkLnN0eWxlLndvcmRXcmFwID0gd29yZFdyYXA7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5zdHlsZS5icmVha1dvcmRzID0gd29yZFdyYXA7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5jb250ZW50ID0gdGhpcy4kdGV4dDsgLy90cmlnZ2VyIHQuZGlydHkgPSB0cnVlXG4gICAgICAgIHRoaXMuJGZvbnRQcm9wZXJ0aWVzID0gVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQodGhpcy4kc3R5bGUudG9Gb250U3RyaW5nKCkpO1xuICAgICAgICB0aGlzLiR0ZXh0V2lkdGggPSBNYXRoLmNlaWwodGhpcy4kdGV4dEZpZWxkLnRleHRXaWR0aCk7XG4gICAgICAgIGlmICh0aGlzLiR0ZXh0V2lkdGggPiAwKVxuICAgICAgICAgICAgdGhpcy4kdGV4dFdpZHRoICs9IEdUZXh0RmllbGQuR1VUVEVSX1ggKiAyOyAvL21hcmdpbiBnYXBcbiAgICAgICAgdGhpcy4kdGV4dEhlaWdodCA9IE1hdGguY2VpbCh0aGlzLiR0ZXh0RmllbGQudGV4dEhlaWdodCk7XG4gICAgICAgIGlmICh0aGlzLiR0ZXh0SGVpZ2h0ID4gMClcbiAgICAgICAgICAgIHRoaXMuJHRleHRIZWlnaHQgKz0gR1RleHRGaWVsZC5HVVRURVJfWSAqIDI7IC8vbWFyZ2luIGdhcFxuICAgICAgICBsZXQgdyA9IHRoaXMud2lkdGgsIGggPSB0aGlzLmhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1NpemUgPT0gMyAvKiBTaHJpbmsgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc2hyaW5rVGV4dEZpZWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiR0ZXh0RmllbGQuc2V0KHsgc2NhbGVYOiAxLCBzY2FsZVk6IDEgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy4kd2lkdGhBdXRvU2l6ZSkge1xuICAgICAgICAgICAgICAgIHcgPSB0aGlzLiR0ZXh0V2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGV4dEZpZWxkLndpZHRoID0gdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRoZWlnaHRBdXRvU2l6ZSkge1xuICAgICAgICAgICAgICAgIGggPSB0aGlzLiR0ZXh0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiR0ZXh0RmllbGQuaGVpZ2h0ICE9IHRoaXMuJHRleHRIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHRleHRGaWVsZC5oZWlnaHQgPSB0aGlzLiR0ZXh0SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiR0ZXh0SGVpZ2h0ID4gaClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdGV4dEhlaWdodCA9IGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZUJvdW5kcykge1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRpbmdTaXplID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2l6ZSh3LCBoKTtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0aW5nU2l6ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5b3V0QWxpZ24oKTtcbiAgICB9XG4gICAgcmVuZGVyV2l0aEJpdG1hcEZvbnQodXBkYXRlQm91bmRzKSB7XG4gICAgICAgIHRoaXMuc3dpdGNoQml0bWFwTW9kZSh0cnVlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRvZG9cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGJ0Q29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuJGJpdG1hcFBvb2wucHVzaCh0aGlzLiRidENvbnRhaW5lci5nZXRDaGlsZEF0KGkpKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuJGJ0Q29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICAgIGlmICghdGhpcy4kbGluZXMpXG4gICAgICAgICAgICB0aGlzLiRsaW5lcyA9IFtdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBMaW5lSW5mby5yZWN5Y2xlTWFueSh0aGlzLiRsaW5lcyk7XG4gICAgICAgIGxldCBsZXR0ZXJTcGFjaW5nID0gdGhpcy5sZXR0ZXJTcGFjaW5nO1xuICAgICAgICBsZXQgbGluZVNwYWNpbmcgPSB0aGlzLmxlYWRpbmcgLSAxO1xuICAgICAgICBsZXQgcmVjdFdpZHRoID0gdGhpcy53aWR0aCAtIEdUZXh0RmllbGQuR1VUVEVSX1ggKiAyO1xuICAgICAgICBsZXQgbGluZVdpZHRoID0gMCwgbGluZUhlaWdodCA9IDAsIGxpbmVUZXh0SGVpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGdseXBoV2lkdGggPSAwLCBnbHlwaEhlaWdodCA9IDA7XG4gICAgICAgIGxldCB3b3JkQ2hhcnMgPSAwLCB3b3JkU3RhcnQgPSAwLCB3b3JkRW5kID0gMDtcbiAgICAgICAgbGV0IGxhc3RMaW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGxpbmVCdWZmZXIgPSAnJztcbiAgICAgICAgbGV0IGxpbmVZID0gR1RleHRGaWVsZC5HVVRURVJfWTtcbiAgICAgICAgbGV0IGxpbmU7XG4gICAgICAgIGxldCB3b3JkV3JhcCA9ICF0aGlzLiR3aWR0aEF1dG9TaXplICYmIHRoaXMubXVsdGlwbGVMaW5lO1xuICAgICAgICBsZXQgZm9udFNjYWxlID0gdGhpcy4kYml0bWFwRm9udC5yZXNpemFibGUgPyB0aGlzLmZvbnRTaXplIC8gdGhpcy4kYml0bWFwRm9udC5zaXplIDogMTtcbiAgICAgICAgbGV0IGdseXBoO1xuICAgICAgICB0aGlzLiR0ZXh0V2lkdGggPSAwO1xuICAgICAgICB0aGlzLiR0ZXh0SGVpZ2h0ID0gMDtcbiAgICAgICAgbGV0IHRleHRMZW5ndGggPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCB0ZXh0TGVuZ3RoOyArK29mZnNldCkge1xuICAgICAgICAgICAgbGV0IGNoID0gdGhpcy4kdGV4dC5jaGFyQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCBjYyA9IGNoLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChjaCA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIGxpbmVCdWZmZXIgKz0gY2g7XG4gICAgICAgICAgICAgICAgbGluZSA9IExpbmVJbmZvLmdldCgpO1xuICAgICAgICAgICAgICAgIGxpbmUud2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVUZXh0SGVpZ2h0ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RMaW5lSGVpZ2h0ID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TGluZUhlaWdodCA9IE1hdGguY2VpbCh0aGlzLmZvbnRTaXplICogZm9udFNjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVIZWlnaHQgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBsYXN0TGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbGluZVRleHRIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lLmhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxpbmUudGV4dEhlaWdodCA9IGxpbmVUZXh0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxpbmUudGV4dCA9IGxpbmVCdWZmZXI7XG4gICAgICAgICAgICAgICAgbGluZS55ID0gbGluZVk7XG4gICAgICAgICAgICAgICAgbGluZVkgKz0gbGluZS5oZWlnaHQgKyBsaW5lU3BhY2luZztcbiAgICAgICAgICAgICAgICBpZiAobGluZS53aWR0aCA+IHRoaXMuJHRleHRXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdGV4dFdpZHRoID0gbGluZS53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLiRsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIGxpbmVCdWZmZXIgPSAnJztcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgIGxpbmVUZXh0SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICB3b3JkQ2hhcnMgPSAwO1xuICAgICAgICAgICAgICAgIHdvcmRTdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgd29yZEVuZCA9IDA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2MgPiAyNTYgfHwgY2MgPD0gMzIpIHtcbiAgICAgICAgICAgICAgICBpZiAod29yZENoYXJzID4gMClcbiAgICAgICAgICAgICAgICAgICAgd29yZEVuZCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICB3b3JkQ2hhcnMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmRDaGFycyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICB3b3JkU3RhcnQgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgd29yZENoYXJzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhXaWR0aCA9IE1hdGguY2VpbCh0aGlzLmZvbnRTaXplIC8gMik7XG4gICAgICAgICAgICAgICAgZ2x5cGhIZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5mb250U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbHlwaCA9IHRoaXMuJGJpdG1hcEZvbnQuZ2x5cGhzW2NoXTtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhXaWR0aCA9IE1hdGguY2VpbChnbHlwaC5hZHZhbmNlICogZm9udFNjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhIZWlnaHQgPSBNYXRoLmNlaWwoZ2x5cGgubGluZUhlaWdodCAqIGZvbnRTY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaFdpZHRoID0gTWF0aC5jZWlsKCh0aGlzLiRiaXRtYXBGb250LnNpemUgKiBmb250U2NhbGUpIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoSGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMuJGJpdG1hcEZvbnQuc2l6ZSAqIGZvbnRTY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnbHlwaEhlaWdodCA+IGxpbmVUZXh0SGVpZ2h0KVxuICAgICAgICAgICAgICAgIGxpbmVUZXh0SGVpZ2h0ID0gZ2x5cGhIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoZ2x5cGhIZWlnaHQgPiBsaW5lSGVpZ2h0KVxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBnbHlwaEhlaWdodDtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggIT0gMClcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggKz0gbGV0dGVyU3BhY2luZztcbiAgICAgICAgICAgIGxpbmVXaWR0aCArPSBnbHlwaFdpZHRoO1xuICAgICAgICAgICAgaWYgKCF3b3JkV3JhcCB8fCBsaW5lV2lkdGggPD0gcmVjdFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGluZUJ1ZmZlciArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBMaW5lSW5mby5nZXQoKTtcbiAgICAgICAgICAgICAgICBsaW5lLmhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGluZS50ZXh0SGVpZ2h0ID0gbGluZVRleHRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVCdWZmZXIubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbGluZSBjYW5udCBmaXQgZXZlbiBhIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgbGluZS50ZXh0ID0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdvcmRDaGFycyA+IDAgJiYgd29yZEVuZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB3b3JkIGhhZCBicm9rZW4sIG1vdmUgaXQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgbGluZUJ1ZmZlciArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlbiA9IGxpbmVCdWZmZXIubGVuZ3RoIC0gd29yZENoYXJzO1xuICAgICAgICAgICAgICAgICAgICBsaW5lLnRleHQgPSBTdHJpbmdVdGlsLnRyaW1SaWdodChsaW5lQnVmZmVyLnN1YnN0cigwLCBsZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZS53aWR0aCA9IHdvcmRFbmQ7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVCdWZmZXIgPSBsaW5lQnVmZmVyLnN1YnN0cihsZW4gKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoIC09IHdvcmRTdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUudGV4dCA9IGxpbmVCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUud2lkdGggPSBsaW5lV2lkdGggLSAoZ2x5cGhXaWR0aCArIGxldHRlclNwYWNpbmcpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lQnVmZmVyID0gY2g7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IGdseXBoV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBnbHlwaEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbGluZVRleHRIZWlnaHQgPSBnbHlwaEhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZS55ID0gbGluZVk7XG4gICAgICAgICAgICAgICAgbGluZVkgKz0gbGluZS5oZWlnaHQgKyBsaW5lU3BhY2luZztcbiAgICAgICAgICAgICAgICBpZiAobGluZS53aWR0aCA+IHRoaXMuJHRleHRXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdGV4dFdpZHRoID0gbGluZS53aWR0aDtcbiAgICAgICAgICAgICAgICB3b3JkQ2hhcnMgPSAwO1xuICAgICAgICAgICAgICAgIHdvcmRTdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgd29yZEVuZCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy4kbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZUJ1ZmZlci5sZW5ndGggPiAwIHx8XG4gICAgICAgICAgICAodGhpcy4kbGluZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIFN0cmluZ1V0aWwuZW5kc1dpdGgodGhpcy4kbGluZXNbdGhpcy4kbGluZXMubGVuZ3RoIC0gMV0udGV4dCwgJ1xcbicpKSkge1xuICAgICAgICAgICAgbGluZSA9IExpbmVJbmZvLmdldCgpO1xuICAgICAgICAgICAgbGluZS53aWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIGlmIChsaW5lSGVpZ2h0ID09IDApXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodCA9IGxhc3RMaW5lSGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGxpbmVUZXh0SGVpZ2h0ID09IDApXG4gICAgICAgICAgICAgICAgbGluZVRleHRIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgbGluZS5oZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgbGluZS50ZXh0SGVpZ2h0ID0gbGluZVRleHRIZWlnaHQ7XG4gICAgICAgICAgICBsaW5lLnRleHQgPSBsaW5lQnVmZmVyO1xuICAgICAgICAgICAgbGluZS55ID0gbGluZVk7XG4gICAgICAgICAgICBpZiAobGluZS53aWR0aCA+IHRoaXMuJHRleHRXaWR0aClcbiAgICAgICAgICAgICAgICB0aGlzLiR0ZXh0V2lkdGggPSBsaW5lLndpZHRoO1xuICAgICAgICAgICAgdGhpcy4kbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kdGV4dFdpZHRoID4gMClcbiAgICAgICAgICAgIHRoaXMuJHRleHRXaWR0aCArPSBHVGV4dEZpZWxkLkdVVFRFUl9YICogMjtcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy4kbGluZXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy4kdGV4dEhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy4kbGluZXNbdGhpcy4kbGluZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB0aGlzLiR0ZXh0SGVpZ2h0ID0gbGluZS55ICsgbGluZS5oZWlnaHQgKyBHVGV4dEZpZWxkLkdVVFRFUl9ZO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3LCBoID0gMDtcbiAgICAgICAgaWYgKHRoaXMuJHdpZHRoQXV0b1NpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0ZXh0V2lkdGggPT0gMClcbiAgICAgICAgICAgICAgICB3ID0gMDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy4kdGV4dFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHcgPSB0aGlzLndpZHRoO1xuICAgICAgICBpZiAodGhpcy4kaGVpZ2h0QXV0b1NpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0ZXh0SGVpZ2h0ID09IDApXG4gICAgICAgICAgICAgICAgaCA9IDA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaCA9IHRoaXMuJHRleHRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBpZiAodXBkYXRlQm91bmRzKSB7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGluZ1NpemUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXRTaXplKHcsIGgpO1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRpbmdTaXplID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHcgPT0gMCB8fCBoID09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlY3RXaWR0aCA9IHRoaXMud2lkdGggLSBHVGV4dEZpZWxkLkdVVFRFUl9YICogMjtcbiAgICAgICAgdGhpcy4kbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgIGxldCBjaGFyWCA9IEdUZXh0RmllbGQuR1VUVEVSX1g7XG4gICAgICAgICAgICBsZXQgbGluZUluZGVudCA9IDA7XG4gICAgICAgICAgICBsZXQgY2hhckluZGVudCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGlnbiA9PSBcImNlbnRlclwiIC8qIENlbnRlciAqLylcbiAgICAgICAgICAgICAgICBsaW5lSW5kZW50ID0gKHJlY3RXaWR0aCAtIGxpbmUud2lkdGgpIC8gMjtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWxpZ24gPT0gXCJyaWdodFwiIC8qIFJpZ2h0ICovKVxuICAgICAgICAgICAgICAgIGxpbmVJbmRlbnQgPSByZWN0V2lkdGggLSBsaW5lLndpZHRoO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxpbmVJbmRlbnQgPSAwO1xuICAgICAgICAgICAgdGV4dExlbmd0aCA9IGxpbmUudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRleHRMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IGxpbmUudGV4dC5jaGFyQXQoaik7XG4gICAgICAgICAgICAgICAgZ2x5cGggPSB0aGlzLiRiaXRtYXBGb250LmdseXBoc1tjaF07XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckluZGVudCA9IChsaW5lLmhlaWdodCArIGxpbmUudGV4dEhlaWdodCkgLyAyIC0gTWF0aC5jZWlsKGdseXBoLmxpbmVIZWlnaHQgKiBmb250U2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYm07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRiaXRtYXBQb29sLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJtID0gdGhpcy4kYml0bWFwUG9vbC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYm0gPSBuZXcgQml0bWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIGJtLnggPSBjaGFyWCArIGxpbmVJbmRlbnQgKyBNYXRoLmNlaWwoZ2x5cGgub2Zmc2V0WCAqIGZvbnRTY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGJtLnkgPSBsaW5lLnkgKyBjaGFySW5kZW50ICsgTWF0aC5jZWlsKGdseXBoLm9mZnNldFkgKiBmb250U2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBibS50ZXh0dXJlID0gZ2x5cGgudGV4dHVyZS5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgYm0udGV4dHVyZVJlY3QgPSBnbHlwaC50ZXh0dXJlLnJlY3Q7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGdseXBoO1xuICAgICAgICAgICAgICAgICAgICBibS5zb3VyY2VSZWN0ID0gbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYm0uc2V0KHsgc2NhbGVYOiBmb250U2NhbGUsIHNjYWxlWTogZm9udFNjYWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICBibS50aW50ID0gdGhpcy4kYml0bWFwRm9udC5jb2xvcmFibGUgPT09IHRydWUgPyB0aGlzLiRjb2xvciA6ICcweEZGRkZGRic7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGJ0Q29udGFpbmVyLmFkZENoaWxkKGJtKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhclggKz0gbGV0dGVyU3BhY2luZyArIE1hdGguY2VpbChnbHlwaC5hZHZhbmNlICogZm9udFNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJYICs9IGxldHRlclNwYWNpbmcgKyBNYXRoLmNlaWwoKHRoaXMuJGJpdG1hcEZvbnQuc2l6ZSAqIGZvbnRTY2FsZSkgLyAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJYICs9IGxldHRlclNwYWNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9jYWxUb0dsb2JhbChheCA9IDAsIGF5ID0gMCwgcmVzdWx0UG9pbnQpIHtcbiAgICAgICAgYXggLT0gdGhpcy4kb2Zmc2V0Lng7XG4gICAgICAgIGF5IC09IHRoaXMuJG9mZnNldC55O1xuICAgICAgICByZXR1cm4gc3VwZXIubG9jYWxUb0dsb2JhbChheCwgYXksIHJlc3VsdFBvaW50KTtcbiAgICB9XG4gICAgZ2xvYmFsVG9Mb2NhbChheCA9IDAsIGF5ID0gMCwgcmVzdWx0UG9pbnQpIHtcbiAgICAgICAgbGV0IHIgPSBzdXBlci5nbG9iYWxUb0xvY2FsKGF4LCBheSwgcmVzdWx0UG9pbnQpO1xuICAgICAgICByLnggLT0gdGhpcy4kb2Zmc2V0Lng7XG4gICAgICAgIHIueSAtPSB0aGlzLiRvZmZzZXQueTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGhhbmRsZVNpemVDaGFuZ2VkKCkge1xuICAgICAgICBpZiAodGhpcy4kdXBkYXRpbmdTaXplKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy4kYml0bWFwRm9udCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJHdpZHRoQXV0b1NpemUpXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRpblByb2dyZXNzQnVpbGRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR0ZXh0RmllbGQud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuJHRleHRGaWVsZC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRhdXRvU2l6ZSA9PSAzIC8qIFNocmluayAqLylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaHJpbmtUZXh0RmllbGQoKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLiR3aWR0aEF1dG9TaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuJGhlaWdodEF1dG9TaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kdGV4dEZpZWxkLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiR0ZXh0RmllbGQuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kdGV4dEZpZWxkLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxheW91dEFsaWduKCk7XG4gICAgfVxuICAgIHNocmlua1RleHRGaWVsZCgpIHtcbiAgICAgICAgbGV0IGZpdFNjYWxlID0gTWF0aC5taW4oMSwgdGhpcy53aWR0aCAvIHRoaXMuJHRleHRXaWR0aCk7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5zZXQoeyBzY2FsZVg6IGZpdFNjYWxlLCBzY2FsZVk6IGZpdFNjYWxlIH0pO1xuICAgIH1cbiAgICBsYXlvdXRBbGlnbigpIHtcbiAgICAgICAgbGV0IHR3ID0gdGhpcy4kdGV4dFdpZHRoLCB0aCA9IHRoaXMuJHRleHRIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLmF1dG9TaXplID09IDMgLyogU2hyaW5rICovKSB7XG4gICAgICAgICAgICB0dyAqPSB0aGlzLmRpc3BsYXlPYmplY3Quc2NhbGVYO1xuICAgICAgICAgICAgdGggKj0gdGhpcy5kaXNwbGF5T2JqZWN0LnNjYWxlWTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kdmVydGljYWxBbGlnbiA9PSAwIC8qIFRvcCAqLyB8fCB0aCA9PSAwKVxuICAgICAgICAgICAgdGhpcy4kb2Zmc2V0LnkgPSBHVGV4dEZpZWxkLkdVVFRFUl9ZO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaCA9IE1hdGgubWF4KDAsIHRoaXMuaGVpZ2h0IC0gdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHZlcnRpY2FsQWxpZ24gPT0gMSAvKiBNaWRkbGUgKi8pXG4gICAgICAgICAgICAgICAgdGhpcy4kb2Zmc2V0LnkgPSBkaCAqIDAuNTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJHZlcnRpY2FsQWxpZ24gPT0gMiAvKiBCb3R0b20gKi8pXG4gICAgICAgICAgICAgICAgdGhpcy4kb2Zmc2V0LnkgPSBkaDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeFBvcyA9IDA7XG4gICAgICAgIHN3aXRjaCAodGhpcy4kc3R5bGUuYWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgeFBvcyA9ICh0aGlzLndpZHRoIC0gdHcpICogMC41O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHhQb3MgPSB0aGlzLndpZHRoIC0gdHc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kb2Zmc2V0LnggPSB4UG9zO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICAgIHVwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgICBsZXQgeCA9IE1hdGguZmxvb3IodGhpcy54ICsgdGhpcy4kb2Zmc2V0LngpO1xuICAgICAgICBsZXQgeSA9IE1hdGguZmxvb3IodGhpcy55ICsgdGhpcy4kb2Zmc2V0LnkpO1xuICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3Quc2V0KHsgeCwgeSB9KTtcbiAgICAgICAgdGhpcy4kdGV4dEZpZWxkLnVwZGF0ZU11bHRpcGxlUG9zaXRpb24oeCwgeSk7XG4gICAgfVxuICAgIGhhbmRsZVhZQ2hhbmdlZCgpIHtcbiAgICAgICAgc3VwZXIuaGFuZGxlWFlDaGFuZ2VkKCk7XG4gICAgICAgIGlmICh0aGlzLiRkaXNwbGF5T2JqZWN0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgICBzZXR1cEJlZm9yZUFkZCh4bWwpIHtcbiAgICAgICAgc3VwZXIuc2V0dXBCZWZvcmVBZGQoeG1sKTtcbiAgICAgICAgbGV0IHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmZvbnQ7XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLmZvbnQgPSBzdHI7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnZBbGlnbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMudmVydGljYWxBbGlnbiA9IFBhcnNlVmVydEFsaWduVHlwZShzdHIpO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5sZWFkaW5nO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgdGhpcy4kc3R5bGUubGVhZGluZyA9IHBhcnNlSW50KHN0cik7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmxldHRlclNwYWNpbmc7XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLiRzdHlsZS5sZXR0ZXJTcGFjaW5nID0gcGFyc2VJbnQoc3RyKTtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuZm9udFNpemU7XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLiRzdHlsZS5mb250U2l6ZSA9IHBhcnNlSW50KHN0cik7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmNvbG9yO1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnNoYWRvd0NvbG9yO1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICB0aGlzLiRzdHlsZS5kcm9wU2hhZG93Q29sb3IgPSBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFycjtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuc2hhZG93T2Zmc2V0O1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGlmIChhcnIubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHN0eWxlLmRyb3BTaGFkb3dPZmZzZXRYID0gcGFyc2VJbnQoYXJyWzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRzdHlsZS5kcm9wU2hhZG93T2Zmc2V0WSA9IHBhcnNlSW50KGFyclsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuYWxpZ247XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLmFsaWduID0gUGFyc2VBbGlnblR5cGUoc3RyKTtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuYXV0b1NpemU7XG4gICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b1NpemUgPSBQYXJzZUF1dG9TaXplVHlwZShzdHIpO1xuICAgICAgICAgICAgdGhpcy4kd2lkdGhBdXRvU2l6ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy4kYXV0b1NpemUgPT0gMSAvKiBCb3RoICovIHx8IHRoaXMuJGF1dG9TaXplID09IDMgLyogU2hyaW5rICovO1xuICAgICAgICAgICAgdGhpcy4kaGVpZ2h0QXV0b1NpemUgPVxuICAgICAgICAgICAgICAgIHRoaXMuJGF1dG9TaXplID09IDEgLyogQm90aCAqLyB8fCB0aGlzLiRhdXRvU2l6ZSA9PSAyIC8qIEhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuZGVybGluZSA9IHhtbC5hdHRyaWJ1dGVzLnVuZGVybGluZSA9PSAndHJ1ZSc7XG4gICAgICAgIHRoaXMuaXRhbGljID0geG1sLmF0dHJpYnV0ZXMuaXRhbGljID09ICd0cnVlJztcbiAgICAgICAgdGhpcy5ib2xkID0geG1sLmF0dHJpYnV0ZXMuYm9sZCA9PSAndHJ1ZSc7XG4gICAgICAgIHRoaXMubXVsdGlwbGVMaW5lID0geG1sLmF0dHJpYnV0ZXMuc2luZ2xlTGluZSAhPSAndHJ1ZSc7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnN0cm9rZUNvbG9yO1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gc3RyO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuc3Ryb2tlU2l6ZTtcbiAgICAgICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBwYXJzZUludChzdHIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuc3Ryb2tlID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXR1cEFmdGVyQWRkKHhtbCkge1xuICAgICAgICBzdXBlci5zZXR1cEFmdGVyQWRkKHhtbCk7XG4gICAgICAgIGxldCBzdHIgPSB4bWwuYXR0cmlidXRlcy50ZXh0O1xuICAgICAgICBpZiAoc3RyICE9IG51bGwgJiYgc3RyLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB0aGlzLnRleHQgPSBzdHI7XG4gICAgICAgIHRoaXMuJHNpemVEaXJ0eSA9IGZhbHNlO1xuICAgIH1cbn1cbkdUZXh0RmllbGQuR1VUVEVSX1ggPSAyO1xuR1RleHRGaWVsZC5HVVRURVJfWSA9IDI7XG5cbi8vVE9PRDogaW1wbFxuY2xhc3MgR1JpY2hUZXh0RmllbGQgZXh0ZW5kcyBHVGV4dEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gdGhpcy4kdGV4dEZpZWxkLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgLy8gdGhpcy4kdGV4dEZpZWxkLmludGVyYWN0aXZlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbihcIl9fbGlua0NsaWNrXCIgLyogTGlua0NsaWNrICovLCB0aGlzLiRjbGlja0xpbmssIHRoaXMpO1xuICAgIH1cbiAgICBzZXQgdWJiRW5hYmxlZCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kdWJiRW5hYmxlZCAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kdWJiRW5hYmxlZCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdWJiRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHViYkVuYWJsZWQ7XG4gICAgfVxuICAgIHNldHVwQmVmb3JlQWRkKHhtbCkge1xuICAgICAgICBzdXBlci5zZXR1cEJlZm9yZUFkZCh4bWwpO1xuICAgICAgICB0aGlzLiR1YmJFbmFibGVkID0geG1sLmF0dHJpYnV0ZXMudWJiID09ICd0cnVlJztcbiAgICB9XG4gICAgc2V0IHRleHRGbG93KGZsb3cpIHtcbiAgICAgICAgdGhpcy4kdGV4dEZsb3cgPSBmbG93O1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBzZXQgdGV4dCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiR0ZXh0ID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLiR0ZXh0ID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLiR0ZXh0ID0gJyc7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIC8vIGlmKHRoaXMuJHViYkVuYWJsZWQpXG4gICAgICAgIC8vIHRoaXMudGV4dEZsb3cgPSBTdHJpbmdVdGlsLnBhcnNlVUJCKHRoaXMuJHRleHQpOyAgIC8vVE9ETzogcGFyc2VyIGltcGxcbiAgICAgICAgdGhpcy51cGRhdGVHZWFyKDYgLyogVGV4dCAqLyk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgICRjbGlja0xpbmsoYmxvY2spIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX19saW5rQ2xpY2tcIiAvKiBMaW5rQ2xpY2sgKi8sIHRydWUsIGZhbHNlKTtcbiAgICAgICAgZXZlbnQuZGF0YSA9IGJsb2NrLnRleHQ7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCwgdGhpcyk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMub2ZmKFwiX19saW5rQ2xpY2tcIiAvKiBMaW5rQ2xpY2sgKi8sIHRoaXMuJGNsaWNrTGluayk7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG59XG5cbmNsYXNzIElucHV0RWxlbWVudCBleHRlbmRzIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IodGYpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4kcmVxdWVzdFRvU2hvdyA9IGZhbHNlO1xuICAgICAgICAvL3ByaXZhdGUgJHJlcXVlc3RUb0hpZGU6Ym9vbGVhbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5wdXREaXYgPSBudWxsO1xuICAgICAgICB0aGlzLiRzY2FsZVggPSAwO1xuICAgICAgICB0aGlzLiRzY2FsZVkgPSAwO1xuICAgICAgICB0aGlzLnRleHRWYWx1ZSA9ICcnO1xuICAgICAgICB0aGlzLmNvbG9yVmFsdWUgPSAnMHhmZmZmZmYnO1xuICAgICAgICB0aGlzLiRhdHRyc0NhY2hlID0ge307XG4gICAgICAgIHRoaXMuJHRleHRmaWVsZCA9IHRmO1xuICAgIH1cbiAgICAvKipAaW50ZXJuYWwgKi9cbiAgICAkYWRkVG9TdGFnZSgpIHtcbiAgICAgICAgdGhpcy5odG1sSW5wdXQgPSBIVE1MSW5wdXQuaW5zdDsgLy90YWtlIG11bHRpcGxlIGNhbnZhcyBvbiB3ZWJwYWdlIGludG8gYWNjb3VudD9cbiAgICB9XG4gICAgaW5pdEVsZW1lbnQoKSB7XG4gICAgICAgIGxldCBwb2ludCA9IHRoaXMuJHRleHRmaWVsZC5sb2NhbFRvR2xvYmFsKDAsIDApO1xuICAgICAgICBsZXQgeCA9IHBvaW50Lng7XG4gICAgICAgIGxldCB5ID0gcG9pbnQueTtcbiAgICAgICAgbGV0IHNjYWxlWCA9IHRoaXMuaHRtbElucHV0LiRzY2FsZVg7XG4gICAgICAgIGxldCBzY2FsZVkgPSB0aGlzLmh0bWxJbnB1dC4kc2NhbGVZO1xuICAgICAgICBpZiAoIXRoaXMuJHRleHRmaWVsZC5tdWx0aXBsZUxpbmUpXG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zdHlsZS50b3AgPSAtdGhpcy4kdGV4dGZpZWxkLmxlYWRpbmcgKiBzY2FsZVkgKyAncHgnO1xuICAgICAgICB0aGlzLmlucHV0RGl2LnN0eWxlLnRvcCA9ICh5ICsgMSkgKiBzY2FsZVkgKyAncHgnO1xuICAgICAgICB0aGlzLmlucHV0RGl2LnN0eWxlLmxlZnQgPSB4ICogc2NhbGVYICsgJ3B4JztcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLiR0ZXh0ZmllbGQ7XG4gICAgICAgIGxldCBjWCA9IDE7XG4gICAgICAgIGxldCBjWSA9IDE7XG4gICAgICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgICAgIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgY1ggKj0gbm9kZS5zY2FsZVg7XG4gICAgICAgICAgICBjWSAqPSBub2RlLnNjYWxlWTtcbiAgICAgICAgICAgIHJvdGF0aW9uICs9IG5vZGUucm90YXRpb247XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0eWxlID0gdGhpcy5pbnB1dERpdi5zdHlsZTtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUubXNUcmFuc2Zvcm0gPSBzdHlsZS5tb3pUcmFuc2Zvcm0gPSBzdHlsZS5vVHJhbnNmb3JtID1cbiAgICAgICAgICAgICdyb3RhdGUoJyArIHJvdGF0aW9uICsgJ2RlZyknO1xuICAgICAgICB0aGlzLiRzY2FsZVggPSBzY2FsZVggKiBjWDtcbiAgICAgICAgdGhpcy4kc2NhbGVZID0gc2NhbGVZICogY1k7XG4gICAgfVxuICAgIGdldCB0ZXh0RmllbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0ZXh0ZmllbGQ7XG4gICAgfVxuICAgIC8qKkBpbnRlcm5hbCAqL1xuICAgICRzaG93KCkge1xuICAgICAgICBpZiAoIXRoaXMuaHRtbElucHV0LmlzQ3VycmVudElucHV0KHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudCA9IHRoaXMuaHRtbElucHV0LnJlcXVlc3RJbnB1dCh0aGlzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy4kdGV4dGZpZWxkLm11bHRpcGxlTGluZSlcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC50eXBlID0gdGhpcy4kdGV4dGZpZWxkLnR5cGU7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy4kYXR0cnNDYWNoZSlcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB0aGlzLiRhdHRyc0NhY2hlW2tleV0pO1xuICAgICAgICAgICAgdGhpcy5pbnB1dERpdiA9IHRoaXMuaHRtbElucHV0LiR3cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50Lm9uYmx1ciA9IG51bGw7XG4gICAgICAgIHRoaXMuaHRtbElucHV0LiRyZXF1ZXN0VG9TaG93ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kcmVxdWVzdFRvU2hvdyA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5pdEVsZW1lbnQoKTtcbiAgICB9XG4gICAgJGhpZGUoKSB7IH1cbiAgICBvbkJsdXJIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmh0bWxJbnB1dC5jbGVhcklucHV0RWxlbWVudCgpO1xuICAgICAgICB0aGlzLmh0bWxJbnB1dC5jbGVhckF0dHJpYnV0ZXModGhpcy4kYXR0cnNDYWNoZSk7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0VmFsdWUpXG4gICAgICAgICAgICB0aGlzLnRleHRWYWx1ZSA9ICcnO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0VmFsdWU7XG4gICAgfVxuICAgIHNldCB0ZXh0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGV4dFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmlucHV0RWxlbWVudClcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlID0gdGhpcy50ZXh0VmFsdWU7XG4gICAgfVxuICAgIHNldENvbG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29sb3JWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5pbnB1dEVsZW1lbnQpXG4gICAgICAgICAgICB0aGlzLnNldEVsZW1lbnRTdHlsZSgnY29sb3InLCBTdHJpbmdVdGlsLkhFWDJSR0IodGhpcy5jb2xvclZhbHVlKSk7XG4gICAgfVxuICAgIC8qKkBpbnRlcm5hbCAqL1xuICAgICRvbkJsdXIoKSB7XG4gICAgICAgIC8vIHRoaXMuZGlzcGF0Y2hFdmVudChcInVwZGF0ZVRleHRcIik7XG4gICAgfVxuICAgIG9uSW5wdXRIYW5kbGVyKCkge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dEVsZW1lbnQgJiYgdGhpcy5pbnB1dEVsZW1lbnQuc2VsZWN0aW9uU3RhcnQgPT0gdGhpcy5pbnB1dEVsZW1lbnQuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0VmFsdWUgPSB0aGlzLmlucHV0RWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3VwZGF0ZVRleHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIHNldEFyZWFIZWlnaHQoKSB7XG4gICAgICAgIGxldCB0ZiA9IHRoaXMuJHRleHRmaWVsZDtcbiAgICAgICAgaWYgKHRmLm11bHRpcGxlTGluZSkge1xuICAgICAgICAgICAgbGV0IHRleHRoZWlnaHQgPSB0Zi50ZXh0SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHRmLmhlaWdodCA8PSB0Zi5mb250U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudFN0eWxlKCdoZWlnaHQnLCB0Zi5mb250U2l6ZSAqIHRoaXMuJHNjYWxlWSArICdweCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudFN0eWxlKCdwYWRkaW5nJywgJzBweCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudFN0eWxlKCdsaW5lSGVpZ2h0JywgdGYubGluZUhlaWdodCAqIHRoaXMuJHNjYWxlWSArICdweCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGYuaGVpZ2h0IDwgdGV4dGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudFN0eWxlKCdoZWlnaHQnLCB0Zi5oZWlnaHQgKiB0aGlzLiRzY2FsZVkgKyAncHgnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVsZW1lbnRTdHlsZSgncGFkZGluZycsICcwcHgnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVsZW1lbnRTdHlsZSgnbGluZUhlaWdodCcsIHRmLmxpbmVIZWlnaHQgKiB0aGlzLiRzY2FsZVkgKyAncHgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudFN0eWxlKCdoZWlnaHQnLCAodGV4dGhlaWdodCArIHRmLmxlYWRpbmcpICogdGhpcy4kc2NhbGVZICsgJ3B4Jyk7XG4gICAgICAgICAgICAgICAgbGV0IHJhcCA9ICh0Zi5oZWlnaHQgLSB0ZXh0aGVpZ2h0KSAqIHRoaXMuJHNjYWxlWTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsaWduID0gdGhpcy5nZXRWQWxpZ25GYWN0b3IodGYpO1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSByYXAgKiB2YWxpZ247XG4gICAgICAgICAgICAgICAgbGV0IGJvdHRvbSA9IHJhcCAtIHRvcDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVsZW1lbnRTdHlsZSgncGFkZGluZycsIHRvcCArICdweCAwcHggJyArIGJvdHRvbSArICdweCAwcHgnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVsZW1lbnRTdHlsZSgnbGluZUhlaWdodCcsIHRmLmxpbmVIZWlnaHQgKiB0aGlzLiRzY2FsZVkgKyAncHgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRWQWxpZ25GYWN0b3IodGV4dGZpZWxkKSB7XG4gICAgICAgIGxldCB2YW8gPSAwO1xuICAgICAgICBzd2l0Y2ggKHRleHRmaWVsZC52ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogVG9wICovOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxIC8qIE1pZGRsZSAqLzpcbiAgICAgICAgICAgICAgICB2YW8gPSAwLjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogQm90dG9tICovOlxuICAgICAgICAgICAgICAgIHZhbyA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbztcbiAgICB9XG4gICAgb25DbGlja0hhbmRsZXIoZSkge1xuICAgICAgICBpZiAodGhpcy4kcmVxdWVzdFRvU2hvdykge1xuICAgICAgICAgICAgLy9lLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy4kcmVxdWVzdFRvU2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQudmFsdWUgPSB0aGlzLnRleHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dEVsZW1lbnQub25ibHVyID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQub25ibHVyID0gQmluZGVyLmNyZWF0ZSh0aGlzLm9uQmx1ckhhbmRsZXIsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZXNldElucHV0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy4kdGV4dGZpZWxkLm1heExlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCdtYXhsZW5ndGgnLCBTdHJpbmcodGhpcy4kdGV4dGZpZWxkLm1heExlbmd0aCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnbWF4bGVuZ3RoJyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZWxlY3Rpb25TdGFydCA9IHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnNlbGVjdGlvbkVuZCA9IHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICBsZXQgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX19mb2N1c0NoYW5nZWRcIiAvKiBDSEFOR0VEICovLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICBldnQuZGF0YSA9ICdmb2N1cyc7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgbGV0IGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcIl9fZm9jdXNDaGFuZ2VkXCIgLyogQ0hBTkdFRCAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBldnQuZGF0YSA9ICdibHVyJztcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfVxuICAgIHNldEVsZW1lbnRTdHlsZShzdHlsZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmlucHV0RWxlbWVudCkge1xuICAgICAgICAgICAgbGV0IHNzID0gdGhpcy5pbnB1dEVsZW1lbnQuc3R5bGU7XG4gICAgICAgICAgICBzc1tzdHlsZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gbnVsbCB8fCB2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRhdHRyc0NhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRhdHRyc0NhY2hlW25hbWVdO1xuICAgIH1cbiAgICAvKipAaW50ZXJuYWwgKi9cbiAgICAkcmVtb3ZlRnJvbVN0YWdlKCkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dEVsZW1lbnQpXG4gICAgICAgICAgICB0aGlzLmh0bWxJbnB1dC5kaXNjb25uZWN0KHRoaXMpO1xuICAgIH1cbiAgICByZXNldElucHV0KCkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0ZmllbGQgPSB0aGlzLiR0ZXh0ZmllbGQ7XG4gICAgICAgICAgICB0aGlzLnNldEVsZW1lbnRTdHlsZSgnZm9udEZhbWlseScsIHRleHRmaWVsZC5mb250KTtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudFN0eWxlKCdmb250U3R5bGUnLCB0ZXh0ZmllbGQuaXRhbGljID8gJ2l0YWxpYycgOiAnbm9ybWFsJyk7XG4gICAgICAgICAgICB0aGlzLnNldEVsZW1lbnRTdHlsZSgnZm9udFdlaWdodCcsIHRleHRmaWVsZC5ib2xkID8gJ2JvbGQnIDogJ25vcm1hbCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50U3R5bGUoJ3RleHRBbGlnbicsIHRleHRmaWVsZC5hbGlnbik7XG4gICAgICAgICAgICB0aGlzLnNldEVsZW1lbnRTdHlsZSgnZm9udFNpemUnLCB0ZXh0ZmllbGQuZm9udFNpemUgKiB0aGlzLiRzY2FsZVkgKyAncHgnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudFN0eWxlKCdjb2xvcicsIFN0cmluZ1V0aWwuY29udmVydFRvSHRtbENvbG9yKCt0ZXh0ZmllbGQuY29sb3IpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudFN0eWxlKCd3aWR0aCcsIHRleHRmaWVsZC53aWR0aCAqIHRoaXMuJHNjYWxlWCArICdweCcpOyAvL3Rha2UgJ21heFdpZHRoJyBpbnRvIGFjY291bnRcbiAgICAgICAgICAgIGxldCB2YSA9ICdtaWRkbGUnLCB2YW8gPSAwO1xuICAgICAgICAgICAgc3dpdGNoICh0ZXh0ZmllbGQudmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBUb3AgKi86XG4gICAgICAgICAgICAgICAgICAgIHZhID0gJ3RvcCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBNaWRkbGUgKi86XG4gICAgICAgICAgICAgICAgICAgIHZhID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgICAgIHZhbyA9IDAuNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIEJvdHRvbSAqLzpcbiAgICAgICAgICAgICAgICAgICAgdmEgPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgdmFvID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEVsZW1lbnRTdHlsZSgndmVydGljYWxBbGlnbicsIHZhKTtcbiAgICAgICAgICAgIGlmICh0ZXh0ZmllbGQubXVsdGlwbGVMaW5lKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXJlYUhlaWdodCgpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50U3R5bGUoJ2xpbmVIZWlnaHQnLCB0ZXh0ZmllbGQubGluZUhlaWdodCAqIHRoaXMuJHNjYWxlWSArICdweCcpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0ZmllbGQuaGVpZ2h0IDwgdGV4dGZpZWxkLmZvbnRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudFN0eWxlKCdoZWlnaHQnLCB0ZXh0ZmllbGQuZm9udFNpemUgKiB0aGlzLiRzY2FsZVkgKyAncHgnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50U3R5bGUoJ3BhZGRpbmcnLCAnMHB4IDBweCAnICsgdGV4dGZpZWxkLmZvbnRTaXplICogMC41ICogdGhpcy4kc2NhbGVYICsgJ3B4IDBweCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50U3R5bGUoJ2hlaWdodCcsIHRleHRmaWVsZC5mb250U2l6ZSAqIHRoaXMuJHNjYWxlWSArICdweCcpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFwID0gKHRleHRmaWVsZC5oZWlnaHQgLSB0ZXh0ZmllbGQuZm9udFNpemUpICogdGhpcy4kc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9wID0gcmFwICogdmFvO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYm90dG9tID0gcmFwIC0gdG9wLCBmc3kgPSB0ZXh0ZmllbGQuZm9udFNpemUgKiAwLjUgKiB0aGlzLiRzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib3R0b20gPCBmc3kpXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSBmc3k7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudFN0eWxlKCdwYWRkaW5nJywgdG9wICsgJ3B4IDBweCAnICsgYm90dG9tICsgJ3B4IDBweCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5wdXREaXYuc3R5bGUuY2xpcCA9XG4gICAgICAgICAgICAgICAgJ3JlY3QoMHB4ICcgK1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ZmllbGQud2lkdGggKiB0aGlzLiRzY2FsZVggK1xuICAgICAgICAgICAgICAgICAgICAncHggJyArXG4gICAgICAgICAgICAgICAgICAgIHRleHRmaWVsZC5oZWlnaHQgKiB0aGlzLiRzY2FsZVkgK1xuICAgICAgICAgICAgICAgICAgICAncHggMHB4KSc7XG4gICAgICAgICAgICB0aGlzLmlucHV0RGl2LnN0eWxlLmhlaWdodCA9IHRleHRmaWVsZC5oZWlnaHQgKiB0aGlzLiRzY2FsZVkgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5pbnB1dERpdi5zdHlsZS53aWR0aCA9IHRleHRmaWVsZC53aWR0aCAqIHRoaXMuJHNjYWxlWCArICdweCc7IC8vdGFrZSAnbWF4V2lkdGgnIGludG8gYWNjb3VudFxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBJbnB1dERlbGVnYXRlIHtcbiAgICBjb25zdHJ1Y3Rvcih0Zikge1xuICAgICAgICB0aGlzLiRpbml0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kcmVzdHJpY3RTdHJpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLiRyZXN0cmljdFJlZ2V4ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiR0ZXh0RmllbGQgPSB0ZjtcbiAgICAgICAgdGhpcy4kaW5wdXQgPSBuZXcgSW5wdXRFbGVtZW50KHRmKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGluaXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaW5wdXQuJGFkZFRvU3RhZ2UoKTtcbiAgICAgICAgdGhpcy4kaW5wdXQub24oJ3VwZGF0ZVRleHQnLCB0aGlzLnVwZGF0ZVRleHQsIHRoaXMpO1xuICAgICAgICB0aGlzLiRpbnB1dC5vbihcIl9fZm9jdXNDaGFuZ2VkXCIgLyogQ0hBTkdFRCAqLywgdGhpcy5mb2N1c0hhbmRsZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLiR0ZXh0RmllbGQub24oSW50ZXJhY3RpdmVFdmVudHMuRG93biwgdGhpcy50ZXh0RmllbGREb3duSGFuZGxlciwgdGhpcyk7XG4gICAgICAgIHRoaXMuJGluaXRlZCA9IHRydWU7XG4gICAgfVxuICAgIHRleHRGaWVsZERvd25IYW5kbGVyKCkge1xuICAgICAgICB0aGlzLiRvbkZvY3VzKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy4kaW5pdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRpbnB1dC4kcmVtb3ZlRnJvbVN0YWdlKCk7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5vZmYoSW50ZXJhY3RpdmVFdmVudHMuRG93biwgdGhpcy50ZXh0RmllbGREb3duSGFuZGxlcik7XG4gICAgICAgIEdSb290Lmluc3Qub2ZmKEludGVyYWN0aXZlRXZlbnRzLkRvd24sIHRoaXMub25TdGFnZURvd24pO1xuICAgICAgICB0aGlzLiRpbnB1dC5vZmYoJ3VwZGF0ZVRleHQnLCB0aGlzLnVwZGF0ZVRleHQpO1xuICAgICAgICB0aGlzLiRpbnB1dC5vZmYoXCJfX2ZvY3VzQ2hhbmdlZFwiIC8qIENIQU5HRUQgKi8sIHRoaXMuZm9jdXNIYW5kbGVyKTtcbiAgICAgICAgdGhpcy4kaW5pdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQudGV4dDtcbiAgICB9XG4gICAgc2V0IHRleHQodikge1xuICAgICAgICB0aGlzLiRpbnB1dC50ZXh0ID0gdjtcbiAgICB9XG4gICAgc2V0Q29sb3Iodikge1xuICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQuc2V0Q29sb3Iodik7XG4gICAgfVxuICAgIHVwZGF0ZVRleHQoKSB7XG4gICAgICAgIGxldCB0ZXh0VmFsdWUgPSB0aGlzLiRpbnB1dC50ZXh0O1xuICAgICAgICBsZXQgaXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLiRyZXN0cmljdFJlZ2V4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0ZXh0VmFsdWUubWF0Y2godGhpcy4kcmVzdHJpY3RSZWdleCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgIHRleHRWYWx1ZSA9IHJlc3VsdC5qb2luKCcnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0ZXh0VmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2hhbmdlZCAmJiB0aGlzLiRpbnB1dC50ZXh0ICE9IHRleHRWYWx1ZSlcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LnRleHQgPSB0ZXh0VmFsdWU7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC50ZXh0ID0gdGhpcy4kaW5wdXQudGV4dDtcbiAgICAgICAgbGV0IGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcIl9fdGV4dENoYW5nZVwiIC8qIENoYW5nZSAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBldnQuZGF0YSA9IHsgdGV4dEZpZWxkOiB0aGlzLiR0ZXh0RmllbGQgfTtcbiAgICAgICAgdGhpcy4kdGV4dEZpZWxkLmRpc3BhdGNoRXZlbnQoZXZ0LCB0aGlzKTtcbiAgICB9XG4gICAgb25TdGFnZURvd24oZSkge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gR09iamVjdC5jYXN0RnJvbU5hdGl2ZU9iamVjdChlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9IHRoaXMuJHRleHRGaWVsZClcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LiRoaWRlKCk7XG4gICAgfVxuICAgIGZvY3VzSGFuZGxlcihldnQpIHtcbiAgICAgICAgbGV0IHsgZGF0YSB9ID0gZXZ0O1xuICAgICAgICBpZiAoZGF0YSA9PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRmb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiR0ZXh0RmllbGQuJGlzVHlwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiR0ZXh0RmllbGQuYWxwaGEgPSAwLjAxO1xuICAgICAgICAgICAgICAgIHRoaXMuJHRleHRGaWVsZC5kaXNwYXRjaEV2ZW50KFwiX19mb2N1c0NoYW5nZWRcIiAvKiBDSEFOR0VEICovLCAnZm9jdXMnKTtcbiAgICAgICAgICAgICAgICB0aGlzLiR0ZXh0RmllbGQuZGlzcGF0Y2hFdmVudChcIl9fdGV4dEZvY3VzSW5cIiAvKiBGb2N1c0luICovLCB0aGlzLiR0ZXh0RmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEgPT0gJ2JsdXInKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kZm9jdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBHUm9vdC5pbnN0Lm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5Eb3duLCB0aGlzLm9uU3RhZ2VEb3duKTtcbiAgICAgICAgICAgICAgICB0aGlzLiR0ZXh0RmllbGQuJGlzVHlwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGV4dEZpZWxkLmFscGhhID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC4kb25CbHVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGV4dEZpZWxkLmRpc3BhdGNoRXZlbnQoXCJfX2ZvY3VzQ2hhbmdlZFwiIC8qIENIQU5HRUQgKi8sICdibHVyJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGV4dEZpZWxkLmRpc3BhdGNoRXZlbnQoXCJfX3RleHRGb2N1c091dFwiIC8qIEZvY3VzT3V0ICovLCB0aGlzLiR0ZXh0RmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0ZvY3VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmb2N1c2VkO1xuICAgIH1cbiAgICAvKipAaW50ZXJuYWwgKi9cbiAgICAkZ2V0UHJvcGVydHkobmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuJGluaXRlZCAmJiB0aGlzLiRpbnB1dC5nZXRBdHRyaWJ1dGUobmFtZSkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKkBpbnRlcm5hbCAqL1xuICAgICRzZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuJGluaXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaW5wdXQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0ICRyZXN0cmljdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlc3RyaWN0U3RyaW5nO1xuICAgIH1cbiAgICBzZXQgJHJlc3RyaWN0KHYpIHtcbiAgICAgICAgdGhpcy4kcmVzdHJpY3RTdHJpbmcgPSB2O1xuICAgICAgICBpZiAodGhpcy4kcmVzdHJpY3RTdHJpbmcgIT0gbnVsbCAmJiB0aGlzLiRyZXN0cmljdFN0cmluZy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhpcy4kcmVzdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAodGhpcy4kcmVzdHJpY3RTdHJpbmcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRyZXN0cmljdFJlZ2V4ID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0eXBlO1xuICAgIH1cbiAgICBzZXQgdHlwZSh2KSB7XG4gICAgICAgIGlmICh2ICE9IHRoaXMuJHR5cGUpXG4gICAgICAgICAgICB0aGlzLiR0eXBlID0gdjtcbiAgICB9XG4gICAgdHJ5SGlkZUlucHV0KCkge1xuICAgICAgICBpZiAoIXRoaXMuJHRleHRGaWVsZC52aXNpYmxlICYmIHRoaXMuJGlucHV0KVxuICAgICAgICAgICAgdGhpcy4kaW5wdXQuJHJlbW92ZUZyb21TdGFnZSgpO1xuICAgIH1cbiAgICAvKipAaW50ZXJuYWwgKi9cbiAgICAkdXBkYXRlUHJvcGVydGllcygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5yZXNldElucHV0KCk7XG4gICAgICAgICAgICB0aGlzLnRyeUhpZGVJbnB1dCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGlucHV0LnRleHQgPSB0aGlzLiR0ZXh0RmllbGQudGV4dDtcbiAgICAgICAgdGhpcy4kaW5wdXQucmVzZXRJbnB1dCgpO1xuICAgICAgICB0aGlzLnRyeUhpZGVJbnB1dCgpO1xuICAgIH1cbiAgICAvKipAaW50ZXJuYWwgKi9cbiAgICAkb25Gb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLiR0ZXh0RmllbGQudmlzaWJsZSB8fCB0aGlzLiRmb2N1c2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBHUm9vdC5pbnN0Lm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5Eb3duLCB0aGlzLm9uU3RhZ2VEb3duKTtcbiAgICAgICAgR1RpbWVyLmluc3QuY2FsbExhdGVyKCgpID0+IHtcbiAgICAgICAgICAgIEdSb290Lmluc3Qub24oSW50ZXJhY3RpdmVFdmVudHMuRG93biwgdGhpcy5vblN0YWdlRG93biwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLiRpbnB1dC4kc2hvdygpO1xuICAgIH1cbn1cblxuY2xhc3MgR1RleHRJbnB1dCBleHRlbmRzIEdUZXh0RmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLiR1dGlsID0gbnVsbDtcbiAgICAgICAgLyoqQGludGVybmFsICovXG4gICAgICAgIHRoaXMuJGlzVHlwaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9jdXNhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IHRydWU7IC8vaW5pdFxuICAgICAgICB0aGlzLnR5cGUgPSBcInRleHRcIiAvKiBURVhUICovO1xuICAgICAgICB0aGlzLm9uKCdyZW1vdmVkJywgdGhpcy5yZW1vdmVkLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignYWRkZWQnLCB0aGlzLmFkZGVkLCB0aGlzKTtcbiAgICAgICAgdGhpcy4kdXRpbC5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIGNyZWF0ZURpc3BsYXlPYmplY3QoKSB7XG4gICAgICAgIHN1cGVyLmNyZWF0ZURpc3BsYXlPYmplY3QoKTtcbiAgICAgICAgdGhpcy4kaGl0QXJlYSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgICB0aGlzLiRoaXRBcmVhLmdyYXBoaWNzLmJlZ2luRmlsbCgnIzAwMCcpLmRyYXdSZWN0KDAsIDAsIHRoaXMuJHdpZHRoLCB0aGlzLiRoZWlnaHQpO1xuICAgICAgICB0aGlzLiRkaXNwbGF5T2JqZWN0LmhpdEFyZWEgPSB0aGlzLiRoaXRBcmVhO1xuICAgIH1cbiAgICBoYW5kbGVTaXplQ2hhbmdlZCgpIHtcbiAgICAgICAgc3VwZXIuaGFuZGxlU2l6ZUNoYW5nZWQoKTtcbiAgICAgICAgdGhpcy4kaGl0QXJlYS5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCB0aGlzLiR3aWR0aCwgdGhpcy4kaGVpZ2h0KTtcbiAgICAgICAgdGhpcy4kZGlzcGxheU9iamVjdC5oaXRBcmVhID0gdGhpcy4kaGl0QXJlYTtcbiAgICB9XG4gICAgcmVtb3ZlZChkaXNwKSB7XG4gICAgICAgIGlmICh0aGlzLiR1dGlsKVxuICAgICAgICAgICAgdGhpcy4kdXRpbC5kZXN0cm95KCk7XG4gICAgfVxuICAgIGFkZGVkKGRpc3ApIHtcbiAgICAgICAgaWYgKHRoaXMuJHV0aWwpXG4gICAgICAgICAgICB0aGlzLiR1dGlsLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgcmVxdWVzdEZvY3VzKCkge1xuICAgICAgICAvL3RhYiBvciBjYWxsIGFjdGl2ZWx5XG4gICAgICAgIERlY2xzJDEuR1Jvb3QuaW5zdC5mb2N1cyA9IHRoaXM7XG4gICAgICAgIHRoaXMuJHV0aWwuJG9uRm9jdXMoKTtcbiAgICB9XG4gICAgZ2V0IGVkaXRhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZWRpdGFibGU7XG4gICAgfVxuICAgIHNldCBlZGl0YWJsZSh2KSB7XG4gICAgICAgIGlmICh2ICE9IHRoaXMuJGVkaXRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLiRlZGl0YWJsZSA9IHY7XG4gICAgICAgICAgICBpZiAodGhpcy4kZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuJHV0aWwpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHV0aWwgPSBuZXcgSW5wdXREZWxlZ2F0ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiR1dGlsLmluaXRpYWxpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiR1dGlsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiR1dGlsLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudG91Y2hhYmxlID0gdGhpcy4kZWRpdGFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hhbmdlVG9QYXNzVGV4dCh0ZXh0KSB7XG4gICAgICAgIGxldCBwYXNzVGV4dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbnVtID0gdGV4dC5sZW5ndGg7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgc3dpdGNoICh0ZXh0LmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICAgICAgICAgIHBhc3NUZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdcXHInOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwYXNzVGV4dCArPSAnKic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhc3NUZXh0O1xuICAgIH1cbiAgICBnZXRUZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdXRpbC50ZXh0O1xuICAgIH1cbiAgICBzZXRUZXh0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuJHRleHQgPT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJHV0aWwudGV4dCA9IHZhbHVlO1xuICAgICAgICBzdXBlci5zZXRUZXh0KHZhbHVlKTtcbiAgICB9XG4gICAgc2V0Q29sb3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIuc2V0Q29sb3IodmFsdWUpO1xuICAgICAgICB0aGlzLiR1dGlsLnNldENvbG9yKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHByb21wdFRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR1dGlsLiRnZXRQcm9wZXJ0eSgncGxhY2Vob2xkZXInKTtcbiAgICB9XG4gICAgc2V0IHByb21wdFRleHQodikge1xuICAgICAgICBpZiAodiA9PSBudWxsKVxuICAgICAgICAgICAgdiA9ICcnO1xuICAgICAgICB0aGlzLiR1dGlsLiRzZXRQcm9wZXJ0eSgncGxhY2Vob2xkZXInLCB2KTtcbiAgICB9XG4gICAgZ2V0IG1heExlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuJHV0aWwuJGdldFByb3BlcnR5KCdtYXhsZW5ndGgnKSkgfHwgMDtcbiAgICB9XG4gICAgc2V0IG1heExlbmd0aCh2KSB7XG4gICAgICAgIHRoaXMuJHV0aWwuJHNldFByb3BlcnR5KCdtYXhsZW5ndGgnLCBTdHJpbmcodikpO1xuICAgIH1cbiAgICBnZXQgcmVzdHJpY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR1dGlsLiRyZXN0cmljdDtcbiAgICB9XG4gICAgc2V0IHJlc3RyaWN0KHYpIHtcbiAgICAgICAgdGhpcy4kdXRpbC4kcmVzdHJpY3QgPSB2O1xuICAgIH1cbiAgICBnZXQgcGFzc3dvcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gXCJwYXNzd29yZFwiIC8qIFBBU1NXT1JEICovO1xuICAgIH1cbiAgICBzZXQgcGFzc3dvcmQodikge1xuICAgICAgICB0aGlzLnR5cGUgPSBcInBhc3N3b3JkXCIgLyogUEFTU1dPUkQgKi87XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdXRpbC50eXBlO1xuICAgIH1cbiAgICBzZXQgdHlwZSh0KSB7XG4gICAgICAgIHRoaXMuJHV0aWwudHlwZSA9IHQ7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vZmYoJ3JlbW92ZWQnLCB0aGlzLnJlbW92ZWQpO1xuICAgICAgICB0aGlzLm9mZignYWRkZWQnLCB0aGlzLmFkZGVkKTtcbiAgICAgICAgdGhpcy4kdXRpbC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJHV0aWwgPSBudWxsO1xuICAgIH1cbiAgICByZW5kZXJOb3codXBkYXRlQm91bmRzID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLiRyZXF1aXJlUmVuZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJHNpemVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiR1dGlsLiR1cGRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGlmICh0aGlzLiRpc1R5cGluZylcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGVJbnB1dGJveCgpO1xuICAgICAgICBsZXQgb3JpZ1RleHQgPSB0aGlzLiR0ZXh0O1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwicGFzc3dvcmRcIiAvKiBQQVNTV09SRCAqLylcbiAgICAgICAgICAgIHRoaXMuJHRleHQgPSB0aGlzLmNoYW5nZVRvUGFzc1RleHQodGhpcy4kdGV4dCk7XG4gICAgICAgIHN1cGVyLnJlbmRlck5vdyh1cGRhdGVCb3VuZHMpO1xuICAgICAgICB0aGlzLiR0ZXh0ID0gb3JpZ1RleHQ7XG4gICAgfVxuICAgIGRlY29yYXRlSW5wdXRib3goKSB7XG4gICAgICAgIC8vZHJhdyB1bmRlcmxpbmVzP1xuICAgIH1cbiAgICBzZXR1cEJlZm9yZUFkZCh4bWwpIHtcbiAgICAgICAgc3VwZXIuc2V0dXBCZWZvcmVBZGQoeG1sKTtcbiAgICAgICAgLy90aGlzLnByb21wdFRleHQgPSB4bWwuYXR0cmlidXRlcy5wcm9tcHQ7ICAvL3RoaXMgd2lsbCBiZSBhdmFpbGFibGUgb25jZSBVQkIgaGFzIGltcGxlbWVudGVkLlxuICAgICAgICB2YXIgc3RyID0geG1sLmF0dHJpYnV0ZXMubWF4TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLm1heExlbmd0aCA9IHBhcnNlSW50KHN0cik7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnJlc3RyaWN0O1xuICAgICAgICBpZiAoc3RyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLnJlc3RyaWN0ID0gc3RyO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5wYXNzd29yZDtcbiAgICAgICAgaWYgKHN0ciA9PSAndHJ1ZScpXG4gICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gdHJ1ZTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5rZXlib2FyZFR5cGU7XG4gICAgICAgICAgICBpZiAoc3RyID09ICc0JylcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcIm51bWJlclwiIC8qIE5VTUJFUiAqLztcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ciA9PSAnMycpXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJ1cmxcIiAvKiBVUkwgKi87XG4gICAgICAgICAgICBlbHNlIGlmIChzdHIgPT0gJzUnKVxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwidGVsXCIgLyogVEVMICovO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RyID09ICc2JylcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImVtYWlsXCIgLyogRU1BSUwgKi87XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFJlY3ljbGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy4kY291bnQgPSAwO1xuICAgICAgICB0aGlzLiRwb29sID0ge307XG4gICAgfVxuICAgIGdldCBjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvdW50O1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuJHBvb2wpIHtcbiAgICAgICAgICAgIGxldCBhcnIgPSB0aGlzLiRwb29sW2tleV07XG4gICAgICAgICAgICBpZiAoYXJyKSB7XG4gICAgICAgICAgICAgICAgYXJyLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgYXJyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRwb29sID0ge307XG4gICAgICAgIHRoaXMuJGNvdW50ID0gMDtcbiAgICB9XG4gICAgZ2V0KGlkKSB7XG4gICAgICAgIGxldCBhcnIgPSB0aGlzLiRwb29sW2lkXTtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICBhcnIgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuJHBvb2xbaWRdID0gYXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLiRjb3VudC0tO1xuICAgICAgICAgICAgcmV0dXJuIGFyci5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU9iamVjdChpZCk7XG4gICAgfVxuICAgIHJlY3ljbGUoaWQsIG9iaikge1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgYXJyID0gdGhpcy4kcG9vbFtpZF07XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyID0gW107XG4gICAgICAgICAgICB0aGlzLiRwb29sW2lkXSA9IGFycjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRjb3VudCsrO1xuICAgICAgICBhcnIucHVzaChvYmopO1xuICAgIH1cbn1cblxuY2xhc3MgR09iamVjdFJlY3ljbGVyIGV4dGVuZHMgUmVjeWNsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuJHBvb2wpIHtcbiAgICAgICAgICAgIGxldCBhcnIgPSB0aGlzLiRwb29sW2tleV07XG4gICAgICAgICAgICBpZiAoYXJyKSB7XG4gICAgICAgICAgICAgICAgYXJyLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuY2xlYXIoKTtcbiAgICB9XG4gICAgY3JlYXRlT2JqZWN0KGlkKSB7XG4gICAgICAgIHJldHVybiBVSVBhY2thZ2UuY3JlYXRlT2JqZWN0RnJvbVVSTChpZCk7IC8vaWQgPSB1cmxcbiAgICB9XG59XG5cbmNsYXNzIEdMb2FkZXIgZXh0ZW5kcyBHT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4kZnJhbWUgPSAwO1xuICAgICAgICB0aGlzLiRjb2xvciA9ICcjZmZmJztcbiAgICAgICAgdGhpcy4kY29udGVudFNvdXJjZVdpZHRoID0gMDtcbiAgICAgICAgdGhpcy4kY29udGVudFNvdXJjZUhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuJGNvbnRlbnRXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuJGNvbnRlbnRIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLiRsb2FkaW5nVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMuJHBsYXlpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLiR1cmwgPSAnJztcbiAgICAgICAgdGhpcy4kZmlsbCA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgdGhpcy4kYWxpZ24gPSBcImxlZnRcIiAvKiBMZWZ0ICovO1xuICAgICAgICB0aGlzLiR2ZXJ0aWNhbEFsaWduID0gMCAvKiBUb3AgKi87XG4gICAgICAgIHRoaXMuJHNob3dFcnJvclNpZ24gPSB0cnVlO1xuICAgICAgICB0aGlzLiRjb2xvciA9ICcjZmZmJztcbiAgICB9XG4gICAgY3JlYXRlRGlzcGxheU9iamVjdCgpIHtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gbmV3IFVJQ29udGFpbmVyKHRoaXMpO1xuICAgICAgICB0aGlzLiRoaXRBcmVhID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICAgIHRoaXMuJGhpdEFyZWEuZ3JhcGhpY3MuYmVnaW5GaWxsKCcjMDAwJykuZHJhd1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5oaXRBcmVhID0gdGhpcy4kaGl0QXJlYTtcbiAgICAgICAgdGhpcy5zZXREaXNwbGF5T2JqZWN0KHRoaXMuJGNvbnRhaW5lcik7XG4gICAgICAgIC8vIHRoaXMuJGNvbnRhaW5lci5tb3VzZUNoaWxkcmVuID0gZmFsc2VcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbGVhckNvbnRlbnQoKTtcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBnZXQgdXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdXJsO1xuICAgIH1cbiAgICBzZXQgdXJsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiR1cmwgPT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJHVybCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvYWRDb250ZW50KCk7XG4gICAgICAgIHRoaXMudXBkYXRlR2Vhcig3IC8qIEljb24gKi8pO1xuICAgIH1cbiAgICBnZXQgaWNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHVybDtcbiAgICB9XG4gICAgc2V0IGljb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGFsaWduKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kYWxpZ247XG4gICAgfVxuICAgIHNldCBhbGlnbih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kYWxpZ24gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGFsaWduID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxheW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB2ZXJ0aWNhbEFsaWduKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdmVydGljYWxBbGlnbjtcbiAgICB9XG4gICAgc2V0IHZlcnRpY2FsQWxpZ24odmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJHZlcnRpY2FsQWxpZ24gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJHZlcnRpY2FsQWxpZ24gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmaWxsO1xuICAgIH1cbiAgICBzZXQgZmlsbCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kZmlsbCAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kZmlsbCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYXV0b1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRhdXRvU2l6ZTtcbiAgICB9XG4gICAgc2V0IGF1dG9TaXplKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRhdXRvU2l6ZSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kYXV0b1NpemUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHBsYXlpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRwbGF5aW5nO1xuICAgIH1cbiAgICBzZXQgcGxheWluZyh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kcGxheWluZyAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kcGxheWluZyA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGNvbnRlbnQgaW5zdGFuY2VvZiBNb3ZpZUNsaXApXG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGVudC5wbGF5aW5nID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUdlYXIoNSAvKiBBbmltYXRpb24gKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmcmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGZyYW1lO1xuICAgIH1cbiAgICBzZXQgZnJhbWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGZyYW1lICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRmcmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGNvbnRlbnQgaW5zdGFuY2VvZiBNb3ZpZUNsaXApXG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGVudC5jdXJyZW50RnJhbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlR2Vhcig1IC8qIEFuaW1hdGlvbiAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY29sb3I7XG4gICAgfVxuICAgIHNldCBjb2xvcih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kY29sb3IgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUdlYXIoNCAvKiBDb2xvciAqLyk7XG4gICAgICAgICAgICB0aGlzLmFwcGx5Q29sb3IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseUNvbG9yKCkge1xuICAgICAgICBpZiAodGhpcy4kY29udGVudClcbiAgICAgICAgICAgIHRoaXMuJGNvbnRlbnQudGludCA9IHRoaXMuJGNvbG9yO1xuICAgIH1cbiAgICBnZXQgc2hvd0Vycm9yU2lnbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNob3dFcnJvclNpZ247XG4gICAgfVxuICAgIHNldCBzaG93RXJyb3JTaWduKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJHNob3dFcnJvclNpZ24gPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjb250ZW50O1xuICAgIH1cbiAgICBnZXQgdGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGNvbnRlbnQgaW5zdGFuY2VvZiBVSUltYWdlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRlbnQudGV4dHVyZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zd2l0Y2hUb01vdmllTW9kZShmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLiRjb250ZW50IGluc3RhbmNlb2YgVUlJbWFnZSlcbiAgICAgICAgICAgIHRoaXMuJGNvbnRlbnQudGV4dHVyZSA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRlbnRTb3VyY2VXaWR0aCA9IHZhbHVlLndpZHRoO1xuICAgICAgICAgICAgdGhpcy4kY29udGVudFNvdXJjZUhlaWdodCA9IHZhbHVlLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRjb250ZW50U291cmNlV2lkdGggPSB0aGlzLiRjb250ZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy51cGRhdGVMYXlvdXQoKTtcbiAgICB9XG4gICAgbG9hZENvbnRlbnQoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZW50KCk7XG4gICAgICAgIGlmICghdGhpcy4kdXJsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoU3RyaW5nVXRpbC5zdGFydHNXaXRoKHRoaXMuJHVybCwgJ3VpOi8vJykpXG4gICAgICAgICAgICB0aGlzLmxvYWRGcm9tUGFja2FnZSh0aGlzLiR1cmwpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmxvYWRFeHRlcm5hbCgpO1xuICAgIH1cbiAgICBsb2FkRnJvbVBhY2thZ2UoaXRlbVVSTCkge1xuICAgICAgICB0aGlzLiRjb250ZW50SXRlbSA9IFVJUGFja2FnZS5nZXRJdGVtQnlVUkwoaXRlbVVSTCk7XG4gICAgICAgIGlmICh0aGlzLiRjb250ZW50SXRlbSkge1xuICAgICAgICAgICAgdGhpcy4kY29udGVudEl0ZW0ubG9hZCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGNvbnRlbnRJdGVtLnR5cGUgPT0gMCAvKiBJbWFnZSAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRjb250ZW50SXRlbS50ZXh0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFcnJvclN0YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaFRvTW92aWVNb2RlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29udGVudC4kaW5pdERpc3AodGhpcy4kY29udGVudEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50U291cmNlV2lkdGggPSB0aGlzLiRjb250ZW50SXRlbS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29udGVudFNvdXJjZUhlaWdodCA9IHRoaXMuJGNvbnRlbnRJdGVtLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXlvdXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRjb250ZW50SXRlbS50eXBlID09IDIgLyogTW92aWVDbGlwICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hUb01vdmllTW9kZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50U291cmNlV2lkdGggPSB0aGlzLiRjb250ZW50SXRlbS53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50U291cmNlSGVpZ2h0ID0gdGhpcy4kY29udGVudEl0ZW0uaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCBtYyA9IHRoaXMuJGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgbWMuaW50ZXJ2YWwgPSB0aGlzLiRjb250ZW50SXRlbS5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICBtYy5zd2luZyA9IHRoaXMuJGNvbnRlbnRJdGVtLnN3aW5nO1xuICAgICAgICAgICAgICAgIG1jLnJlcGVhdERlbGF5ID0gdGhpcy4kY29udGVudEl0ZW0ucmVwZWF0RGVsYXk7XG4gICAgICAgICAgICAgICAgbWMuZnJhbWVzID0gdGhpcy4kY29udGVudEl0ZW0uZnJhbWVzO1xuICAgICAgICAgICAgICAgIG1jLmJvdW5kc1JlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKDAsIDAsIHRoaXMuJGNvbnRlbnRTb3VyY2VXaWR0aCwgdGhpcy4kY29udGVudFNvdXJjZUhlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXlvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVycm9yU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNldEVycm9yU3RhdGUoKTtcbiAgICB9XG4gICAgc3dpdGNoVG9Nb3ZpZU1vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCEodGhpcy4kY29udGVudCBpbnN0YW5jZW9mIE1vdmllQ2xpcCkpXG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGVudCA9IG5ldyBNb3ZpZUNsaXAodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLiRjb250ZW50IGluc3RhbmNlb2YgVUlJbWFnZSkpXG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGVudCA9IG5ldyBVSUltYWdlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLiRjb250ZW50KTtcbiAgICB9XG4gICAgLyoqb3ZlcndyaXRlIHRoaXMgbWV0aG9kIGlmIHlvdSBuZWVkIHRvIGxvYWQgcmVzb3VyY2VzIGJ5IHlvdXIgb3duIHdheSovXG4gICAgbG9hZEV4dGVybmFsKCkge1xuICAgICAgICAvLyBsZXQgdGV4dHVyZSA9IEJpdG1hcC5mcm9tSW1hZ2UodGhpcy4kdXJsLCB0cnVlKTtcbiAgICAgICAgbGV0IHRleHR1cmUgPSBuZXcgQml0bWFwKCk7XG4gICAgICAgIHRoaXMuJGxvYWRpbmdUZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgICAgLy9UT0RPOiBUZXh0dXJlIGRvZXMgbm90IGhhdmUgZXJyb3IgZXZlbnQuLi4gbW9uaXRvciBlcnJvciBldmVudCBvbiBiYXNlVGV4dHVyZSB3aWxsIGNhc3VlIGNyb3NzLWVycm9yLWV2ZW50IHByb2JsZW0uXG4gICAgICAgIC8vIHRleHR1cmUub25jZShcInVwZGF0ZVwiLCAoKSA9PiB7XG4gICAgICAgIC8vICAgICBpZiAoIXRleHR1cmUud2lkdGggfHwgIXRleHR1cmUuaGVpZ2h0KVxuICAgICAgICAvLyAgICAgICAgIHRoaXMuJGxvYWRSZXNDb21wbGV0ZWQobnVsbCk7XG4gICAgICAgIC8vICAgICBlbHNlXG4gICAgICAgIC8vICAgICAgICAgdGhpcy4kbG9hZFJlc0NvbXBsZXRlZCh0ZXh0dXJlKTtcbiAgICAgICAgLy8gfSk7XG4gICAgfVxuICAgIC8qKmZyZWUgdGhlIHJlc291cmNlIHlvdSBsb2FkZWQgKi9cbiAgICBmcmVlRXh0ZXJuYWwodGV4dHVyZSkge1xuICAgICAgICAvLyBCaXRtYXAucmVtb3ZlRnJvbUNhY2hlKHRleHR1cmUpO1xuICAgICAgICAvLyB0ZXh0dXJlLmRlc3Ryb3kodGV4dHVyZS5iYXNlVGV4dHVyZSAhPSBudWxsKTtcbiAgICB9XG4gICAgJGxvYWRSZXNDb21wbGV0ZWQocmVzKSB7XG4gICAgICAgIGlmIChyZXMpXG4gICAgICAgICAgICB0aGlzLm9uRXh0ZXJuYWxMb2FkU3VjY2VzcyhyZXMpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25FeHRlcm5hbExvYWRGYWlsZWQoKTtcbiAgICAgICAgICAgIC8vIHRoaXMuJGxvYWRpbmdUZXh0dXJlLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcy5mcmVlRXh0ZXJuYWwodGhpcy4kbG9hZGluZ1RleHR1cmUpO1xuICAgICAgICAgICAgdGhpcy4kbG9hZGluZ1RleHR1cmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGxvYWRpbmdUZXh0dXJlID0gbnVsbDtcbiAgICB9XG4gICAgLyoqY29udGVudCBsb2FkZWQgKi9cbiAgICBvbkV4dGVybmFsTG9hZFN1Y2Nlc3ModGV4dHVyZSkge1xuICAgICAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgICAgaWYgKCF0aGlzLiRjb250ZW50IHx8ICEodGhpcy4kY29udGVudCBpbnN0YW5jZW9mIFVJSW1hZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLiRjb250ZW50ID0gbmV3IFVJSW1hZ2UobnVsbCk7XG4gICAgICAgICAgICB0aGlzLiRjb250ZW50LiRpbml0RGlzcCgpO1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmFkZENoaWxkKHRoaXMuJGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLiRjb250ZW50KTtcbiAgICAgICAgLy9iYXNlVGV4dHVyZSBsb2FkZWQsIHNvIHVwZGF0ZSBmcmFtZSBpbmZvICAvLyB0b2RvXG4gICAgICAgIHRoaXMuJGNvbnRlbnQudGV4dHVyZSA9IHRleHR1cmUudGV4dHVyZTtcbiAgICAgICAgdGhpcy4kY29udGVudFNvdXJjZVdpZHRoID0gdGV4dHVyZS5zb3VyY2VSZWN0LndpZHRoO1xuICAgICAgICB0aGlzLiRjb250ZW50U291cmNlSGVpZ2h0ID0gdGV4dHVyZS5zb3VyY2VSZWN0LmhlaWdodDtcbiAgICAgICAgdGhpcy51cGRhdGVMYXlvdXQoKTtcbiAgICB9XG4gICAgb25FeHRlcm5hbExvYWRGYWlsZWQoKSB7XG4gICAgICAgIHRoaXMuc2V0RXJyb3JTdGF0ZSgpO1xuICAgIH1cbiAgICBzZXRFcnJvclN0YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHNob3dFcnJvclNpZ24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLiRlcnJvclNpZ24gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFVJQ29uZmlnLmxvYWRlckVycm9yU2lnbikge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVycm9yU2lnbiA9IEdMb2FkZXIuJGVycm9yU2lnblBvb2wuZ2V0KFVJQ29uZmlnLmxvYWRlckVycm9yU2lnbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGVycm9yU2lnbikge1xuICAgICAgICAgICAgdGhpcy4kZXJyb3JTaWduLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuJGVycm9yU2lnbi5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLiRlcnJvclNpZ24uZGlzcGxheU9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJFcnJvclN0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy4kZXJyb3JTaWduKSB7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy4kZXJyb3JTaWduLmRpc3BsYXlPYmplY3QpO1xuICAgICAgICAgICAgR0xvYWRlci4kZXJyb3JTaWduUG9vbC5yZWN5Y2xlKHRoaXMuJGVycm9yU2lnbi5yZXNvdXJjZVVSTCwgdGhpcy4kZXJyb3JTaWduKTtcbiAgICAgICAgICAgIHRoaXMuJGVycm9yU2lnbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTGF5b3V0KCkge1xuICAgICAgICBpZiAodGhpcy4kY29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kYXV0b1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGluZ0xheW91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTaXplKDUwLCAzMCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kdXBkYXRpbmdMYXlvdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRjb250ZW50LnNldCh7IHg6IDAsIHk6IDAgfSk7XG4gICAgICAgIHRoaXMuJGNvbnRlbnQuc2V0KHsgc2NhbGVYOiAxLCBzY2FsZVk6IDEgfSk7XG4gICAgICAgIHRoaXMuJGNvbnRlbnRXaWR0aCA9IHRoaXMuJGNvbnRlbnRTb3VyY2VXaWR0aDtcbiAgICAgICAgdGhpcy4kY29udGVudEhlaWdodCA9IHRoaXMuJGNvbnRlbnRTb3VyY2VIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLiRhdXRvU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRpbmdMYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGNvbnRlbnRXaWR0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRlbnRXaWR0aCA9IDUwO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGNvbnRlbnRIZWlnaHQgPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50SGVpZ2h0ID0gMzA7XG4gICAgICAgICAgICB0aGlzLnNldFNpemUodGhpcy4kY29udGVudFdpZHRoLCB0aGlzLiRjb250ZW50SGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0aW5nTGF5b3V0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3ggPSAxLCBzeSA9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy4kZmlsbCAhPSAwIC8qIE5vbmUgKi8pIHtcbiAgICAgICAgICAgICAgICBzeCA9IHRoaXMud2lkdGggLyB0aGlzLiRjb250ZW50U291cmNlV2lkdGg7XG4gICAgICAgICAgICAgICAgc3kgPSB0aGlzLmhlaWdodCAvIHRoaXMuJGNvbnRlbnRTb3VyY2VIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHN4ICE9IDEgfHwgc3kgIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kZmlsbCA9PSAyIC8qIFNjYWxlTWF0Y2hIZWlnaHQgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBzeCA9IHN5O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRmaWxsID09IDMgLyogU2NhbGVNYXRjaFdpZHRoICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3kgPSBzeDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4kZmlsbCA9PSAxIC8qIFNjYWxlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ggPiBzeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeCA9IHN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5ID0gc3g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4kZmlsbCA9PSA1IC8qIFNjYWxlTm9Cb3JkZXIgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzeCA+IHN5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5ID0gc3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ggPSBzeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50V2lkdGggPSB0aGlzLiRjb250ZW50U291cmNlV2lkdGggKiBzeDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29udGVudEhlaWdodCA9IHRoaXMuJGNvbnRlbnRTb3VyY2VIZWlnaHQgKiBzeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kY29udGVudCBpbnN0YW5jZW9mIFVJSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50LndpZHRoID0gdGhpcy4kY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRlbnQuaGVpZ2h0ID0gdGhpcy4kY29udGVudEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50LnNldCh7IHNjYWxlWDogc3gsIHNjYWxlWTogc3kgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy4kYWxpZ24gPT0gXCJjZW50ZXJcIiAvKiBDZW50ZXIgKi8pXG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGVudC54ID0gTWF0aC5mbG9vcigodGhpcy53aWR0aCAtIHRoaXMuJGNvbnRlbnRXaWR0aCkgLyAyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJGFsaWduID09IFwicmlnaHRcIiAvKiBSaWdodCAqLylcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50LnggPSB0aGlzLndpZHRoIC0gdGhpcy4kY29udGVudFdpZHRoO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHZlcnRpY2FsQWxpZ24gPT0gMSAvKiBNaWRkbGUgKi8pXG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGVudC55ID0gTWF0aC5mbG9vcigodGhpcy5oZWlnaHQgLSB0aGlzLiRjb250ZW50SGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4kdmVydGljYWxBbGlnbiA9PSAyIC8qIEJvdHRvbSAqLylcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250ZW50LnkgPSB0aGlzLmhlaWdodCAtIHRoaXMuJGNvbnRlbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJDb250ZW50KCkge1xuICAgICAgICB0aGlzLmNsZWFyRXJyb3JTdGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy4kY29udGVudCAmJiB0aGlzLiRjb250ZW50LnBhcmVudClcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLiRjb250ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuJGxvYWRpbmdUZXh0dXJlKSB7XG4gICAgICAgICAgICAvLyB0aGlzLiRsb2FkaW5nVGV4dHVyZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTsvLyB0b2RvXG4gICAgICAgICAgICB0aGlzLmZyZWVFeHRlcm5hbCh0aGlzLiRsb2FkaW5nVGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLiRsb2FkaW5nVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgKHRoaXMuJGNvbnRlbnRJdGVtID09IG51bGwgJiYgdGhpcy4kY29udGVudCBpbnN0YW5jZW9mIFVJSW1hZ2UpXG4gICAgICAgIC8vICAgICB0aGlzLmZyZWVFeHRlcm5hbCh0aGlzLiRjb250ZW50LnRleHR1cmUpOyAvLyB0b2RvXG4gICAgICAgIHRoaXMuJGNvbnRlbnQgJiYgdGhpcy4kY29udGVudC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiRjb250ZW50SXRlbSA9IG51bGw7XG4gICAgfVxuICAgIGhhbmRsZVNpemVDaGFuZ2VkKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHVwZGF0aW5nTGF5b3V0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMYXlvdXQoKTtcbiAgICAgICAgdGhpcy4kaGl0QXJlYS5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIHNldHVwQmVmb3JlQWRkKHhtbCkge1xuICAgICAgICBzdXBlci5zZXR1cEJlZm9yZUFkZCh4bWwpO1xuICAgICAgICBsZXQgc3RyO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy51cmw7XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLiR1cmwgPSBzdHI7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmFsaWduO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgdGhpcy4kYWxpZ24gPSBQYXJzZUFsaWduVHlwZShzdHIpO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy52QWxpZ247XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLiR2ZXJ0aWNhbEFsaWduID0gUGFyc2VWZXJ0QWxpZ25UeXBlKHN0cik7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmZpbGw7XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLiRmaWxsID0gUGFyc2VMb2FkZXJGaWxsVHlwZShzdHIpO1xuICAgICAgICB0aGlzLiRhdXRvU2l6ZSA9IHhtbC5hdHRyaWJ1dGVzLmF1dG9TaXplID09ICd0cnVlJztcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuZXJyb3JTaWduO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgdGhpcy4kc2hvd0Vycm9yU2lnbiA9IHN0ciA9PSAndHJ1ZSc7XG4gICAgICAgIHRoaXMuJHBsYXlpbmcgPSB4bWwuYXR0cmlidXRlcy5wbGF5aW5nICE9ICdmYWxzZSc7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmNvbG9yO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgdGhpcy5jb2xvciA9IHN0cjtcbiAgICAgICAgaWYgKHRoaXMuJHVybClcbiAgICAgICAgICAgIHRoaXMubG9hZENvbnRlbnQoKTtcbiAgICB9XG59XG5HTG9hZGVyLiRlcnJvclNpZ25Qb29sID0gbmV3IEdPYmplY3RSZWN5Y2xlcigpO1xuXG5sZXQgaXNDb2xvcmFibGVUaXRsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwidGl0bGVDb2xvclwiIGluIG9iaiAmJiBcImZvbnRTaXplXCIgaW4gb2JqO1xufTtcblxuY2xhc3MgR0xhYmVsIGV4dGVuZHMgR0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgIGdldCBpY29uKCkge1xuICAgICAgICBpZiAodGhpcy4kaWNvbk9iamVjdCAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGljb25PYmplY3QuaWNvbjtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNldCBpY29uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRpY29uT2JqZWN0ICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLiRpY29uT2JqZWN0Lmljb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVHZWFyKDcgLyogSWNvbiAqLyk7XG4gICAgfVxuICAgIGdldCB0aXRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHRpdGxlT2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHRpdGxlT2JqZWN0LnRleHQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXQgdGl0bGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJHRpdGxlT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy4kdGl0bGVPYmplY3QudGV4dCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUdlYXIoNiAvKiBUZXh0ICovKTtcbiAgICB9XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH1cbiAgICBzZXQgdGV4dCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRpdGxlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB0aXRsZUNvbG9yKCkge1xuICAgICAgICBpZiAoaXNDb2xvcmFibGVUaXRsZSh0aGlzLiR0aXRsZU9iamVjdCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kdGl0bGVPYmplY3QudGl0bGVDb2xvcjtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBzZXQgdGl0bGVDb2xvcih2YWx1ZSkge1xuICAgICAgICBpZiAoaXNDb2xvcmFibGVUaXRsZSh0aGlzLiR0aXRsZU9iamVjdCkpXG4gICAgICAgICAgICB0aGlzLiR0aXRsZU9iamVjdC50aXRsZUNvbG9yID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBmb250U2l6ZSgpIHtcbiAgICAgICAgaWYgKGlzQ29sb3JhYmxlVGl0bGUodGhpcy4kdGl0bGVPYmplY3QpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHRpdGxlT2JqZWN0LmZvbnRTaXplO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgc2V0IGZvbnRTaXplKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0NvbG9yYWJsZVRpdGxlKHRoaXMuJHRpdGxlT2JqZWN0KSlcbiAgICAgICAgICAgIHRoaXMuJHRpdGxlT2JqZWN0LmZvbnRTaXplID0gdmFsdWU7XG4gICAgfVxuICAgIHNldCBlZGl0YWJsZSh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuJHRpdGxlT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy4kdGl0bGVPYmplY3QuZWRpdGFibGUgPSB2YWw7XG4gICAgfVxuICAgIGdldCBlZGl0YWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHRpdGxlT2JqZWN0ICYmIHRoaXMuJHRpdGxlT2JqZWN0IGluc3RhbmNlb2YgR1RleHRJbnB1dClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiR0aXRsZU9iamVjdC5lZGl0YWJsZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RGcm9tWE1MKHhtbCkge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3RGcm9tWE1MKHhtbCk7XG4gICAgICAgIHRoaXMuJHRpdGxlT2JqZWN0ID0gdGhpcy5nZXRDaGlsZCgndGl0bGUnKTtcbiAgICAgICAgdGhpcy4kaWNvbk9iamVjdCA9IHRoaXMuZ2V0Q2hpbGQoJ2ljb24nKTtcbiAgICB9XG4gICAgc2V0dXBBZnRlckFkZCh4bWwpIHtcbiAgICAgICAgc3VwZXIuc2V0dXBBZnRlckFkZCh4bWwpO1xuICAgICAgICBsZXQgY3MgPSBYbWxQYXJzZXIuZ2V0Q2hpbGROb2Rlcyh4bWwsICdMYWJlbCcpO1xuICAgICAgICBpZiAoY3MgJiYgY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgeG1sID0gY3NbMF07XG4gICAgICAgICAgICBsZXQgc3RyO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMudGl0bGU7XG4gICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgIHRoaXMudGV4dCA9IHN0cjtcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmljb247XG4gICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgIHRoaXMuaWNvbiA9IHN0cjtcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnRpdGxlQ29sb3I7XG4gICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgIHRoaXMudGl0bGVDb2xvciA9IHN0cjtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0aXRsZU9iamVjdCBpbnN0YW5jZW9mIEdUZXh0SW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5wcm9tcHQ7XG4gICAgICAgICAgICAgICAgbGV0IHRpID0gdGhpcy4kdGl0bGVPYmplY3Q7XG4gICAgICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICAgICAgdGkucHJvbXB0VGV4dCA9IHN0cjtcbiAgICAgICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5tYXhMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICAgICAgdGkubWF4TGVuZ3RoID0gcGFyc2VJbnQoc3RyKTtcbiAgICAgICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5yZXN0cmljdDtcbiAgICAgICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgICAgICB0aS5yZXN0cmljdCA9IHN0cjtcbiAgICAgICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5wYXNzd29yZDtcbiAgICAgICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgICAgICB0aS5wYXNzd29yZCA9IHN0ciA9PSAndHJ1ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFBhZ2VPcHRpb24ge1xuICAgIHNldCBjb250cm9sbGVyKHZhbCkge1xuICAgICAgICB0aGlzLiRjb250cm9sbGVyID0gdmFsO1xuICAgIH1cbiAgICBzZXQgbmFtZShwYWdlTmFtZSkge1xuICAgICAgICB0aGlzLiRpZCA9IHRoaXMuJGNvbnRyb2xsZXIuZ2V0UGFnZUlkQnlOYW1lKHBhZ2VOYW1lKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLiRpZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjb250cm9sbGVyLmdldFBhZ2VOYW1lQnlJZCh0aGlzLiRpZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXQgaW5kZXgocGFnZUluZGV4KSB7XG4gICAgICAgIHRoaXMuJGlkID0gdGhpcy4kY29udHJvbGxlci5nZXRQYWdlSWQocGFnZUluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgICBpZiAodGhpcy4kaWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY29udHJvbGxlci5nZXRQYWdlSW5kZXhCeUlkKHRoaXMuJGlkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy4kaWQgPSBudWxsO1xuICAgIH1cbiAgICBzZXQgaWQoaWQpIHtcbiAgICAgICAgdGhpcy4kaWQgPSBpZDtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaWQ7XG4gICAgfVxufVxuXG5jbGFzcyBHQnV0dG9uIGV4dGVuZHMgR0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuJG1vZGUgPSAwIC8qIENvbW1vbiAqLztcbiAgICAgICAgdGhpcy4kdGl0bGUgPSAnJztcbiAgICAgICAgdGhpcy4kaWNvbiA9ICcnO1xuICAgICAgICB0aGlzLiRzb3VuZCA9IFVJQ29uZmlnLmJ1dHRvblNvdW5kO1xuICAgICAgICB0aGlzLiRzb3VuZFZvbHVtZVNjYWxlID0gVUlDb25maWcuYnV0dG9uU291bmRWb2x1bWVTY2FsZTtcbiAgICAgICAgdGhpcy4kcGFnZU9wdGlvbiA9IG5ldyBQYWdlT3B0aW9uKCk7XG4gICAgICAgIHRoaXMuJGNoYW5nZVN0YXRlT25DbGljayA9IHRydWU7XG4gICAgICAgIHRoaXMuJGRvd25FZmZlY3QgPSAwO1xuICAgICAgICB0aGlzLiRkb3duRWZmZWN0VmFsdWUgPSAwLjg7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgfVxuICAgIHNldERpc3BsYXlPYmplY3QodmFsdWUpIHtcbiAgICAgICAgc3VwZXIuc2V0RGlzcGxheU9iamVjdCh2YWx1ZSk7XG4gICAgICAgIC8vIHRoaXMuJGRpc3BsYXlPYmplY3QuYnV0dG9uTW9kZSA9IHRydWU7IC8vdG9kb1xuICAgIH1cbiAgICBnZXQgaWNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGljb247XG4gICAgfVxuICAgIHNldCBpY29uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJGljb24gPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLiRzZWxlY3RlZCAmJiB0aGlzLiRzZWxlY3RlZEljb24gPyB0aGlzLiRzZWxlY3RlZEljb24gOiB0aGlzLiRpY29uO1xuICAgICAgICBpZiAodGhpcy4kaWNvbk9iamVjdCAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy4kaWNvbk9iamVjdC5pY29uID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlR2Vhcig3IC8qIEljb24gKi8pO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRJY29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2VsZWN0ZWRJY29uO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWRJY29uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJHNlbGVjdGVkSWNvbiA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuJHNlbGVjdGVkICYmIHRoaXMuJHNlbGVjdGVkSWNvbiA/IHRoaXMuJHNlbGVjdGVkSWNvbiA6IHRoaXMuJGljb247XG4gICAgICAgIGlmICh0aGlzLiRpY29uT2JqZWN0ICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLiRpY29uT2JqZWN0Lmljb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdGl0bGU7XG4gICAgfVxuICAgIHNldCB0aXRsZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiR0aXRsZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy4kdGl0bGVPYmplY3QpXG4gICAgICAgICAgICB0aGlzLiR0aXRsZU9iamVjdC50ZXh0ID1cbiAgICAgICAgICAgICAgICB0aGlzLiRzZWxlY3RlZCAmJiB0aGlzLiRzZWxlY3RlZFRpdGxlID8gdGhpcy4kc2VsZWN0ZWRUaXRsZSA6IHRoaXMuJHRpdGxlO1xuICAgICAgICB0aGlzLnVwZGF0ZUdlYXIoNiAvKiBUZXh0ICovKTtcbiAgICB9XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH1cbiAgICBzZXQgdGV4dCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRpdGxlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZFRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2VsZWN0ZWRUaXRsZTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkVGl0bGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kc2VsZWN0ZWRUaXRsZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy4kdGl0bGVPYmplY3QpXG4gICAgICAgICAgICB0aGlzLiR0aXRsZU9iamVjdC50ZXh0ID1cbiAgICAgICAgICAgICAgICB0aGlzLiRzZWxlY3RlZCAmJiB0aGlzLiRzZWxlY3RlZFRpdGxlID8gdGhpcy4kc2VsZWN0ZWRUaXRsZSA6IHRoaXMuJHRpdGxlO1xuICAgIH1cbiAgICBnZXQgdGl0bGVDb2xvcigpIHtcbiAgICAgICAgaWYgKGlzQ29sb3JhYmxlVGl0bGUodGhpcy4kdGl0bGVPYmplY3QpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHRpdGxlT2JqZWN0LnRpdGxlQ29sb3I7XG4gICAgfVxuICAgIHNldCB0aXRsZUNvbG9yKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0NvbG9yYWJsZVRpdGxlKHRoaXMuJHRpdGxlT2JqZWN0KSlcbiAgICAgICAgICAgIHRoaXMuJHRpdGxlT2JqZWN0LnRpdGxlQ29sb3IgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGZvbnRTaXplKCkge1xuICAgICAgICBpZiAoaXNDb2xvcmFibGVUaXRsZSh0aGlzLiR0aXRsZU9iamVjdCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kdGl0bGVPYmplY3QuZm9udFNpemU7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBzZXQgZm9udFNpemUodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQ29sb3JhYmxlVGl0bGUodGhpcy4kdGl0bGVPYmplY3QpKVxuICAgICAgICAgICAgdGhpcy4kdGl0bGVPYmplY3QuZm9udFNpemUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHNvdW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc291bmQ7XG4gICAgfVxuICAgIHNldCBzb3VuZCh2YWwpIHtcbiAgICAgICAgdGhpcy4kc291bmQgPSB2YWw7XG4gICAgfVxuICAgIGdldCBzb3VuZFZvbHVtZVNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc291bmRWb2x1bWVTY2FsZTtcbiAgICB9XG4gICAgc2V0IHNvdW5kVm9sdW1lU2NhbGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kc291bmRWb2x1bWVTY2FsZSA9IHZhbHVlO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWQodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLiRtb2RlID09IDAgLyogQ29tbW9uICovKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy4kc2VsZWN0ZWQgIT0gdmFsKSB7XG4gICAgICAgICAgICB0aGlzLiRzZWxlY3RlZCA9IHZhbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyYXllZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuJGJ1dHRvbkNvbnRyb2xsZXIgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiRidXR0b25Db250cm9sbGVyLmhhc1BhZ2UoR0J1dHRvbi5ESVNBQkxFRCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kc2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoR0J1dHRvbi5TRUxFQ1RFRF9ESVNBQkxFRCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKEdCdXR0b24uRElTQUJMRUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHNlbGVjdGVkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuJG92ZXIgPyBHQnV0dG9uLlNFTEVDVEVEX09WRVIgOiBHQnV0dG9uLkRPV04pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLiRvdmVyID8gR0J1dHRvbi5PVkVSIDogR0J1dHRvbi5VUCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kc2VsZWN0ZWRUaXRsZSAmJiB0aGlzLiR0aXRsZU9iamVjdClcbiAgICAgICAgICAgICAgICB0aGlzLiR0aXRsZU9iamVjdC50ZXh0ID0gdGhpcy4kc2VsZWN0ZWQgPyB0aGlzLiRzZWxlY3RlZFRpdGxlIDogdGhpcy4kdGl0bGU7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2VsZWN0ZWRJY29uKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ciA9IHRoaXMuJHNlbGVjdGVkID8gdGhpcy4kc2VsZWN0ZWRJY29uIDogdGhpcy4kaWNvbjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kaWNvbk9iamVjdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRpY29uT2JqZWN0Lmljb24gPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kcmVsYXRlZENvbnRyb2xsZXIgJiYgdGhpcy4kcGFyZW50ICYmICF0aGlzLiRwYXJlbnQuJGJ1aWxkaW5nRGlzcGxheUxpc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcmVsYXRlZENvbnRyb2xsZXIuc2VsZWN0ZWRQYWdlSWQgPSB0aGlzLiRwYWdlT3B0aW9uLmlkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kcmVsYXRlZENvbnRyb2xsZXIuJGF1dG9SYWRpb0dyb3VwRGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRwYXJlbnQuYWRqdXN0UmFkaW9Hcm91cERlcHRoKHRoaXMsIHRoaXMuJHJlbGF0ZWRDb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4kbW9kZSA9PSAxIC8qIENoZWNrICovICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHJlbGF0ZWRDb250cm9sbGVyLnNlbGVjdGVkUGFnZUlkID09IHRoaXMuJHBhZ2VPcHRpb24uaWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHJlbGF0ZWRDb250cm9sbGVyLm9wcG9zaXRlUGFnZUlkID0gdGhpcy4kcGFnZU9wdGlvbi5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzZWxlY3RlZDtcbiAgICB9XG4gICAgZ2V0IG1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRtb2RlO1xuICAgIH1cbiAgICBzZXQgbW9kZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kbW9kZSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IDAgLyogQ29tbW9uICovKVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuJG1vZGUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcmVsYXRlZENvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWxhdGVkQ29udHJvbGxlcjtcbiAgICB9XG4gICAgc2V0IHJlbGF0ZWRDb250cm9sbGVyKHZhbCkge1xuICAgICAgICBpZiAodmFsICE9IHRoaXMuJHJlbGF0ZWRDb250cm9sbGVyKSB7XG4gICAgICAgICAgICB0aGlzLiRyZWxhdGVkQ29udHJvbGxlciA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuJHBhZ2VPcHRpb24uY29udHJvbGxlciA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuJHBhZ2VPcHRpb24uY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcGFnZU9wdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHBhZ2VPcHRpb247XG4gICAgfVxuICAgIGdldCBjaGFuZ2VTdGF0ZU9uQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjaGFuZ2VTdGF0ZU9uQ2xpY2s7XG4gICAgfVxuICAgIHNldCBjaGFuZ2VTdGF0ZU9uQ2xpY2sodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kY2hhbmdlU3RhdGVPbkNsaWNrID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBsaW5rZWRQb3B1cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGxpbmtlZFBvcHVwO1xuICAgIH1cbiAgICBzZXQgbGlua2VkUG9wdXAodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kbGlua2VkUG9wdXAgPSB2YWx1ZTtcbiAgICB9XG4gICAgYWRkU3RhdGVMaXN0ZW5lcihsaXN0ZW5lciwgdGhpc09iaikge1xuICAgICAgICB0aGlzLm9uKFwiX19zdGF0ZUNoYW5nZWRcIiAvKiBDSEFOR0VEICovLCBsaXN0ZW5lciwgdGhpc09iaik7XG4gICAgfVxuICAgIHJlbW92ZVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5vZmYoXCJfX3N0YXRlQ2hhbmdlZFwiIC8qIENIQU5HRUQgKi8sIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgZmlyZUNsaWNrKGRvd25FZmZlY3QgPSB0cnVlKSB7XG4gICAgICAgIGlmIChkb3duRWZmZWN0ICYmIHRoaXMuJG1vZGUgPT0gMCAvKiBDb21tb24gKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoR0J1dHRvbi5PVkVSKTtcbiAgICAgICAgICAgIEdUaW1lci5pbnN0LmFkZCgxMDAsIDEsIHRoaXMuc2V0U3RhdGUsIHRoaXMsIEdCdXR0b24uRE9XTik7XG4gICAgICAgICAgICBHVGltZXIuaW5zdC5hZGQoMjAwLCAxLCB0aGlzLnNldFN0YXRlLCB0aGlzLCBHQnV0dG9uLlVQKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRjbGljayhudWxsKTtcbiAgICB9XG4gICAgc2V0U3RhdGUodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLiRidXR0b25Db250cm9sbGVyKVxuICAgICAgICAgICAgdGhpcy4kYnV0dG9uQ29udHJvbGxlci5zZWxlY3RlZFBhZ2UgPSB2YWw7XG4gICAgICAgIGlmICh0aGlzLiRkb3duRWZmZWN0ID09IDEpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gR0J1dHRvbi5ET1dOIHx8IHZhbCA9PSBHQnV0dG9uLlNFTEVDVEVEX09WRVIgfHwgdmFsID09IEdCdXR0b24uU0VMRUNURURfRElTQUJMRUQpIHtcbiAgICAgICAgICAgICAgICBsZXQgciA9IHRoaXMuJGRvd25FZmZlY3RWYWx1ZSAqIDI1NTtcbiAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSAociA8PCAxNikgKyAociA8PCA4KSArIHI7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChvYmogPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb2xvckdlYXIob2JqKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5jb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChvYmogPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb2xvckdlYXIob2JqKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5jb2xvciA9IDB4ZmZmZmZmO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJGRvd25FZmZlY3QgPT0gMikge1xuICAgICAgICAgICAgaWYgKHZhbCA9PSBHQnV0dG9uLkRPV04gfHwgdmFsID09IEdCdXR0b24uU0VMRUNURURfT1ZFUiB8fCB2YWwgPT0gR0J1dHRvbi5TRUxFQ1RFRF9ESVNBQkxFRClcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNjYWxlKHRoaXMuJGRvd25FZmZlY3RWYWx1ZSwgdGhpcy4kZG93bkVmZmVjdFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNjYWxlKDEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNvbnRyb2xsZXJDaGFuZ2VkKGMpIHtcbiAgICAgICAgc3VwZXIuaGFuZGxlQ29udHJvbGxlckNoYW5nZWQoYyk7XG4gICAgICAgIGlmICh0aGlzLiRyZWxhdGVkQ29udHJvbGxlciA9PSBjKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuJHBhZ2VPcHRpb24uaWQgPT0gYy5zZWxlY3RlZFBhZ2VJZDtcbiAgICB9XG4gICAgaGFuZGxlR3JheWVkQ2hhbmdlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGJ1dHRvbkNvbnRyb2xsZXIgJiYgdGhpcy4kYnV0dG9uQ29udHJvbGxlci5oYXNQYWdlKEdCdXR0b24uRElTQUJMRUQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmF5ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kc2VsZWN0ZWQgJiYgdGhpcy4kYnV0dG9uQ29udHJvbGxlci5oYXNQYWdlKEdCdXR0b24uU0VMRUNURURfRElTQUJMRUQpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKEdCdXR0b24uU0VMRUNURURfRElTQUJMRUQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShHQnV0dG9uLkRJU0FCTEVEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJHNlbGVjdGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoR0J1dHRvbi5ET1dOKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKEdCdXR0b24uVVApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN1cGVyLmhhbmRsZUdyYXllZENoYW5nZWQoKTtcbiAgICB9XG4gICAgY29uc3RydWN0RnJvbVhNTCh4bWwpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0RnJvbVhNTCh4bWwpO1xuICAgICAgICB4bWwgPSBYbWxQYXJzZXIuZ2V0Q2hpbGROb2Rlcyh4bWwsICdCdXR0b24nKVswXTtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMubW9kZTtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuJG1vZGUgPSBQYXJzZUJ1dHRvbk1vZGUoc3RyKTtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuc291bmQ7XG4gICAgICAgIGlmIChzdHIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuJHNvdW5kID0gc3RyO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy52b2x1bWU7XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLiRzb3VuZFZvbHVtZVNjYWxlID0gcGFyc2VJbnQoc3RyKSAvIDEwMDtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuZG93bkVmZmVjdDtcbiAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgdGhpcy4kZG93bkVmZmVjdCA9IHN0ciA9PSAnZGFyaycgPyAxIDogc3RyID09ICdzY2FsZScgPyAyIDogMDtcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmRvd25FZmZlY3RWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuJGRvd25FZmZlY3RWYWx1ZSA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRkb3duRWZmZWN0ID09IDIpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQaXZvdCgwLjUsIDAuNSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kYnV0dG9uQ29udHJvbGxlciA9IHRoaXMuZ2V0Q29udHJvbGxlcignYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuJHRpdGxlT2JqZWN0ID0gdGhpcy5nZXRDaGlsZCgndGl0bGUnKTtcbiAgICAgICAgdGhpcy4kaWNvbk9iamVjdCA9IHRoaXMuZ2V0Q2hpbGQoJ2ljb24nKTtcbiAgICAgICAgaWYgKHRoaXMuJHRpdGxlT2JqZWN0ICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLiR0aXRsZSA9IHRoaXMuJHRpdGxlT2JqZWN0LnRleHQ7XG4gICAgICAgIGlmICh0aGlzLiRpY29uT2JqZWN0ICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLiRpY29uID0gdGhpcy4kaWNvbk9iamVjdC5pY29uO1xuICAgICAgICBpZiAodGhpcy4kbW9kZSA9PSAwIC8qIENvbW1vbiAqLylcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoR0J1dHRvbi5VUCk7XG4gICAgICAgIHRoaXMub24oSW50ZXJhY3RpdmVFdmVudHMuT3ZlciwgdGhpcy4kcm9sbG92ZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLm9uKEludGVyYWN0aXZlRXZlbnRzLk91dCwgdGhpcy4kcm9sbG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMub24oSW50ZXJhY3RpdmVFdmVudHMuRG93biwgdGhpcy4kbW91c2Vkb3duLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbihJbnRlcmFjdGl2ZUV2ZW50cy5DbGljaywgdGhpcy4kY2xpY2ssIHRoaXMpO1xuICAgICAgICB0aGlzLiRoaXRBcmVhID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICAgIHRoaXMuJGhpdEFyZWEuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmZlwiKS5kcmF3UmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuJGRpc3BsYXlPYmplY3QuaGl0QXJlYSA9IHRoaXMuJGhpdEFyZWE7XG4gICAgfVxuICAgIHNldHVwQWZ0ZXJBZGQoeG1sKSB7XG4gICAgICAgIHN1cGVyLnNldHVwQWZ0ZXJBZGQoeG1sKTtcbiAgICAgICAgeG1sID0gWG1sUGFyc2VyLmdldENoaWxkTm9kZXMoeG1sLCAnQnV0dG9uJylbMF07XG4gICAgICAgIGlmICh4bWwpIHtcbiAgICAgICAgICAgIGxldCBzdHI7XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy50aXRsZTtcbiAgICAgICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICAgICAgdGhpcy50aXRsZSA9IHN0cjtcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmljb247XG4gICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgIHRoaXMuaWNvbiA9IHN0cjtcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnNlbGVjdGVkVGl0bGU7XG4gICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRUaXRsZSA9IHN0cjtcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnNlbGVjdGVkSWNvbjtcbiAgICAgICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEljb24gPSBzdHI7XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy50aXRsZUNvbG9yO1xuICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRpdGxlQ29sb3IgPSBTdHJpbmdVdGlsLkhFWDJSR0Ioc3RyKTtcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnNvdW5kO1xuICAgICAgICAgICAgaWYgKHN0ciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuJHNvdW5kID0gc3RyO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMudm9sdW1lO1xuICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICB0aGlzLiRzb3VuZFZvbHVtZVNjYWxlID0gcGFyc2VJbnQoc3RyKSAvIDEwMDtcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnRpdGxlRm9udFNpemU7XG4gICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgIHRoaXMuZm9udFNpemUgPSBwYXJzZUludChzdHIpO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuY29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICAgICAgdGhpcy4kcmVsYXRlZENvbnRyb2xsZXIgPSB0aGlzLiRwYXJlbnQuZ2V0Q29udHJvbGxlcihzdHIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuJHJlbGF0ZWRDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJHBhZ2VPcHRpb24uaWQgPSB4bWwuYXR0cmlidXRlcy5wYWdlO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHhtbC5hdHRyaWJ1dGVzLmNoZWNrZWQgPT0gJ3RydWUnO1xuICAgICAgICB9XG4gICAgfVxuICAgICRyb2xsb3ZlcihldnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRidXR0b25Db250cm9sbGVyIHx8ICF0aGlzLiRidXR0b25Db250cm9sbGVyLmhhc1BhZ2UoR0J1dHRvbi5PVkVSKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kb3ZlciA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLiRkb3duKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuJHNlbGVjdGVkID8gR0J1dHRvbi5TRUxFQ1RFRF9PVkVSIDogR0J1dHRvbi5PVkVSKTtcbiAgICB9XG4gICAgJHJvbGxvdXQoZXZ0KSB7XG4gICAgICAgIGlmICghdGhpcy4kYnV0dG9uQ29udHJvbGxlciB8fCAhdGhpcy4kYnV0dG9uQ29udHJvbGxlci5oYXNQYWdlKEdCdXR0b24uT1ZFUikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJG92ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuJGRvd24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy4kc2VsZWN0ZWQgPyBHQnV0dG9uLkRPV04gOiBHQnV0dG9uLlVQKTtcbiAgICB9XG4gICAgJG1vdXNlZG93bihldnQpIHtcbiAgICAgICAgdGhpcy4kZG93biA9IHRydWU7XG4gICAgICAgIHRoaXMuJG1vdXNlVXBFdmVudCA9IERlY2xzJDEuR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vbihJbnRlcmFjdGl2ZUV2ZW50cy5VcCwgdGhpcy4kbW91c2V1cCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLiRtb2RlID09IDAgLyogQ29tbW9uICovKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmF5ZWQgJiYgdGhpcy4kYnV0dG9uQ29udHJvbGxlciAmJiB0aGlzLiRidXR0b25Db250cm9sbGVyLmhhc1BhZ2UoR0J1dHRvbi5ESVNBQkxFRCkpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShHQnV0dG9uLlNFTEVDVEVEX0RJU0FCTEVEKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKEdCdXR0b24uRE9XTik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGxpbmtlZFBvcHVwICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRsaW5rZWRQb3B1cCBpbnN0YW5jZW9mIFdpbmRvdylcbiAgICAgICAgICAgICAgICB0aGlzLiRsaW5rZWRQb3B1cC50b2dnbGVWaXNpYmxlKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgRGVjbHMkMS5HUm9vdC5pbnN0LnRvZ2dsZVBvcHVwKHRoaXMuJGxpbmtlZFBvcHVwLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAkbW91c2V1cChldnQpIHtcbiAgICAgICAgaWYgKHRoaXMuJGRvd24pIHtcbiAgICAgICAgICAgIERlY2xzJDEuR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vZmYoSW50ZXJhY3RpdmVFdmVudHMuVXAsIHRoaXMuJG1vdXNlVXBFdmVudCk7XG4gICAgICAgICAgICB0aGlzLiRkb3duID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy4kbW9kZSA9PSAwIC8qIENvbW1vbiAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyYXllZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRidXR0b25Db250cm9sbGVyICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1dHRvbkNvbnRyb2xsZXIuaGFzUGFnZShHQnV0dG9uLkRJU0FCTEVEKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShHQnV0dG9uLkRJU0FCTEVEKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRvdmVyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKEdCdXR0b24uT1ZFUik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKEdCdXR0b24uVVApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICRjbGljayhldnQpIHtcbiAgICAgICAgaWYgKHRoaXMuJHNvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcGkgPSBVSVBhY2thZ2UuZ2V0SXRlbUJ5VVJMKHRoaXMuJHNvdW5kKTtcbiAgICAgICAgICAgIGlmIChwaSkge1xuICAgICAgICAgICAgICAgIHZhciBzb3VuZCA9IHBpLm93bmVyLmdldEl0ZW1Bc3NldChwaSk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdW5kKVxuICAgICAgICAgICAgICAgICAgICBEZWNscyQxLkdSb290Lmluc3QucGxheU9uZVNob3RTb3VuZChzb3VuZCwgdGhpcy4kc291bmRWb2x1bWVTY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLiRjaGFuZ2VTdGF0ZU9uQ2xpY2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLiRtb2RlID09IDEgLyogQ2hlY2sgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSAhdGhpcy4kc2VsZWN0ZWQ7XG4gICAgICAgICAgICBsZXQgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX19zdGF0ZUNoYW5nZWRcIiAvKiBDSEFOR0VEICovLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICBldnQuZGF0YSA9IHsgc2VsZWN0ZWQ6IHRoaXMuc2VsZWN0ZWQgfTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJG1vZGUgPT0gMiAvKiBSYWRpbyAqLykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiRzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJfX3N0YXRlQ2hhbmdlZFwiIC8qIENIQU5HRUQgKi8sIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBldnQuZGF0YSA9IHsgc2VsZWN0ZWQ6IHRoaXMuc2VsZWN0ZWQgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBHVGltZXIuaW5zdC5yZW1vdmUodGhpcy5zZXRTdGF0ZSwgdGhpcyk7XG4gICAgICAgIEdUaW1lci5pbnN0LnJlbW92ZSh0aGlzLnNldFN0YXRlLCB0aGlzKTtcbiAgICAgICAgRGVjbHMkMS5HUm9vdC5pbnN0Lm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5VcCwgdGhpcy4kbW91c2V1cCk7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG59XG5HQnV0dG9uLlVQID0gJ3VwJztcbkdCdXR0b24uRE9XTiA9ICdkb3duJztcbkdCdXR0b24uT1ZFUiA9ICdvdmVyJztcbkdCdXR0b24uU0VMRUNURURfT1ZFUiA9ICdzZWxlY3RlZE92ZXInO1xuR0J1dHRvbi5ESVNBQkxFRCA9ICdkaXNhYmxlZCc7XG5HQnV0dG9uLlNFTEVDVEVEX0RJU0FCTEVEID0gJ3NlbGVjdGVkRGlzYWJsZWQnO1xuXG5jbGFzcyBHQ29tYm9Cb3ggZXh0ZW5kcyBHQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4kdmlzaWJsZUl0ZW1Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuJHNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgICB0aGlzLiRwb3B1cERpciA9IDEgLyogRG93biAqLztcbiAgICAgICAgdGhpcy4kdmlzaWJsZUl0ZW1Db3VudCA9IFVJQ29uZmlnLmRlZmF1bHRDb21ib0JveFZpc2libGVJdGVtQ291bnQ7XG4gICAgICAgIHRoaXMuJGl0ZW1zVXBkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuJHNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy4kaXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy4kdmFsdWVzID0gW107XG4gICAgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICBpZiAodGhpcy4kdGl0bGVPYmplY3QpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kdGl0bGVPYmplY3QudGV4dDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNldCB0ZXh0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiR0aXRsZU9iamVjdClcbiAgICAgICAgICAgIHRoaXMuJHRpdGxlT2JqZWN0LnRleHQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVHZWFyKDYgLyogVGV4dCAqLyk7XG4gICAgfVxuICAgIGdldCBpY29uKCkge1xuICAgICAgICBpZiAodGhpcy4kaWNvbk9iamVjdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRpY29uT2JqZWN0Lmljb247XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXQgaWNvbih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kaWNvbk9iamVjdClcbiAgICAgICAgICAgIHRoaXMuJGljb25PYmplY3QuaWNvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUdlYXIoNyAvKiBJY29uICovKTtcbiAgICB9XG4gICAgZ2V0IHRpdGxlQ29sb3IoKSB7XG4gICAgICAgIGlmIChpc0NvbG9yYWJsZVRpdGxlKHRoaXMuJHRpdGxlT2JqZWN0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiR0aXRsZU9iamVjdC50aXRsZUNvbG9yO1xuICAgICAgICAvLyByZXR1cm4gMDtcbiAgICB9XG4gICAgc2V0IHRpdGxlQ29sb3IodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQ29sb3JhYmxlVGl0bGUodGhpcy4kdGl0bGVPYmplY3QpKVxuICAgICAgICAgICAgdGhpcy4kdGl0bGVPYmplY3QudGl0bGVDb2xvciA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdmlzaWJsZUl0ZW1Db3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHZpc2libGVJdGVtQ291bnQ7XG4gICAgfVxuICAgIHNldCB2aXNpYmxlSXRlbUNvdW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJHZpc2libGVJdGVtQ291bnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHBvcHVwRGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcG9wdXBEaXI7XG4gICAgfVxuICAgIHNldCBwb3B1cERpcmVjdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLiRwb3B1cERpciA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRpdGVtcztcbiAgICB9XG4gICAgc2V0IGl0ZW1zKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICB0aGlzLiRpdGVtcy5sZW5ndGggPSAwO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRpdGVtcyA9IHZhbHVlLmNvbmNhdCgpO1xuICAgICAgICBpZiAodGhpcy4kaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNlbGVjdGVkSW5kZXggPj0gdGhpcy4kaXRlbXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMuJHNlbGVjdGVkSW5kZXggPSB0aGlzLiRpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4kc2VsZWN0ZWRJbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLiRzZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRoaXMuJGl0ZW1zW3RoaXMuJHNlbGVjdGVkSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGljb25zICE9IG51bGwgJiYgdGhpcy4kc2VsZWN0ZWRJbmRleCA8IHRoaXMuJGljb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLmljb24gPSB0aGlzLiRpY29uc1t0aGlzLiRzZWxlY3RlZEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGljb25zICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5pY29uID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJHNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRpdGVtc1VwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgaWNvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRpY29ucztcbiAgICB9XG4gICAgc2V0IGljb25zKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJGljb25zID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLiRpY29ucyAhPSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLiRzZWxlY3RlZEluZGV4ICE9IC0xICYmXG4gICAgICAgICAgICB0aGlzLiRzZWxlY3RlZEluZGV4IDwgdGhpcy4kaWNvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5pY29uID0gdGhpcy4kaWNvbnNbdGhpcy4kc2VsZWN0ZWRJbmRleF07XG4gICAgfVxuICAgIGdldCB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR2YWx1ZXM7XG4gICAgfVxuICAgIHNldCB2YWx1ZXModmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgIHRoaXMuJHZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiR2YWx1ZXMgPSB2YWx1ZS5jb25jYXQoKTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzZWxlY3RlZEluZGV4O1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWRJbmRleCh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuJHNlbGVjdGVkSW5kZXggPT0gdmFsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRzZWxlY3RlZEluZGV4ID0gdmFsO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID49IDAgJiYgdGhpcy5zZWxlY3RlZEluZGV4IDwgdGhpcy4kaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLiRpdGVtc1t0aGlzLiRzZWxlY3RlZEluZGV4XTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRpY29ucyAhPSBudWxsICYmIHRoaXMuJHNlbGVjdGVkSW5kZXggPCB0aGlzLiRpY29ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5pY29uID0gdGhpcy4kaWNvbnNbdGhpcy4kc2VsZWN0ZWRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLiRpY29ucyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuaWNvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdmFsdWVzW3RoaXMuJHNlbGVjdGVkSW5kZXhdO1xuICAgIH1cbiAgICBzZXQgdmFsdWUodmFsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMuJHZhbHVlcy5pbmRleE9mKHZhbCk7XG4gICAgfVxuICAgIHNldFN0YXRlKHZhbCkge1xuICAgICAgICBpZiAodGhpcy4kYnV0dG9uQ29udHJvbGxlcilcbiAgICAgICAgICAgIHRoaXMuJGJ1dHRvbkNvbnRyb2xsZXIuc2VsZWN0ZWRQYWdlID0gdmFsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RGcm9tWE1MKHhtbCkge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3RGcm9tWE1MKHhtbCk7XG4gICAgICAgIHhtbCA9IFhtbFBhcnNlci5nZXRDaGlsZE5vZGVzKHhtbCwgJ0NvbWJvQm94JylbMF07XG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIHRoaXMuJGJ1dHRvbkNvbnRyb2xsZXIgPSB0aGlzLmdldENvbnRyb2xsZXIoJ2J1dHRvbicpO1xuICAgICAgICB0aGlzLiR0aXRsZU9iamVjdCA9IHRoaXMuZ2V0Q2hpbGQoJ3RpdGxlJyk7XG4gICAgICAgIHRoaXMuJGljb25PYmplY3QgPSB0aGlzLmdldENoaWxkKCdpY29uJyk7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmRyb3Bkb3duO1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICB0aGlzLiRkcm9wZG93biA9IFVJUGFja2FnZS5jcmVhdGVPYmplY3RGcm9tVVJMKHN0cik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJGRyb3Bkb3duKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRoZSAnZHJvcGRvd24nIGlzIG5vdCBzcGVjaWZpZWQsIGl0IG11c3QgYmUgYSBjb21wb25lbnQgZGVmaW5pZWQgaW4gdGhlIHBhY2thZ2UgcG9vbFwiKTtcbiAgICAgICAgICAgIHRoaXMuJGRyb3Bkb3duLm5hbWUgPSAndGhpcy5kcm9wZG93bic7XG4gICAgICAgICAgICB0aGlzLiRsaXN0ID0gdGhpcy4kZHJvcGRvd24uZ2V0Q2hpbGQoJ2xpc3QnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRsaXN0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMucmVzb3VyY2VVUkx9OiB0aGUgZHJvcGRvd24gY29tcG9uZW50IG11c3QgaGF2ZSBhIEdMaXN0IGNoaWxkIGFuZCBuYW1lZCAnbGlzdCcuYCk7XG4gICAgICAgICAgICB0aGlzLiRsaXN0Lm9uKFwiX19pdGVtQ2xpY2tcIiAvKiBJdGVtQ2xpY2sgKi8sIHRoaXMuJGNsaWNrSXRlbSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLiRsaXN0LmFkZFJlbGF0aW9uKHRoaXMuJGRyb3Bkb3duLCAxNCAvKiBXaWR0aCAqLyk7XG4gICAgICAgICAgICB0aGlzLiRsaXN0LnJlbW92ZVJlbGF0aW9uKHRoaXMuJGRyb3Bkb3duLCAxNSAvKiBIZWlnaHQgKi8pO1xuICAgICAgICAgICAgdGhpcy4kZHJvcGRvd24uYWRkUmVsYXRpb24odGhpcy4kbGlzdCwgMTUgLyogSGVpZ2h0ICovKTtcbiAgICAgICAgICAgIHRoaXMuJGRyb3Bkb3duLnJlbW92ZVJlbGF0aW9uKHRoaXMuJGxpc3QsIDE0IC8qIFdpZHRoICovKTtcbiAgICAgICAgICAgIHRoaXMuJGRyb3Bkb3duLm9uKCdyZW1vdmVkJywgdGhpcy4kcG9wdXBXaW5DbG9zZWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNNb2JpbGUuYW55KSB7XG4gICAgICAgICAgICB0aGlzLm9uKEludGVyYWN0aXZlRXZlbnRzLk92ZXIsIHRoaXMuJHJvbGxvdmVyLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub24oSW50ZXJhY3RpdmVFdmVudHMuT3V0LCB0aGlzLiRyb2xsb3V0LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uKEludGVyYWN0aXZlRXZlbnRzLkRvd24sIHRoaXMuJG1vdXNlZG93biwgdGhpcyk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIEdUaW1lci5pbnN0LnJlbW92ZSh0aGlzLmRlbGF5ZWRDbGlja0l0ZW0sIHRoaXMpO1xuICAgICAgICB0aGlzLiRsaXN0Lm9mZihcIl9faXRlbUNsaWNrXCIgLyogSXRlbUNsaWNrICovLCB0aGlzLiRjbGlja0l0ZW0pO1xuICAgICAgICB0aGlzLiRkcm9wZG93bi5vZmYoJ3JlbW92ZWQnLCB0aGlzLiRwb3B1cFdpbkNsb3NlZCk7XG4gICAgICAgIEdSb290Lmluc3QubmF0aXZlU3RhZ2Uub2ZmKEludGVyYWN0aXZlRXZlbnRzLlVwLCB0aGlzLiRtb3VzZVVwRXZlbnQpO1xuICAgICAgICB0aGlzLiRwb3B1cFdpbkNsb3NlZChudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuJGRyb3Bkb3duKSB7XG4gICAgICAgICAgICB0aGlzLiRkcm9wZG93bi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLiRkcm9wZG93biA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBzZXR1cEFmdGVyQWRkKHhtbCkge1xuICAgICAgICBzdXBlci5zZXR1cEFmdGVyQWRkKHhtbCk7XG4gICAgICAgIHhtbCA9IFhtbFBhcnNlci5nZXRDaGlsZE5vZGVzKHhtbCwgJ0NvbWJvQm94JylbMF07XG4gICAgICAgIGlmICh4bWwpIHtcbiAgICAgICAgICAgIGxldCBzdHI7XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy50aXRsZUNvbG9yO1xuICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRpdGxlQ29sb3IgPSBzdHI7XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy52aXNpYmxlSXRlbUNvdW50O1xuICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICB0aGlzLiR2aXNpYmxlSXRlbUNvdW50ID0gcGFyc2VJbnQoc3RyKTtcbiAgICAgICAgICAgIGxldCBjb2wgPSB4bWwuY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAoY29sKSB7XG4gICAgICAgICAgICAgICAgY29sLmZvckVhY2goKHgsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgubm9kZU5hbWUgPT0gJ2l0ZW0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5wdXNoKHguYXR0cmlidXRlcy50aXRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiR2YWx1ZXMucHVzaCh4LmF0dHJpYnV0ZXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0geC5hdHRyaWJ1dGVzLmljb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLiRpY29ucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kaWNvbnMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRpY29uc1tpXSA9IHN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMudGl0bGU7XG4gICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gc3RyO1xuICAgICAgICAgICAgICAgIHRoaXMuJHNlbGVjdGVkSW5kZXggPSB0aGlzLiRpdGVtcy5pbmRleE9mKHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy4kaXRlbXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy4kc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuaWNvbjtcbiAgICAgICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICAgICAgdGhpcy5pY29uID0gc3RyO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuZGlyZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gJ3VwJylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcG9wdXBEaXIgPSAyIC8qIFVwICovO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0ciA9PSAnYXV0bycpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHBvcHVwRGlyID0gMCAvKiBBdXRvICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNob3dEcm9wZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuJGl0ZW1zVXBkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy4kaXRlbXNVcGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRsaXN0LnJlbW92ZUNoaWxkcmVuVG9Qb29sKCk7XG4gICAgICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKChvLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLiRsaXN0LmFkZEl0ZW1Gcm9tUG9vbCgpO1xuICAgICAgICAgICAgICAgIGl0ZW0ubmFtZSA9IGkgPCB0aGlzLiR2YWx1ZXMubGVuZ3RoID8gdGhpcy4kdmFsdWVzW2ldIDogJyc7XG4gICAgICAgICAgICAgICAgaXRlbS50ZXh0ID0gdGhpcy4kaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgaXRlbS5pY29uID0gdGhpcy4kaWNvbnMgIT0gbnVsbCAmJiBpIDwgdGhpcy4kaWNvbnMubGVuZ3RoID8gdGhpcy4kaWNvbnNbaV0gOiBudWxsO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLiRsaXN0LnJlc2l6ZVRvRml0KHRoaXMuJHZpc2libGVJdGVtQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGxpc3Quc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLiRkcm9wZG93bi53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIEdSb290LmZpbmRGb3IodGhpcykudG9nZ2xlUG9wdXAodGhpcy4kZHJvcGRvd24sIHRoaXMsIHRoaXMuJHBvcHVwRGlyKTtcbiAgICAgICAgaWYgKHRoaXMuJGRyb3Bkb3duLnBhcmVudClcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoR0J1dHRvbi5ET1dOKTtcbiAgICB9XG4gICAgJHBvcHVwV2luQ2xvc2VkKGV2dCkge1xuICAgICAgICBpZiAodGhpcy4kb3ZlcilcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoR0J1dHRvbi5PVkVSKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShHQnV0dG9uLlVQKTtcbiAgICB9XG4gICAgJGNsaWNrSXRlbShldnQpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSBldnQuZGF0YS5pdGVtO1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLiRsaXN0LmdldENoaWxkSW5kZXgoaXRlbSk7XG4gICAgICAgIEdUaW1lci5pbnN0LmFkZCgxMDAsIDEsIHRoaXMuZGVsYXllZENsaWNrSXRlbSwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBkZWxheWVkQ2xpY2tJdGVtKGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLiRkcm9wZG93bi5wYXJlbnQgaW5zdGFuY2VvZiBHUm9vdClcbiAgICAgICAgICAgIHRoaXMuJGRyb3Bkb3duLnBhcmVudC5oaWRlUG9wdXAoKTtcbiAgICAgICAgdGhpcy4kc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAodGhpcy4kc2VsZWN0ZWRJbmRleCA+PSAwKVxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy4kaXRlbXNbdGhpcy4kc2VsZWN0ZWRJbmRleF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudGV4dCA9ICcnO1xuICAgICAgICBsZXQgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiX19zdGF0ZUNoYW5nZWRcIiAvKiBDSEFOR0VEICovLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGV2dC5kYXRhID0geyBzZWxlY3RlZEluZGV4OiB0aGlzLiRzZWxlY3RlZEluZGV4IH07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQsIHRoaXMpO1xuICAgIH1cbiAgICAkcm9sbG92ZXIoZXZ0KSB7XG4gICAgICAgIHRoaXMuJG92ZXIgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy4kZG93biB8fCAodGhpcy4kZHJvcGRvd24gJiYgdGhpcy4kZHJvcGRvd24ucGFyZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShHQnV0dG9uLk9WRVIpO1xuICAgIH1cbiAgICAkcm9sbG91dChldnQpIHtcbiAgICAgICAgdGhpcy4kb3ZlciA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4kZG93biB8fCAodGhpcy4kZHJvcGRvd24gJiYgdGhpcy4kZHJvcGRvd24ucGFyZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShHQnV0dG9uLlVQKTtcbiAgICB9XG4gICAgJG1vdXNlZG93bihldnQpIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBHUm9vdC5pbnN0LmNoZWNrUG9wdXBzKGV2dC50YXJnZXQpO1xuICAgICAgICB0aGlzLiRkb3duID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kbW91c2VVcEV2ZW50ID0gR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vbihJbnRlcmFjdGl2ZUV2ZW50cy5VcCwgdGhpcy4kbW91c2V1cCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLiRkcm9wZG93bilcbiAgICAgICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duKCk7XG4gICAgfVxuICAgICRtb3VzZXVwKGV2dCkge1xuICAgICAgICBpZiAodGhpcy4kZG93bikge1xuICAgICAgICAgICAgdGhpcy4kZG93biA9IGZhbHNlO1xuICAgICAgICAgICAgR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vZmYoSW50ZXJhY3RpdmVFdmVudHMuVXAsIHRoaXMuJG1vdXNlVXBFdmVudCk7XG4gICAgICAgICAgICBpZiAodGhpcy4kZHJvcGRvd24gJiYgIXRoaXMuJGRyb3Bkb3duLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRvdmVyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKEdCdXR0b24uT1ZFUik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKEdCdXR0b24uVVApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBHU2xpZGVyIGV4dGVuZHMgR0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuJG1heCA9IDA7XG4gICAgICAgIHRoaXMuJHZhbHVlID0gMDtcbiAgICAgICAgdGhpcy4kYmFyTWF4V2lkdGggPSAwO1xuICAgICAgICB0aGlzLiRiYXJNYXhIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLiRiYXJNYXhXaWR0aERlbHRhID0gMDtcbiAgICAgICAgdGhpcy4kYmFyTWF4SGVpZ2h0RGVsdGEgPSAwO1xuICAgICAgICB0aGlzLiR0aXRsZVR5cGUgPSAwIC8qIFBlcmNlbnQgKi87XG4gICAgICAgIHRoaXMuJHZhbHVlID0gNTA7XG4gICAgICAgIHRoaXMuJG1heCA9IDEwMDtcbiAgICAgICAgdGhpcy4kY2xpY2tQb3MgPSBuZXcgY3JlYXRlanMuUG9pbnQoKTtcbiAgICB9XG4gICAgZ2V0IHRpdGxlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHRpdGxlVHlwZTtcbiAgICB9XG4gICAgc2V0IHRpdGxlVHlwZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiR0aXRsZVR5cGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IG1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG1heDtcbiAgICB9XG4gICAgc2V0IG1heCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kbWF4ICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kdmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJHZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHBlcmNlbnQgPSBNYXRoLm1pbih0aGlzLiR2YWx1ZSAvIHRoaXMuJG1heCwgMSk7XG4gICAgICAgIHRoaXMudXBkYXRlV2lkdGhQZXJjZW50KHBlcmNlbnQpO1xuICAgIH1cbiAgICB1cGRhdGVXaWR0aFBlcmNlbnQocGVyY2VudCkge1xuICAgICAgICBpZiAodGhpcy4kdGl0bGVPYmplY3QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy4kdGl0bGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIFBlcmNlbnQgKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHRpdGxlT2JqZWN0LnRleHQgPSBgJHtNYXRoLnJvdW5kKHBlcmNlbnQgKiAxMDApfSVgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogVmFsdWVBbmRNYXggKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHRpdGxlT2JqZWN0LnRleHQgPSBgJHt0aGlzLiR2YWx1ZX0vJHt0aGlzLiRtYXh9YDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIFZhbHVlICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiR0aXRsZU9iamVjdC50ZXh0ID0gYCR7dGhpcy4kdmFsdWV9YDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIE1heCAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdGl0bGVPYmplY3QudGV4dCA9IGAke3RoaXMuJG1heH1gO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kYmFyT2JqZWN0SClcbiAgICAgICAgICAgIHRoaXMuJGJhck9iamVjdEgud2lkdGggPSAodGhpcy53aWR0aCAtIHRoaXMuJGJhck1heFdpZHRoRGVsdGEpICogcGVyY2VudDtcbiAgICAgICAgaWYgKHRoaXMuJGJhck9iamVjdFYpXG4gICAgICAgICAgICB0aGlzLiRiYXJPYmplY3RWLmhlaWdodCA9ICh0aGlzLmhlaWdodCAtIHRoaXMuJGJhck1heEhlaWdodERlbHRhKSAqIHBlcmNlbnQ7XG4gICAgICAgIGlmICh0aGlzLiRhbmlPYmplY3QgaW5zdGFuY2VvZiBHTW92aWVDbGlwKVxuICAgICAgICAgICAgdGhpcy4kYW5pT2JqZWN0LmZyYW1lID0gTWF0aC5yb3VuZChwZXJjZW50ICogMTAwKTtcbiAgICB9XG4gICAgaGFuZGxlU2l6ZUNoYW5nZWQoKSB7XG4gICAgICAgIHN1cGVyLmhhbmRsZVNpemVDaGFuZ2VkKCk7XG4gICAgICAgIGlmICh0aGlzLiRiYXJPYmplY3RIKVxuICAgICAgICAgICAgdGhpcy4kYmFyTWF4V2lkdGggPSB0aGlzLndpZHRoIC0gdGhpcy4kYmFyTWF4V2lkdGhEZWx0YTtcbiAgICAgICAgaWYgKHRoaXMuJGJhck9iamVjdFYpXG4gICAgICAgICAgICB0aGlzLiRiYXJNYXhIZWlnaHQgPSB0aGlzLmhlaWdodCAtIHRoaXMuJGJhck1heEhlaWdodERlbHRhO1xuICAgICAgICBpZiAoIXRoaXMuJGluUHJvZ3Jlc3NCdWlsZGluZylcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIHNldHVwQWZ0ZXJBZGQoeG1sKSB7XG4gICAgICAgIHN1cGVyLnNldHVwQWZ0ZXJBZGQoeG1sKTtcbiAgICAgICAgeG1sID0gWG1sUGFyc2VyLmdldENoaWxkTm9kZXMoeG1sLCAnU2xpZGVyJylbMF07XG4gICAgICAgIGlmICh4bWwpIHtcbiAgICAgICAgICAgIHRoaXMuJHZhbHVlID0gcGFyc2VJbnQoeG1sLmF0dHJpYnV0ZXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy4kbWF4ID0gcGFyc2VJbnQoeG1sLmF0dHJpYnV0ZXMubWF4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RGcm9tWE1MKHhtbCkge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3RGcm9tWE1MKHhtbCk7XG4gICAgICAgIHhtbCA9IFhtbFBhcnNlci5nZXRDaGlsZE5vZGVzKHhtbCwgJ1NsaWRlcicpWzBdO1xuICAgICAgICBsZXQgc3RyO1xuICAgICAgICBpZiAoeG1sKSB7XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy50aXRsZVR5cGU7XG4gICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgIHRoaXMuJHRpdGxlVHlwZSA9IFBhcnNlUHJvZ3Jlc3NUaXRsZVR5cGUoc3RyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR0aXRsZU9iamVjdCA9IHRoaXMuZ2V0Q2hpbGQoJ3RpdGxlJyk7XG4gICAgICAgIHRoaXMuJGJhck9iamVjdEggPSB0aGlzLmdldENoaWxkKCdiYXInKTtcbiAgICAgICAgdGhpcy4kYmFyT2JqZWN0ViA9IHRoaXMuZ2V0Q2hpbGQoJ2Jhcl92Jyk7XG4gICAgICAgIHRoaXMuJGFuaU9iamVjdCA9IHRoaXMuZ2V0Q2hpbGQoJ2FuaScpO1xuICAgICAgICB0aGlzLiRncmlwT2JqZWN0ID0gdGhpcy5nZXRDaGlsZCgnZ3JpcCcpO1xuICAgICAgICBpZiAodGhpcy4kYmFyT2JqZWN0SCkge1xuICAgICAgICAgICAgdGhpcy4kYmFyTWF4V2lkdGggPSB0aGlzLiRiYXJPYmplY3RILndpZHRoO1xuICAgICAgICAgICAgdGhpcy4kYmFyTWF4V2lkdGhEZWx0YSA9IHRoaXMud2lkdGggLSB0aGlzLiRiYXJNYXhXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kYmFyT2JqZWN0Vikge1xuICAgICAgICAgICAgdGhpcy4kYmFyTWF4SGVpZ2h0ID0gdGhpcy4kYmFyT2JqZWN0Vi5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLiRiYXJNYXhIZWlnaHREZWx0YSA9IHRoaXMuaGVpZ2h0IC0gdGhpcy4kYmFyTWF4SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRncmlwT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy4kZ3JpcE9iamVjdC5vbihJbnRlcmFjdGl2ZUV2ZW50cy5Eb3duLCB0aGlzLiRncmlwTW91c2VEb3duLCB0aGlzKTtcbiAgICB9XG4gICAgJGdyaXBNb3VzZURvd24oZXZ0KSB7XG4gICAgICAgIHRoaXMuJGNsaWNrUG9zID0gdGhpcy5nbG9iYWxUb0xvY2FsKGV2dC5zdGFnZVgsIGV2dC5zdGFnZVkpO1xuICAgICAgICB0aGlzLiRjbGlja1BlcmNlbnQgPSB0aGlzLiR2YWx1ZSAvIHRoaXMuJG1heDtcbiAgICAgICAgdGhpcy4kbW91c2VNb3ZlRXZlbnQgPSBHUm9vdC5pbnN0Lm5hdGl2ZVN0YWdlLm9uKEludGVyYWN0aXZlRXZlbnRzLk1vdmUsIHRoaXMuJGdyaXBNb3VzZU1vdmUsIHRoaXMpO1xuICAgICAgICB0aGlzLiRtb3VzZVVwRXZlbnQgPSBHUm9vdC5pbnN0Lm5hdGl2ZVN0YWdlLm9uKEludGVyYWN0aXZlRXZlbnRzLlVwLCB0aGlzLiRncmlwTW91c2VVcCwgdGhpcyk7XG4gICAgfVxuICAgICRncmlwTW91c2VNb3ZlKGV2dCkge1xuICAgICAgICBsZXQgcHQgPSB0aGlzLmdsb2JhbFRvTG9jYWwoZXZ0LnN0YWdlWCwgZXZ0LnN0YWdlWSwgR1NsaWRlci5zU2lsZGVySGVscGVyUG9pbnQpO1xuICAgICAgICBsZXQgZGVsdGFYID0gcHQueCAtIHRoaXMuJGNsaWNrUG9zLng7XG4gICAgICAgIGxldCBkZWx0YVkgPSBwdC55IC0gdGhpcy4kY2xpY2tQb3MueTtcbiAgICAgICAgbGV0IHBlcmNlbnQ7XG4gICAgICAgIGlmICh0aGlzLiRiYXJPYmplY3RIKVxuICAgICAgICAgICAgcGVyY2VudCA9IHRoaXMuJGNsaWNrUGVyY2VudCArIGRlbHRhWCAvIHRoaXMuJGJhck1heFdpZHRoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwZXJjZW50ID0gdGhpcy4kY2xpY2tQZXJjZW50ICsgZGVsdGFZIC8gdGhpcy4kYmFyTWF4SGVpZ2h0O1xuICAgICAgICBpZiAocGVyY2VudCA+IDEpXG4gICAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgZWxzZSBpZiAocGVyY2VudCA8IDApXG4gICAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gTWF0aC5yb3VuZCh0aGlzLiRtYXggKiBwZXJjZW50KTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9IHRoaXMuJHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiR2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgbGV0IGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcIl9fc3RhdGVDaGFuZ2VkXCIgLyogQ0hBTkdFRCAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2dCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVXaWR0aFBlcmNlbnQocGVyY2VudCk7XG4gICAgfVxuICAgICRncmlwTW91c2VVcChldnQpIHtcbiAgICAgICAgbGV0IHBlcmNlbnQgPSB0aGlzLiR2YWx1ZSAvIHRoaXMuJG1heDtcbiAgICAgICAgdGhpcy51cGRhdGVXaWR0aFBlcmNlbnQocGVyY2VudCk7XG4gICAgICAgIEdSb290Lmluc3QubmF0aXZlU3RhZ2Uub2ZmKEludGVyYWN0aXZlRXZlbnRzLk1vdmUsIHRoaXMuJG1vdXNlTW92ZUV2ZW50KTtcbiAgICAgICAgR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vZmYoSW50ZXJhY3RpdmVFdmVudHMuVXAsIHRoaXMuJG1vdXNlVXBFdmVudCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLiRncmlwT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy4kZ3JpcE9iamVjdC5vZmYoSW50ZXJhY3RpdmVFdmVudHMuRG93biwgdGhpcy4kZ3JpcE1vdXNlRG93bik7XG4gICAgICAgIEdSb290Lmluc3QubmF0aXZlU3RhZ2Uub2ZmKEludGVyYWN0aXZlRXZlbnRzLk1vdmUsIHRoaXMuJG1vdXNlTW92ZUV2ZW50KTtcbiAgICAgICAgR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vZmYoSW50ZXJhY3RpdmVFdmVudHMuVXAsIHRoaXMuJG1vdXNlVXBFdmVudCk7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG59XG5HU2xpZGVyLnNTaWxkZXJIZWxwZXJQb2ludCA9IG5ldyBjcmVhdGVqcy5Qb2ludCgpO1xuXG5jbGFzcyBHUHJvZ3Jlc3NCYXIgZXh0ZW5kcyBHQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4kbWF4ID0gMDtcbiAgICAgICAgdGhpcy4kdmFsdWUgPSAwO1xuICAgICAgICB0aGlzLiRiYXJNYXhXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuJGJhck1heEhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuJGJhck1heFdpZHRoRGVsdGEgPSAwO1xuICAgICAgICB0aGlzLiRiYXJNYXhIZWlnaHREZWx0YSA9IDA7XG4gICAgICAgIHRoaXMuJGJhclN0YXJ0WCA9IDA7XG4gICAgICAgIHRoaXMuJGJhclN0YXJ0WSA9IDA7XG4gICAgICAgIHRoaXMuJHR3ZWVuVmFsdWUgPSAwO1xuICAgICAgICB0aGlzLiR0aXRsZVR5cGUgPSAwIC8qIFBlcmNlbnQgKi87XG4gICAgICAgIHRoaXMuJHZhbHVlID0gNTA7XG4gICAgICAgIHRoaXMuJG1heCA9IDEwMDtcbiAgICB9XG4gICAgZ2V0IHRpdGxlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHRpdGxlVHlwZTtcbiAgICB9XG4gICAgc2V0IHRpdGxlVHlwZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kdGl0bGVUeXBlICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiR0aXRsZVR5cGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMuJHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kbWF4O1xuICAgIH1cbiAgICBzZXQgbWF4KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRtYXggIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy4kdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJHR3ZWVuZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4kdHdlZW5lci5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kdHdlZW5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJHZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiR2YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy4kdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHR3ZWVuVmFsdWUodmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLiR2YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHR3ZWVuZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR0d2VlbmVyLnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy4kdHdlZW5lci5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZWpzLlR3ZWVuLnJlbW92ZVR3ZWVucyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHR3ZWVuVmFsdWUgPSB0aGlzLiR2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuJHZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLiR0d2VlbmVyID0gY3JlYXRlanMuVHdlZW4uZ2V0KHRoaXMsIHtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogQmluZGVyLmNyZWF0ZSh0aGlzLm9uVXBkYXRlVHdlZW4sIHRoaXMpXG4gICAgICAgICAgICB9KS50byh7ICR0d2VlblZhbHVlOiB2YWx1ZSB9LCBkdXJhdGlvbiAqIDEwMDAsIEdQcm9ncmVzc0Jhci5lYXNlTGluZWFyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiR0d2VlbmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBvblVwZGF0ZVR3ZWVuKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLiR0d2VlblZhbHVlKTtcbiAgICB9XG4gICAgdXBkYXRlKHZhbCkge1xuICAgICAgICBsZXQgcGVyY2VudCA9IHRoaXMuJG1heCAhPSAwID8gTWF0aC5taW4odmFsIC8gdGhpcy4kbWF4LCAxKSA6IDA7XG4gICAgICAgIGlmICh0aGlzLiR0aXRsZU9iamVjdCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLiR0aXRsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogUGVyY2VudCAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdGl0bGVPYmplY3QudGV4dCA9IGAke01hdGgucm91bmQocGVyY2VudCAqIDEwMCl9JWA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBWYWx1ZUFuZE1heCAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdGl0bGVPYmplY3QudGV4dCA9IGAke01hdGgucm91bmQodmFsKX0vJHtNYXRoLnJvdW5kKHRoaXMuJG1heCl9YDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIFZhbHVlICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiR0aXRsZU9iamVjdC50ZXh0ID0gYCR7TWF0aC5yb3VuZCh2YWwpfWA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBNYXggKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHRpdGxlT2JqZWN0LnRleHQgPSBgJHtNYXRoLnJvdW5kKHRoaXMuJG1heCl9YDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bGxXaWR0aCA9IHRoaXMud2lkdGggLSB0aGlzLiRiYXJNYXhXaWR0aERlbHRhO1xuICAgICAgICBsZXQgZnVsbEhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gdGhpcy4kYmFyTWF4SGVpZ2h0RGVsdGE7XG4gICAgICAgIGlmICghdGhpcy4kcmV2ZXJzZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGJhck9iamVjdEgpXG4gICAgICAgICAgICAgICAgdGhpcy4kYmFyT2JqZWN0SC53aWR0aCA9IGZ1bGxXaWR0aCAqIHBlcmNlbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy4kYmFyT2JqZWN0VilcbiAgICAgICAgICAgICAgICB0aGlzLiRiYXJPYmplY3RWLmhlaWdodCA9IGZ1bGxIZWlnaHQgKiBwZXJjZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGJhck9iamVjdEgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRiYXJPYmplY3RILndpZHRoID0gZnVsbFdpZHRoICogcGVyY2VudDtcbiAgICAgICAgICAgICAgICB0aGlzLiRiYXJPYmplY3RILnggPSB0aGlzLiRiYXJTdGFydFggKyAoZnVsbFdpZHRoIC0gdGhpcy4kYmFyT2JqZWN0SC53aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kYmFyT2JqZWN0Vikge1xuICAgICAgICAgICAgICAgIHRoaXMuJGJhck9iamVjdFYuaGVpZ2h0ID0gZnVsbEhlaWdodCAqIHBlcmNlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy4kYmFyT2JqZWN0Vi55ID0gdGhpcy4kYmFyU3RhcnRZICsgKGZ1bGxIZWlnaHQgLSB0aGlzLiRiYXJPYmplY3RWLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGFuaU9iamVjdCBpbnN0YW5jZW9mIEdNb3ZpZUNsaXApXG4gICAgICAgICAgICB0aGlzLiRhbmlPYmplY3QuZnJhbWUgPSBNYXRoLnJvdW5kKHBlcmNlbnQgKiAxMDApO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RGcm9tWE1MKHhtbCkge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3RGcm9tWE1MKHhtbCk7XG4gICAgICAgIHhtbCA9IFhtbFBhcnNlci5nZXRDaGlsZE5vZGVzKHhtbCwgJ1Byb2dyZXNzQmFyJylbMF07XG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnRpdGxlVHlwZTtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuJHRpdGxlVHlwZSA9IFBhcnNlUHJvZ3Jlc3NUaXRsZVR5cGUoc3RyKTtcbiAgICAgICAgdGhpcy4kcmV2ZXJzZSA9IHhtbC5hdHRyaWJ1dGVzLnJldmVyc2UgPT0gJ3RydWUnO1xuICAgICAgICB0aGlzLiR0aXRsZU9iamVjdCA9IHRoaXMuZ2V0Q2hpbGQoJ3RpdGxlJyk7XG4gICAgICAgIHRoaXMuJGJhck9iamVjdEggPSB0aGlzLmdldENoaWxkKCdiYXInKTtcbiAgICAgICAgdGhpcy4kYmFyT2JqZWN0ViA9IHRoaXMuZ2V0Q2hpbGQoJ2Jhcl92Jyk7XG4gICAgICAgIHRoaXMuJGFuaU9iamVjdCA9IHRoaXMuZ2V0Q2hpbGQoJ2FuaScpO1xuICAgICAgICBpZiAodGhpcy4kYmFyT2JqZWN0SCkge1xuICAgICAgICAgICAgdGhpcy4kYmFyTWF4V2lkdGggPSB0aGlzLiRiYXJPYmplY3RILndpZHRoO1xuICAgICAgICAgICAgdGhpcy4kYmFyTWF4V2lkdGhEZWx0YSA9IHRoaXMud2lkdGggLSB0aGlzLiRiYXJNYXhXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuJGJhclN0YXJ0WCA9IHRoaXMuJGJhck9iamVjdEgueDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kYmFyT2JqZWN0Vikge1xuICAgICAgICAgICAgdGhpcy4kYmFyTWF4SGVpZ2h0ID0gdGhpcy4kYmFyT2JqZWN0Vi5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLiRiYXJNYXhIZWlnaHREZWx0YSA9IHRoaXMuaGVpZ2h0IC0gdGhpcy4kYmFyTWF4SGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy4kYmFyU3RhcnRZID0gdGhpcy4kYmFyT2JqZWN0Vi55O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVNpemVDaGFuZ2VkKCkge1xuICAgICAgICBzdXBlci5oYW5kbGVTaXplQ2hhbmdlZCgpO1xuICAgICAgICBpZiAodGhpcy4kYmFyT2JqZWN0SClcbiAgICAgICAgICAgIHRoaXMuJGJhck1heFdpZHRoID0gdGhpcy53aWR0aCAtIHRoaXMuJGJhck1heFdpZHRoRGVsdGE7XG4gICAgICAgIGlmICh0aGlzLiRiYXJPYmplY3RWKVxuICAgICAgICAgICAgdGhpcy4kYmFyTWF4SGVpZ2h0ID0gdGhpcy5oZWlnaHQgLSB0aGlzLiRiYXJNYXhIZWlnaHREZWx0YTtcbiAgICAgICAgaWYgKCF0aGlzLiRpblByb2dyZXNzQnVpbGRpbmcpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLiR2YWx1ZSk7XG4gICAgfVxuICAgIHNldHVwQWZ0ZXJBZGQoeG1sKSB7XG4gICAgICAgIHN1cGVyLnNldHVwQWZ0ZXJBZGQoeG1sKTtcbiAgICAgICAgeG1sID0gWG1sUGFyc2VyLmdldENoaWxkTm9kZXMoeG1sLCAnUHJvZ3Jlc3NCYXInKVswXTtcbiAgICAgICAgaWYgKHhtbCkge1xuICAgICAgICAgICAgdGhpcy4kdmFsdWUgPSBwYXJzZUludCh4bWwuYXR0cmlidXRlcy52YWx1ZSkgfHwgMDtcbiAgICAgICAgICAgIHRoaXMuJG1heCA9IHBhcnNlSW50KHhtbC5hdHRyaWJ1dGVzLm1heCkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLiR2YWx1ZSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLiR0d2VlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLiR0d2VlbmVyLnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiR0d2VlbmVyLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlanMuVHdlZW4ucmVtb3ZlVHdlZW5zKHRoaXMpO1xuICAgICAgICB0aGlzLiR0d2VlbmVyID0gbnVsbDtcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbn1cbkdQcm9ncmVzc0Jhci5lYXNlTGluZWFyID0gUGFyc2VFYXNlVHlwZSgnbGluZWFyJyk7IC8vIGNyZWF0ZWpzLkVhc2UuZ2V0UG93SW4oMSk7XG5cbmNsYXNzIEdTY3JvbGxCYXIgZXh0ZW5kcyBHQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4kZHJhZ09mZnNldCA9IG5ldyBjcmVhdGVqcy5Qb2ludCgpO1xuICAgICAgICB0aGlzLiRzY3JvbGxQZXJjID0gMDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsUGFuZSh0YXJnZXQsIHZlcnRpY2FsKSB7XG4gICAgICAgIHRoaXMuJHRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy4kdmVydGljYWwgPSB2ZXJ0aWNhbDtcbiAgICB9XG4gICAgc2V0IGRpc3BsYXlQZXJjKHZhbCkge1xuICAgICAgICBpZiAodGhpcy4kdmVydGljYWwpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kZml4ZWRHcmlwU2l6ZSlcbiAgICAgICAgICAgICAgICB0aGlzLiRncmlwLmhlaWdodCA9IHZhbCAqIHRoaXMuJGJhci5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLiRncmlwLnkgPSB0aGlzLiRiYXIueSArICh0aGlzLiRiYXIuaGVpZ2h0IC0gdGhpcy4kZ3JpcC5oZWlnaHQpICogdGhpcy4kc2Nyb2xsUGVyYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kZml4ZWRHcmlwU2l6ZSlcbiAgICAgICAgICAgICAgICB0aGlzLiRncmlwLndpZHRoID0gdmFsICogdGhpcy4kYmFyLndpZHRoO1xuICAgICAgICAgICAgdGhpcy4kZ3JpcC54ID0gdGhpcy4kYmFyLnggKyAodGhpcy4kYmFyLndpZHRoIC0gdGhpcy4kZ3JpcC53aWR0aCkgKiB0aGlzLiRzY3JvbGxQZXJjO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzY3JvbGxQZXJjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2Nyb2xsUGVyYztcbiAgICB9XG4gICAgc2V0IHNjcm9sbFBlcmModmFsKSB7XG4gICAgICAgIHRoaXMuJHNjcm9sbFBlcmMgPSB2YWw7XG4gICAgICAgIGlmICh0aGlzLiR2ZXJ0aWNhbClcbiAgICAgICAgICAgIHRoaXMuJGdyaXAueSA9IHRoaXMuJGJhci55ICsgKHRoaXMuJGJhci5oZWlnaHQgLSB0aGlzLiRncmlwLmhlaWdodCkgKiB0aGlzLiRzY3JvbGxQZXJjO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRncmlwLnggPSB0aGlzLiRiYXIueCArICh0aGlzLiRiYXIud2lkdGggLSB0aGlzLiRncmlwLndpZHRoKSAqIHRoaXMuJHNjcm9sbFBlcmM7XG4gICAgfVxuICAgIGdldCBtaW5TaXplKCkge1xuICAgICAgICBpZiAodGhpcy4kdmVydGljYWwpXG4gICAgICAgICAgICByZXR1cm4gKCh0aGlzLiRhcnJvd0J1dHRvbjEgIT0gbnVsbCA/IHRoaXMuJGFycm93QnV0dG9uMS5oZWlnaHQgOiAwKSArXG4gICAgICAgICAgICAgICAgKHRoaXMuJGFycm93QnV0dG9uMiAhPSBudWxsID8gdGhpcy4kYXJyb3dCdXR0b24yLmhlaWdodCA6IDApKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICgodGhpcy4kYXJyb3dCdXR0b24xICE9IG51bGwgPyB0aGlzLiRhcnJvd0J1dHRvbjEud2lkdGggOiAwKSArXG4gICAgICAgICAgICAgICAgKHRoaXMuJGFycm93QnV0dG9uMiAhPSBudWxsID8gdGhpcy4kYXJyb3dCdXR0b24yLndpZHRoIDogMCkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RGcm9tWE1MKHhtbCkge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3RGcm9tWE1MKHhtbCk7XG4gICAgICAgIHhtbCA9IFhtbFBhcnNlci5nZXRDaGlsZE5vZGVzKHhtbCwgJ1Njcm9sbEJhcicpWzBdO1xuICAgICAgICBpZiAoeG1sICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLiRmaXhlZEdyaXBTaXplID0geG1sLmF0dHJpYnV0ZXMuZml4ZWRHcmlwU2l6ZSA9PSAndHJ1ZSc7XG4gICAgICAgIHRoaXMuJGdyaXAgPSB0aGlzLmdldENoaWxkKCdncmlwJyk7XG4gICAgICAgIGlmICghdGhpcy4kZ3JpcCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInBsZWFzZSBjcmVhdGUgYW5kIGRlZmluZSAnZ3JpcCcgaW4gdGhlIEVkaXRvciBmb3IgdGhlIHNjcm9sbGJhclwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRiYXIgPSB0aGlzLmdldENoaWxkKCdiYXInKTtcbiAgICAgICAgaWYgKCF0aGlzLiRiYXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJwbGVhc2UgY3JlYXRlIGFuZCBkZWZpbmUgJ2JhcicgaW4gdGhlIEVkaXRvciBmb3IgdGhlIHNjcm9sbGJhclwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRhcnJvd0J1dHRvbjEgPSB0aGlzLmdldENoaWxkKCdhcnJvdzEnKTtcbiAgICAgICAgdGhpcy4kYXJyb3dCdXR0b24yID0gdGhpcy5nZXRDaGlsZCgnYXJyb3cyJyk7XG4gICAgICAgIHRoaXMuJGdyaXAub24oSW50ZXJhY3RpdmVFdmVudHMuRG93biwgdGhpcy4kZ3JpcE1vdXNlRG93biwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLiRhcnJvd0J1dHRvbjEpXG4gICAgICAgICAgICB0aGlzLiRhcnJvd0J1dHRvbjEub24oSW50ZXJhY3RpdmVFdmVudHMuRG93biwgdGhpcy4kYXJyb3dCdXR0b24xQ2xpY2ssIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy4kYXJyb3dCdXR0b24yKVxuICAgICAgICAgICAgdGhpcy4kYXJyb3dCdXR0b24yLm9uKEludGVyYWN0aXZlRXZlbnRzLkRvd24sIHRoaXMuJGFycm93QnV0dG9uMkNsaWNrLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbihJbnRlcmFjdGl2ZUV2ZW50cy5Eb3duLCB0aGlzLiRiYXJNb3VzZURvd24sIHRoaXMpO1xuICAgIH1cbiAgICAkZ3JpcE1vdXNlRG93bihldnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRiYXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gdGhpcy4kZHJhZ09mZnNldCA9IGV2dC5kYXRhLmdldExvY2FsUG9zaXRpb24odGhpcy5kaXNwbGF5T2JqZWN0LCB0aGlzLiRkcmFnT2Zmc2V0KTtcbiAgICAgICAgdGhpcy4kZHJhZ09mZnNldCA9IG5ldyBjcmVhdGVqcy5Qb2ludChldnQubG9jYWxYLCBldnQubG9jYWxZKTtcbiAgICAgICAgdGhpcy4kZHJhZ09mZnNldC54IC09IHRoaXMuJGdyaXAueDtcbiAgICAgICAgdGhpcy4kZHJhZ09mZnNldC55IC09IHRoaXMuJGdyaXAueTtcbiAgICAgICAgdGhpcy4kbW91c2VNb3ZlRXZlbnQgPSBHUm9vdC5pbnN0Lm5hdGl2ZVN0YWdlLm9uKEludGVyYWN0aXZlRXZlbnRzLk1vdmUsIHRoaXMuJGdyaXBEcmFnZ2luZywgdGhpcyk7XG4gICAgICAgIHRoaXMuJG1vdXNlVXBFdmVudCA9IEdSb290Lmluc3QubmF0aXZlU3RhZ2Uub24oSW50ZXJhY3RpdmVFdmVudHMuVXAsIHRoaXMuJGdyaXBEcmFnZ2luZ0VuZCwgdGhpcyk7XG4gICAgfVxuICAgICRncmlwRHJhZ2dpbmcoZXZ0KSB7XG4gICAgICAgIGxldCBwdCA9IGV2dC50YXJnZXQubG9jYWxUb0xvY2FsKGV2dC5sb2NhbFgsIGV2dC5sb2NhbFksIHRoaXMuJGRpc3BsYXlPYmplY3QpOyAvLyB0b2RvXG4gICAgICAgIGlmIChHU2Nyb2xsQmFyLnNTY3JvbGxiYXJIZWxwZXJQb2ludC54ID09IDAgJiYgR1Njcm9sbEJhci5zU2Nyb2xsYmFySGVscGVyUG9pbnQueSA9PSAwKSB7XG4gICAgICAgICAgICBHU2Nyb2xsQmFyLnNTY3JvbGxiYXJIZWxwZXJQb2ludC54ID0gdGhpcy4kdGFyZ2V0WyckeFBvcyddO1xuICAgICAgICAgICAgR1Njcm9sbEJhci5zU2Nyb2xsYmFySGVscGVyUG9pbnQueSA9IHRoaXMuJHRhcmdldFsnJHlQb3MnXTtcbiAgICAgICAgfVxuICAgICAgICBwdC54IC09IEdTY3JvbGxCYXIuc1Njcm9sbGJhckhlbHBlclBvaW50Lng7XG4gICAgICAgIHB0LnkgLT0gR1Njcm9sbEJhci5zU2Nyb2xsYmFySGVscGVyUG9pbnQueTtcbiAgICAgICAgaWYgKHRoaXMuJHZlcnRpY2FsKSB7XG4gICAgICAgICAgICBsZXQgY3VyWSA9IHB0LnkgLSB0aGlzLiRkcmFnT2Zmc2V0Lnk7XG4gICAgICAgICAgICB0aGlzLiR0YXJnZXQuc2V0UGVyY1koKGN1clkgLSB0aGlzLiRiYXIueSkgLyAodGhpcy4kYmFyLmhlaWdodCAtIHRoaXMuJGdyaXAuaGVpZ2h0KSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGN1clggPSBwdC54IC0gdGhpcy4kZHJhZ09mZnNldC54O1xuICAgICAgICAgICAgdGhpcy4kdGFyZ2V0LnNldFBlcmNYKChjdXJYIC0gdGhpcy4kYmFyLngpIC8gKHRoaXMuJGJhci53aWR0aCAtIHRoaXMuJGdyaXAud2lkdGgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgJGdyaXBEcmFnZ2luZ0VuZChldnQpIHtcbiAgICAgICAgR1Njcm9sbEJhci5zU2Nyb2xsYmFySGVscGVyUG9pbnQgPSBuZXcgY3JlYXRlanMuUG9pbnQoKTtcbiAgICAgICAgR1Jvb3QuaW5zdC5uYXRpdmVTdGFnZS5vZmYoSW50ZXJhY3RpdmVFdmVudHMuTW92ZSwgdGhpcy4kbW91c2VNb3ZlRXZlbnQpO1xuICAgICAgICBHUm9vdC5pbnN0Lm5hdGl2ZVN0YWdlLm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5VcCwgdGhpcy4kbW91c2VVcEV2ZW50KTtcbiAgICB9XG4gICAgJGFycm93QnV0dG9uMUNsaWNrKGV2dCkge1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLiR2ZXJ0aWNhbClcbiAgICAgICAgICAgIHRoaXMuJHRhcmdldC5zY3JvbGxVcCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiR0YXJnZXQuc2Nyb2xsTGVmdCgpO1xuICAgIH1cbiAgICAkYXJyb3dCdXR0b24yQ2xpY2soZXZ0KSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuJHZlcnRpY2FsKVxuICAgICAgICAgICAgdGhpcy4kdGFyZ2V0LnNjcm9sbERvd24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kdGFyZ2V0LnNjcm9sbFJpZ2h0KCk7XG4gICAgfVxuICAgICRiYXJNb3VzZURvd24oZXZ0KSB7XG4gICAgICAgIGxldCBwdCA9IG5ldyBjcmVhdGVqcy5Qb2ludChldnQubG9jYWxYLCBldnQubG9jYWxZKTtcbiAgICAgICAgLy8gbGV0IHB0OiBjcmVhdGVqcy5Qb2ludCA9IGV2dC5kYXRhLmdldExvY2FsUG9zaXRpb24odGhpcy4kZ3JpcC5kaXNwbGF5T2JqZWN0LCBHU2Nyb2xsQmFyLnNTY3JvbGxiYXJIZWxwZXJQb2ludCk7XG4gICAgICAgIGlmICh0aGlzLiR2ZXJ0aWNhbCkge1xuICAgICAgICAgICAgaWYgKHB0LnkgPCAwKVxuICAgICAgICAgICAgICAgIHRoaXMuJHRhcmdldC5zY3JvbGxVcCg0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLiR0YXJnZXQuc2Nyb2xsRG93big0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwdC54IDwgMClcbiAgICAgICAgICAgICAgICB0aGlzLiR0YXJnZXQuc2Nyb2xsTGVmdCg0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLiR0YXJnZXQuc2Nyb2xsUmlnaHQoNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5vZmYoSW50ZXJhY3RpdmVFdmVudHMuRG93biwgdGhpcy4kYmFyTW91c2VEb3duKTtcbiAgICAgICAgR1Njcm9sbEJhci5zU2Nyb2xsYmFySGVscGVyUG9pbnQgPSBuZXcgY3JlYXRlanMuUG9pbnQoKTtcbiAgICAgICAgaWYgKHRoaXMuJGFycm93QnV0dG9uMSlcbiAgICAgICAgICAgIHRoaXMuJGFycm93QnV0dG9uMS5vZmYoSW50ZXJhY3RpdmVFdmVudHMuRG93biwgdGhpcy4kYXJyb3dCdXR0b24xQ2xpY2spO1xuICAgICAgICBpZiAodGhpcy4kYXJyb3dCdXR0b24yKVxuICAgICAgICAgICAgdGhpcy4kYXJyb3dCdXR0b24yLm9mZihJbnRlcmFjdGl2ZUV2ZW50cy5Eb3duLCB0aGlzLiRhcnJvd0J1dHRvbjJDbGljayk7XG4gICAgICAgIHRoaXMuJGdyaXAub2ZmKEludGVyYWN0aXZlRXZlbnRzLkRvd24sIHRoaXMuJGdyaXBNb3VzZURvd24pO1xuICAgICAgICB0aGlzLiRncmlwRHJhZ2dpbmdFbmQobnVsbCk7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG59XG5HU2Nyb2xsQmFyLnNTY3JvbGxiYXJIZWxwZXJQb2ludCA9IG5ldyBjcmVhdGVqcy5Qb2ludCgpO1xuXG5jbGFzcyBJdGVtSW5mbyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMudXBkYXRlRmxhZyA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBHTGlzdCBleHRlbmRzIEdDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLiRsaW5lQ291bnQgPSAwO1xuICAgICAgICB0aGlzLiRjb2x1bW5Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuJGxpbmVHYXAgPSAwO1xuICAgICAgICB0aGlzLiRjb2x1bW5HYXAgPSAwO1xuICAgICAgICB0aGlzLiRsYXN0U2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuJG51bUl0ZW1zID0gMDtcbiAgICAgICAgdGhpcy4kZmlyc3RJbmRleCA9IDA7IC8vdG9wIGxlZnQgaW5kZXhcbiAgICAgICAgdGhpcy4kY3VyTGluZUl0ZW1Db3VudCA9IDA7IC8vaXRlbSBjb3VudCBpbiBvbmUgbGluZVxuICAgICAgICB0aGlzLiR2aXJ0dWFsTGlzdENoYW5nZWQgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgIC8vcmVuZGVyIHNvcnRpbmcgdHlwZVxuICAgICAgICB0aGlzLiRhcGV4SW5kZXggPSAwO1xuICAgICAgICB0aGlzLiRjaGlsZHJlblJlbmRlck9yZGVyID0gMCAvKiBBc2NlbnQgKi87XG4gICAgICAgIHRoaXMuJGl0ZW1JbmZvVmVyID0gMDsgLy9pcyB0aGUgaXRlbSB1c2VkIGluIHRoZSBjdXJyZW50IGhhbmRsaW5nIG9yIG5vdFxuICAgICAgICB0aGlzLiRlbnRlckNvdW50ZXIgPSAwOyAvL2JlY2F1c2UgdGhlIGhhbmRsZVNjcm9sbCBmdW5jdGlvbiBjYW4gYmUgcmUtZW50ZXJlZCwgc28gdGhpcyB2YXJpYWJsZSBpcyB1c2VkIHRvIGF2b2lkIGRlYWQtbG9ja1xuICAgICAgICB0aGlzLiR0cmFja0JvdW5kcyA9IHRydWU7XG4gICAgICAgIHRoaXMuJHBvb2wgPSBuZXcgR09iamVjdFJlY3ljbGVyKCk7XG4gICAgICAgIHRoaXMuJGxheW91dCA9IDAgLyogU2luZ2xlQ29sdW1uICovO1xuICAgICAgICB0aGlzLiRhdXRvUmVzaXplSXRlbSA9IHRydWU7XG4gICAgICAgIHRoaXMuJGxhc3RTZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuJHNlbGVjdGlvbk1vZGUgPSAwIC8qIFNpbmdsZSAqLztcbiAgICAgICAgdGhpcy5vcGFxdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjcm9sbEl0ZW1Ub1ZpZXdPbkNsaWNrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kYWxpZ24gPSBcImxlZnRcIiAvKiBMZWZ0ICovO1xuICAgICAgICB0aGlzLiR2ZXJ0aWNhbEFsaWduID0gMCAvKiBUb3AgKi87XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lciA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAgICAgICAgdGhpcy4kcm9vdENvbnRhaW5lci5hZGRDaGlsZCh0aGlzLiRjb250YWluZXIpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW5SZW5kZXJPcmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNoaWxkcmVuUmVuZGVyT3JkZXI7XG4gICAgfVxuICAgIHNldCBjaGlsZHJlblJlbmRlck9yZGVyKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRjaGlsZHJlblJlbmRlck9yZGVyICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRjaGlsZHJlblJlbmRlck9yZGVyID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkcmVuTGlzdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhcGV4SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRhcGV4SW5kZXg7XG4gICAgfVxuICAgIHNldCBhcGV4SW5kZXgodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGFwZXhJbmRleCAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kYXBleEluZGV4ID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy4kY2hpbGRyZW5SZW5kZXJPcmRlciA9PSAyIC8qIEFyY2ggKi8pXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZHJlbkxpc3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipAb3ZlcnJpZGUgKi9cbiAgICBhcHBlbmRDaGlsZHJlbkxpc3QoKSB7XG4gICAgICAgIGNvbnN0IGNudCA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgaWYgKGNudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGNoaWxkO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuJGNoaWxkcmVuUmVuZGVyT3JkZXIpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBBc2NlbnQgKi86XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZGlzcGxheU9iamVjdCAhPSBudWxsICYmIGNoaWxkLmZpbmFsVmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIuYWRkQ2hpbGQoY2hpbGQuZGlzcGxheU9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEgLyogRGVzY2VudCAqLzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGNudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuJGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmRpc3BsYXlPYmplY3QgIT0gbnVsbCAmJiBjaGlsZC5maW5hbFZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmFkZENoaWxkKGNoaWxkLmRpc3BsYXlPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIEFyY2ggKi86XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy4kYXBleEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZGlzcGxheU9iamVjdCAhPSBudWxsICYmIGNoaWxkLmZpbmFsVmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIuYWRkQ2hpbGQoY2hpbGQuZGlzcGxheU9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gY250IC0gMTsgaSA+PSB0aGlzLiRhcGV4SW5kZXg7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLiRjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kaXNwbGF5T2JqZWN0ICE9IG51bGwgJiYgY2hpbGQuZmluYWxWaXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDaGlsZChjaGlsZC5kaXNwbGF5T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipAb3ZlcnJpZGUgKi9cbiAgICBzZXRYWSh4diwgeXYpIHtcbiAgICAgICAgaWYgKHRoaXMuJHggIT0geHYgfHwgdGhpcy4keSAhPSB5dikge1xuICAgICAgICAgICAgdGhpcy4keCA9IHh2O1xuICAgICAgICAgICAgdGhpcy4keSA9IHl2O1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVYWUNoYW5nZWQoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlR2VhcigxIC8qIFhZICovKTtcbiAgICAgICAgICAgIGlmIChHT2JqZWN0LmRyYWdnaW5nT2JqZWN0ID09IHRoaXMgJiYgIUdPYmplY3Quc1VwZGF0aW5nV2hpbGVEcmFnZ2luZylcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsVG9HbG9iYWxSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBHT2JqZWN0LnNHbG9iYWxSZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipAb3ZlcnJpZGUgKi9cbiAgICAkc2V0Q2hpbGRJbmRleChjaGlsZCwgb2xkSW5kZXgsIGluZGV4ID0gMCkge1xuICAgICAgICBsZXQgY250ID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAoaW5kZXggPiBjbnQpXG4gICAgICAgICAgICBpbmRleCA9IGNudDtcbiAgICAgICAgaWYgKG9sZEluZGV4ID09IGluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgICB0aGlzLiRjaGlsZHJlbi5zcGxpY2Uob2xkSW5kZXgsIDEpO1xuICAgICAgICB0aGlzLiRjaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICAgICAgaWYgKGNoaWxkLmluQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBsZXQgZGlzcGxheUluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBnO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBpZiAodGhpcy4kY2hpbGRyZW5SZW5kZXJPcmRlciA9PSAwIC8qIEFzY2VudCAqLykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGcgPSB0aGlzLiRjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGcuaW5Db250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BsYXlJbmRleCA9PSB0aGlzLiRjb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5SW5kZXgtLTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIuc2V0Q2hpbGRJbmRleChjaGlsZC5kaXNwbGF5T2JqZWN0LCBkaXNwbGF5SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4kY2hpbGRyZW5SZW5kZXJPcmRlciA9PSAxIC8qIERlc2NlbnQgKi8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBjbnQgLSAxOyBpID4gaW5kZXg7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBnID0gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChnLmluQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheUluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5SW5kZXggPT0gdGhpcy4kY29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheUluZGV4LS07XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnNldENoaWxkSW5kZXgoY2hpbGQuZGlzcGxheU9iamVjdCwgZGlzcGxheUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBHVGltZXIuaW5zdC5jYWxsTGF0ZXIodGhpcy5hcHBlbmRDaGlsZHJlbkxpc3QsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXRCb3VuZHNDaGFuZ2VkRmxhZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgLyoqQG92ZXJyaWRlICovXG4gICAgY2hpbGRTdGF0ZUNoYW5nZWQoY2hpbGQpIHtcbiAgICAgICAgaWYgKHRoaXMuJGJ1aWxkaW5nRGlzcGxheUxpc3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdHcm91cCkge1xuICAgICAgICAgICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChnID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZy5ncm91cCA9PSBjaGlsZClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZFN0YXRlQ2hhbmdlZChnKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGQuZGlzcGxheU9iamVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGNoaWxkLmZpbmFsVmlzaWJsZSkge1xuICAgICAgICAgICAgbGV0IGksIGc7XG4gICAgICAgICAgICBsZXQgY250ID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFjaGlsZC5kaXNwbGF5T2JqZWN0LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGNoaWxkcmVuUmVuZGVyT3JkZXIgPT0gMCAvKiBBc2NlbnQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHRoaXMuJGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGcgPT0gY2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZy5kaXNwbGF5T2JqZWN0ICE9IG51bGwgJiYgZy5kaXNwbGF5T2JqZWN0LnBhcmVudCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmFkZENoaWxkQXQoY2hpbGQuZGlzcGxheU9iamVjdCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRjaGlsZHJlblJlbmRlck9yZGVyID09IDEgLyogRGVzY2VudCAqLykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBjbnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHRoaXMuJGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGcgPT0gY2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZy5kaXNwbGF5T2JqZWN0ICE9IG51bGwgJiYgZy5kaXNwbGF5T2JqZWN0LnBhcmVudCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmFkZENoaWxkQXQoY2hpbGQuZGlzcGxheU9iamVjdCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmFkZENoaWxkKGNoaWxkLmRpc3BsYXlPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICBHVGltZXIuaW5zdC5jYWxsTGF0ZXIodGhpcy5hcHBlbmRDaGlsZHJlbkxpc3QsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5kaXNwbGF5T2JqZWN0LnBhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQuZGlzcGxheU9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgR1RpbWVyLmluc3QucmVtb3ZlKHRoaXMuJHJlZnJlc2hWaXJ0dWFsTGlzdCwgdGhpcyk7XG4gICAgICAgIHRoaXMuJHBvb2wuY2xlYXIoKTtcbiAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFBhbmUpXG4gICAgICAgICAgICB0aGlzLiRzY3JvbGxQYW5lLm9mZihcIl9fc2Nyb2xsXCIgLyogU0NST0xMICovLCB0aGlzLiRzY3JvbGxlZCk7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZ2V0IGxheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGxheW91dDtcbiAgICB9XG4gICAgc2V0IGxheW91dCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kbGF5b3V0ICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRsYXlvdXQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0Qm91bmRzQ2hhbmdlZEZsYWcoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR2aXJ0dWFsKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmlydHVhbExpc3RDaGFuZ2VkRmxhZyh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGluZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kbGluZUNvdW50O1xuICAgIH1cbiAgICBzZXQgbGluZUNvdW50KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRsaW5lQ291bnQgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGxpbmVDb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGxheW91dCA9PSAzIC8qIEZsb3dWZXJ0aWNhbCAqLyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuJGxheW91dCA9PSA0IC8qIFBhZ2luYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEJvdW5kc0NoYW5nZWRGbGFnKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHZpcnR1YWwpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmlydHVhbExpc3RDaGFuZ2VkRmxhZyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY29sdW1uQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjb2x1bW5Db3VudDtcbiAgICB9XG4gICAgc2V0IGNvbHVtbkNvdW50KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRjb2x1bW5Db3VudCAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kY29sdW1uQ291bnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRsYXlvdXQgPT0gMiAvKiBGbG93SG9yaXpvbnRhbCAqLyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuJGxheW91dCA9PSA0IC8qIFBhZ2luYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEJvdW5kc0NoYW5nZWRGbGFnKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHZpcnR1YWwpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmlydHVhbExpc3RDaGFuZ2VkRmxhZyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGluZUdhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGxpbmVHYXA7XG4gICAgfVxuICAgIHNldCBsaW5lR2FwKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRsaW5lR2FwICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRsaW5lR2FwID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNldEJvdW5kc0NoYW5nZWRGbGFnKCk7XG4gICAgICAgICAgICBpZiAodGhpcy4kdmlydHVhbClcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZpcnR1YWxMaXN0Q2hhbmdlZEZsYWcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvbHVtbkdhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbHVtbkdhcDtcbiAgICB9XG4gICAgc2V0IGNvbHVtbkdhcCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy4kY29sdW1uR2FwICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRjb2x1bW5HYXAgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0Qm91bmRzQ2hhbmdlZEZsYWcoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR2aXJ0dWFsKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmlydHVhbExpc3RDaGFuZ2VkRmxhZyh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYWxpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRhbGlnbjtcbiAgICB9XG4gICAgc2V0IGFsaWduKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiRhbGlnbiAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kYWxpZ24gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0Qm91bmRzQ2hhbmdlZEZsYWcoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR2aXJ0dWFsKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmlydHVhbExpc3RDaGFuZ2VkRmxhZyh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdmVydGljYWxBbGlnbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHZlcnRpY2FsQWxpZ247XG4gICAgfVxuICAgIHNldCB2ZXJ0aWNhbEFsaWduKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiR2ZXJ0aWNhbEFsaWduICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiR2ZXJ0aWNhbEFsaWduID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNldEJvdW5kc0NoYW5nZWRGbGFnKCk7XG4gICAgICAgICAgICBpZiAodGhpcy4kdmlydHVhbClcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZpcnR1YWxMaXN0Q2hhbmdlZEZsYWcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHZpcnR1YWxJdGVtU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1TaXplO1xuICAgIH1cbiAgICBzZXQgdmlydHVhbEl0ZW1TaXplKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLiR2aXJ0dWFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kaXRlbVNpemUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtU2l6ZSA9IG5ldyBjcmVhdGVqcy5Qb2ludCgpO1xuICAgICAgICAgICAgdGhpcy4kaXRlbVNpemUuY29weSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNldFZpcnR1YWxMaXN0Q2hhbmdlZEZsYWcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZGVmYXVsdEl0ZW07XG4gICAgfVxuICAgIHNldCBkZWZhdWx0SXRlbSh2YWwpIHtcbiAgICAgICAgdGhpcy4kZGVmYXVsdEl0ZW0gPSB2YWw7XG4gICAgfVxuICAgIGdldCBhdXRvUmVzaXplSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGF1dG9SZXNpemVJdGVtO1xuICAgIH1cbiAgICBzZXQgYXV0b1Jlc2l6ZUl0ZW0odmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGF1dG9SZXNpemVJdGVtICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRhdXRvUmVzaXplSXRlbSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXRCb3VuZHNDaGFuZ2VkRmxhZygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHZpcnR1YWwpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWaXJ0dWFsTGlzdENoYW5nZWRGbGFnKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzZWxlY3Rpb25Nb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2VsZWN0aW9uTW9kZTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGlvbk1vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kc2VsZWN0aW9uTW9kZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0aW9uQ29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNlbGVjdGlvbkNvbnRyb2xsZXI7XG4gICAgfVxuICAgIHNldCBzZWxlY3Rpb25Db250cm9sbGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJHNlbGVjdGlvbkNvbnRyb2xsZXIgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGl0ZW1Qb29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcG9vbDtcbiAgICB9XG4gICAgZ2V0RnJvbVBvb2wodXJsID0gbnVsbCkge1xuICAgICAgICBpZiAoIXVybClcbiAgICAgICAgICAgIHVybCA9IHRoaXMuJGRlZmF1bHRJdGVtO1xuICAgICAgICBsZXQgb2JqID0gdGhpcy4kcG9vbC5nZXQodXJsKTtcbiAgICAgICAgaWYgKG9iaiAhPSBudWxsKVxuICAgICAgICAgICAgb2JqLnZpc2libGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm5Ub1Bvb2wob2JqKSB7XG4gICAgICAgIHRoaXMuJHBvb2wucmVjeWNsZShvYmoucmVzb3VyY2VVUkwsIG9iaik7XG4gICAgfVxuICAgIGFkZENoaWxkQXQoY2hpbGQsIGluZGV4ID0gMCkge1xuICAgICAgICBzdXBlci5hZGRDaGlsZEF0KGNoaWxkLCBpbmRleCk7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdCdXR0b24pIHtcbiAgICAgICAgICAgIGNoaWxkLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjaGlsZC5jaGFuZ2VTdGF0ZU9uQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5jbGljayh0aGlzLiRjbGlja0l0ZW0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGFkZEl0ZW0odXJsID0gbnVsbCkge1xuICAgICAgICBpZiAoIXVybClcbiAgICAgICAgICAgIHVybCA9IHRoaXMuJGRlZmF1bHRJdGVtO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRDaGlsZChVSVBhY2thZ2UuY3JlYXRlT2JqZWN0RnJvbVVSTCh1cmwpKTtcbiAgICB9XG4gICAgYWRkSXRlbUZyb21Qb29sKHVybCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ2hpbGQodGhpcy5nZXRGcm9tUG9vbCh1cmwpKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2hpbGRBdChpbmRleCwgZGlzcG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5udW1DaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy4kY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjaGlsZC5zb3J0aW5nT3JkZXIgIT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLiRzb3J0aW5nQ2hpbGRDb3VudC0tO1xuICAgICAgICAgICAgdGhpcy4kY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5pbkNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZC5kaXNwbGF5T2JqZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kY2hpbGRyZW5SZW5kZXJPcmRlciA9PSAyIC8qIEFyY2ggKi8pXG4gICAgICAgICAgICAgICAgICAgIEdUaW1lci5pbnN0LmNhbGxMYXRlcih0aGlzLmFwcGVuZENoaWxkcmVuTGlzdCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzcG9zZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBjaGlsZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnNldEJvdW5kc0NoYW5nZWRGbGFnKCk7XG4gICAgICAgICAgICBjaGlsZC5yZW1vdmVDbGljayh0aGlzLiRjbGlja0l0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGlsZCBpbmRleCcpO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZFRvUG9vbEF0KGluZGV4KSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXMucmVtb3ZlQ2hpbGRBdChpbmRleCk7XG4gICAgICAgIHRoaXMucmV0dXJuVG9Qb29sKGNoaWxkKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2hpbGRUb1Bvb2woY2hpbGQpIHtcbiAgICAgICAgc3VwZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB0aGlzLnJldHVyblRvUG9vbChjaGlsZCk7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuVG9Qb29sKGJlZ2luSW5kZXggPSAwLCBlbmRJbmRleCA9IC0xKSB7XG4gICAgICAgIGlmIChlbmRJbmRleCA8IDAgfHwgZW5kSW5kZXggPj0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgZW5kSW5kZXggPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gYmVnaW5JbmRleDsgaSA8PSBlbmRJbmRleDsgKytpKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZFRvUG9vbEF0KGJlZ2luSW5kZXgpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRJbmRleCgpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGlmICh0aGlzLiR2aXJ0dWFsKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy4kcmVhbE51bUl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpaSA9IHRoaXMuJHZpcnR1YWxJdGVtc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoKGlpLm9iaiBpbnN0YW5jZW9mIEdCdXR0b24gJiYgaWkub2JqLnNlbGVjdGVkKSB8fCAoaWkub2JqID09IG51bGwgJiYgaWkuc2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRsb29wKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgJSB0aGlzLiRudW1JdGVtcztcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY250ID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAhPSBudWxsICYmIG9iai5zZWxlY3RlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWRJbmRleCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8IHRoaXMubnVtSXRlbXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgIT0gMCAvKiBTaW5nbGUgKi8pXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3Rpb24odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgICBsZXQgcmV0ID0gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpZiAodGhpcy4kdmlydHVhbCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuJHJlYWxOdW1JdGVtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWkgPSB0aGlzLiR2aXJ0dWFsSXRlbXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKChpaS5vYmogaW5zdGFuY2VvZiBHQnV0dG9uICYmIGlpLm9iai5zZWxlY3RlZCkgfHwgKGlpLm9iaiA9PSBudWxsICYmIGlpLnNlbGVjdGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaiA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRsb29wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gaSAlIHRoaXMuJG51bUl0ZW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldC5pbmRleE9mKGopICE9IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNudCA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvYmogIT0gbnVsbCAmJiBvYmouc2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGFkZFNlbGVjdGlvbihpbmRleCwgc2Nyb2xsSW50b1ZpZXcgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy4kc2VsZWN0aW9uTW9kZSA9PSAzIC8qIE5vbmUgKi8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY2hlY2tWaXJ0dWFsTGlzdCgpO1xuICAgICAgICBpZiAodGhpcy4kc2VsZWN0aW9uTW9kZSA9PSAwIC8qIFNpbmdsZSAqLylcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHNjcm9sbEludG9WaWV3KVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1ZpZXcoaW5kZXgpO1xuICAgICAgICB0aGlzLiRsYXN0U2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgb2JqID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuJHZpcnR1YWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGlpID0gdGhpcy4kdmlydHVhbEl0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChpaS5vYmogIT0gbnVsbClcbiAgICAgICAgICAgICAgICBvYmogPSBpaS5vYmo7XG4gICAgICAgICAgICBpaS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2JqID0gdGhpcy5nZXRDaGlsZEF0KGluZGV4KTtcbiAgICAgICAgaWYgKG9iaiAhPSBudWxsICYmICFvYmouc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIG9iai5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkNvbnRyb2xsZXIoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVNlbGVjdGlvbihpbmRleCkge1xuICAgICAgICBpZiAodGhpcy4kc2VsZWN0aW9uTW9kZSA9PSAzIC8qIE5vbmUgKi8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBvYmogPSBudWxsO1xuICAgICAgICBpZiAodGhpcy4kdmlydHVhbCkge1xuICAgICAgICAgICAgY29uc3QgaWkgPSB0aGlzLiR2aXJ0dWFsSXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGlpLm9iaiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG9iaiA9IGlpLm9iajtcbiAgICAgICAgICAgIGlpLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2JqID0gdGhpcy5nZXRDaGlsZEF0KGluZGV4KTtcbiAgICAgICAgaWYgKG9iaiAhPSBudWxsKVxuICAgICAgICAgICAgb2JqLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKHRoaXMuJHZpcnR1YWwpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLiRyZWFsTnVtSXRlbXM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlpID0gdGhpcy4kdmlydHVhbEl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpaS5vYmogaW5zdGFuY2VvZiBHQnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICBpaS5vYmouc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpaS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY250ID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBvYmouc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhclNlbGVjdGlvbkV4Y2VwdChnKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpZiAodGhpcy4kdmlydHVhbCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuJHJlYWxOdW1JdGVtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWkgPSB0aGlzLiR2aXJ0dWFsSXRlbXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGlpLm9iaiAhPSBnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpaS5vYmogaW5zdGFuY2VvZiBHQnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWkub2JqLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlpLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY250ID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAhPSBudWxsICYmIG9iaiAhPSBnKVxuICAgICAgICAgICAgICAgICAgICBvYmouc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RBbGwoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tWaXJ0dWFsTGlzdCgpO1xuICAgICAgICBsZXQgbGFzdCA9IC0xO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKHRoaXMuJHZpcnR1YWwpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLiRyZWFsTnVtSXRlbXM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlpID0gdGhpcy4kdmlydHVhbEl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpaS5vYmogaW5zdGFuY2VvZiBHQnV0dG9uICYmICFpaS5vYmouc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWkub2JqLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNudCA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvYmogIT0gbnVsbCAmJiAhb2JqLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdCAhPSAtMSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uQ29udHJvbGxlcihsYXN0KTtcbiAgICB9XG4gICAgc2VsZWN0Tm9uZSgpIHtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBzZWxlY3RSZXZlcnNlKCkge1xuICAgICAgICB0aGlzLmNoZWNrVmlydHVhbExpc3QoKTtcbiAgICAgICAgbGV0IGxhc3QgPSAtMTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGlmICh0aGlzLiR2aXJ0dWFsKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy4kcmVhbE51bUl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpaSA9IHRoaXMuJHZpcnR1YWxJdGVtc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaWkub2JqIGluc3RhbmNlb2YgR0J1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICBpaS5vYmouc2VsZWN0ZWQgPSAhaWkub2JqLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWkub2JqLnNlbGVjdGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpLnNlbGVjdGVkID0gIWlpLnNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY250ID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5zZWxlY3RlZCA9ICFvYmouc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmouc2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3QgIT0gLTEpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkNvbnRyb2xsZXIobGFzdCk7XG4gICAgfVxuICAgIGhhbmRsZUFycm93S2V5KGtleSkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICAgIGxldCBrLCBpO1xuICAgICAgICBsZXQgb2JqO1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAzOCAvKiBVcCAqLzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kbGF5b3V0ID09IDAgLyogU2luZ2xlQ29sdW1uICovIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxheW91dCA9PSAzIC8qIEZsb3dWZXJ0aWNhbCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3Rpb24oaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJGxheW91dCA9PSAyIC8qIEZsb3dIb3Jpem9udGFsICovIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxheW91dCA9PSA0IC8qIFBhZ2luYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuJGNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHRoaXMuJGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai55ICE9IGN1cnJlbnQueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB0aGlzLiRjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmoueSAhPSBjdXJyZW50LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3Rpb24oaSArIGsgKyAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzkgLyogUmlnaHQgKi86XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGxheW91dCA9PSAxIC8qIFNpbmdsZVJvdyAqLyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsYXlvdXQgPT0gMiAvKiBGbG93SG9yaXpvbnRhbCAqLyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsYXlvdXQgPT0gNCAvKiBQYWdpbmF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMuJGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3Rpb24oaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJGxheW91dCA9PSAzIC8qIEZsb3dWZXJ0aWNhbCAqLykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy4kY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY250ID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBpbmRleCArIDE7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnggIT0gY3VycmVudC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB0aGlzLiRjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmoueCAhPSBjdXJyZW50LngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3Rpb24oaSAtIGsgLSAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDAgLyogRG93biAqLzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kbGF5b3V0ID09IDAgLyogU2luZ2xlQ29sdW1uICovIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxheW91dCA9PSAzIC8qIEZsb3dWZXJ0aWNhbCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLiRjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2VsZWN0aW9uKGluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRsYXlvdXQgPT0gMiAvKiBGbG93SG9yaXpvbnRhbCAqLyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsYXlvdXQgPT0gNCAvKiBQYWdpbmF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLiRjaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbnQgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGluZGV4ICsgMTsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB0aGlzLiRjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmoueSAhPSBjdXJyZW50LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHRoaXMuJGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai55ICE9IGN1cnJlbnQueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNlbGVjdGlvbihpIC0gayAtIDEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzNyAvKiBMZWZ0ICovOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRsYXlvdXQgPT0gMSAvKiBTaW5nbGVSb3cgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbGF5b3V0ID09IDIgLyogRmxvd0hvcml6b250YWwgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbGF5b3V0ID09IDQgLyogUGFnaW5hdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3Rpb24oaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJGxheW91dCA9PSAzIC8qIEZsb3dWZXJ0aWNhbCAqLykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy4kY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gdGhpcy4kY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnggIT0gY3VycmVudC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHRoaXMuJGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai54ICE9IGN1cnJlbnQueCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNlbGVjdGlvbihpICsgayArIDEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgICRjbGlja0l0ZW0oZXZ0KSB7XG4gICAgICAgIGlmICh0aGlzLiRzY3JvbGxQYW5lICE9IG51bGwgJiYgdGhpcy4kc2Nyb2xsUGFuZS5pc0RyYWdnaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpdGVtID0gR09iamVjdC5jYXN0RnJvbU5hdGl2ZU9iamVjdChldnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25PbkV2ZW50KGl0ZW0pO1xuICAgICAgICBpZiAodGhpcy4kc2Nyb2xsUGFuZSAmJiB0aGlzLnNjcm9sbEl0ZW1Ub1ZpZXdPbkNsaWNrKVxuICAgICAgICAgICAgdGhpcy4kc2Nyb2xsUGFuZS5zY3JvbGxUb1ZpZXcoaXRlbSwgdHJ1ZSk7XG4gICAgICAgIGxldCBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcIl9faXRlbUNsaWNrXCIgLyogSXRlbUNsaWNrICovLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGV2ZW50LmRhdGEgPSB7IGl0ZW0gfTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0aGlzKTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uT25FdmVudChidXR0b24pIHtcbiAgICAgICAgaWYgKCEoYnV0dG9uIGluc3RhbmNlb2YgR0J1dHRvbikgfHwgdGhpcy4kc2VsZWN0aW9uTW9kZSA9PSAzIC8qIE5vbmUgKi8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb250Q2hhbmdlTGFzdEluZGV4ID0gZmFsc2U7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuY2hpbGRJbmRleFRvSXRlbUluZGV4KHRoaXMuZ2V0Q2hpbGRJbmRleChidXR0b24pKTtcbiAgICAgICAgaWYgKHRoaXMuJHNlbGVjdGlvbk1vZGUgPT0gMCAvKiBTaW5nbGUgKi8pIHtcbiAgICAgICAgICAgIGlmICghYnV0dG9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbkV4Y2VwdChidXR0b24pO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoRE9NRXZlbnRNYW5hZ2VyLmluc3QuaXNLZXlQcmVzc2VkKDE2IC8qIFNoaWZ0ICovKSkge1xuICAgICAgICAgICAgICAgIGlmICghYnV0dG9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRsYXN0U2VsZWN0ZWRJbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4odGhpcy4kbGFzdFNlbGVjdGVkSW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWluKE1hdGgubWF4KHRoaXMuJGxhc3RTZWxlY3RlZEluZGV4LCBpbmRleCksIHRoaXMubnVtSXRlbXMgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuJHZpcnR1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBtaW47IGkgPD0gbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWkgPSB0aGlzLiR2aXJ0dWFsSXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpaS5vYmogaW5zdGFuY2VvZiBHQnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWkub2JqLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWkuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IG1pbjsgaSA8PSBtYXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmdldENoaWxkQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmogIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9udENoYW5nZUxhc3RJbmRleCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChET01FdmVudE1hbmFnZXIuaW5zdC5pc0tleVByZXNzZWQoMTcgLyogQ3RybCAqLykgfHxcbiAgICAgICAgICAgICAgICB0aGlzLiRzZWxlY3Rpb25Nb2RlID09IDIgLyogTXVsdGlwbGVfU2luZ2xlQ2xpY2sgKi8pXG4gICAgICAgICAgICAgICAgYnV0dG9uLnNlbGVjdGVkID0gIWJ1dHRvbi5zZWxlY3RlZDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghYnV0dG9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25FeGNlcHQoYnV0dG9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uRXhjZXB0KGJ1dHRvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb250Q2hhbmdlTGFzdEluZGV4KVxuICAgICAgICAgICAgdGhpcy4kbGFzdFNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgICAgaWYgKGJ1dHRvbi5zZWxlY3RlZClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uQ29udHJvbGxlcihpbmRleCk7XG4gICAgfVxuICAgIHJlc2l6ZVRvRml0KGl0ZW1Db3VudCA9IDEwMDAwMDAsIG1pblNpemUgPSAwKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQm91bmRzQ29ycmVjdCgpO1xuICAgICAgICBjb25zdCBjdXJDb3VudCA9IHRoaXMubnVtSXRlbXM7XG4gICAgICAgIGlmIChpdGVtQ291bnQgPiBjdXJDb3VudClcbiAgICAgICAgICAgIGl0ZW1Db3VudCA9IGN1ckNvdW50O1xuICAgICAgICBpZiAodGhpcy4kdmlydHVhbCkge1xuICAgICAgICAgICAgY29uc3QgbGluZUNvdW50ID0gTWF0aC5jZWlsKGl0ZW1Db3VudCAvIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGxheW91dCA9PSAwIC8qIFNpbmdsZUNvbHVtbiAqLyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuJGxheW91dCA9PSAyIC8qIEZsb3dIb3Jpem9udGFsICovKVxuICAgICAgICAgICAgICAgIHRoaXMudmlld0hlaWdodCA9IGxpbmVDb3VudCAqIHRoaXMuJGl0ZW1TaXplLnkgKyBNYXRoLm1heCgwLCBsaW5lQ291bnQgLSAxKSAqIHRoaXMuJGxpbmVHYXA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3V2lkdGggPSBsaW5lQ291bnQgKiB0aGlzLiRpdGVtU2l6ZS54ICsgTWF0aC5tYXgoMCwgbGluZUNvdW50IC0gMSkgKiB0aGlzLiRjb2x1bW5HYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbUNvdW50ID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRsYXlvdXQgPT0gMCAvKiBTaW5nbGVDb2x1bW4gKi8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLiRsYXlvdXQgPT0gMiAvKiBGbG93SG9yaXpvbnRhbCAqLylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdIZWlnaHQgPSBtaW5TaXplO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMudmlld1dpZHRoID0gbWluU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpID0gaXRlbUNvdW50IC0gMTtcbiAgICAgICAgICAgIGxldCBvYmo7XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gdGhpcy5nZXRDaGlsZEF0KGkpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5mb2xkSW52aXNpYmxlSXRlbXMgfHwgb2JqLnZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRsYXlvdXQgPT0gMCAvKiBTaW5nbGVDb2x1bW4gKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbGF5b3V0ID09IDIgLyogRmxvd0hvcml6b250YWwgKi8pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0hlaWdodCA9IG1pblNpemU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdXaWR0aCA9IG1pblNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGxheW91dCA9PSAwIC8qIFNpbmdsZUNvbHVtbiAqLyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsYXlvdXQgPT0gMiAvKiBGbG93SG9yaXpvbnRhbCAqLykge1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gb2JqLnkgKyBvYmouaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA8IG1pblNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gbWluU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3SGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBvYmoueCArIG9iai53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPCBtaW5TaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IG1pblNpemU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld1dpZHRoID0gc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWF4SXRlbVdpZHRoKCkge1xuICAgICAgICBjb25zdCBjbnQgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRBdChpKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC53aWR0aCA+IG1heClcbiAgICAgICAgICAgICAgICBtYXggPSBjaGlsZC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBoYW5kbGVTaXplQ2hhbmdlZCgpIHtcbiAgICAgICAgc3VwZXIuaGFuZGxlU2l6ZUNoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5zZXRCb3VuZHNDaGFuZ2VkRmxhZygpO1xuICAgICAgICBpZiAodGhpcy4kdmlydHVhbClcbiAgICAgICAgICAgIHRoaXMuc2V0VmlydHVhbExpc3RDaGFuZ2VkRmxhZyh0cnVlKTtcbiAgICB9XG4gICAgaGFuZGxlQ29udHJvbGxlckNoYW5nZWQoYykge1xuICAgICAgICBzdXBlci5oYW5kbGVDb250cm9sbGVyQ2hhbmdlZChjKTtcbiAgICAgICAgaWYgKHRoaXMuJHNlbGVjdGlvbkNvbnRyb2xsZXIgPT0gYylcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGMuc2VsZWN0ZWRJbmRleDtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0aW9uQ29udHJvbGxlcihpbmRleCkge1xuICAgICAgICBpZiAodGhpcy4kc2VsZWN0aW9uQ29udHJvbGxlciAhPSBudWxsICYmXG4gICAgICAgICAgICAhdGhpcy4kc2VsZWN0aW9uQ29udHJvbGxlci4kdXBkYXRpbmcgJiZcbiAgICAgICAgICAgIGluZGV4IDwgdGhpcy5zZWxlY3Rpb25Db250cm9sbGVyLnBhZ2VDb3VudCkge1xuICAgICAgICAgICAgY29uc3QgYyA9IHRoaXMuJHNlbGVjdGlvbkNvbnRyb2xsZXI7XG4gICAgICAgICAgICB0aGlzLiRzZWxlY3Rpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgICAgIGMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy4kc2VsZWN0aW9uQ29udHJvbGxlciA9IGM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U25hcHBpbmdQb3NpdGlvbih4VmFsdWUsIHlWYWx1ZSwgcmVzdWx0UG9pbnQgPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLiR2aXJ0dWFsKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdFBvaW50KVxuICAgICAgICAgICAgICAgIHJlc3VsdFBvaW50ID0gbmV3IGNyZWF0ZWpzLlBvaW50KCk7XG4gICAgICAgICAgICBsZXQgc2F2ZWQ7XG4gICAgICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgICAgICBpZiAodGhpcy4kbGF5b3V0ID09IDAgLyogU2luZ2xlQ29sdW1uICovIHx8XG4gICAgICAgICAgICAgICAgdGhpcy4kbGF5b3V0ID09IDIgLyogRmxvd0hvcml6b250YWwgKi8pIHtcbiAgICAgICAgICAgICAgICBzYXZlZCA9IHlWYWx1ZTtcbiAgICAgICAgICAgICAgICBHTGlzdC4kbGFzdFBvc0hlbHBlciA9IHlWYWx1ZTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuZ2V0SW5kZXhPblBvczEoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHlWYWx1ZSA9IEdMaXN0LiRsYXN0UG9zSGVscGVyO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMuJHZpcnR1YWxJdGVtcy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgc2F2ZWQgLSB5VmFsdWUgPiB0aGlzLiR2aXJ0dWFsSXRlbXNbaW5kZXhdLmhlaWdodCAvIDIgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPCB0aGlzLiRyZWFsTnVtSXRlbXMpXG4gICAgICAgICAgICAgICAgICAgIHlWYWx1ZSArPSB0aGlzLiR2aXJ0dWFsSXRlbXNbaW5kZXhdLmhlaWdodCArIHRoaXMuJGxpbmVHYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRsYXlvdXQgPT0gMSAvKiBTaW5nbGVSb3cgKi8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLiRsYXlvdXQgPT0gMyAvKiBGbG93VmVydGljYWwgKi8pIHtcbiAgICAgICAgICAgICAgICBzYXZlZCA9IHhWYWx1ZTtcbiAgICAgICAgICAgICAgICBHTGlzdC4kbGFzdFBvc0hlbHBlciA9IHhWYWx1ZTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuZ2V0SW5kZXhPblBvczIoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHhWYWx1ZSA9IEdMaXN0LiRsYXN0UG9zSGVscGVyO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMuJHZpcnR1YWxJdGVtcy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgc2F2ZWQgLSB4VmFsdWUgPiB0aGlzLiR2aXJ0dWFsSXRlbXNbaW5kZXhdLndpZHRoIC8gMiAmJlxuICAgICAgICAgICAgICAgICAgICBpbmRleCA8IHRoaXMuJHJlYWxOdW1JdGVtcylcbiAgICAgICAgICAgICAgICAgICAgeFZhbHVlICs9IHRoaXMuJHZpcnR1YWxJdGVtc1tpbmRleF0ud2lkdGggKyB0aGlzLiRjb2x1bW5HYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYXZlZCA9IHhWYWx1ZTtcbiAgICAgICAgICAgICAgICBHTGlzdC4kbGFzdFBvc0hlbHBlciA9IHhWYWx1ZTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuZ2V0SW5kZXhPblBvczMoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHhWYWx1ZSA9IEdMaXN0LiRsYXN0UG9zSGVscGVyO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMuJHZpcnR1YWxJdGVtcy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgc2F2ZWQgLSB4VmFsdWUgPiB0aGlzLiR2aXJ0dWFsSXRlbXNbaW5kZXhdLndpZHRoIC8gMiAmJlxuICAgICAgICAgICAgICAgICAgICBpbmRleCA8IHRoaXMuJHJlYWxOdW1JdGVtcylcbiAgICAgICAgICAgICAgICAgICAgeFZhbHVlICs9IHRoaXMuJHZpcnR1YWxJdGVtc1tpbmRleF0ud2lkdGggKyB0aGlzLiRjb2x1bW5HYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRQb2ludC54ID0geFZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0UG9pbnQueSA9IHlWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRQb2ludDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZ2V0U25hcHBpbmdQb3NpdGlvbih4VmFsdWUsIHlWYWx1ZSwgcmVzdWx0UG9pbnQpO1xuICAgIH1cbiAgICBzY3JvbGxUb1ZpZXcoaW5kZXgsIGFuaSA9IGZhbHNlLCBzbmFwVG9GaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLiR2aXJ0dWFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kbnVtSXRlbXMgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmNoZWNrVmlydHVhbExpc3QoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLiR2aXJ0dWFsSXRlbXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGlsZCBpbmRleDogJHtpbmRleH0gaXMgbGFyZ2VyIHRoYW4gbWF4IGxlbmd0aDogJHt0aGlzLiR2aXJ0dWFsSXRlbXMubGVuZ3RofWApO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGxvb3ApXG4gICAgICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKHRoaXMuJGZpcnN0SW5kZXggLyB0aGlzLiRudW1JdGVtcykgKiB0aGlzLiRudW1JdGVtcyArIGluZGV4O1xuICAgICAgICAgICAgbGV0IHJlY3Q7XG4gICAgICAgICAgICBjb25zdCBpaSA9IHRoaXMuJHZpcnR1YWxJdGVtc1tpbmRleF07XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGxheW91dCA9PSAwIC8qIFNpbmdsZUNvbHVtbiAqLyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuJGxheW91dCA9PSAyIC8qIEZsb3dIb3Jpem9udGFsICovKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluZGV4OyBpICs9IHRoaXMuJGN1ckxpbmVJdGVtQ291bnQpXG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSB0aGlzLiR2aXJ0dWFsSXRlbXNbaV0uaGVpZ2h0ICsgdGhpcy4kbGluZUdhcDtcbiAgICAgICAgICAgICAgICByZWN0ID0gbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgwLCBwb3MsIHRoaXMuJGl0ZW1TaXplLngsIGlpLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRsYXlvdXQgPT0gMSAvKiBTaW5nbGVSb3cgKi8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLiRsYXlvdXQgPT0gMyAvKiBGbG93VmVydGljYWwgKi8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gdGhpcy4kY3VyTGluZUl0ZW1Db3VudClcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IHRoaXMuJHZpcnR1YWxJdGVtc1tpXS53aWR0aCArIHRoaXMuJGNvbHVtbkdhcDtcbiAgICAgICAgICAgICAgICByZWN0ID0gbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZShwb3MsIDAsIGlpLndpZHRoLCB0aGlzLiRpdGVtU2l6ZS55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBpbmRleCAvICh0aGlzLiRjdXJMaW5lSXRlbUNvdW50ICogdGhpcy4kY3VyTGluZUl0ZW1Db3VudDIpO1xuICAgICAgICAgICAgICAgIHJlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKHBhZ2UgKiB0aGlzLnZpZXdXaWR0aCArIChpbmRleCAlIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQpICogKGlpLndpZHRoICsgdGhpcy4kY29sdW1uR2FwKSwgKChpbmRleCAvIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQpICUgdGhpcy4kY3VyTGluZUl0ZW1Db3VudDIpICpcbiAgICAgICAgICAgICAgICAgICAgKGlpLmhlaWdodCArIHRoaXMuJGxpbmVHYXApLCBpaS53aWR0aCwgaWkuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdGhlIHBvc2l0aW9uIHdpbGwgYmUgYWxzbyBjaGFuZ2VkIGlmIHRoZSBoZWlnaHQgb2YgaXRzIHBhcmVudCAoaWYgY2hhbmdlYWJsZSkgaXMgYmVpbmcgY2hhbmdlZCwgc28gaGVyZSB3ZSBuZWVkIHRvIGZvcmNlbHkgc2V0IHRoaXMgdG8gdHJ1ZVxuICAgICAgICAgICAgc25hcFRvRmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFBhbmUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLiRzY3JvbGxQYW5lLnNjcm9sbFRvVmlldyhyZWN0LCBhbmksIHNuYXBUb0ZpcnN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuZ2V0Q2hpbGRBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2Nyb2xsUGFuZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuJHNjcm9sbFBhbmUuc2Nyb2xsVG9WaWV3KG9iaiwgYW5pLCBzbmFwVG9GaXJzdCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudCAhPSBudWxsICYmIHRoaXMucGFyZW50LnNjcm9sbFBhbmUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5zY3JvbGxQYW5lLnNjcm9sbFRvVmlldyhvYmosIGFuaSwgc25hcFRvRmlyc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEZpcnN0Q2hpbGRJblZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkSW5kZXhUb0l0ZW1JbmRleChzdXBlci5nZXRGaXJzdENoaWxkSW5WaWV3KCkpO1xuICAgIH1cbiAgICBjaGlsZEluZGV4VG9JdGVtSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiR2aXJ0dWFsKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICBpZiAodGhpcy4kbGF5b3V0ID09IDQgLyogUGFnaW5hdGlvbiAqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuJGZpcnN0SW5kZXg7IGkgPCB0aGlzLiRyZWFsTnVtSXRlbXM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiR2aXJ0dWFsSXRlbXNbaV0ub2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ICs9IHRoaXMuJGZpcnN0SW5kZXg7XG4gICAgICAgICAgICBpZiAodGhpcy4kbG9vcCAmJiB0aGlzLiRudW1JdGVtcyA+IDApXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCAlIHRoaXMuJG51bUl0ZW1zO1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGl0ZW1JbmRleFRvQ2hpbGRJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuJHZpcnR1YWwpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIGlmICh0aGlzLiRsYXlvdXQgPT0gNCAvKiBQYWdpbmF0aW9uICovKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRJbmRleCh0aGlzLiR2aXJ0dWFsSXRlbXNbaW5kZXhdLm9iaik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGxvb3AgJiYgdGhpcy4kbnVtSXRlbXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaiA9IHRoaXMuJGZpcnN0SW5kZXggJSB0aGlzLiRudW1JdGVtcztcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gailcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLiRmaXJzdEluZGV4ICsgKGluZGV4IC0gaik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuJGZpcnN0SW5kZXggKyB0aGlzLiRudW1JdGVtcyArIChqIC0gaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGluZGV4IC09IHRoaXMuJGZpcnN0SW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VmlydHVhbCgpIHtcbiAgICAgICAgdGhpcy4kc2V0VmlydHVhbChmYWxzZSk7XG4gICAgfVxuICAgIHNldFZpcnR1YWxBbmRMb29wKCkge1xuICAgICAgICB0aGlzLiRzZXRWaXJ0dWFsKHRydWUpO1xuICAgIH1cbiAgICAkc2V0VmlydHVhbChsb29wKSB7XG4gICAgICAgIGlmICghdGhpcy4kdmlydHVhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFBhbmUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpcnR1YWwgbGlzdCBtdXN0IGJlIHNjcm9sbGFibGUnKTtcbiAgICAgICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGxheW91dCA9PSAyIC8qIEZsb3dIb3Jpem9udGFsICovIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxheW91dCA9PSAzIC8qIEZsb3dWZXJ0aWNhbCAqLylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWaXJ0dWFsIGxpc3Qgd2l0aCBsb29wIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBmb3IgYm90aCBGbG93SG9yaXpvbnRhbCBhbmQgRmxvd1ZlcnRpY2FsIGxheW91dCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHNjcm9sbFBhbmUuYm91bmNlYmFja0VmZmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kdmlydHVhbCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiRsb29wID0gbG9vcDtcbiAgICAgICAgICAgIHRoaXMuJHZpcnR1YWxJdGVtcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZHJlblRvUG9vbCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGl0ZW1TaXplID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtU2l6ZSA9IG5ldyBjcmVhdGVqcy5Qb2ludCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuZ2V0RnJvbVBvb2wobnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpcnR1YWwgbGlzdCBtdXN0IGhhdmUgYSBkZWZhdWx0IGxpc3QgaXRlbSByZXNvdXJjZSBzcGVjaWZpZWQgdGhyb3VnaCBsaXN0LmRlZmF1bHRJdGVtID0gcmVzVXJsLicpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRpdGVtU2l6ZS54ID0gb2JqLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRpdGVtU2l6ZS55ID0gb2JqLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZXR1cm5Ub1Bvb2wob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRsYXlvdXQgPT0gMCAvKiBTaW5nbGVDb2x1bW4gKi8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLiRsYXlvdXQgPT0gMiAvKiBGbG93SG9yaXpvbnRhbCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuJHNjcm9sbFBhbmUuc2Nyb2xsU3BlZWQgPSB0aGlzLiRpdGVtU2l6ZS55O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRsb29wKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRzY3JvbGxQYW5lLiRsb29wID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJHNjcm9sbFBhbmUuc2Nyb2xsU3BlZWQgPSB0aGlzLiRpdGVtU2l6ZS54O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRsb29wKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRzY3JvbGxQYW5lLiRsb29wID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHNjcm9sbFBhbmUub24oXCJfX3Njcm9sbFwiIC8qIFNDUk9MTCAqLywgdGhpcy4kc2Nyb2xsZWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXRWaXJ0dWFsTGlzdENoYW5nZWRGbGFnKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBudW1JdGVtcygpIHtcbiAgICAgICAgaWYgKHRoaXMuJHZpcnR1YWwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kbnVtSXRlbXM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgfVxuICAgIHNldCBudW1JdGVtcyh2YWx1ZSkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKHRoaXMuJHZpcnR1YWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1SZW5kZXJlciA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGlzdC5pdGVtUmVuZGVyZXIgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHRoaXMuJG51bUl0ZW1zID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy4kbG9vcClcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWFsTnVtSXRlbXMgPSB0aGlzLiRudW1JdGVtcyAqIDY7XG4gICAgICAgICAgICAvL2VubGFyZ2UgZm9yIGxvb3BcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWFsTnVtSXRlbXMgPSB0aGlzLiRudW1JdGVtcztcbiAgICAgICAgICAgIC8vaW5jcmVhc2Ugb25seVxuICAgICAgICAgICAgY29uc3Qgb2xkQ291bnQgPSB0aGlzLiR2aXJ0dWFsSXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHJlYWxOdW1JdGVtcyA+IG9sZENvdW50KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gb2xkQ291bnQ7IGkgPCB0aGlzLiRyZWFsTnVtSXRlbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWkgPSBuZXcgSXRlbUluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgaWkud2lkdGggPSB0aGlzLiRpdGVtU2l6ZS54O1xuICAgICAgICAgICAgICAgICAgICBpaS5oZWlnaHQgPSB0aGlzLiRpdGVtU2l6ZS55O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR2aXJ0dWFsSXRlbXMucHVzaChpaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gdGhpcy4kcmVhbE51bUl0ZW1zOyBpIDwgb2xkQ291bnQ7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdmlydHVhbEl0ZW1zW2ldLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kdmlydHVhbExpc3RDaGFuZ2VkICE9IDAgLyogTm9uZSAqLylcbiAgICAgICAgICAgICAgICBHVGltZXIuaW5zdC5yZW1vdmUodGhpcy4kcmVmcmVzaFZpcnR1YWxMaXN0LCB0aGlzKTtcbiAgICAgICAgICAgIC8vcmVmcmVzaCBub3dcbiAgICAgICAgICAgIHRoaXMuJHJlZnJlc2hWaXJ0dWFsTGlzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY250ID0gdGhpcy4kY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gY250KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gY250OyBpIDwgdmFsdWU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtUHJvdmlkZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUZyb21Qb29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUZyb21Qb29sKHRoaXMuaXRlbVByb3ZpZGVyKGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZHJlblRvUG9vbCh2YWx1ZSwgY250KTtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1SZW5kZXJlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbVJlbmRlcmVyKGksIHRoaXMuZ2V0Q2hpbGRBdChpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmcmVzaFZpcnR1YWxMaXN0KCkge1xuICAgICAgICB0aGlzLnNldFZpcnR1YWxMaXN0Q2hhbmdlZEZsYWcoZmFsc2UpO1xuICAgIH1cbiAgICBjaGVja1ZpcnR1YWxMaXN0KCkge1xuICAgICAgICBpZiAodGhpcy4kdmlydHVhbExpc3RDaGFuZ2VkICE9IDAgLyogTm9uZSAqLykge1xuICAgICAgICAgICAgdGhpcy4kcmVmcmVzaFZpcnR1YWxMaXN0KCk7XG4gICAgICAgICAgICBHVGltZXIuaW5zdC5yZW1vdmUodGhpcy4kcmVmcmVzaFZpcnR1YWxMaXN0LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRWaXJ0dWFsTGlzdENoYW5nZWRGbGFnKGxheW91dENoYW5nZWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAobGF5b3V0Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuJHZpcnR1YWxMaXN0Q2hhbmdlZCA9IDIgLyogU2l6ZUNoYW5nZWQgKi87XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJHZpcnR1YWxMaXN0Q2hhbmdlZCA9PSAwIC8qIE5vbmUgKi8pXG4gICAgICAgICAgICB0aGlzLiR2aXJ0dWFsTGlzdENoYW5nZWQgPSAxIC8qIENvbnRlbnRDaGFuZ2VkICovO1xuICAgICAgICBHVGltZXIuaW5zdC5jYWxsTGF0ZXIodGhpcy4kcmVmcmVzaFZpcnR1YWxMaXN0LCB0aGlzKTtcbiAgICB9XG4gICAgJHJlZnJlc2hWaXJ0dWFsTGlzdCgpIHtcbiAgICAgICAgY29uc3QgbGF5b3V0Q2hhbmdlZCA9IHRoaXMuJHZpcnR1YWxMaXN0Q2hhbmdlZCA9PSAyIC8qIFNpemVDaGFuZ2VkICovO1xuICAgICAgICB0aGlzLiR2aXJ0dWFsTGlzdENoYW5nZWQgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgIHRoaXMuJGV2ZW50TG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxheW91dENoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRsYXlvdXQgPT0gMCAvKiBTaW5nbGVDb2x1bW4gKi8gfHwgdGhpcy4kbGF5b3V0ID09IDEgLyogU2luZ2xlUm93ICovKVxuICAgICAgICAgICAgICAgIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQgPSAxO1xuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4kbGF5b3V0ID09IDIgLyogRmxvd0hvcml6b250YWwgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kY29sdW1uQ291bnQgPiAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjdXJMaW5lSXRlbUNvdW50ID0gdGhpcy4kY29sdW1uQ291bnQ7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQgPSBNYXRoLmZsb29yKCh0aGlzLiRzY3JvbGxQYW5lLnZpZXdXaWR0aCArIHRoaXMuJGNvbHVtbkdhcCkgLyAodGhpcy4kaXRlbVNpemUueCArIHRoaXMuJGNvbHVtbkdhcCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kY3VyTGluZUl0ZW1Db3VudCA8PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kY3VyTGluZUl0ZW1Db3VudCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4kbGF5b3V0ID09IDMgLyogRmxvd1ZlcnRpY2FsICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGxpbmVDb3VudCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQgPSB0aGlzLiRsaW5lQ291bnQ7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQgPSBNYXRoLmZsb29yKCh0aGlzLiRzY3JvbGxQYW5lLnZpZXdIZWlnaHQgKyB0aGlzLiRsaW5lR2FwKSAvICh0aGlzLiRpdGVtU2l6ZS55ICsgdGhpcy4kbGluZUdhcCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kY3VyTGluZUl0ZW1Db3VudCA8PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kY3VyTGluZUl0ZW1Db3VudCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvL3BhZ2luYXRpb25cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRjb2x1bW5Db3VudCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQgPSB0aGlzLiRjb2x1bW5Db3VudDtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY3VyTGluZUl0ZW1Db3VudCA9IE1hdGguZmxvb3IoKHRoaXMuJHNjcm9sbFBhbmUudmlld1dpZHRoICsgdGhpcy4kY29sdW1uR2FwKSAvICh0aGlzLiRpdGVtU2l6ZS54ICsgdGhpcy4kY29sdW1uR2FwKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRjdXJMaW5lSXRlbUNvdW50IDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjdXJMaW5lSXRlbUNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGxpbmVDb3VudCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQyID0gdGhpcy4kbGluZUNvdW50O1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjdXJMaW5lSXRlbUNvdW50MiA9IE1hdGguZmxvb3IoKHRoaXMuJHNjcm9sbFBhbmUudmlld0hlaWdodCArIHRoaXMuJGxpbmVHYXApIC8gKHRoaXMuJGl0ZW1TaXplLnkgKyB0aGlzLiRsaW5lR2FwKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRjdXJMaW5lSXRlbUNvdW50MiA8PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kY3VyTGluZUl0ZW1Db3VudDIgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2ggPSAwLCBjdyA9IDA7XG4gICAgICAgIGlmICh0aGlzLiRyZWFsTnVtSXRlbXMgPiAwKSB7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLmNlaWwodGhpcy4kcmVhbE51bUl0ZW1zIC8gdGhpcy4kY3VyTGluZUl0ZW1Db3VudCkgKiB0aGlzLiRjdXJMaW5lSXRlbUNvdW50O1xuICAgICAgICAgICAgbGV0IGxlbjIgPSBNYXRoLm1pbih0aGlzLiRjdXJMaW5lSXRlbUNvdW50LCB0aGlzLiRyZWFsTnVtSXRlbXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGxheW91dCA9PSAwIC8qIFNpbmdsZUNvbHVtbiAqLyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuJGxheW91dCA9PSAyIC8qIEZsb3dIb3Jpem9udGFsICovKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSB0aGlzLiRjdXJMaW5lSXRlbUNvdW50KVxuICAgICAgICAgICAgICAgICAgICBjaCArPSB0aGlzLiR2aXJ0dWFsSXRlbXNbaV0uaGVpZ2h0ICsgdGhpcy4kbGluZUdhcDtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPiAwKVxuICAgICAgICAgICAgICAgICAgICBjaCAtPSB0aGlzLiRsaW5lR2FwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRhdXRvUmVzaXplSXRlbSlcbiAgICAgICAgICAgICAgICAgICAgY3cgPSB0aGlzLiRzY3JvbGxQYW5lLnZpZXdXaWR0aDtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjI7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGN3ICs9IHRoaXMuJHZpcnR1YWxJdGVtc1tpXS53aWR0aCArIHRoaXMuJGNvbHVtbkdhcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN3ID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGN3IC09IHRoaXMuJGNvbHVtbkdhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRsYXlvdXQgPT0gMSAvKiBTaW5nbGVSb3cgKi8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLiRsYXlvdXQgPT0gMyAvKiBGbG93VmVydGljYWwgKi8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IHRoaXMuJGN1ckxpbmVJdGVtQ291bnQpXG4gICAgICAgICAgICAgICAgICAgIGN3ICs9IHRoaXMuJHZpcnR1YWxJdGVtc1tpXS53aWR0aCArIHRoaXMuJGNvbHVtbkdhcDtcbiAgICAgICAgICAgICAgICBpZiAoY3cgPiAwKVxuICAgICAgICAgICAgICAgICAgICBjdyAtPSB0aGlzLiRjb2x1bW5HYXA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGF1dG9SZXNpemVJdGVtKVxuICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuJHNjcm9sbFBhbmUudmlld0hlaWdodDtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjI7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoICs9IHRoaXMuJHZpcnR1YWxJdGVtc1tpXS5oZWlnaHQgKyB0aGlzLiRsaW5lR2FwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2ggLT0gdGhpcy4kbGluZUdhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlQ291bnQgPSBNYXRoLmNlaWwobGVuIC8gKHRoaXMuJGN1ckxpbmVJdGVtQ291bnQgKiB0aGlzLiRjdXJMaW5lSXRlbUNvdW50MikpO1xuICAgICAgICAgICAgICAgIGN3ID0gcGFnZUNvdW50ICogdGhpcy52aWV3V2lkdGg7XG4gICAgICAgICAgICAgICAgY2ggPSB0aGlzLnZpZXdIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVBbGlnbihjdywgY2gpO1xuICAgICAgICB0aGlzLiRzY3JvbGxQYW5lLnNldENvbnRlbnRTaXplKGN3LCBjaCk7XG4gICAgICAgIHRoaXMuJGV2ZW50TG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsKHRydWUpO1xuICAgIH1cbiAgICAkc2Nyb2xsZWQoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsKGZhbHNlKTtcbiAgICB9XG4gICAgZ2V0SW5kZXhPblBvczEoZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuJHJlYWxOdW1JdGVtcyA8IHRoaXMuJGN1ckxpbmVJdGVtQ291bnQpIHtcbiAgICAgICAgICAgIEdMaXN0LiRsYXN0UG9zSGVscGVyID0gMDtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgcG9zMjtcbiAgICAgICAgbGV0IHBvczM7XG4gICAgICAgIGlmICh0aGlzLm51bUNoaWxkcmVuID4gMCAmJiAhZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgICAgIHBvczIgPSB0aGlzLmdldENoaWxkQXQoMCkueTtcbiAgICAgICAgICAgIGlmIChwb3MyID4gR0xpc3QuJGxhc3RQb3NIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSB0aGlzLiRmaXJzdEluZGV4IC0gdGhpcy4kY3VyTGluZUl0ZW1Db3VudDsgaSA+PSAwOyBpIC09IHRoaXMuJGN1ckxpbmVJdGVtQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zMiAtPSB0aGlzLiR2aXJ0dWFsSXRlbXNbaV0uaGVpZ2h0ICsgdGhpcy4kbGluZUdhcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvczIgPD0gR0xpc3QuJGxhc3RQb3NIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEdMaXN0LiRsYXN0UG9zSGVscGVyID0gcG9zMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEdMaXN0LiRsYXN0UG9zSGVscGVyID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuJGZpcnN0SW5kZXg7IGkgPCB0aGlzLiRyZWFsTnVtSXRlbXM7IGkgKz0gdGhpcy4kY3VyTGluZUl0ZW1Db3VudCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MzID0gcG9zMiArIHRoaXMuJHZpcnR1YWxJdGVtc1tpXS5oZWlnaHQgKyB0aGlzLiRsaW5lR2FwO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zMyA+IEdMaXN0LiRsYXN0UG9zSGVscGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBHTGlzdC4kbGFzdFBvc0hlbHBlciA9IHBvczI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3MyID0gcG9zMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgR0xpc3QuJGxhc3RQb3NIZWxwZXIgPSBwb3MyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRyZWFsTnVtSXRlbXMgLSB0aGlzLiRjdXJMaW5lSXRlbUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zMiA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy4kcmVhbE51bUl0ZW1zOyBpICs9IHRoaXMuJGN1ckxpbmVJdGVtQ291bnQpIHtcbiAgICAgICAgICAgICAgICBwb3MzID0gcG9zMiArIHRoaXMuJHZpcnR1YWxJdGVtc1tpXS5oZWlnaHQgKyB0aGlzLiRsaW5lR2FwO1xuICAgICAgICAgICAgICAgIGlmIChwb3MzID4gR0xpc3QuJGxhc3RQb3NIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgR0xpc3QuJGxhc3RQb3NIZWxwZXIgPSBwb3MyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zMiA9IHBvczM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBHTGlzdC4kbGFzdFBvc0hlbHBlciA9IHBvczI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcmVhbE51bUl0ZW1zIC0gdGhpcy4kY3VyTGluZUl0ZW1Db3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJbmRleE9uUG9zMihmb3JjZVVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy4kcmVhbE51bUl0ZW1zIDwgdGhpcy4kY3VyTGluZUl0ZW1Db3VudCkge1xuICAgICAgICAgICAgR0xpc3QuJGxhc3RQb3NIZWxwZXIgPSAwO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBwb3MyO1xuICAgICAgICBsZXQgcG9zMztcbiAgICAgICAgaWYgKHRoaXMubnVtQ2hpbGRyZW4gPiAwICYmICFmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgcG9zMiA9IHRoaXMuZ2V0Q2hpbGRBdCgwKS54O1xuICAgICAgICAgICAgaWYgKHBvczIgPiBHTGlzdC4kbGFzdFBvc0hlbHBlcikge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuJGZpcnN0SW5kZXggLSB0aGlzLiRjdXJMaW5lSXRlbUNvdW50OyBpID49IDA7IGkgLT0gdGhpcy4kY3VyTGluZUl0ZW1Db3VudCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MyIC09IHRoaXMuJHZpcnR1YWxJdGVtc1tpXS53aWR0aCArIHRoaXMuJGNvbHVtbkdhcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvczIgPD0gR0xpc3QuJGxhc3RQb3NIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEdMaXN0LiRsYXN0UG9zSGVscGVyID0gcG9zMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEdMaXN0LiRsYXN0UG9zSGVscGVyID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuJGZpcnN0SW5kZXg7IGkgPCB0aGlzLiRyZWFsTnVtSXRlbXM7IGkgKz0gdGhpcy4kY3VyTGluZUl0ZW1Db3VudCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MzID0gcG9zMiArIHRoaXMuJHZpcnR1YWxJdGVtc1tpXS53aWR0aCArIHRoaXMuJGNvbHVtbkdhcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvczMgPiBHTGlzdC4kbGFzdFBvc0hlbHBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgR0xpc3QuJGxhc3RQb3NIZWxwZXIgPSBwb3MyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zMiA9IHBvczM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEdMaXN0LiRsYXN0UG9zSGVscGVyID0gcG9zMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcmVhbE51bUl0ZW1zIC0gdGhpcy4kY3VyTGluZUl0ZW1Db3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvczIgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuJHJlYWxOdW1JdGVtczsgaSArPSB0aGlzLiRjdXJMaW5lSXRlbUNvdW50KSB7XG4gICAgICAgICAgICAgICAgcG9zMyA9IHBvczIgKyB0aGlzLiR2aXJ0dWFsSXRlbXNbaV0ud2lkdGggKyB0aGlzLiRjb2x1bW5HYXA7XG4gICAgICAgICAgICAgICAgaWYgKHBvczMgPiBHTGlzdC4kbGFzdFBvc0hlbHBlcikge1xuICAgICAgICAgICAgICAgICAgICBHTGlzdC4kbGFzdFBvc0hlbHBlciA9IHBvczI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MyID0gcG9zMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdMaXN0LiRsYXN0UG9zSGVscGVyID0gcG9zMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRyZWFsTnVtSXRlbXMgLSB0aGlzLiRjdXJMaW5lSXRlbUNvdW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEluZGV4T25Qb3MzKGZvcmNlVXBkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLiRyZWFsTnVtSXRlbXMgPCB0aGlzLiRjdXJMaW5lSXRlbUNvdW50KSB7XG4gICAgICAgICAgICBHTGlzdC4kbGFzdFBvc0hlbHBlciA9IDA7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWV3V2lkdGggPSB0aGlzLnZpZXdXaWR0aDtcbiAgICAgICAgY29uc3QgcGFnZSA9IE1hdGguZmxvb3IoR0xpc3QuJGxhc3RQb3NIZWxwZXIgLyB2aWV3V2lkdGgpO1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gcGFnZSAqICh0aGlzLiRjdXJMaW5lSXRlbUNvdW50ICogdGhpcy4kY3VyTGluZUl0ZW1Db3VudDIpO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IHBvczM7XG4gICAgICAgIGxldCBwb3MyID0gcGFnZSAqIHZpZXdXaWR0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuJGN1ckxpbmVJdGVtQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgcG9zMyA9IHBvczIgKyB0aGlzLiR2aXJ0dWFsSXRlbXNbc3RhcnRJbmRleCArIGldLndpZHRoICsgdGhpcy4kY29sdW1uR2FwO1xuICAgICAgICAgICAgaWYgKHBvczMgPiBHTGlzdC4kbGFzdFBvc0hlbHBlcikge1xuICAgICAgICAgICAgICAgIEdMaXN0LiRsYXN0UG9zSGVscGVyID0gcG9zMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmRleCArIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MyID0gcG9zMztcbiAgICAgICAgfVxuICAgICAgICBHTGlzdC4kbGFzdFBvc0hlbHBlciA9IHBvczI7XG4gICAgICAgIHJldHVybiBzdGFydEluZGV4ICsgdGhpcy4kY3VyTGluZUl0ZW1Db3VudCAtIDE7XG4gICAgfVxuICAgIGhhbmRsZVNjcm9sbChmb3JjZVVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy4kZXZlbnRMb2NrZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJGVudGVyQ291bnRlciA9IDA7XG4gICAgICAgIGlmICh0aGlzLiRsYXlvdXQgPT0gMCAvKiBTaW5nbGVDb2x1bW4gKi8gfHxcbiAgICAgICAgICAgIHRoaXMuJGxheW91dCA9PSAyIC8qIEZsb3dIb3Jpem9udGFsICovKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbDEoZm9yY2VVcGRhdGUpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBcmNoT3JkZXIxKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy4kbGF5b3V0ID09IDEgLyogU2luZ2xlUm93ICovIHx8XG4gICAgICAgICAgICB0aGlzLiRsYXlvdXQgPT0gMyAvKiBGbG93VmVydGljYWwgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsMihmb3JjZVVwZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUFyY2hPcmRlcjIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbDMoZm9yY2VVcGRhdGUpO1xuICAgICAgICB0aGlzLiRib3VuZHNDaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIGhhbmRsZVNjcm9sbDEoZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgdGhpcy4kZW50ZXJDb3VudGVyKys7XG4gICAgICAgIGlmICh0aGlzLiRlbnRlckNvdW50ZXIgPiAzKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoaXMgbGlzdCB2aWV3IGNhbm5vdCBiZSBmaWxsZWQgZnVsbCBhcyB0aGUgaXRlbVJlbmRlcmVyIGZ1bmN0aW9uIGFsd2F5cyByZXR1cm5zIGFuIGl0ZW0gd2l0aCBkaWZmZXJlbnQgc2l6ZS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9zID0gdGhpcy4kc2Nyb2xsUGFuZS5zY3JvbGxpbmdQb3NZO1xuICAgICAgICBsZXQgbWF4ID0gcG9zICsgdGhpcy4kc2Nyb2xsUGFuZS52aWV3SGVpZ2h0O1xuICAgICAgICBjb25zdCBlbmQgPSBtYXggPT0gdGhpcy4kc2Nyb2xsUGFuZS5jb250ZW50SGVpZ2h0OyAvL2luZGljYXRlcyB3ZSBuZWVkIHRvIHNjcm9sbCB0byBlbmQgaW4gc3BpdGUgb2YgY29udGVudCBzaXplIGNoYW5naW5nXG4gICAgICAgIC8vZmluZCB0aGUgZmlyc3QgaXRlbSBmcm9tIGN1cnJlbnQgcG9zXG4gICAgICAgIEdMaXN0LiRsYXN0UG9zSGVscGVyID0gcG9zO1xuICAgICAgICBjb25zdCBuZXdGaXJzdEluZGV4ID0gdGhpcy5nZXRJbmRleE9uUG9zMShmb3JjZVVwZGF0ZSk7XG4gICAgICAgIGlmIChuZXdGaXJzdEluZGV4ID09IHRoaXMuJGZpcnN0SW5kZXggJiYgIWZvcmNlVXBkYXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwb3MgPSBHTGlzdC4kbGFzdFBvc0hlbHBlcjtcbiAgICAgICAgY29uc3Qgb2xkRmlyc3RJbmRleCA9IHRoaXMuJGZpcnN0SW5kZXg7XG4gICAgICAgIHRoaXMuJGZpcnN0SW5kZXggPSBuZXdGaXJzdEluZGV4O1xuICAgICAgICBsZXQgY3VySW5kZXggPSBuZXdGaXJzdEluZGV4O1xuICAgICAgICBjb25zdCBmb3J3YXJkID0gb2xkRmlyc3RJbmRleCA+IG5ld0ZpcnN0SW5kZXg7XG4gICAgICAgIGNvbnN0IG9sZENvdW50ID0gdGhpcy5udW1DaGlsZHJlbjtcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gb2xkRmlyc3RJbmRleCArIG9sZENvdW50IC0gMTtcbiAgICAgICAgbGV0IHJldXNlSW5kZXggPSBmb3J3YXJkID8gbGFzdEluZGV4IDogb2xkRmlyc3RJbmRleDtcbiAgICAgICAgbGV0IGN1clggPSAwLCBjdXJZID0gcG9zO1xuICAgICAgICBsZXQgbmVlZFJlbmRlcjtcbiAgICAgICAgbGV0IGRlbHRhU2l6ZSA9IDA7XG4gICAgICAgIGxldCBmaXJzdEl0ZW1EZWx0YVNpemUgPSAwO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy5kZWZhdWx0SXRlbTtcbiAgICAgICAgbGV0IGlpLCBpaTI7XG4gICAgICAgIGxldCBpLCBqO1xuICAgICAgICBjb25zdCBwYXJ0U2l6ZSA9ICh0aGlzLiRzY3JvbGxQYW5lLnZpZXdXaWR0aCAtIHRoaXMuJGNvbHVtbkdhcCAqICh0aGlzLiRjdXJMaW5lSXRlbUNvdW50IC0gMSkpIC9cbiAgICAgICAgICAgIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQ7XG4gICAgICAgIHRoaXMuJGl0ZW1JbmZvVmVyKys7XG4gICAgICAgIHdoaWxlIChjdXJJbmRleCA8IHRoaXMuJHJlYWxOdW1JdGVtcyAmJiAoZW5kIHx8IGN1clkgPCBtYXgpKSB7XG4gICAgICAgICAgICBpaSA9IHRoaXMuJHZpcnR1YWxJdGVtc1tjdXJJbmRleF07XG4gICAgICAgICAgICBpZiAoaWkub2JqID09IG51bGwgfHwgZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtUHJvdmlkZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLml0ZW1Qcm92aWRlcihjdXJJbmRleCAlIHRoaXMuJG51bUl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdGhpcy4kZGVmYXVsdEl0ZW07XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFVJUGFja2FnZS5ub3JtYWxpemVVUkwodXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlpLm9iaiAhPSBudWxsICYmIGlpLm9iai5yZXNvdXJjZVVSTCAhPSB1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlpLm9iaiBpbnN0YW5jZW9mIEdCdXR0b24pXG4gICAgICAgICAgICAgICAgICAgICAgICBpaS5zZWxlY3RlZCA9IGlpLm9iai5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZFRvUG9vbChpaS5vYmopO1xuICAgICAgICAgICAgICAgICAgICBpaS5vYmogPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpaS5vYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vc2VhcmNoIGZvciBhIG1vc3Qgc3VpdGFibGUgaXRlbSB0byByZXVzZSBpbiBvcmRlciB0byByZW5kZXIgb3IgY3JlYXRlIGxlc3MgaXRlbSB3aGVuIHJlZnJlc2hcbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSByZXVzZUluZGV4OyBqID49IG9sZEZpcnN0SW5kZXg7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWkyID0gdGhpcy4kdmlydHVhbEl0ZW1zW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlpMi5vYmogIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlpMi51cGRhdGVGbGFnICE9IHRoaXMuJGl0ZW1JbmZvVmVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWkyLm9iai5yZXNvdXJjZVVSTCA9PSB1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWkyLm9iaiBpbnN0YW5jZW9mIEdCdXR0b24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlpMi5zZWxlY3RlZCA9IGlpMi5vYmouc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWkub2JqID0gaWkyLm9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpaTIub2JqID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSByZXVzZUluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXVzZUluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IHJldXNlSW5kZXg7IGogPD0gbGFzdEluZGV4OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlpMiA9IHRoaXMuJHZpcnR1YWxJdGVtc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpaTIub2JqICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpaTIudXBkYXRlRmxhZyAhPSB0aGlzLiRpdGVtSW5mb1ZlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlpMi5vYmoucmVzb3VyY2VVUkwgPT0gdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlpMi5vYmogaW5zdGFuY2VvZiBHQnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpaTIuc2VsZWN0ZWQgPSBpaTIub2JqLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlpLm9iaiA9IGlpMi5vYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWkyLm9iaiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gcmV1c2VJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV1c2VJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpaS5vYmogIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDaGlsZEluZGV4KGlpLm9iaiwgZm9yd2FyZCA/IGN1ckluZGV4IC0gbmV3Rmlyc3RJbmRleCA6IHRoaXMubnVtQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpaS5vYmogPSB0aGlzLiRwb29sLmdldCh1cmwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGRBdChpaS5vYmosIGN1ckluZGV4IC0gbmV3Rmlyc3RJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoaWkub2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlpLm9iaiBpbnN0YW5jZW9mIEdCdXR0b24pXG4gICAgICAgICAgICAgICAgICAgIGlpLm9iai5zZWxlY3RlZCA9IGlpLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgIG5lZWRSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5lZWRSZW5kZXIgPSBmb3JjZVVwZGF0ZTtcbiAgICAgICAgICAgIGlmIChuZWVkUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGF1dG9SZXNpemVJdGVtICYmXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLiRsYXlvdXQgPT0gMCAvKiBTaW5nbGVDb2x1bW4gKi8gfHwgdGhpcy4kY29sdW1uQ291bnQgPiAwKSlcbiAgICAgICAgICAgICAgICAgICAgaWkub2JqLnNldFNpemUocGFydFNpemUsIGlpLm9iai5oZWlnaHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbVJlbmRlcmVyKGN1ckluZGV4ICUgdGhpcy4kbnVtSXRlbXMsIGlpLm9iaik7XG4gICAgICAgICAgICAgICAgaWYgKGN1ckluZGV4ICUgdGhpcy4kY3VyTGluZUl0ZW1Db3VudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhU2l6ZSArPSBNYXRoLmNlaWwoaWkub2JqLmhlaWdodCkgLSBpaS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJJbmRleCA9PSBuZXdGaXJzdEluZGV4ICYmIG9sZEZpcnN0SW5kZXggPiBuZXdGaXJzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3doZW4gc2Nyb2xsaW5nIGRvd24sIHdlIG5lZWQgdG8gbWFrZSBjb21wZW5zYXRpb24gZm9yIHRoZSBwb3NpdGlvbiB0byBhdm9pZCBmbGlja2VyaW5nIGlmIHRoZSBpdGVtJ3Mgc2l6ZSBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEl0ZW1EZWx0YVNpemUgPSBNYXRoLmNlaWwoaWkub2JqLmhlaWdodCkgLSBpaS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkud2lkdGggPSBNYXRoLmNlaWwoaWkub2JqLndpZHRoKTtcbiAgICAgICAgICAgICAgICBpaS5oZWlnaHQgPSBNYXRoLmNlaWwoaWkub2JqLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaS51cGRhdGVGbGFnID0gdGhpcy4kaXRlbUluZm9WZXI7XG4gICAgICAgICAgICBpaS5vYmouc2V0WFkoY3VyWCwgY3VyWSk7XG4gICAgICAgICAgICBpZiAoY3VySW5kZXggPT0gbmV3Rmlyc3RJbmRleClcbiAgICAgICAgICAgICAgICAvL3BhZCBvbmUgbW9yZVxuICAgICAgICAgICAgICAgIG1heCArPSBpaS5oZWlnaHQ7XG4gICAgICAgICAgICBjdXJYICs9IGlpLndpZHRoICsgdGhpcy4kY29sdW1uR2FwO1xuICAgICAgICAgICAgaWYgKGN1ckluZGV4ICUgdGhpcy4kY3VyTGluZUl0ZW1Db3VudCA9PSB0aGlzLiRjdXJMaW5lSXRlbUNvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgIGN1clggPSAwO1xuICAgICAgICAgICAgICAgIGN1clkgKz0gaWkuaGVpZ2h0ICsgdGhpcy4kbGluZUdhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ckluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9sZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlpID0gdGhpcy4kdmlydHVhbEl0ZW1zW29sZEZpcnN0SW5kZXggKyBpXTtcbiAgICAgICAgICAgIGlmIChpaS51cGRhdGVGbGFnICE9IHRoaXMuJGl0ZW1JbmZvVmVyICYmIGlpLm9iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlpLm9iaiBpbnN0YW5jZW9mIEdCdXR0b24pXG4gICAgICAgICAgICAgICAgICAgIGlpLnNlbGVjdGVkID0gaWkub2JqLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGRUb1Bvb2woaWkub2JqKTtcbiAgICAgICAgICAgICAgICBpaS5vYmogPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YVNpemUgIT0gMCB8fCBmaXJzdEl0ZW1EZWx0YVNpemUgIT0gMClcbiAgICAgICAgICAgIHRoaXMuJHNjcm9sbFBhbmUuY2hhbmdlQ29udGVudFNpemVPblNjcm9sbGluZygwLCBkZWx0YVNpemUsIDAsIGZpcnN0SXRlbURlbHRhU2l6ZSk7XG4gICAgICAgIGlmIChjdXJJbmRleCA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMubnVtQ2hpbGRyZW4gPiAwICYmXG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIueSA8IDAgJiZcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2hpbGRBdCgwKS55ID4gLXRoaXMuJGNvbnRhaW5lci55KVxuICAgICAgICAgICAgLy9sYXN0IHBhZ2UgaXMgbm90IGZ1bGxcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsMShmYWxzZSk7IC8vcmVjdXJzaXZlXG4gICAgfVxuICAgIGhhbmRsZVNjcm9sbDIoZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgdGhpcy4kZW50ZXJDb3VudGVyKys7XG4gICAgICAgIGlmICh0aGlzLiRlbnRlckNvdW50ZXIgPiAzKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoaXMgbGlzdCB2aWV3IGNhbm5vdCBiZSBmaWxsZWQgZnVsbCBhcyB0aGUgaXRlbVJlbmRlcmVyIGZ1bmN0aW9uIGFsd2F5cyByZXR1cm5zIGFuIGl0ZW0gd2l0aCBkaWZmZXJlbnQgc2l6ZS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9zID0gdGhpcy4kc2Nyb2xsUGFuZS5zY3JvbGxpbmdQb3NYO1xuICAgICAgICBsZXQgbWF4ID0gcG9zICsgdGhpcy4kc2Nyb2xsUGFuZS52aWV3V2lkdGg7XG4gICAgICAgIGNvbnN0IGVuZCA9IHBvcyA9PSB0aGlzLiRzY3JvbGxQYW5lLmNvbnRlbnRXaWR0aDtcbiAgICAgICAgR0xpc3QuJGxhc3RQb3NIZWxwZXIgPSBwb3M7XG4gICAgICAgIGNvbnN0IG5ld0ZpcnN0SW5kZXggPSB0aGlzLmdldEluZGV4T25Qb3MyKGZvcmNlVXBkYXRlKTtcbiAgICAgICAgaWYgKG5ld0ZpcnN0SW5kZXggPT0gdGhpcy4kZmlyc3RJbmRleCAmJiAhZm9yY2VVcGRhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBvcyA9IEdMaXN0LiRsYXN0UG9zSGVscGVyO1xuICAgICAgICBjb25zdCBvbGRGaXJzdEluZGV4ID0gdGhpcy4kZmlyc3RJbmRleDtcbiAgICAgICAgdGhpcy4kZmlyc3RJbmRleCA9IG5ld0ZpcnN0SW5kZXg7XG4gICAgICAgIGxldCBjdXJJbmRleCA9IG5ld0ZpcnN0SW5kZXg7XG4gICAgICAgIGNvbnN0IGZvcndhcmQgPSBvbGRGaXJzdEluZGV4ID4gbmV3Rmlyc3RJbmRleDtcbiAgICAgICAgY29uc3Qgb2xkQ291bnQgPSB0aGlzLm51bUNoaWxkcmVuO1xuICAgICAgICBsZXQgbGFzdEluZGV4ID0gb2xkRmlyc3RJbmRleCArIG9sZENvdW50IC0gMTtcbiAgICAgICAgbGV0IHJldXNlSW5kZXggPSBmb3J3YXJkID8gbGFzdEluZGV4IDogb2xkRmlyc3RJbmRleDtcbiAgICAgICAgbGV0IGN1clggPSBwb3MsIGN1clkgPSAwO1xuICAgICAgICBsZXQgbmVlZFJlbmRlcjtcbiAgICAgICAgbGV0IGRlbHRhU2l6ZSA9IDA7XG4gICAgICAgIGxldCBmaXJzdEl0ZW1EZWx0YVNpemUgPSAwO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy5kZWZhdWx0SXRlbTtcbiAgICAgICAgbGV0IGlpLCBpaTI7XG4gICAgICAgIGxldCBpLCBqO1xuICAgICAgICBjb25zdCBwYXJ0U2l6ZSA9ICh0aGlzLiRzY3JvbGxQYW5lLnZpZXdIZWlnaHQgLSB0aGlzLiRsaW5lR2FwICogKHRoaXMuJGN1ckxpbmVJdGVtQ291bnQgLSAxKSkgL1xuICAgICAgICAgICAgdGhpcy4kY3VyTGluZUl0ZW1Db3VudDtcbiAgICAgICAgdGhpcy4kaXRlbUluZm9WZXIrKztcbiAgICAgICAgd2hpbGUgKGN1ckluZGV4IDwgdGhpcy4kcmVhbE51bUl0ZW1zICYmIChlbmQgfHwgY3VyWCA8IG1heCkpIHtcbiAgICAgICAgICAgIGlpID0gdGhpcy4kdmlydHVhbEl0ZW1zW2N1ckluZGV4XTtcbiAgICAgICAgICAgIGlmIChpaS5vYmogPT0gbnVsbCB8fCBmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1Qcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuaXRlbVByb3ZpZGVyKGN1ckluZGV4ICUgdGhpcy4kbnVtSXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXJsID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLiRkZWZhdWx0SXRlbTtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gVUlQYWNrYWdlLm5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaWkub2JqICE9IG51bGwgJiYgaWkub2JqLnJlc291cmNlVVJMICE9IHVybCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWkub2JqIGluc3RhbmNlb2YgR0J1dHRvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGlpLnNlbGVjdGVkID0gaWkub2JqLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkVG9Qb29sKGlpLm9iaik7XG4gICAgICAgICAgICAgICAgICAgIGlpLm9iaiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlpLm9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gcmV1c2VJbmRleDsgaiA+PSBvbGRGaXJzdEluZGV4OyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlpMiA9IHRoaXMuJHZpcnR1YWxJdGVtc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpaTIub2JqICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpaTIudXBkYXRlRmxhZyAhPSB0aGlzLiRpdGVtSW5mb1ZlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlpMi5vYmoucmVzb3VyY2VVUkwgPT0gdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlpMi5vYmogaW5zdGFuY2VvZiBHQnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpaTIuc2VsZWN0ZWQgPSBpaTIub2JqLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlpLm9iaiA9IGlpMi5vYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWkyLm9iaiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gcmV1c2VJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV1c2VJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSByZXVzZUluZGV4OyBqIDw9IGxhc3RJbmRleDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpaTIgPSB0aGlzLiR2aXJ0dWFsSXRlbXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWkyLm9iaiAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWkyLnVwZGF0ZUZsYWcgIT0gdGhpcy4kaXRlbUluZm9WZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpaTIub2JqLnJlc291cmNlVVJMID09IHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpaTIub2JqIGluc3RhbmNlb2YgR0J1dHRvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWkyLnNlbGVjdGVkID0gaWkyLm9iai5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpaS5vYmogPSBpaTIub2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlpMi5vYmogPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID09IHJldXNlSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldXNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaWkub2JqICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2hpbGRJbmRleChpaS5vYmosIGZvcndhcmQgPyBjdXJJbmRleCAtIG5ld0ZpcnN0SW5kZXggOiB0aGlzLm51bUNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWkub2JqID0gdGhpcy4kcG9vbC5nZXQodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkQXQoaWkub2JqLCBjdXJJbmRleCAtIG5ld0ZpcnN0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKGlpLm9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpaS5vYmogaW5zdGFuY2VvZiBHQnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICBpaS5vYmouc2VsZWN0ZWQgPSBpaS5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICBuZWVkUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBuZWVkUmVuZGVyID0gZm9yY2VVcGRhdGU7XG4gICAgICAgICAgICBpZiAobmVlZFJlbmRlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRhdXRvUmVzaXplSXRlbSAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy4kbGF5b3V0ID09IDEgLyogU2luZ2xlUm93ICovIHx8IHRoaXMuJGxpbmVDb3VudCA+IDApKVxuICAgICAgICAgICAgICAgICAgICBpaS5vYmouc2V0U2l6ZShpaS5vYmoud2lkdGgsIHBhcnRTaXplLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1SZW5kZXJlcihjdXJJbmRleCAlIHRoaXMuJG51bUl0ZW1zLCBpaS5vYmopO1xuICAgICAgICAgICAgICAgIGlmIChjdXJJbmRleCAlIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVNpemUgKz0gTWF0aC5jZWlsKGlpLm9iai53aWR0aCkgLSBpaS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckluZGV4ID09IG5ld0ZpcnN0SW5kZXggJiYgb2xkRmlyc3RJbmRleCA+IG5ld0ZpcnN0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEl0ZW1EZWx0YVNpemUgPSBNYXRoLmNlaWwoaWkub2JqLndpZHRoKSAtIGlpLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaS53aWR0aCA9IE1hdGguY2VpbChpaS5vYmoud2lkdGgpO1xuICAgICAgICAgICAgICAgIGlpLmhlaWdodCA9IE1hdGguY2VpbChpaS5vYmouaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpLnVwZGF0ZUZsYWcgPSB0aGlzLiRpdGVtSW5mb1ZlcjtcbiAgICAgICAgICAgIGlpLm9iai5zZXRYWShjdXJYLCBjdXJZKTtcbiAgICAgICAgICAgIGlmIChjdXJJbmRleCA9PSBuZXdGaXJzdEluZGV4KVxuICAgICAgICAgICAgICAgIG1heCArPSBpaS53aWR0aDtcbiAgICAgICAgICAgIGN1clkgKz0gaWkuaGVpZ2h0ICsgdGhpcy4kbGluZUdhcDtcbiAgICAgICAgICAgIGlmIChjdXJJbmRleCAlIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQgPT0gdGhpcy4kY3VyTGluZUl0ZW1Db3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjdXJZID0gMDtcbiAgICAgICAgICAgICAgICBjdXJYICs9IGlpLndpZHRoICsgdGhpcy4kY29sdW1uR2FwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VySW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2xkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWkgPSB0aGlzLiR2aXJ0dWFsSXRlbXNbb2xkRmlyc3RJbmRleCArIGldO1xuICAgICAgICAgICAgaWYgKGlpLnVwZGF0ZUZsYWcgIT0gdGhpcy4kaXRlbUluZm9WZXIgJiYgaWkub2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWkub2JqIGluc3RhbmNlb2YgR0J1dHRvbilcbiAgICAgICAgICAgICAgICAgICAgaWkuc2VsZWN0ZWQgPSBpaS5vYmouc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZFRvUG9vbChpaS5vYmopO1xuICAgICAgICAgICAgICAgIGlpLm9iaiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbHRhU2l6ZSAhPSAwIHx8IGZpcnN0SXRlbURlbHRhU2l6ZSAhPSAwKVxuICAgICAgICAgICAgdGhpcy4kc2Nyb2xsUGFuZS5jaGFuZ2VDb250ZW50U2l6ZU9uU2Nyb2xsaW5nKGRlbHRhU2l6ZSwgMCwgZmlyc3RJdGVtRGVsdGFTaXplLCAwKTtcbiAgICAgICAgaWYgKGN1ckluZGV4ID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5udW1DaGlsZHJlbiA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci54IDwgMCAmJlxuICAgICAgICAgICAgdGhpcy5nZXRDaGlsZEF0KDApLnggPiAtdGhpcy4kY29udGFpbmVyLngpXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbDIoZmFsc2UpO1xuICAgIH1cbiAgICBoYW5kbGVTY3JvbGwzKGZvcmNlVXBkYXRlKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLiRzY3JvbGxQYW5lLnNjcm9sbGluZ1Bvc1g7XG4gICAgICAgIEdMaXN0LiRsYXN0UG9zSGVscGVyID0gcG9zO1xuICAgICAgICBjb25zdCBuZXdGaXJzdEluZGV4ID0gdGhpcy5nZXRJbmRleE9uUG9zMyhmb3JjZVVwZGF0ZSk7XG4gICAgICAgIGlmIChuZXdGaXJzdEluZGV4ID09IHRoaXMuJGZpcnN0SW5kZXggJiYgIWZvcmNlVXBkYXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwb3MgPSBHTGlzdC4kbGFzdFBvc0hlbHBlcjtcbiAgICAgICAgY29uc3Qgb2xkRmlyc3RJbmRleCA9IHRoaXMuJGZpcnN0SW5kZXg7XG4gICAgICAgIHRoaXMuJGZpcnN0SW5kZXggPSBuZXdGaXJzdEluZGV4O1xuICAgICAgICAvL2hlaWdodC1zeW5jIGlzIG5vdCBzdXBwb3J0ZWQgaW4gcGFnbmF0aW9uIG1vZGUsIHNvIGp1c3Qgb25seSByZW5kZXIgMSBwYWdlXG4gICAgICAgIGxldCByZXVzZUluZGV4ID0gb2xkRmlyc3RJbmRleDtcbiAgICAgICAgY29uc3QgdmlydHVhbEl0ZW1Db3VudCA9IHRoaXMuJHZpcnR1YWxJdGVtcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHBhZ2VTaXplID0gdGhpcy4kY3VyTGluZUl0ZW1Db3VudCAqIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQyO1xuICAgICAgICBjb25zdCBzdGFydENvbCA9IG5ld0ZpcnN0SW5kZXggJSB0aGlzLiRjdXJMaW5lSXRlbUNvdW50O1xuICAgICAgICBjb25zdCB2aWV3V2lkdGggPSB0aGlzLnZpZXdXaWR0aDtcbiAgICAgICAgY29uc3QgcGFnZSA9IE1hdGguZmxvb3IobmV3Rmlyc3RJbmRleCAvIHBhZ2VTaXplKTtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHBhZ2UgKiBwYWdlU2l6ZTtcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gc3RhcnRJbmRleCArIHBhZ2VTaXplICogMjtcbiAgICAgICAgbGV0IG5lZWRSZW5kZXI7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgaWksIGlpMjtcbiAgICAgICAgbGV0IGNvbDtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMuJGRlZmF1bHRJdGVtO1xuICAgICAgICBjb25zdCBwYXJ0V2lkdGggPSAodGhpcy4kc2Nyb2xsUGFuZS52aWV3V2lkdGggLSB0aGlzLiRjb2x1bW5HYXAgKiAodGhpcy4kY3VyTGluZUl0ZW1Db3VudCAtIDEpKSAvXG4gICAgICAgICAgICB0aGlzLiRjdXJMaW5lSXRlbUNvdW50O1xuICAgICAgICBjb25zdCBwYXJ0SGVpZ2h0ID0gKHRoaXMuJHNjcm9sbFBhbmUudmlld0hlaWdodCAtIHRoaXMuJGxpbmVHYXAgKiAodGhpcy4kY3VyTGluZUl0ZW1Db3VudDIgLSAxKSkgL1xuICAgICAgICAgICAgdGhpcy4kY3VyTGluZUl0ZW1Db3VudDI7XG4gICAgICAgIHRoaXMuJGl0ZW1JbmZvVmVyKys7XG4gICAgICAgIC8vYWRkIG1hcmsgZm9yIGl0ZW1zIHVzZWQgdGhpcyB0aW1lXG4gICAgICAgIGZvciAoaSA9IHN0YXJ0SW5kZXg7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy4kcmVhbE51bUl0ZW1zKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29sID0gaSAlIHRoaXMuJGN1ckxpbmVJdGVtQ291bnQ7XG4gICAgICAgICAgICBpZiAoaSAtIHN0YXJ0SW5kZXggPCBwYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb2wgPCBzdGFydENvbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sID4gc3RhcnRDb2wpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSB0aGlzLiR2aXJ0dWFsSXRlbXNbaV07XG4gICAgICAgICAgICBpaS51cGRhdGVGbGFnID0gdGhpcy4kaXRlbUluZm9WZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhc3RPYmogPSBudWxsO1xuICAgICAgICBsZXQgaW5zZXJ0SW5kZXggPSAwO1xuICAgICAgICBmb3IgKGkgPSBzdGFydEluZGV4OyBpIDwgbGFzdEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID49IHRoaXMuJHJlYWxOdW1JdGVtcylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlpID0gdGhpcy4kdmlydHVhbEl0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGlpLnVwZGF0ZUZsYWcgIT0gdGhpcy4kaXRlbUluZm9WZXIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoaWkub2JqID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvL2ZpbmQgaWYgYW55IGZyZWUgaXRlbSBjYW4gYmUgdXNlZFxuICAgICAgICAgICAgICAgIHdoaWxlIChyZXVzZUluZGV4IDwgdmlydHVhbEl0ZW1Db3VudCkge1xuICAgICAgICAgICAgICAgICAgICBpaTIgPSB0aGlzLiR2aXJ0dWFsSXRlbXNbcmV1c2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpaTIub2JqICE9IG51bGwgJiYgaWkyLnVwZGF0ZUZsYWcgIT0gdGhpcy4kaXRlbUluZm9WZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpaTIub2JqIGluc3RhbmNlb2YgR0J1dHRvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpaTIuc2VsZWN0ZWQgPSBpaTIub2JqLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWkub2JqID0gaWkyLm9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlpMi5vYmogPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV1c2VJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0SW5kZXggPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydEluZGV4ID0gdGhpcy5nZXRDaGlsZEluZGV4KGxhc3RPYmopICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoaWkub2JqID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbVByb3ZpZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuaXRlbVByb3ZpZGVyKGkgJSB0aGlzLiRudW1JdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdGhpcy4kZGVmYXVsdEl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBVSVBhY2thZ2Uubm9ybWFsaXplVVJMKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWkub2JqID0gdGhpcy4kcG9vbC5nZXQodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZEF0KGlpLm9iaiwgaW5zZXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGluc2VydEluZGV4ID0gdGhpcy5zZXRDaGlsZEluZGV4QmVmb3JlKGlpLm9iaiwgaW5zZXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGluc2VydEluZGV4Kys7XG4gICAgICAgICAgICAgICAgaWYgKGlpLm9iaiBpbnN0YW5jZW9mIEdCdXR0b24pXG4gICAgICAgICAgICAgICAgICAgIGlpLm9iai5zZWxlY3RlZCA9IGlpLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgIG5lZWRSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVlZFJlbmRlciA9IGZvcmNlVXBkYXRlO1xuICAgICAgICAgICAgICAgIGluc2VydEluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgbGFzdE9iaiA9IGlpLm9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZWVkUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGF1dG9SZXNpemVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRjdXJMaW5lSXRlbUNvdW50ID09IHRoaXMuJGNvbHVtbkNvdW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjdXJMaW5lSXRlbUNvdW50MiA9PSB0aGlzLiRsaW5lQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBpaS5vYmouc2V0U2l6ZShwYXJ0V2lkdGgsIHBhcnRIZWlnaHQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLiRjdXJMaW5lSXRlbUNvdW50ID09IHRoaXMuJGNvbHVtbkNvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWkub2JqLnNldFNpemUocGFydFdpZHRoLCBpaS5vYmouaGVpZ2h0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4kY3VyTGluZUl0ZW1Db3VudDIgPT0gdGhpcy4kbGluZUNvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWkub2JqLnNldFNpemUoaWkub2JqLndpZHRoLCBwYXJ0SGVpZ2h0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtUmVuZGVyZXIoaSAlIHRoaXMuJG51bUl0ZW1zLCBpaS5vYmopO1xuICAgICAgICAgICAgICAgIGlpLndpZHRoID0gTWF0aC5jZWlsKGlpLm9iai53aWR0aCk7XG4gICAgICAgICAgICAgICAgaWkuaGVpZ2h0ID0gTWF0aC5jZWlsKGlpLm9iai5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vbGF5b3V0XG4gICAgICAgIGxldCBib3JkZXJYID0gKHN0YXJ0SW5kZXggLyBwYWdlU2l6ZSkgKiB2aWV3V2lkdGg7XG4gICAgICAgIGxldCB4eCA9IGJvcmRlclg7XG4gICAgICAgIGxldCB5eSA9IDA7XG4gICAgICAgIGxldCBsaW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgZm9yIChpID0gc3RhcnRJbmRleDsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSB0aGlzLiRyZWFsTnVtSXRlbXMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpaSA9IHRoaXMuJHZpcnR1YWxJdGVtc1tpXTtcbiAgICAgICAgICAgIGlmIChpaS51cGRhdGVGbGFnID09IHRoaXMuJGl0ZW1JbmZvVmVyKVxuICAgICAgICAgICAgICAgIGlpLm9iai5zZXRYWSh4eCwgeXkpO1xuICAgICAgICAgICAgaWYgKGlpLmhlaWdodCA+IGxpbmVIZWlnaHQpXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodCA9IGlpLmhlaWdodDtcbiAgICAgICAgICAgIGlmIChpICUgdGhpcy4kY3VyTGluZUl0ZW1Db3VudCA9PSB0aGlzLiRjdXJMaW5lSXRlbUNvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgIHh4ID0gYm9yZGVyWDtcbiAgICAgICAgICAgICAgICB5eSArPSBsaW5lSGVpZ2h0ICsgdGhpcy4kbGluZUdhcDtcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBzdGFydEluZGV4ICsgcGFnZVNpemUgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclggKz0gdmlld1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB4eCA9IGJvcmRlclg7XG4gICAgICAgICAgICAgICAgICAgIHl5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgeHggKz0gaWkud2lkdGggKyB0aGlzLiRjb2x1bW5HYXA7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWxlYXNlIGl0ZW1zIG5vdCB1c2VkXG4gICAgICAgIGZvciAoaSA9IHJldXNlSW5kZXg7IGkgPCB2aXJ0dWFsSXRlbUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlpID0gdGhpcy4kdmlydHVhbEl0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGlpLnVwZGF0ZUZsYWcgIT0gdGhpcy4kaXRlbUluZm9WZXIgJiYgaWkub2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWkub2JqIGluc3RhbmNlb2YgR0J1dHRvbilcbiAgICAgICAgICAgICAgICAgICAgaWkuc2VsZWN0ZWQgPSBpaS5vYmouc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZFRvUG9vbChpaS5vYmopO1xuICAgICAgICAgICAgICAgIGlpLm9iaiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQXJjaE9yZGVyMSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGNoaWxkcmVuUmVuZGVyT3JkZXIgPT0gMiAvKiBBcmNoICovKSB7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSB0aGlzLiRzY3JvbGxQYW5lLnBvc1kgKyB0aGlzLnZpZXdIZWlnaHQgLyAyO1xuICAgICAgICAgICAgbGV0IG1pbkRpc3QgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICBsZXQgZGlzdCA9IDA7XG4gICAgICAgICAgICBsZXQgYXBleEluZGV4ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGNudCA9IHRoaXMubnVtQ2hpbGRyZW47XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5nZXRDaGlsZEF0KGkpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5mb2xkSW52aXNpYmxlSXRlbXMgfHwgb2JqLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguYWJzKG1pZCAtIG9iai55IC0gb2JqLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBleEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBleEluZGV4ID0gYXBleEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUFyY2hPcmRlcjIoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuUmVuZGVyT3JkZXIgPT0gMiAvKiBBcmNoICovKSB7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSB0aGlzLiRzY3JvbGxQYW5lLnBvc1ggKyB0aGlzLnZpZXdXaWR0aCAvIDI7XG4gICAgICAgICAgICBsZXQgbWluRGlzdCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gMDtcbiAgICAgICAgICAgIGxldCBhcGV4SW5kZXggPSAwO1xuICAgICAgICAgICAgY29uc3QgY250ID0gdGhpcy5udW1DaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmdldENoaWxkQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZvbGRJbnZpc2libGVJdGVtcyB8fCBvYmoudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5hYnMobWlkIC0gb2JqLnggLSBvYmoud2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwZXhJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwZXhJbmRleCA9IGFwZXhJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVBbGlnbihjb250ZW50V2lkdGgsIGNvbnRlbnRIZWlnaHQpIHtcbiAgICAgICAgbGV0IG5ld09mZnNldFggPSAwO1xuICAgICAgICBsZXQgbmV3T2Zmc2V0WSA9IDA7XG4gICAgICAgIGlmIChjb250ZW50SGVpZ2h0IDwgdGhpcy52aWV3SGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kdmVydGljYWxBbGlnbiA9PSAxIC8qIE1pZGRsZSAqLylcbiAgICAgICAgICAgICAgICBuZXdPZmZzZXRZID0gTWF0aC5mbG9vcigodGhpcy52aWV3SGVpZ2h0IC0gY29udGVudEhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJHZlcnRpY2FsQWxpZ24gPT0gMiAvKiBCb3R0b20gKi8pXG4gICAgICAgICAgICAgICAgbmV3T2Zmc2V0WSA9IHRoaXMudmlld0hlaWdodCAtIGNvbnRlbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRXaWR0aCA8IHRoaXMudmlld1dpZHRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kYWxpZ24gPT0gXCJjZW50ZXJcIiAvKiBDZW50ZXIgKi8pXG4gICAgICAgICAgICAgICAgbmV3T2Zmc2V0WCA9IE1hdGguZmxvb3IoKHRoaXMudmlld1dpZHRoIC0gY29udGVudFdpZHRoKSAvIDIpO1xuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4kYWxpZ24gPT0gXCJyaWdodFwiIC8qIFJpZ2h0ICovKVxuICAgICAgICAgICAgICAgIG5ld09mZnNldFggPSB0aGlzLnZpZXdXaWR0aCAtIGNvbnRlbnRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3T2Zmc2V0WCAhPSB0aGlzLiRhbGlnbk9mZnNldC54IHx8IG5ld09mZnNldFkgIT0gdGhpcy4kYWxpZ25PZmZzZXQueSkge1xuICAgICAgICAgICAgdGhpcy4kYWxpZ25PZmZzZXQuc2V0VmFsdWVzKG5ld09mZnNldFgsIG5ld09mZnNldFkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFBhbmUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLiRzY3JvbGxQYW5lLmFkanVzdE1hc2tDb250YWluZXIoKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci54ID0gdGhpcy4kbWFyZ2luLmxlZnQgKyB0aGlzLiRhbGlnbk9mZnNldC54O1xuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci55ID0gdGhpcy4kbWFyZ2luLnRvcCArIHRoaXMuJGFsaWduT2Zmc2V0Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqQG92ZXJyaWRlICovXG4gICAgdXBkYXRlQm91bmRzKCkge1xuICAgICAgICBpZiAodGhpcy4kdmlydHVhbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgbGV0IGN1clggPSAwO1xuICAgICAgICBsZXQgY3VyWSA9IDA7XG4gICAgICAgIGxldCBtYXhXaWR0aCA9IDA7XG4gICAgICAgIGxldCBtYXhIZWlnaHQgPSAwO1xuICAgICAgICBsZXQgY3cgPSAwLCBjaCA9IDA7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgbGV0IHBhZ2UgPSAwO1xuICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgIGNvbnN0IGNudCA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgdmlld1dpZHRoID0gdGhpcy52aWV3V2lkdGg7XG4gICAgICAgIGNvbnN0IHZpZXdIZWlnaHQgPSB0aGlzLnZpZXdIZWlnaHQ7XG4gICAgICAgIGxldCBsaW5lU2l6ZSA9IDA7XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSAwO1xuICAgICAgICBsZXQgcmF0aW87XG4gICAgICAgIGlmICh0aGlzLiRsYXlvdXQgPT0gMCAvKiBTaW5nbGVDb2x1bW4gKi8pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KGkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvbGRJbnZpc2libGVJdGVtcyAmJiAhY2hpbGQudmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1clkgIT0gMClcbiAgICAgICAgICAgICAgICAgICAgY3VyWSArPSB0aGlzLiRsaW5lR2FwO1xuICAgICAgICAgICAgICAgIGNoaWxkLnkgPSBjdXJZO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRhdXRvUmVzaXplSXRlbSlcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0U2l6ZSh2aWV3V2lkdGgsIGNoaWxkLmhlaWdodCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY3VyWSArPSBNYXRoLmNlaWwoY2hpbGQuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQud2lkdGggPiBtYXhXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBjaGlsZC53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN3ID0gTWF0aC5jZWlsKG1heFdpZHRoKTtcbiAgICAgICAgICAgIGNoID0gY3VyWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiRsYXlvdXQgPT0gMSAvKiBTaW5nbGVSb3cgKi8pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KGkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvbGRJbnZpc2libGVJdGVtcyAmJiAhY2hpbGQudmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1clggIT0gMClcbiAgICAgICAgICAgICAgICAgICAgY3VyWCArPSB0aGlzLiRjb2x1bW5HYXA7XG4gICAgICAgICAgICAgICAgY2hpbGQueCA9IGN1clg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGF1dG9SZXNpemVJdGVtKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRTaXplKGNoaWxkLndpZHRoLCB2aWV3SGVpZ2h0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjdXJYICs9IE1hdGguY2VpbChjaGlsZC53aWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmhlaWdodCA+IG1heEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gY2hpbGQuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3cgPSBjdXJYO1xuICAgICAgICAgICAgY2ggPSBNYXRoLmNlaWwobWF4SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiRsYXlvdXQgPT0gMiAvKiBGbG93SG9yaXpvbnRhbCAqLykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGF1dG9SZXNpemVJdGVtICYmIHRoaXMuJGNvbHVtbkNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZm9sZEludmlzaWJsZUl0ZW1zICYmICFjaGlsZC52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTaXplICs9IGNoaWxkLnNvdXJjZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09IHRoaXMuJGNvbHVtbkNvdW50IHx8IGkgPT0gY250IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF0aW8gPSAodmlld1dpZHRoIC0gbGluZVNpemUgLSAoaiAtIDEpICogdGhpcy4kY29sdW1uR2FwKSAvIGxpbmVTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyWCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBsaW5lU3RhcnQ7IGogPD0gaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZm9sZEludmlzaWJsZUl0ZW1zICYmICFjaGlsZC52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRYWShjdXJYLCBjdXJZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0U2l6ZShjaGlsZC5zb3VyY2VXaWR0aCArIE1hdGgucm91bmQoY2hpbGQuc291cmNlV2lkdGggKiByYXRpbyksIGNoaWxkLmhlaWdodCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clggKz0gTWF0aC5jZWlsKGNoaWxkLndpZHRoKSArIHRoaXMuJGNvbHVtbkdhcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRTaXplKHZpZXdXaWR0aCAtIGN1clgsIGNoaWxkLmhlaWdodCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmhlaWdodCA+IG1heEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gY2hpbGQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXcgbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyWSArPSBNYXRoLmNlaWwobWF4SGVpZ2h0KSArIHRoaXMuJGxpbmVHYXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVTaXplID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaCA9IGN1clkgKyBNYXRoLmNlaWwobWF4SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdyA9IHZpZXdXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZm9sZEludmlzaWJsZUl0ZW1zICYmICFjaGlsZC52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJYICE9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJYICs9IHRoaXMuJGNvbHVtbkdhcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLiRjb2x1bW5Db3VudCAhPSAwICYmIGogPj0gdGhpcy4kY29sdW1uQ291bnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy4kY29sdW1uQ291bnQgPT0gMCAmJiBjdXJYICsgY2hpbGQud2lkdGggPiB2aWV3V2lkdGggJiYgbWF4SGVpZ2h0ICE9IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL25ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJYID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clkgKz0gTWF0aC5jZWlsKG1heEhlaWdodCkgKyB0aGlzLiRsaW5lR2FwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnNldFhZKGN1clgsIGN1clkpO1xuICAgICAgICAgICAgICAgICAgICBjdXJYICs9IE1hdGguY2VpbChjaGlsZC53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJYID4gbWF4V2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IGN1clg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5oZWlnaHQgPiBtYXhIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2ggPSBjdXJZICsgTWF0aC5jZWlsKG1heEhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3cgPSBNYXRoLmNlaWwobWF4V2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJGxheW91dCA9PSAzIC8qIEZsb3dWZXJ0aWNhbCAqLykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGF1dG9SZXNpemVJdGVtICYmIHRoaXMuJGxpbmVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvbGRJbnZpc2libGVJdGVtcyAmJiAhY2hpbGQudmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsaW5lU2l6ZSArPSBjaGlsZC5zb3VyY2VIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gdGhpcy4kbGluZUNvdW50IHx8IGkgPT0gY250IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF0aW8gPSAodmlld0hlaWdodCAtIGxpbmVTaXplIC0gKGogLSAxKSAqIHRoaXMuJGxpbmVHYXApIC8gbGluZVNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJZID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGxpbmVTdGFydDsgaiA8PSBpOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRBdChqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mb2xkSW52aXNpYmxlSXRlbXMgJiYgIWNoaWxkLnZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnNldFhZKGN1clgsIGN1clkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqIDwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRTaXplKGNoaWxkLndpZHRoLCBjaGlsZC5zb3VyY2VIZWlnaHQgKyBNYXRoLnJvdW5kKGNoaWxkLnNvdXJjZUhlaWdodCAqIHJhdGlvKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clkgKz0gTWF0aC5jZWlsKGNoaWxkLmhlaWdodCkgKyB0aGlzLiRsaW5lR2FwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnNldFNpemUoY2hpbGQud2lkdGgsIHZpZXdIZWlnaHQgLSBjdXJZLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQud2lkdGggPiBtYXhXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBjaGlsZC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clggKz0gTWF0aC5jZWlsKG1heFdpZHRoKSArIHRoaXMuJGNvbHVtbkdhcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3cgPSBjdXJYICsgTWF0aC5jZWlsKG1heFdpZHRoKTtcbiAgICAgICAgICAgICAgICBjaCA9IHZpZXdIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvbGRJbnZpc2libGVJdGVtcyAmJiAhY2hpbGQudmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyWSAhPSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyWSArPSB0aGlzLiRsaW5lR2FwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuJGxpbmVDb3VudCAhPSAwICYmIGogPj0gdGhpcy4kbGluZUNvdW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuJGxpbmVDb3VudCA9PSAwICYmIGN1clkgKyBjaGlsZC5oZWlnaHQgPiB2aWV3SGVpZ2h0ICYmIG1heFdpZHRoICE9IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJZID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clggKz0gTWF0aC5jZWlsKG1heFdpZHRoKSArIHRoaXMuJGNvbHVtbkdhcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnNldFhZKGN1clgsIGN1clkpO1xuICAgICAgICAgICAgICAgICAgICBjdXJZICs9IE1hdGguY2VpbChjaGlsZC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyWSA+IG1heEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IGN1clk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC53aWR0aCA+IG1heFdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBjaGlsZC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdyA9IGN1clggKyBNYXRoLmNlaWwobWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgIGNoID0gTWF0aC5jZWlsKG1heEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy9wYWdpbmF0aW9uXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGVhY2hIZWlnaHQ7XG4gICAgICAgICAgICBpZiAodGhpcy4kYXV0b1Jlc2l6ZUl0ZW0gJiYgdGhpcy4kbGluZUNvdW50ID4gMClcbiAgICAgICAgICAgICAgICBlYWNoSGVpZ2h0ID0gTWF0aC5mbG9vcigodmlld0hlaWdodCAtICh0aGlzLiRsaW5lQ291bnQgLSAxKSAqIHRoaXMuJGxpbmVHYXApIC8gdGhpcy4kbGluZUNvdW50KTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRhdXRvUmVzaXplSXRlbSAmJiB0aGlzLiRjb2x1bW5Db3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvbGRJbnZpc2libGVJdGVtcyAmJiAhY2hpbGQudmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsaW5lU2l6ZSArPSBjaGlsZC5zb3VyY2VXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSB0aGlzLiRjb2x1bW5Db3VudCB8fCBpID09IGNudCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdGlvID0gKHZpZXdXaWR0aCAtIGxpbmVTaXplIC0gKGogLSAxKSAqIHRoaXMuJGNvbHVtbkdhcCkgLyBsaW5lU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gbGluZVN0YXJ0OyBqIDw9IGk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvbGRJbnZpc2libGVJdGVtcyAmJiAhY2hpbGQudmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0WFkocGFnZSAqIHZpZXdXaWR0aCArIGN1clgsIGN1clkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqIDwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRTaXplKGNoaWxkLnNvdXJjZVdpZHRoICsgTWF0aC5yb3VuZChjaGlsZC5zb3VyY2VXaWR0aCAqIHJhdGlvKSwgdGhpcy4kbGluZUNvdW50ID4gMCA/IGVhY2hIZWlnaHQgOiBjaGlsZC5oZWlnaHQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJYICs9IE1hdGguY2VpbChjaGlsZC53aWR0aCkgKyB0aGlzLiRjb2x1bW5HYXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0U2l6ZSh2aWV3V2lkdGggLSBjdXJYLCB0aGlzLiRsaW5lQ291bnQgPiAwID8gZWFjaEhlaWdodCA6IGNoaWxkLmhlaWdodCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmhlaWdodCA+IG1heEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gY2hpbGQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXcgbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyWSArPSBNYXRoLmNlaWwobWF4SGVpZ2h0KSArIHRoaXMuJGxpbmVHYXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVTaXplID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy4kbGluZUNvdW50ICE9IDAgJiYgayA+PSB0aGlzLiRsaW5lQ291bnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuJGxpbmVDb3VudCA9PSAwICYmIGN1clkgKyBjaGlsZC5oZWlnaHQgPiB2aWV3SGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbmV3IHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyWSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvbGRJbnZpc2libGVJdGVtcyAmJiAhY2hpbGQudmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyWCAhPSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyWCArPSB0aGlzLiRjb2x1bW5HYXA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRhdXRvUmVzaXplSXRlbSAmJiB0aGlzLiRsaW5lQ291bnQgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0U2l6ZShjaGlsZC53aWR0aCwgZWFjaEhlaWdodCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy4kY29sdW1uQ291bnQgIT0gMCAmJiBqID49IHRoaXMuJGNvbHVtbkNvdW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuJGNvbHVtbkNvdW50ID09IDAgJiYgY3VyWCArIGNoaWxkLndpZHRoID4gdmlld1dpZHRoICYmIG1heEhlaWdodCAhPSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXcgbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyWCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJZICs9IE1hdGguY2VpbChtYXhIZWlnaHQpICsgdGhpcy4kbGluZUdhcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy4kbGluZUNvdW50ICE9IDAgJiYgayA+PSB0aGlzLiRsaW5lQ291bnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuJGxpbmVDb3VudCA9PSAwICYmIGN1clkgKyBjaGlsZC5oZWlnaHQgPiB2aWV3SGVpZ2h0ICYmIG1heFdpZHRoICE9IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXcgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJZID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRYWShwYWdlICogdmlld1dpZHRoICsgY3VyWCwgY3VyWSk7XG4gICAgICAgICAgICAgICAgICAgIGN1clggKz0gTWF0aC5jZWlsKGNoaWxkLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clggPiBtYXhXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoID0gY3VyWDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmhlaWdodCA+IG1heEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IGNoaWxkLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoID0gcGFnZSA+IDAgPyB2aWV3SGVpZ2h0IDogY3VyWSArIE1hdGguY2VpbChtYXhIZWlnaHQpO1xuICAgICAgICAgICAgY3cgPSAocGFnZSArIDEpICogdmlld1dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlQWxpZ24oY3csIGNoKTtcbiAgICAgICAgdGhpcy5zZXRCb3VuZHMoMCwgMCwgY3csIGNoKTtcbiAgICB9XG4gICAgc2V0dXBCZWZvcmVBZGQoeG1sKSB7XG4gICAgICAgIHN1cGVyLnNldHVwQmVmb3JlQWRkKHhtbCk7XG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGxldCBhcnI7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmxheW91dDtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuJGxheW91dCA9IFBhcnNlTGlzdExheW91dFR5cGUoc3RyKTtcbiAgICAgICAgbGV0IG92ZXJmbG93O1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5vdmVyZmxvdztcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIG92ZXJmbG93ID0gUGFyc2VPdmVyZmxvd1R5cGUoc3RyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb3ZlcmZsb3cgPSAwIC8qIFZpc2libGUgKi87XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLm1hcmdpbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuJG1hcmdpbi5wYXJzZShzdHIpO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5hbGlnbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuJGFsaWduID0gUGFyc2VBbGlnblR5cGUoc3RyKTtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMudkFsaWduO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgdGhpcy4kdmVydGljYWxBbGlnbiA9IFBhcnNlVmVydEFsaWduVHlwZShzdHIpO1xuICAgICAgICBpZiAob3ZlcmZsb3cgPT0gMiAvKiBTY3JvbGwgKi8pIHtcbiAgICAgICAgICAgIGxldCBzY3JvbGw7XG4gICAgICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5zY3JvbGw7XG4gICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgIHNjcm9sbCA9IFBhcnNlU2Nyb2xsVHlwZShzdHIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNjcm9sbCA9IDEgLyogVmVydGljYWwgKi87XG4gICAgICAgICAgICBsZXQgc2Nyb2xsQmFyRGlzcGxheTtcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnNjcm9sbEJhcjtcbiAgICAgICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICAgICAgc2Nyb2xsQmFyRGlzcGxheSA9IFBhcnNlU2Nyb2xsQmFyRGlzcGxheVR5cGUoc3RyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzY3JvbGxCYXJEaXNwbGF5ID0gMCAvKiBEZWZhdWx0ICovO1xuICAgICAgICAgICAgbGV0IHNjcm9sbEJhckZsYWdzO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuc2Nyb2xsQmFyRmxhZ3M7XG4gICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgIHNjcm9sbEJhckZsYWdzID0gcGFyc2VJbnQoc3RyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzY3JvbGxCYXJGbGFncyA9IDA7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsQmFyTWFyZ2luID0gbmV3IE1hcmdpbigpO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuc2Nyb2xsQmFyTWFyZ2luO1xuICAgICAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgICAgICBzY3JvbGxCYXJNYXJnaW4ucGFyc2Uoc3RyKTtcbiAgICAgICAgICAgIGxldCB2dFNjcm9sbEJhclJlcztcbiAgICAgICAgICAgIGxldCBoelNjcm9sbEJhclJlcztcbiAgICAgICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnNjcm9sbEJhclJlcztcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICB2dFNjcm9sbEJhclJlcyA9IGFyclswXTtcbiAgICAgICAgICAgICAgICBoelNjcm9sbEJhclJlcyA9IGFyclsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBoZWFkZXJSZXM7XG4gICAgICAgICAgICBsZXQgZm9vdGVyUmVzO1xuICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMucHRyUmVzO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIGhlYWRlclJlcyA9IGFyclswXTtcbiAgICAgICAgICAgICAgICBmb290ZXJSZXMgPSBhcnJbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldHVwU2Nyb2xsKHNjcm9sbEJhck1hcmdpbiwgc2Nyb2xsLCBzY3JvbGxCYXJEaXNwbGF5LCBzY3JvbGxCYXJGbGFncywgdnRTY3JvbGxCYXJSZXMsIGh6U2Nyb2xsQmFyUmVzLCBoZWFkZXJSZXMsIGZvb3RlclJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zZXR1cE92ZXJmbG93KG92ZXJmbG93KTtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMubGluZUdhcDtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuJGxpbmVHYXAgPSBwYXJzZUludChzdHIpO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5jb2xHYXA7XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICB0aGlzLiRjb2x1bW5HYXAgPSBwYXJzZUludChzdHIpO1xuICAgICAgICBzdHIgPSB4bWwuYXR0cmlidXRlcy5saW5lSXRlbUNvdW50O1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kbGF5b3V0ID09IDIgLyogRmxvd0hvcml6b250YWwgKi8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLiRsYXlvdXQgPT0gNCAvKiBQYWdpbmF0aW9uICovKVxuICAgICAgICAgICAgICAgIHRoaXMuJGNvbHVtbkNvdW50ID0gcGFyc2VJbnQoc3RyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJGxheW91dCA9PSAzIC8qIEZsb3dWZXJ0aWNhbCAqLylcbiAgICAgICAgICAgICAgICB0aGlzLiRsaW5lQ291bnQgPSBwYXJzZUludChzdHIpO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmxpbmVJdGVtQ291bnQyO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgdGhpcy4kbGluZUNvdW50ID0gcGFyc2VJbnQoc3RyKTtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuc2VsZWN0aW9uTW9kZTtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuJHNlbGVjdGlvbk1vZGUgPSBQYXJzZUxpc3RTZWxlY3Rpb25Nb2RlKHN0cik7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmRlZmF1bHRJdGVtO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgdGhpcy4kZGVmYXVsdEl0ZW0gPSBzdHI7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLmF1dG9JdGVtU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuJGxheW91dCA9PSAxIC8qIFNpbmdsZVJvdyAqLyB8fCB0aGlzLiRsYXlvdXQgPT0gMCAvKiBTaW5nbGVDb2x1bW4gKi8pXG4gICAgICAgICAgICB0aGlzLiRhdXRvUmVzaXplSXRlbSA9IHN0ciAhPSAnZmFsc2UnO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRhdXRvUmVzaXplSXRlbSA9IHN0ciA9PSAndHJ1ZSc7XG4gICAgICAgIHN0ciA9IHhtbC5hdHRyaWJ1dGVzLnJlbmRlck9yZGVyO1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICB0aGlzLiRjaGlsZHJlblJlbmRlck9yZGVyID0gUGFyc2VMaXN0Q2hpbGRyZW5SZW5kZXJPcmRlcihzdHIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGNoaWxkcmVuUmVuZGVyT3JkZXIgPT0gMiAvKiBBcmNoICovKSB7XG4gICAgICAgICAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuYXBleDtcbiAgICAgICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRhcGV4SW5kZXggPSBwYXJzZUludChzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb2wgPSB4bWwuY2hpbGRyZW47XG4gICAgICAgIGNvbC5mb3JFYWNoKGN4bWwgPT4ge1xuICAgICAgICAgICAgaWYgKGN4bWwubm9kZU5hbWUgIT0gJ2l0ZW0nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB1cmwgPSBjeG1sLmF0dHJpYnV0ZXMudXJsO1xuICAgICAgICAgICAgaWYgKCF1cmwpXG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy4kZGVmYXVsdEl0ZW07XG4gICAgICAgICAgICBpZiAoIXVybClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5nZXRGcm9tUG9vbCh1cmwpO1xuICAgICAgICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChvYmopO1xuICAgICAgICAgICAgICAgIHN0ciA9IGN4bWwuYXR0cmlidXRlcy50aXRsZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgICAgICBvYmoudGV4dCA9IHN0cjtcbiAgICAgICAgICAgICAgICBzdHIgPSBjeG1sLmF0dHJpYnV0ZXMuaWNvbjtcbiAgICAgICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgICAgICBvYmouaWNvbiA9IHN0cjtcbiAgICAgICAgICAgICAgICBzdHIgPSBjeG1sLmF0dHJpYnV0ZXMubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgICAgICAgICBvYmoubmFtZSA9IHN0cjtcbiAgICAgICAgICAgICAgICBzdHIgPSBjeG1sLmF0dHJpYnV0ZXMuc2VsZWN0ZWRJY29uO1xuICAgICAgICAgICAgICAgIGlmIChzdHIgJiYgb2JqIGluc3RhbmNlb2YgR0J1dHRvbilcbiAgICAgICAgICAgICAgICAgICAgb2JqLnNlbGVjdGVkSWNvbiA9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIHNldHVwQWZ0ZXJBZGQoeG1sKSB7XG4gICAgICAgIHN1cGVyLnNldHVwQWZ0ZXJBZGQoeG1sKTtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgc3RyID0geG1sLmF0dHJpYnV0ZXMuc2VsZWN0aW9uQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHRoaXMuJHNlbGVjdGlvbkNvbnRyb2xsZXIgPSB0aGlzLnBhcmVudC5nZXRDb250cm9sbGVyKHN0cik7XG4gICAgfVxufVxuR0xpc3QuJGxhc3RQb3NIZWxwZXIgPSAwO1xuXG5jbGFzcyBQb3B1cE1lbnUge1xuICAgIGNvbnN0cnVjdG9yKHJlc291cmNlVVJMID0gbnVsbCkge1xuICAgICAgICBpZiAoIXJlc291cmNlVVJMKSB7XG4gICAgICAgICAgICByZXNvdXJjZVVSTCA9IFVJQ29uZmlnLnBvcHVwTWVudTtcbiAgICAgICAgICAgIGlmICghcmVzb3VyY2VVUkwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVSUNvbmZpZy5wb3B1cE1lbnUgbm90IGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRjb250ZW50UGFuZSA9IFVJUGFja2FnZS5jcmVhdGVPYmplY3RGcm9tVVJMKHJlc291cmNlVVJMKTtcbiAgICAgICAgdGhpcy4kY29udGVudFBhbmUub24oJ2FkZGVkJywgdGhpcy4kYWRkZWRUb1N0YWdlLCB0aGlzKTtcbiAgICAgICAgdGhpcy4kbGlzdCA9IHRoaXMuJGNvbnRlbnRQYW5lLmdldENoaWxkKCdsaXN0Jyk7XG4gICAgICAgIHRoaXMuJGxpc3QucmVtb3ZlQ2hpbGRyZW5Ub1Bvb2woKTtcbiAgICAgICAgdGhpcy4kbGlzdC5hZGRSZWxhdGlvbih0aGlzLiRjb250ZW50UGFuZSwgMTQgLyogV2lkdGggKi8pO1xuICAgICAgICB0aGlzLiRsaXN0LnJlbW92ZVJlbGF0aW9uKHRoaXMuJGNvbnRlbnRQYW5lLCAxNSAvKiBIZWlnaHQgKi8pO1xuICAgICAgICB0aGlzLiRjb250ZW50UGFuZS5hZGRSZWxhdGlvbih0aGlzLiRsaXN0LCAxNSAvKiBIZWlnaHQgKi8pO1xuICAgICAgICB0aGlzLiRsaXN0Lm9uKFwiX19pdGVtQ2xpY2tcIiAvKiBJdGVtQ2xpY2sgKi8sIHRoaXMuJGNsaWNrSXRlbSwgdGhpcyk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIEdUaW1lci5pbnN0LnJlbW92ZSh0aGlzLiRkZWxheUNsaWNrSXRlbSwgdGhpcyk7XG4gICAgICAgIHRoaXMuJGxpc3Qub2ZmKFwiX19pdGVtQ2xpY2tcIiAvKiBJdGVtQ2xpY2sgKi8sIHRoaXMuJGNsaWNrSXRlbSk7XG4gICAgICAgIHRoaXMuJGNvbnRlbnRQYW5lLm9mZignYWRkZWQnLCB0aGlzLiRhZGRlZFRvU3RhZ2UpO1xuICAgICAgICB0aGlzLiRjb250ZW50UGFuZS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGFkZEl0ZW0oY2FwdGlvbiwgaGFuZGxlcikge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuJGxpc3QuYWRkSXRlbUZyb21Qb29sKCk7XG4gICAgICAgIGl0ZW0udGl0bGUgPSBjYXB0aW9uO1xuICAgICAgICBpdGVtLmRhdGEgPSBoYW5kbGVyO1xuICAgICAgICBpdGVtLmdyYXllZCA9IGZhbHNlO1xuICAgICAgICBsZXQgYyA9IGl0ZW0uZ2V0Q29udHJvbGxlcignY2hlY2tlZCcpO1xuICAgICAgICBpZiAoYyAhPSBudWxsKVxuICAgICAgICAgICAgYy5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIGFkZEl0ZW1BdChjYXB0aW9uLCBpbmRleCwgaGFuZGxlcikge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuJGxpc3QuZ2V0RnJvbVBvb2woKTtcbiAgICAgICAgdGhpcy4kbGlzdC5hZGRDaGlsZEF0KGl0ZW0sIGluZGV4KTtcbiAgICAgICAgaXRlbS50aXRsZSA9IGNhcHRpb247XG4gICAgICAgIGl0ZW0uZGF0YSA9IGhhbmRsZXI7XG4gICAgICAgIGl0ZW0uZ3JheWVkID0gZmFsc2U7XG4gICAgICAgIGxldCBjID0gaXRlbS5nZXRDb250cm9sbGVyKCdjaGVja2VkJyk7XG4gICAgICAgIGlmIChjICE9IG51bGwpXG4gICAgICAgICAgICBjLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgYWRkU2VwZXJhdG9yKCkge1xuICAgICAgICBpZiAoVUlDb25maWcucG9wdXBNZW51U2VwZXJhdG9yID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VJQ29uZmlnLnBvcHVwTWVudVNlcGVyYXRvciBub3QgZGVmaW5lZCcpO1xuICAgICAgICB0aGlzLiRsaXN0LmFkZEl0ZW1Gcm9tUG9vbChVSUNvbmZpZy5wb3B1cE1lbnVTZXBlcmF0b3IpO1xuICAgIH1cbiAgICBnZXRJdGVtTmFtZShpbmRleCkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuJGxpc3QuZ2V0Q2hpbGRBdChpbmRleCk7XG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XG4gICAgfVxuICAgIHNldEl0ZW1UZXh0KG5hbWUsIGNhcHRpb24pIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLiRsaXN0LmdldENoaWxkKG5hbWUpO1xuICAgICAgICBpdGVtLnRpdGxlID0gY2FwdGlvbjtcbiAgICB9XG4gICAgc2V0SXRlbVZpc2libGUobmFtZSwgdmlzaWJsZSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuJGxpc3QuZ2V0Q2hpbGQobmFtZSk7XG4gICAgICAgIGlmIChpdGVtLnZpc2libGUgIT0gdmlzaWJsZSkge1xuICAgICAgICAgICAgaXRlbS52aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgICAgICAgIHRoaXMuJGxpc3Quc2V0Qm91bmRzQ2hhbmdlZEZsYWcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRJdGVtR3JheWVkKG5hbWUsIGdyYXllZCkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuJGxpc3QuZ2V0Q2hpbGQobmFtZSk7XG4gICAgICAgIGl0ZW0uZ3JheWVkID0gZ3JheWVkO1xuICAgIH1cbiAgICBzZXRJdGVtQ2hlY2thYmxlKG5hbWUsIGNoZWNrYWJsZSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuJGxpc3QuZ2V0Q2hpbGQobmFtZSk7XG4gICAgICAgIGxldCBjID0gaXRlbS5nZXRDb250cm9sbGVyKCdjaGVja2VkJyk7XG4gICAgICAgIGlmIChjICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2FibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5zZWxlY3RlZEluZGV4ID09IDApXG4gICAgICAgICAgICAgICAgICAgIGMuc2VsZWN0ZWRJbmRleCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYy5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRJdGVtQ2hlY2tlZChuYW1lLCBjaGVja2VkKSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy4kbGlzdC5nZXRDaGlsZChuYW1lKTtcbiAgICAgICAgbGV0IGMgPSBpdGVtLmdldENvbnRyb2xsZXIoJ2NoZWNrZWQnKTtcbiAgICAgICAgaWYgKGMgIT0gbnVsbClcbiAgICAgICAgICAgIGMuc2VsZWN0ZWRJbmRleCA9IGNoZWNrZWQgPyAyIDogMTtcbiAgICB9XG4gICAgaXNJdGVtQ2hlY2tlZChuYW1lKSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy4kbGlzdC5nZXRDaGlsZChuYW1lKTtcbiAgICAgICAgbGV0IGMgPSBpdGVtLmdldENvbnRyb2xsZXIoJ2NoZWNrZWQnKTtcbiAgICAgICAgaWYgKGMgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBjLnNlbGVjdGVkSW5kZXggPT0gMjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZW1vdmVJdGVtKG5hbWUpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLiRsaXN0LmdldENoaWxkKG5hbWUpO1xuICAgICAgICBpZiAoaXRlbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLiRsaXN0LmdldENoaWxkSW5kZXgoaXRlbSk7XG4gICAgICAgICAgICB0aGlzLiRsaXN0LnJlbW92ZUNoaWxkVG9Qb29sQXQoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjbGVhckl0ZW1zKCkge1xuICAgICAgICB0aGlzLiRsaXN0LnJlbW92ZUNoaWxkcmVuVG9Qb29sKCk7XG4gICAgfVxuICAgIGdldCBpdGVtQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRsaXN0Lm51bUNoaWxkcmVuO1xuICAgIH1cbiAgICBnZXQgY29udGVudFBhbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjb250ZW50UGFuZTtcbiAgICB9XG4gICAgZ2V0IGxpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRsaXN0O1xuICAgIH1cbiAgICBzaG93KHRhcmdldCA9IG51bGwsIGRpcikge1xuICAgICAgICBsZXQgciA9IHRhcmdldCAhPSBudWxsID8gR1Jvb3QuZmluZEZvcih0YXJnZXQpIDogR1Jvb3QuaW5zdDtcbiAgICAgICAgci5zaG93UG9wdXAodGhpcy5jb250ZW50UGFuZSwgdGFyZ2V0IGluc3RhbmNlb2YgR1Jvb3QgPyBudWxsIDogdGFyZ2V0LCBkaXIpO1xuICAgIH1cbiAgICAkY2xpY2tJdGVtKGV2dCkge1xuICAgICAgICBsZXQgaXRlbSA9IGV2dC5kYXRhLml0ZW07XG4gICAgICAgIEdUaW1lci5pbnN0LmFkZCgxMDAsIDEsIHRoaXMuJGRlbGF5Q2xpY2tJdGVtLCB0aGlzLCBpdGVtKTtcbiAgICB9XG4gICAgJGRlbGF5Q2xpY2tJdGVtKGl0ZW1PYmplY3QpIHtcbiAgICAgICAgaWYgKCEoaXRlbU9iamVjdCBpbnN0YW5jZW9mIEdCdXR0b24pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXRlbU9iamVjdC5ncmF5ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuJGxpc3Quc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjID0gaXRlbU9iamVjdC5nZXRDb250cm9sbGVyKCdjaGVja2VkJyk7XG4gICAgICAgIGlmIChjICE9IG51bGwgJiYgYy5zZWxlY3RlZEluZGV4ICE9IDApIHtcbiAgICAgICAgICAgIGlmIChjLnNlbGVjdGVkSW5kZXggPT0gMSlcbiAgICAgICAgICAgICAgICBjLnNlbGVjdGVkSW5kZXggPSAyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGMuc2VsZWN0ZWRJbmRleCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHIgPSB0aGlzLiRjb250ZW50UGFuZS5wYXJlbnQ7XG4gICAgICAgIGlmIChyKVxuICAgICAgICAgICAgci5oaWRlUG9wdXAodGhpcy5jb250ZW50UGFuZSk7XG4gICAgICAgIGlmIChpdGVtT2JqZWN0LmRhdGEgIT0gbnVsbClcbiAgICAgICAgICAgIGl0ZW1PYmplY3QuZGF0YS5jYWxsKG51bGwpO1xuICAgICAgICBHVGltZXIuaW5zdC5yZW1vdmUodGhpcy4kZGVsYXlDbGlja0l0ZW0sIHRoaXMpO1xuICAgIH1cbiAgICAkYWRkZWRUb1N0YWdlKCkge1xuICAgICAgICB0aGlzLiRsaXN0LnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy4kbGlzdC5yZXNpemVUb0ZpdCgxMDAwMDAsIDEwKTtcbiAgICB9XG59XG5cbmNsYXNzIFVJT2JqZWN0RmFjdG9yeSB7XG4gICAgc3RhdGljIHNldFBhY2thZ2VJdGVtRXh0ZW5zaW9uKHVybCwgdHlwZSkge1xuICAgICAgICBVSU9iamVjdEZhY3RvcnkucGFja2FnZUl0ZW1FeHRlbnNpb25zW3VybC5zdWJzdHJpbmcoNSldID0gdHlwZTtcbiAgICB9XG4gICAgLy8gcHVibGljIHN0YXRpYyBzZXRMb2FkZXJFeHRlbnNpb24odHlwZTogeyBuZXcoKTogR0xvYWRlciB9KTogdm9pZCB7XG4gICAgLy8gICAgIFVJT2JqZWN0RmFjdG9yeS5sb2FkZXJFeHRlbnNpb24gPSB0eXBlO1xuICAgIC8vIH1cbiAgICBzdGF0aWMgbmV3T2JqZWN0KHBpKSB7XG4gICAgICAgIHN3aXRjaCAocGkudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIEltYWdlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR0ltYWdlKCk7XG4gICAgICAgICAgICBjYXNlIDIgLyogTW92aWVDbGlwICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR01vdmllQ2xpcCgpO1xuICAgICAgICAgICAgY2FzZSA0IC8qIENvbXBvbmVudCAqLzpcbiAgICAgICAgICAgICAgICBsZXQgY2xzID0gVUlPYmplY3RGYWN0b3J5LnBhY2thZ2VJdGVtRXh0ZW5zaW9uc1twaS5vd25lci5pZCArIHBpLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNscygpO1xuICAgICAgICAgICAgICAgIGxldCB4bWwgPSBwaS5vd25lci5nZXRJdGVtQXNzZXQocGkpO1xuICAgICAgICAgICAgICAgIGxldCBleHRlbnRpb24gPSB4bWwuYXR0cmlidXRlcy5leHRlbnRpb247XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVudGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXh0ZW50aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdCdXR0b24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR0J1dHRvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnUHJvZ3Jlc3NCYXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR1Byb2dyZXNzQmFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdMYWJlbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHTGFiZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1NsaWRlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHU2xpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdTY3JvbGxCYXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR1Njcm9sbEJhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ29tYm9Cb3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR0NvbWJvQm94KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHQ29tcG9uZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBuZXdPYmplY3REaXJlY3RseSh0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR0ltYWdlKCk7XG4gICAgICAgICAgICBjYXNlICdtb3ZpZWNsaXAnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR01vdmllQ2xpcCgpO1xuICAgICAgICAgICAgY2FzZSAnY29tcG9uZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdDb21wb25lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR1RleHRGaWVsZCgpO1xuICAgICAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHTGlzdCgpO1xuICAgICAgICAgICAgY2FzZSAncmljaHRleHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR1JpY2hUZXh0RmllbGQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2lucHV0dGV4dCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHVGV4dElucHV0KCk7XG4gICAgICAgICAgICBjYXNlICdncm91cCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHR3JvdXAoKTtcbiAgICAgICAgICAgIGNhc2UgJ2dyYXBoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdHcmFwaCgpO1xuICAgICAgICAgICAgY2FzZSAnbG9hZGVyJzpcbiAgICAgICAgICAgICAgICBpZiAoVUlPYmplY3RGYWN0b3J5LmxvYWRlckV4dGVuc2lvbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVJT2JqZWN0RmFjdG9yeS5sb2FkZXJFeHRlbnNpb24oKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR0xvYWRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblVJT2JqZWN0RmFjdG9yeS5wYWNrYWdlSXRlbUV4dGVuc2lvbnMgPSB7fTtcbkRlY2xzLlVJT2JqZWN0RmFjdG9yeSA9IFVJT2JqZWN0RmFjdG9yeTtcblxuY2xhc3MgRHJhZ0luZGljYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuJGFnZW50ID0gbmV3IEdMb2FkZXIoKTtcbiAgICAgICAgdGhpcy4kYWdlbnQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kYWdlbnQudG91Y2hhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGFnZW50LnNldFNpemUoMTAwLCAxMDApO1xuICAgICAgICB0aGlzLiRhZ2VudC5zZXRQaXZvdCgwLjUsIDAuNSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuJGFnZW50LmFsaWduID0gXCJjZW50ZXJcIiAvKiBDZW50ZXIgKi87XG4gICAgICAgIHRoaXMuJGFnZW50LnZlcnRpY2FsQWxpZ24gPSAxIC8qIE1pZGRsZSAqLztcbiAgICAgICAgdGhpcy4kYWdlbnQuc29ydGluZ09yZGVyID0gMTAwMDAwMDsgLy90b3AgbW9zdFxuICAgICAgICB0aGlzLiRhZ2VudC5vbihcIl9fZHJhZ0VuZFwiIC8qIEVORCAqLywgdGhpcy4kZHJhZ0VuZCwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBkcmFnQWdlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRhZ2VudDtcbiAgICB9XG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRhZ2VudC5wYXJlbnQgIT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZU9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNvdXJjZU9iamVjdDtcbiAgICB9XG4gICAgc3RhcnREcmFnKHNvdXJjZSwgaWNvbiwgc291cmNlRGF0YSwgdG91Y2hQb2ludElEID0gLTEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kc291cmNlT2JqZWN0ID0gc291cmNlO1xuICAgICAgICB0aGlzLiRzb3VyY2VEYXRhID0gc291cmNlRGF0YTtcbiAgICAgICAgdGhpcy4kYWdlbnQudXJsID0gaWNvbjtcbiAgICAgICAgR1Jvb3QuaW5zdC5hZGRDaGlsZCh0aGlzLiRhZ2VudCk7XG4gICAgICAgIGNvbnN0IHB0ID0gR1Jvb3QuaW5zdC5nbG9iYWxUb0xvY2FsKEdSb290Lmdsb2JhbE1vdXNlU3RhdHVzLm1vdXNlWCwgR1Jvb3QuZ2xvYmFsTW91c2VTdGF0dXMubW91c2VZKTtcbiAgICAgICAgdGhpcy4kYWdlbnQuc2V0WFkocHQueCwgcHQueSk7XG4gICAgICAgIHRoaXMuJGFnZW50LnN0YXJ0RHJhZyh0b3VjaFBvaW50SUQpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLiRhZ2VudC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4kYWdlbnQuc3RvcERyYWcoKTtcbiAgICAgICAgICAgIEdSb290Lmluc3QucmVtb3ZlQ2hpbGQodGhpcy4kYWdlbnQpO1xuICAgICAgICAgICAgdGhpcy4kc291cmNlRGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgJGRyYWdFbmQoZXZ0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBHUm9vdC5pbnN0LnJlbW92ZUNoaWxkKHRoaXMuJGFnZW50KTtcbiAgICAgICAgbGV0IHNvdXJjZURhdGEgPSB0aGlzLiRzb3VyY2VEYXRhO1xuICAgICAgICB0aGlzLiRzb3VyY2VEYXRhID0gbnVsbDtcbiAgICAgICAgbGV0IG9iaiA9IEdSb290Lmluc3QuZ2V0T2JqZWN0VW5kZXJQb2ludChldnQudGFyZ2V0LngsIGV2dC50YXJnZXQueSk7XG4gICAgICAgIHdoaWxlIChvYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNMaXN0ZW5lcihcIl9fZHJhZ0Ryb3BcIiAvKiBEUk9QICovKSkge1xuICAgICAgICAgICAgICAgIG9iai5yZXF1ZXN0Rm9jdXMoKTtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFRhcmdldCA9IG9iai5kaXNwbGF5T2JqZWN0O1xuICAgICAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcIl9fZHJhZ0Ryb3BcIiAvKiBEUk9QICovLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YSA9IHsgY3VycmVudFRhcmdldCwgc291cmNlRGF0YSB9O1xuICAgICAgICAgICAgICAgIG9iai5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmoucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBBc3NldExvYWRlciwgQmluZGVyLCBCbGVuZE1vZGVNYXAsIENvbnRyb2xsZXIsIERlZmF1bHRVSVN0YWdlT3B0aW9ucywgRHJhZ0luZGljYXRvciwgR0J1dHRvbiwgR0NvbWJvQm94LCBHQ29tcG9uZW50LCBHR3JhcGgsIEdHcm91cCwgR0ltYWdlLCBHTGFiZWwsIEdMaXN0LCBHTG9hZGVyLCBHTW92aWVDbGlwLCBHT2JqZWN0LCBHUHJvZ3Jlc3NCYXIsIEdSaWNoVGV4dEZpZWxkLCBHUm9vdCwgR1Njcm9sbEJhciwgR1NsaWRlciwgR1RleHRGaWVsZCwgR1RleHRJbnB1dCwgR1RpbWVyLCBHZWFyWE1MTm9kZU5hbWVNYXAsIEludGVyYWN0aXZlRXZlbnRzLCBQYWNrYWdlSXRlbSwgUGFyc2VBbGlnblR5cGUsIFBhcnNlQXV0b1NpemVUeXBlLCBQYXJzZUJ1dHRvbk1vZGUsIFBhcnNlRWFzZVR5cGUsIFBhcnNlRmxpcFR5cGUsIFBhcnNlTGlzdENoaWxkcmVuUmVuZGVyT3JkZXIsIFBhcnNlTGlzdExheW91dFR5cGUsIFBhcnNlTGlzdFNlbGVjdGlvbk1vZGUsIFBhcnNlTG9hZGVyRmlsbFR5cGUsIFBhcnNlT3ZlcmZsb3dUeXBlLCBQYXJzZVBhY2thZ2VJdGVtVHlwZSwgUGFyc2VQcm9ncmVzc1RpdGxlVHlwZSwgUGFyc2VTY3JvbGxCYXJEaXNwbGF5VHlwZSwgUGFyc2VTY3JvbGxUeXBlLCBQYXJzZVZlcnRBbGlnblR5cGUsIFBvcHVwTWVudSwgU2Nyb2xsUGFuZSwgU3RyaW5nVXRpbCwgVHJhbnNpdGlvbiwgVUlDb25maWcsIFVJT2JqZWN0RmFjdG9yeSwgVUlQYWNrYWdlLCBVSVN0YWdlLCBXaW5kb3cgfTtcbiIsImltcG9ydCAqIGFzIGZndWkgZnJvbSAnZmFpcnlndWktY3JlYXRlanMnXHJcbmltcG9ydCAqIGFzIFN0YXRzIGZyb20gXCJzdGF0cy5qc1wiO1xyXG5pbXBvcnQgeyBMb2FkaW5nVmlldyB9IGZyb20gJy4vTG9hZGluZ1ZpZXcnO1xyXG4vLyBpbXBvcnQgeyBXaW5kb3dBIH0gZnJvbSAnLi9XaW5kb3dBJztcclxuLy8gaW1wb3J0IHsgV2luZG93QiB9IGZyb20gJy4vV2luZG93Qic7XHJcbi8vIGltcG9ydCB7IFdpbmRvd1dhaXQgfSBmcm9tICcuL1dpbmRvd1dhaXQnO1xyXG5cclxuY2xhc3MgTWFpbiB7XHJcbiAgICBzdGF0czogU3RhdHM7XHJcbiAgICBsb2FkZXI6IGZndWkuQXNzZXRMb2FkZXI7XHJcbiAgICBtYW5pZmVzdDogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfT4gPSBbXTtcclxuICAgIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XHJcbiAgICBzdGFnZTogY3JlYXRlanMuU3RhZ2U7XHJcbiAgICBjb250ZW50bGF5ZXI6IGZndWkuR0NvbXBvbmVudDtcclxuICAgIGxvYWRpbmdWaWV3OiBMb2FkaW5nVmlldztcclxuICAgIGNvbnN0cnVjdG9yKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIG1hbmlmZXN0OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZzsgfVtdKSB7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XHJcbiAgICAgICAgdGhpcy5tYW5pZmVzdCA9IG1hbmlmZXN0O1xyXG4gICAgICAgIHRoaXMuc3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoY2FudmFzKTtcclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIHRoaXMuaW5pdFN0YXRzKCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVTdGFnZSgpO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlTG9hZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlU3RhZ2UoKSB7XHJcbiAgICAgICAgZmd1aS5HUm9vdC5pbnN0LmF0dGFjaFRvKHRoaXMuc3RhZ2UsIHtcclxuICAgICAgICAgICAgZGVzaWduV2lkdGg6IDgwMCxcclxuICAgICAgICAgICAgZGVzaWduSGVpZ2h0OiA2MDAsXHJcbiAgICAgICAgICAgIHNjYWxlTW9kZTogZmd1aS5TdGFnZVNjYWxlTW9kZS5GSVhFRF9XSURUSCxcclxuICAgICAgICAgICAgb3JpZW50YXRpb246IGZndWkuU3RhZ2VPcmllbnRhdGlvbi5MQU5EU0NBUEUsXHJcbiAgICAgICAgICAgIGFsaWduVjogZmd1aS5TdGFnZUFsaWduLlRPUCxcclxuICAgICAgICAgICAgYWxpZ25IOiBmZ3VpLlN0YWdlQWxpZ24uTEVGVFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjcmVhdGVqcy5UaWNrZXIuZnJhbWVyYXRlID0gNjA7XHJcbiAgICAgICAgY3JlYXRlanMuVGlja2VyLnRpbWluZ01vZGUgPSBjcmVhdGVqcy5UaWNrZXIuUkFGX1NZTkNIRUQ7XHJcbiAgICAgICAgY3JlYXRlanMuVGlja2VyLm9uKCd0aWNrJywgdGhpcy50aWNrLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICB0aWNrKGU6IHsgW2tleTogc3RyaW5nXTogYW55IH0pIHtcclxuICAgICAgICBpZiAoZS5wYXVzZWQgIT09IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS51cGRhdGUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygncGF1c2UhJylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlTG9hZGVyKCkge1xyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IGZndWkuQXNzZXRMb2FkZXIoZmFsc2UsIFwiXCIsIFwiQW5vbnltb3VzXCIpO1xyXG4gICAgICAgIGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07XHJcbiAgICAgICAgdGhpcy5sb2FkZXIuaW5zdGFsbFBsdWdpbihjcmVhdGVqcy5Tb3VuZCk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZE1hbmlmZXN0KHRoaXMubWFuaWZlc3QpO1xyXG4gICAgICAgIC8vIHRoaXMubG9hZGVyLm9uKFwicHJvZ3Jlc3NcIiwgdGhpcy5sb2FkUHJvZ3Jlc3MsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLm9uKFwiY29tcGxldGVcIiwgdGhpcy5yZXNMb2FkZWQsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGluaXRTdGF0cygpIHtcclxuICAgICAgICB0aGlzLnN0YXRzID0gbmV3IFN0YXRzKCk7XHJcbiAgICAgICAgdGhpcy5zdGF0cy5zaG93UGFuZWwoMCk7IC8vIDA6IGZwcywgMTogbXMsIDI6IG1iLCAzKzogY3VzdG9tXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnN0YXRzLmRvbSk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZFByb2dyZXNzKGU6T2JqZWN0KTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHAgPSAoZSBhcyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KS5wcm9ncmVzcyAqIDEwMDtcclxuICAgICAgICB0aGlzLmxvYWRpbmdWaWV3LnNldFByb2dyZXNzKHApO1xyXG4gICAgICAgIGlmIChwID49IDEwMCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5vZmYoXCJwcm9ncmVzc1wiLCB0aGlzLmxvYWRQcm9ncmVzcyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1ZpZXcuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdWaWV3ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50bGF5ZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICBmZ3VpLkdSb290Lmluc3QucmVtb3ZlQ2hpbGQodGhpcy5jb250ZW50bGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXNMb2FkZWQoKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIGZndWkuVUlQYWNrYWdlLmFkZFBhY2thZ2UoXCJ1aXRlc3RcIik7XHJcbiAgICAgICAgbGV0IGlucyA9IGZndWkuVUlQYWNrYWdlLmNyZWF0ZU9iamVjdChcInVpdGVzdFwiLCBcIm1haW5cIikgYXMgZmd1aS5HQ29tcG9uZW50O1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGZndWkuVUlQYWNrYWdlLmFkZFBhY2thZ2UoXCJ1aXRlc3RcIikpO1xyXG4gICAgICAgIGlucy5zZXRTaXplKGZndWkuR1Jvb3QuaW5zdC53aWR0aCwgZmd1aS5HUm9vdC5pbnN0LmhlaWdodCk7XHJcbiAgICAgICAgaW5zLmFkZFJlbGF0aW9uKGZndWkuR1Jvb3QuaW5zdCwgZmd1aS5SZWxhdGlvblR5cGUuU2l6ZSk7XHJcbiAgICAgICAgZmd1aS5HUm9vdC5pbnN0LmFkZENoaWxkKGlucyk7XHJcblxyXG4gICAgICAgIHRoaXMuYW5pbWF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGFuaW1hdGUoKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0cy5iZWdpbigpO1xyXG4gICAgICAgIHRoaXMuc3RhdHMuZW5kKCk7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmxldCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbWFpblZpZXcnKSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcclxubGV0IG1hbmlmZXN0ID0gW1xyXG4gICAgeyBpZDogXCJ1aXRlc3RcIiwgc3JjOiAncHVibGljL3VpL3VpdGVzdC5mdWknLCB0eXBlOiBcImJpbmFyeVwiIH0sXHJcbiAgICB7IGlkOiAndWl0ZXN0QGF0bGFzMCcsIHNyYzogJ3B1YmxpYy91aS91aXRlc3RAYXRsYXMwLmpwZycsIHR5cGU6IFwiaW1hZ2VcIiB9LFxyXG4gICAgLy8geyBpZDogJ3Rlc3RAYXRsYXMwXzEnLCBzcmM6ICd1aS90ZXN0QGF0bGFzMF8xLnBuZycsIHR5cGU6IFwiaW1hZ2VcIiB9XHJcbl07XHJcbm5ldyBNYWluKGNhbnZhcywgbWFuaWZlc3QpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n")}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var C=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g].call(C.exports,C,C.exports,__webpack_require__),C.exports}__webpack_require__.r=g=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(5);main=__webpack_exports__})();